package nettest
import (
	"net"
	"os"
	"runtime"
	"testing"
	"golang.org
)
func TestTestConn(t *testing.T) {
	tests := []struct{ name, network string }{
		{"TCP", "tcp"},
		{"UnixPipe", "unix"},
		{"UnixPacketPipe", "unixpacket"},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if !nettest.TestableNetwork(tt.network) {
				t.Skipf("not supported on %s", runtime.GOOS)
			}
			mp := func() (c1, c2 net.Conn, stop func(), err error) {
				ln, err := nettest.NewLocalListener(tt.network)
				if err != nil {
					return nil, nil, nil, err
				}
				
				var err1, err2 error
				done := make(chan bool)
				go func() {
					c2, err2 = ln.Accept()
					close(done)
				}()
				c1, err1 = net.Dial(ln.Addr().Network(), ln.Addr().String())
				<-done
				stop = func() {
					if err1 == nil {
						c1.Close()
					}
					if err2 == nil {
						c2.Close()
					}
					ln.Close()
					switch tt.network {
					case "unix", "unixpacket":
						os.Remove(ln.Addr().String())
					}
				}
				switch {
				case err1 != nil:
					stop()
					return nil, nil, nil, err1
				case err2 != nil:
					stop()
					return nil, nil, nil, err2
				default:
					return c1, c2, stop, nil
				}
			}
			TestConn(t, mp)
		})
	}
}
package nettest
import "testing"
func testConn(t *testing.T, mp MakePipe) {
	
	t.Run("BasicIO", func(t *testing.T) { timeoutWrapper(t, mp, testBasicIO) })
	t.Run("PingPong", func(t *testing.T) { timeoutWrapper(t, mp, testPingPong) })
	t.Run("RacyRead", func(t *testing.T) { timeoutWrapper(t, mp, testRacyRead) })
	t.Run("RacyWrite", func(t *testing.T) { timeoutWrapper(t, mp, testRacyWrite) })
	t.Run("ReadTimeout", func(t *testing.T) { timeoutWrapper(t, mp, testReadTimeout) })
	t.Run("WriteTimeout", func(t *testing.T) { timeoutWrapper(t, mp, testWriteTimeout) })
	t.Run("PastTimeout", func(t *testing.T) { timeoutWrapper(t, mp, testPastTimeout) })
	t.Run("PresentTimeout", func(t *testing.T) { timeoutWrapper(t, mp, testPresentTimeout) })
	t.Run("FutureTimeout", func(t *testing.T) { timeoutWrapper(t, mp, testFutureTimeout) })
	t.Run("CloseTimeout", func(t *testing.T) { timeoutWrapper(t, mp, testCloseTimeout) })
	t.Run("ConcurrentMethods", func(t *testing.T) { timeoutWrapper(t, mp, testConcurrentMethods) })
}
package nettest
import (
	"bytes"
	"encoding
	"io"
	"io
	"math
	"net"
	"runtime"
	"sync"
	"testing"
	"time"
)
var (
	aLongTimeAgo = time.Unix(233431200, 0)
	neverTimeout = time.Time{}
)
type MakePipe func() (c1, c2 net.Conn, stop func(), err error)
func TestConn(t *testing.T, mp MakePipe) {
	testConn(t, mp)
}
type connTester func(t *testing.T, c1, c2 net.Conn)
func timeoutWrapper(t *testing.T, mp MakePipe, f connTester) {
	c1, c2, stop, err := mp()
	if err != nil {
		t.Fatalf("unable to make pipe: %v", err)
	}
	var once sync.Once
	defer once.Do(func() { stop() })
	timer := time.AfterFunc(time.Minute, func() {
		once.Do(func() {
			t.Error("test timed out; terminating pipe")
			stop()
		})
	})
	defer timer.Stop()
	f(t, c1, c2)
}
func testBasicIO(t *testing.T, c1, c2 net.Conn) {
	want := make([]byte, 1<<20)
	rand.New(rand.NewSource(0)).Read(want)
	dataCh := make(chan []byte)
	go func() {
		rd := bytes.NewReader(want)
		if err := chunkedCopy(c1, rd); err != nil {
			t.Errorf("unexpected c1.Write error: %v", err)
		}
		if err := c1.Close(); err != nil {
			t.Errorf("unexpected c1.Close error: %v", err)
		}
	}()
	go func() {
		wr := new(bytes.Buffer)
		if err := chunkedCopy(wr, c2); err != nil {
			t.Errorf("unexpected c2.Read error: %v", err)
		}
		if err := c2.Close(); err != nil {
			t.Errorf("unexpected c2.Close error: %v", err)
		}
		dataCh <- wr.Bytes()
	}()
	if got := <-dataCh; !bytes.Equal(got, want) {
		t.Errorf("transmitted data differs")
	}
}
func testPingPong(t *testing.T, c1, c2 net.Conn) {
	var wg sync.WaitGroup
	defer wg.Wait()
	pingPonger := func(c net.Conn) {
		defer wg.Done()
		buf := make([]byte, 8)
		var prev uint64
		for {
			if _, err := io.ReadFull(c, buf); err != nil {
				if err == io.EOF {
					break
				}
				t.Errorf("unexpected Read error: %v", err)
			}
			v := binary.LittleEndian.Uint64(buf)
			binary.LittleEndian.PutUint64(buf, v+1)
			if prev != 0 && prev+2 != v {
				t.Errorf("mismatching value: got %d, want %d", v, prev+2)
			}
			prev = v
			if v == 1000 {
				break
			}
			if _, err := c.Write(buf); err != nil {
				t.Errorf("unexpected Write error: %v", err)
				break
			}
		}
		if err := c.Close(); err != nil {
			t.Errorf("unexpected Close error: %v", err)
		}
	}
	wg.Add(2)
	go pingPonger(c1)
	go pingPonger(c2)
	
	if _, err := c1.Write(make([]byte, 8)); err != nil {
		t.Errorf("unexpected c1.Write error: %v", err)
	}
}
func testRacyRead(t *testing.T, c1, c2 net.Conn) {
	go chunkedCopy(c2, rand.New(rand.NewSource(0)))
	var wg sync.WaitGroup
	defer wg.Wait()
	c1.SetReadDeadline(time.Now().Add(time.Millisecond))
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			b1 := make([]byte, 1024)
			b2 := make([]byte, 1024)
			for j := 0; j < 100; j++ {
				_, err := c1.Read(b1)
				copy(b1, b2) 
				if err != nil {
					checkForTimeoutError(t, err)
					c1.SetReadDeadline(time.Now().Add(time.Millisecond))
				}
			}
		}()
	}
}
func testRacyWrite(t *testing.T, c1, c2 net.Conn) {
	go chunkedCopy(ioutil.Discard, c2)
	var wg sync.WaitGroup
	defer wg.Wait()
	c1.SetWriteDeadline(time.Now().Add(time.Millisecond))
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			b1 := make([]byte, 1024)
			b2 := make([]byte, 1024)
			for j := 0; j < 100; j++ {
				_, err := c1.Write(b1)
				copy(b1, b2) 
				if err != nil {
					checkForTimeoutError(t, err)
					c1.SetWriteDeadline(time.Now().Add(time.Millisecond))
				}
			}
		}()
	}
}
func testReadTimeout(t *testing.T, c1, c2 net.Conn) {
	go chunkedCopy(ioutil.Discard, c2)
	c1.SetReadDeadline(aLongTimeAgo)
	_, err := c1.Read(make([]byte, 1024))
	checkForTimeoutError(t, err)
	if _, err := c1.Write(make([]byte, 1024)); err != nil {
		t.Errorf("unexpected Write error: %v", err)
	}
}
func testWriteTimeout(t *testing.T, c1, c2 net.Conn) {
	go chunkedCopy(c2, rand.New(rand.NewSource(0)))
	c1.SetWriteDeadline(aLongTimeAgo)
	_, err := c1.Write(make([]byte, 1024))
	checkForTimeoutError(t, err)
	if _, err := c1.Read(make([]byte, 1024)); err != nil {
		t.Errorf("unexpected Read error: %v", err)
	}
}
func testPastTimeout(t *testing.T, c1, c2 net.Conn) {
	go chunkedCopy(c2, c2)
	testRoundtrip(t, c1)
	c1.SetDeadline(aLongTimeAgo)
	n, err := c1.Write(make([]byte, 1024))
	if n != 0 {
		t.Errorf("unexpected Write count: got %d, want 0", n)
	}
	checkForTimeoutError(t, err)
	n, err = c1.Read(make([]byte, 1024))
	if n != 0 {
		t.Errorf("unexpected Read count: got %d, want 0", n)
	}
	checkForTimeoutError(t, err)
	testRoundtrip(t, c1)
}
func testPresentTimeout(t *testing.T, c1, c2 net.Conn) {
	var wg sync.WaitGroup
	defer wg.Wait()
	wg.Add(3)
	deadlineSet := make(chan bool, 1)
	go func() {
		defer wg.Done()
		time.Sleep(100 * time.Millisecond)
		deadlineSet <- true
		c1.SetReadDeadline(aLongTimeAgo)
		c1.SetWriteDeadline(aLongTimeAgo)
	}()
	go func() {
		defer wg.Done()
		n, err := c1.Read(make([]byte, 1024))
		if n != 0 {
			t.Errorf("unexpected Read count: got %d, want 0", n)
		}
		checkForTimeoutError(t, err)
		if len(deadlineSet) == 0 {
			t.Error("Read timed out before deadline is set")
		}
	}()
	go func() {
		defer wg.Done()
		var err error
		for err == nil {
			_, err = c1.Write(make([]byte, 1024))
		}
		checkForTimeoutError(t, err)
		if len(deadlineSet) == 0 {
			t.Error("Write timed out before deadline is set")
		}
	}()
}
func testFutureTimeout(t *testing.T, c1, c2 net.Conn) {
	var wg sync.WaitGroup
	wg.Add(2)
	c1.SetDeadline(time.Now().Add(100 * time.Millisecond))
	go func() {
		defer wg.Done()
		_, err := c1.Read(make([]byte, 1024))
		checkForTimeoutError(t, err)
	}()
	go func() {
		defer wg.Done()
		var err error
		for err == nil {
			_, err = c1.Write(make([]byte, 1024))
		}
		checkForTimeoutError(t, err)
	}()
	wg.Wait()
	go chunkedCopy(c2, c2)
	resyncConn(t, c1)
	testRoundtrip(t, c1)
}
func testCloseTimeout(t *testing.T, c1, c2 net.Conn) {
	go chunkedCopy(c2, c2)
	var wg sync.WaitGroup
	defer wg.Wait()
	wg.Add(3)
	
	c1.SetDeadline(neverTimeout)
	go func() {
		defer wg.Done()
		time.Sleep(100 * time.Millisecond)
		c1.Close()
	}()
	go func() {
		defer wg.Done()
		var err error
		buf := make([]byte, 1024)
		for err == nil {
			_, err = c1.Read(buf)
		}
	}()
	go func() {
		defer wg.Done()
		var err error
		buf := make([]byte, 1024)
		for err == nil {
			_, err = c1.Write(buf)
		}
	}()
}
func testConcurrentMethods(t *testing.T, c1, c2 net.Conn) {
	if runtime.GOOS == "plan9" {
		t.Skip("skipping on plan9; see https:
	}
	go chunkedCopy(c2, c2)
	
	
	var wg sync.WaitGroup
	for i := 0; i < 100; i++ {
		wg.Add(7)
		go func() {
			defer wg.Done()
			c1.Read(make([]byte, 1024))
		}()
		go func() {
			defer wg.Done()
			c1.Write(make([]byte, 1024))
		}()
		go func() {
			defer wg.Done()
			c1.SetDeadline(time.Now().Add(10 * time.Millisecond))
		}()
		go func() {
			defer wg.Done()
			c1.SetReadDeadline(aLongTimeAgo)
		}()
		go func() {
			defer wg.Done()
			c1.SetWriteDeadline(aLongTimeAgo)
		}()
		go func() {
			defer wg.Done()
			c1.LocalAddr()
		}()
		go func() {
			defer wg.Done()
			c1.RemoteAddr()
		}()
	}
	wg.Wait() 
	resyncConn(t, c1)
	testRoundtrip(t, c1)
}
func checkForTimeoutError(t *testing.T, err error) {
	if nerr, ok := err.(net.Error); ok {
		if !nerr.Timeout() {
			t.Errorf("err.Timeout() = false, want true")
		}
	} else {
		t.Errorf("got %T, want net.Error", err)
	}
}
func testRoundtrip(t *testing.T, c net.Conn) {
	if err := c.SetDeadline(neverTimeout); err != nil {
		t.Errorf("roundtrip SetDeadline error: %v", err)
	}
	const s = "Hello, world!"
	buf := []byte(s)
	if _, err := c.Write(buf); err != nil {
		t.Errorf("roundtrip Write error: %v", err)
	}
	if _, err := io.ReadFull(c, buf); err != nil {
		t.Errorf("roundtrip Read error: %v", err)
	}
	if string(buf) != s {
		t.Errorf("roundtrip data mismatch: got %q, want %q", buf, s)
	}
}
func resyncConn(t *testing.T, c net.Conn) {
	c.SetDeadline(neverTimeout)
	errCh := make(chan error)
	go func() {
		_, err := c.Write([]byte{0xff})
		errCh <- err
	}()
	buf := make([]byte, 1024)
	for {
		n, err := c.Read(buf)
		if n > 0 && bytes.IndexByte(buf[:n], 0xff) == n-1 {
			break
		}
		if err != nil {
			t.Errorf("unexpected Read error: %v", err)
			break
		}
	}
	if err := <-errCh; err != nil {
		t.Errorf("unexpected Write error: %v", err)
	}
}
func chunkedCopy(w io.Writer, r io.Reader) error {
	b := make([]byte, 1024)
	_, err := io.CopyBuffer(struct{ io.Writer }{w}, struct{ io.Reader }{r}, b)
	return err
}
package nettest
import "testing"
func testConn(t *testing.T, mp MakePipe) {
	
	timeoutWrapper(t, mp, testBasicIO)
	timeoutWrapper(t, mp, testPingPong)
	timeoutWrapper(t, mp, testRacyRead)
	timeoutWrapper(t, mp, testRacyWrite)
	timeoutWrapper(t, mp, testReadTimeout)
	timeoutWrapper(t, mp, testWriteTimeout)
	timeoutWrapper(t, mp, testPastTimeout)
	timeoutWrapper(t, mp, testPresentTimeout)
	timeoutWrapper(t, mp, testFutureTimeout)
	timeoutWrapper(t, mp, testCloseTimeout)
	timeoutWrapper(t, mp, testConcurrentMethods)
}
package bpf
import "fmt"
type Instruction interface {
	
	Assemble() (RawInstruction, error)
}
type RawInstruction struct {
	
	Op uint16
	
	
	Jt uint8
	Jf uint8
	
	K uint32
}
func (ri RawInstruction) Assemble() (RawInstruction, error) { return ri, nil }
func (ri RawInstruction) Disassemble() Instruction {
	switch ri.Op & opMaskCls {
	case opClsLoadA, opClsLoadX:
		reg := Register(ri.Op & opMaskLoadDest)
		sz := 0
		switch ri.Op & opMaskLoadWidth {
		case opLoadWidth4:
			sz = 4
		case opLoadWidth2:
			sz = 2
		case opLoadWidth1:
			sz = 1
		default:
			return ri
		}
		switch ri.Op & opMaskLoadMode {
		case opAddrModeImmediate:
			if sz != 4 {
				return ri
			}
			return LoadConstant{Dst: reg, Val: ri.K}
		case opAddrModeScratch:
			if sz != 4 || ri.K > 15 {
				return ri
			}
			return LoadScratch{Dst: reg, N: int(ri.K)}
		case opAddrModeAbsolute:
			if ri.K > extOffset+0xffffffff {
				return LoadExtension{Num: Extension(-extOffset + ri.K)}
			}
			return LoadAbsolute{Size: sz, Off: ri.K}
		case opAddrModeIndirect:
			return LoadIndirect{Size: sz, Off: ri.K}
		case opAddrModePacketLen:
			if sz != 4 {
				return ri
			}
			return LoadExtension{Num: ExtLen}
		case opAddrModeMemShift:
			return LoadMemShift{Off: ri.K}
		default:
			return ri
		}
	case opClsStoreA:
		if ri.Op != opClsStoreA || ri.K > 15 {
			return ri
		}
		return StoreScratch{Src: RegA, N: int(ri.K)}
	case opClsStoreX:
		if ri.Op != opClsStoreX || ri.K > 15 {
			return ri
		}
		return StoreScratch{Src: RegX, N: int(ri.K)}
	case opClsALU:
		switch op := ALUOp(ri.Op & opMaskOperator); op {
		case ALUOpAdd, ALUOpSub, ALUOpMul, ALUOpDiv, ALUOpOr, ALUOpAnd, ALUOpShiftLeft, ALUOpShiftRight, ALUOpMod, ALUOpXor:
			if ri.Op&opMaskOperandSrc != 0 {
				return ALUOpX{Op: op}
			}
			return ALUOpConstant{Op: op, Val: ri.K}
		case aluOpNeg:
			return NegateA{}
		default:
			return ri
		}
	case opClsJump:
		if ri.Op&opMaskJumpConst != opClsJump {
			return ri
		}
		switch ri.Op & opMaskJumpCond {
		case opJumpAlways:
			return Jump{Skip: ri.K}
		case opJumpEqual:
			if ri.Jt == 0 {
				return JumpIf{
					Cond:      JumpNotEqual,
					Val:       ri.K,
					SkipTrue:  ri.Jf,
					SkipFalse: 0,
				}
			}
			return JumpIf{
				Cond:      JumpEqual,
				Val:       ri.K,
				SkipTrue:  ri.Jt,
				SkipFalse: ri.Jf,
			}
		case opJumpGT:
			if ri.Jt == 0 {
				return JumpIf{
					Cond:      JumpLessOrEqual,
					Val:       ri.K,
					SkipTrue:  ri.Jf,
					SkipFalse: 0,
				}
			}
			return JumpIf{
				Cond:      JumpGreaterThan,
				Val:       ri.K,
				SkipTrue:  ri.Jt,
				SkipFalse: ri.Jf,
			}
		case opJumpGE:
			if ri.Jt == 0 {
				return JumpIf{
					Cond:      JumpLessThan,
					Val:       ri.K,
					SkipTrue:  ri.Jf,
					SkipFalse: 0,
				}
			}
			return JumpIf{
				Cond:      JumpGreaterOrEqual,
				Val:       ri.K,
				SkipTrue:  ri.Jt,
				SkipFalse: ri.Jf,
			}
		case opJumpSet:
			return JumpIf{
				Cond:      JumpBitsSet,
				Val:       ri.K,
				SkipTrue:  ri.Jt,
				SkipFalse: ri.Jf,
			}
		default:
			return ri
		}
	case opClsReturn:
		switch ri.Op {
		case opClsReturn | opRetSrcA:
			return RetA{}
		case opClsReturn | opRetSrcConstant:
			return RetConstant{Val: ri.K}
		default:
			return ri
		}
	case opClsMisc:
		switch ri.Op {
		case opClsMisc | opMiscTAX:
			return TAX{}
		case opClsMisc | opMiscTXA:
			return TXA{}
		default:
			return ri
		}
	default:
		panic("unreachable") 
	}
}
type LoadConstant struct {
	Dst Register
	Val uint32
}
func (a LoadConstant) Assemble() (RawInstruction, error) {
	return assembleLoad(a.Dst, 4, opAddrModeImmediate, a.Val)
}
func (a LoadConstant) String() string {
	switch a.Dst {
	case RegA:
		return fmt.Sprintf("ld #%d", a.Val)
	case RegX:
		return fmt.Sprintf("ldx #%d", a.Val)
	default:
		return fmt.Sprintf("unknown instruction: %#v", a)
	}
}
type LoadScratch struct {
	Dst Register
	N   int 
}
func (a LoadScratch) Assemble() (RawInstruction, error) {
	if a.N < 0 || a.N > 15 {
		return RawInstruction{}, fmt.Errorf("invalid scratch slot %d", a.N)
	}
	return assembleLoad(a.Dst, 4, opAddrModeScratch, uint32(a.N))
}
func (a LoadScratch) String() string {
	switch a.Dst {
	case RegA:
		return fmt.Sprintf("ld M[%d]", a.N)
	case RegX:
		return fmt.Sprintf("ldx M[%d]", a.N)
	default:
		return fmt.Sprintf("unknown instruction: %#v", a)
	}
}
type LoadAbsolute struct {
	Off  uint32
	Size int 
}
func (a LoadAbsolute) Assemble() (RawInstruction, error) {
	return assembleLoad(RegA, a.Size, opAddrModeAbsolute, a.Off)
}
func (a LoadAbsolute) String() string {
	switch a.Size {
	case 1: 
		return fmt.Sprintf("ldb [%d]", a.Off)
	case 2: 
		return fmt.Sprintf("ldh [%d]", a.Off)
	case 4: 
		if a.Off > extOffset+0xffffffff {
			return LoadExtension{Num: Extension(a.Off + 0x1000)}.String()
		}
		return fmt.Sprintf("ld [%d]", a.Off)
	default:
		return fmt.Sprintf("unknown instruction: %#v", a)
	}
}
type LoadIndirect struct {
	Off  uint32
	Size int 
}
func (a LoadIndirect) Assemble() (RawInstruction, error) {
	return assembleLoad(RegA, a.Size, opAddrModeIndirect, a.Off)
}
func (a LoadIndirect) String() string {
	switch a.Size {
	case 1: 
		return fmt.Sprintf("ldb [x + %d]", a.Off)
	case 2: 
		return fmt.Sprintf("ldh [x + %d]", a.Off)
	case 4: 
		return fmt.Sprintf("ld [x + %d]", a.Off)
	default:
		return fmt.Sprintf("unknown instruction: %#v", a)
	}
}
type LoadMemShift struct {
	Off uint32
}
func (a LoadMemShift) Assemble() (RawInstruction, error) {
	return assembleLoad(RegX, 1, opAddrModeMemShift, a.Off)
}
func (a LoadMemShift) String() string {
	return fmt.Sprintf("ldx 4*([%d]&0xf)", a.Off)
}
type LoadExtension struct {
	Num Extension
}
func (a LoadExtension) Assemble() (RawInstruction, error) {
	if a.Num == ExtLen {
		return assembleLoad(RegA, 4, opAddrModePacketLen, 0)
	}
	return assembleLoad(RegA, 4, opAddrModeAbsolute, uint32(extOffset+a.Num))
}
func (a LoadExtension) String() string {
	switch a.Num {
	case ExtLen:
		return "ld #len"
	case ExtProto:
		return "ld #proto"
	case ExtType:
		return "ld #type"
	case ExtPayloadOffset:
		return "ld #poff"
	case ExtInterfaceIndex:
		return "ld #ifidx"
	case ExtNetlinkAttr:
		return "ld #nla"
	case ExtNetlinkAttrNested:
		return "ld #nlan"
	case ExtMark:
		return "ld #mark"
	case ExtQueue:
		return "ld #queue"
	case ExtLinkLayerType:
		return "ld #hatype"
	case ExtRXHash:
		return "ld #rxhash"
	case ExtCPUID:
		return "ld #cpu"
	case ExtVLANTag:
		return "ld #vlan_tci"
	case ExtVLANTagPresent:
		return "ld #vlan_avail"
	case ExtVLANProto:
		return "ld #vlan_tpid"
	case ExtRand:
		return "ld #rand"
	default:
		return fmt.Sprintf("unknown instruction: %#v", a)
	}
}
type StoreScratch struct {
	Src Register
	N   int 
}
func (a StoreScratch) Assemble() (RawInstruction, error) {
	if a.N < 0 || a.N > 15 {
		return RawInstruction{}, fmt.Errorf("invalid scratch slot %d", a.N)
	}
	var op uint16
	switch a.Src {
	case RegA:
		op = opClsStoreA
	case RegX:
		op = opClsStoreX
	default:
		return RawInstruction{}, fmt.Errorf("invalid source register %v", a.Src)
	}
	return RawInstruction{
		Op: op,
		K:  uint32(a.N),
	}, nil
}
func (a StoreScratch) String() string {
	switch a.Src {
	case RegA:
		return fmt.Sprintf("st M[%d]", a.N)
	case RegX:
		return fmt.Sprintf("stx M[%d]", a.N)
	default:
		return fmt.Sprintf("unknown instruction: %#v", a)
	}
}
type ALUOpConstant struct {
	Op  ALUOp
	Val uint32
}
func (a ALUOpConstant) Assemble() (RawInstruction, error) {
	return RawInstruction{
		Op: opClsALU | opALUSrcConstant | uint16(a.Op),
		K:  a.Val,
	}, nil
}
func (a ALUOpConstant) String() string {
	switch a.Op {
	case ALUOpAdd:
		return fmt.Sprintf("add #%d", a.Val)
	case ALUOpSub:
		return fmt.Sprintf("sub #%d", a.Val)
	case ALUOpMul:
		return fmt.Sprintf("mul #%d", a.Val)
	case ALUOpDiv:
		return fmt.Sprintf("div #%d", a.Val)
	case ALUOpMod:
		return fmt.Sprintf("mod #%d", a.Val)
	case ALUOpAnd:
		return fmt.Sprintf("and #%d", a.Val)
	case ALUOpOr:
		return fmt.Sprintf("or #%d", a.Val)
	case ALUOpXor:
		return fmt.Sprintf("xor #%d", a.Val)
	case ALUOpShiftLeft:
		return fmt.Sprintf("lsh #%d", a.Val)
	case ALUOpShiftRight:
		return fmt.Sprintf("rsh #%d", a.Val)
	default:
		return fmt.Sprintf("unknown instruction: %#v", a)
	}
}
type ALUOpX struct {
	Op ALUOp
}
func (a ALUOpX) Assemble() (RawInstruction, error) {
	return RawInstruction{
		Op: opClsALU | opALUSrcX | uint16(a.Op),
	}, nil
}
func (a ALUOpX) String() string {
	switch a.Op {
	case ALUOpAdd:
		return "add x"
	case ALUOpSub:
		return "sub x"
	case ALUOpMul:
		return "mul x"
	case ALUOpDiv:
		return "div x"
	case ALUOpMod:
		return "mod x"
	case ALUOpAnd:
		return "and x"
	case ALUOpOr:
		return "or x"
	case ALUOpXor:
		return "xor x"
	case ALUOpShiftLeft:
		return "lsh x"
	case ALUOpShiftRight:
		return "rsh x"
	default:
		return fmt.Sprintf("unknown instruction: %#v", a)
	}
}
type NegateA struct{}
func (a NegateA) Assemble() (RawInstruction, error) {
	return RawInstruction{
		Op: opClsALU | uint16(aluOpNeg),
	}, nil
}
func (a NegateA) String() string {
	return fmt.Sprintf("neg")
}
type Jump struct {
	Skip uint32
}
func (a Jump) Assemble() (RawInstruction, error) {
	return RawInstruction{
		Op: opClsJump | opJumpAlways,
		K:  a.Skip,
	}, nil
}
func (a Jump) String() string {
	return fmt.Sprintf("ja %d", a.Skip)
}
type JumpIf struct {
	Cond      JumpTest
	Val       uint32
	SkipTrue  uint8
	SkipFalse uint8
}
func (a JumpIf) Assemble() (RawInstruction, error) {
	var (
		cond uint16
		flip bool
	)
	switch a.Cond {
	case JumpEqual:
		cond = opJumpEqual
	case JumpNotEqual:
		cond, flip = opJumpEqual, true
	case JumpGreaterThan:
		cond = opJumpGT
	case JumpLessThan:
		cond, flip = opJumpGE, true
	case JumpGreaterOrEqual:
		cond = opJumpGE
	case JumpLessOrEqual:
		cond, flip = opJumpGT, true
	case JumpBitsSet:
		cond = opJumpSet
	case JumpBitsNotSet:
		cond, flip = opJumpSet, true
	default:
		return RawInstruction{}, fmt.Errorf("unknown JumpTest %v", a.Cond)
	}
	jt, jf := a.SkipTrue, a.SkipFalse
	if flip {
		jt, jf = jf, jt
	}
	return RawInstruction{
		Op: opClsJump | cond,
		Jt: jt,
		Jf: jf,
		K:  a.Val,
	}, nil
}
func (a JumpIf) String() string {
	switch a.Cond {
	
	case JumpEqual:
		return conditionalJump(a, "jeq", "jneq")
	
	case JumpNotEqual:
		return fmt.Sprintf("jneq #%d,%d", a.Val, a.SkipTrue)
	
	case JumpGreaterThan:
		return conditionalJump(a, "jgt", "jle")
	
	case JumpLessThan:
		return fmt.Sprintf("jlt #%d,%d", a.Val, a.SkipTrue)
	
	case JumpGreaterOrEqual:
		return conditionalJump(a, "jge", "jlt")
	
	case JumpLessOrEqual:
		return fmt.Sprintf("jle #%d,%d", a.Val, a.SkipTrue)
	
	case JumpBitsSet:
		if a.SkipFalse > 0 {
			return fmt.Sprintf("jset #%d,%d,%d", a.Val, a.SkipTrue, a.SkipFalse)
		}
		return fmt.Sprintf("jset #%d,%d", a.Val, a.SkipTrue)
	
	case JumpBitsNotSet:
		return JumpIf{Cond: JumpBitsSet, SkipTrue: a.SkipFalse, SkipFalse: a.SkipTrue, Val: a.Val}.String()
	default:
		return fmt.Sprintf("unknown instruction: %#v", a)
	}
}
func conditionalJump(inst JumpIf, positiveJump, negativeJump string) string {
	if inst.SkipTrue > 0 {
		if inst.SkipFalse > 0 {
			return fmt.Sprintf("%s #%d,%d,%d", positiveJump, inst.Val, inst.SkipTrue, inst.SkipFalse)
		}
		return fmt.Sprintf("%s #%d,%d", positiveJump, inst.Val, inst.SkipTrue)
	}
	return fmt.Sprintf("%s #%d,%d", negativeJump, inst.Val, inst.SkipFalse)
}
type RetA struct{}
func (a RetA) Assemble() (RawInstruction, error) {
	return RawInstruction{
		Op: opClsReturn | opRetSrcA,
	}, nil
}
func (a RetA) String() string {
	return fmt.Sprintf("ret a")
}
type RetConstant struct {
	Val uint32
}
func (a RetConstant) Assemble() (RawInstruction, error) {
	return RawInstruction{
		Op: opClsReturn | opRetSrcConstant,
		K:  a.Val,
	}, nil
}
func (a RetConstant) String() string {
	return fmt.Sprintf("ret #%d", a.Val)
}
type TXA struct{}
func (a TXA) Assemble() (RawInstruction, error) {
	return RawInstruction{
		Op: opClsMisc | opMiscTXA,
	}, nil
}
func (a TXA) String() string {
	return fmt.Sprintf("txa")
}
type TAX struct{}
func (a TAX) Assemble() (RawInstruction, error) {
	return RawInstruction{
		Op: opClsMisc | opMiscTAX,
	}, nil
}
func (a TAX) String() string {
	return fmt.Sprintf("tax")
}
func assembleLoad(dst Register, loadSize int, mode uint16, k uint32) (RawInstruction, error) {
	var (
		cls uint16
		sz  uint16
	)
	switch dst {
	case RegA:
		cls = opClsLoadA
	case RegX:
		cls = opClsLoadX
	default:
		return RawInstruction{}, fmt.Errorf("invalid target register %v", dst)
	}
	switch loadSize {
	case 1:
		sz = opLoadWidth1
	case 2:
		sz = opLoadWidth2
	case 4:
		sz = opLoadWidth4
	default:
		return RawInstruction{}, fmt.Errorf("invalid load byte length %d", sz)
	}
	return RawInstruction{
		Op: cls | sz | mode,
		K:  k,
	}, nil
}
package bpf_test
import (
	"testing"
	"golang.org
)
func TestVMLoadExtensionNotImplemented(t *testing.T) {
	_, _, err := testVM(t, []bpf.Instruction{
		bpf.LoadExtension{
			Num: 100,
		},
		bpf.RetA{},
	})
	if errStr(err) != "extension 100 not implemented" {
		t.Fatalf("unexpected error: %v", err)
	}
}
func TestVMLoadExtensionExtLen(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadExtension{
			Num: bpf.ExtLen,
		},
		bpf.RetA{},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		0, 1, 2, 3,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 4, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
package bpf
import (
	"encoding
	"fmt"
)
func aluOpConstant(ins ALUOpConstant, regA uint32) uint32 {
	return aluOpCommon(ins.Op, regA, ins.Val)
}
func aluOpX(ins ALUOpX, regA uint32, regX uint32) (uint32, bool) {
	
	
	if regX == 0 {
		switch ins.Op {
		case ALUOpDiv, ALUOpMod:
			return 0, false
		}
	}
	return aluOpCommon(ins.Op, regA, regX), true
}
func aluOpCommon(op ALUOp, regA uint32, value uint32) uint32 {
	switch op {
	case ALUOpAdd:
		return regA + value
	case ALUOpSub:
		return regA - value
	case ALUOpMul:
		return regA * value
	case ALUOpDiv:
		
		return regA 
	case ALUOpOr:
		return regA | value
	case ALUOpAnd:
		return regA & value
	case ALUOpShiftLeft:
		return regA << value
	case ALUOpShiftRight:
		return regA >> value
	case ALUOpMod:
		
		return regA % value
	case ALUOpXor:
		return regA ^ value
	default:
		return regA
	}
}
func jumpIf(ins JumpIf, value uint32) int {
	var ok bool
	inV := uint32(ins.Val)
	switch ins.Cond {
	case JumpEqual:
		ok = value == inV
	case JumpNotEqual:
		ok = value != inV
	case JumpGreaterThan:
		ok = value > inV
	case JumpLessThan:
		ok = value < inV
	case JumpGreaterOrEqual:
		ok = value >= inV
	case JumpLessOrEqual:
		ok = value <= inV
	case JumpBitsSet:
		ok = (value & inV) != 0
	case JumpBitsNotSet:
		ok = (value & inV) == 0
	}
	if ok {
		return int(ins.SkipTrue)
	}
	return int(ins.SkipFalse)
}
func loadAbsolute(ins LoadAbsolute, in []byte) (uint32, bool) {
	offset := int(ins.Off)
	size := int(ins.Size)
	return loadCommon(in, offset, size)
}
func loadConstant(ins LoadConstant, regA uint32, regX uint32) (uint32, uint32) {
	switch ins.Dst {
	case RegA:
		regA = ins.Val
	case RegX:
		regX = ins.Val
	}
	return regA, regX
}
func loadExtension(ins LoadExtension, in []byte) uint32 {
	switch ins.Num {
	case ExtLen:
		return uint32(len(in))
	default:
		panic(fmt.Sprintf("unimplemented extension: %d", ins.Num))
	}
}
func loadIndirect(ins LoadIndirect, in []byte, regX uint32) (uint32, bool) {
	offset := int(ins.Off) + int(regX)
	size := int(ins.Size)
	return loadCommon(in, offset, size)
}
func loadMemShift(ins LoadMemShift, in []byte) (uint32, bool) {
	offset := int(ins.Off)
	if !inBounds(len(in), offset, 0) {
		return 0, false
	}
	
	return uint32(in[offset]&0x0f) * 4, true
}
func inBounds(inLen int, offset int, size int) bool {
	return offset+size <= inLen
}
func loadCommon(in []byte, offset int, size int) (uint32, bool) {
	if !inBounds(len(in), offset, size) {
		return 0, false
	}
	switch size {
	case 1:
		return uint32(in[offset]), true
	case 2:
		return uint32(binary.BigEndian.Uint16(in[offset : offset+size])), true
	case 4:
		return uint32(binary.BigEndian.Uint32(in[offset : offset+size])), true
	default:
		panic(fmt.Sprintf("invalid load size: %d", size))
	}
}
func loadScratch(ins LoadScratch, regScratch [16]uint32, regA uint32, regX uint32) (uint32, uint32) {
	switch ins.Dst {
	case RegA:
		regA = regScratch[ins.N]
	case RegX:
		regX = regScratch[ins.N]
	}
	return regA, regX
}
func storeScratch(ins StoreScratch, regScratch [16]uint32, regA uint32, regX uint32) [16]uint32 {
	switch ins.Src {
	case RegA:
		regScratch[ins.N] = regA
	case RegX:
		regScratch[ins.N] = regX
	}
	return regScratch
}
package bpf
import (
	"errors"
	"fmt"
)
type VM struct {
	filter []Instruction
}
func NewVM(filter []Instruction) (*VM, error) {
	if len(filter) == 0 {
		return nil, errors.New("one or more Instructions must be specified")
	}
	for i, ins := range filter {
		check := len(filter) - (i + 1)
		switch ins := ins.(type) {
		
		case Jump:
			if check <= int(ins.Skip) {
				return nil, fmt.Errorf("cannot jump %d instructions; jumping past program bounds", ins.Skip)
			}
		case JumpIf:
			if check <= int(ins.SkipTrue) {
				return nil, fmt.Errorf("cannot jump %d instructions in true case; jumping past program bounds", ins.SkipTrue)
			}
			if check <= int(ins.SkipFalse) {
				return nil, fmt.Errorf("cannot jump %d instructions in false case; jumping past program bounds", ins.SkipFalse)
			}
		
		case ALUOpConstant:
			if ins.Val != 0 {
				break
			}
			switch ins.Op {
			case ALUOpDiv, ALUOpMod:
				return nil, errors.New("cannot divide by zero using ALUOpConstant")
			}
		
		case LoadExtension:
			switch ins.Num {
			case ExtLen:
			default:
				return nil, fmt.Errorf("extension %d not implemented", ins.Num)
			}
		}
	}
	
	switch filter[len(filter)-1].(type) {
	case RetA, RetConstant:
	default:
		return nil, errors.New("BPF program must end with RetA or RetConstant")
	}
	
	
	
	_, err := Assemble(filter)
	return &VM{
		filter: filter,
	}, err
}
func (v *VM) Run(in []byte) (int, error) {
	var (
		
		regA       uint32
		regX       uint32
		regScratch [16]uint32
		
		
		ok = true
	)
	
	
	
	
	
	
	
	for i := 0; i < len(v.filter) && ok; i++ {
		ins := v.filter[i]
		switch ins := ins.(type) {
		case ALUOpConstant:
			regA = aluOpConstant(ins, regA)
		case ALUOpX:
			regA, ok = aluOpX(ins, regA, regX)
		case Jump:
			i += int(ins.Skip)
		case JumpIf:
			jump := jumpIf(ins, regA)
			i += jump
		case LoadAbsolute:
			regA, ok = loadAbsolute(ins, in)
		case LoadConstant:
			regA, regX = loadConstant(ins, regA, regX)
		case LoadExtension:
			regA = loadExtension(ins, in)
		case LoadIndirect:
			regA, ok = loadIndirect(ins, in, regX)
		case LoadMemShift:
			regX, ok = loadMemShift(ins, in)
		case LoadScratch:
			regA, regX = loadScratch(ins, regScratch, regA, regX)
		case RetA:
			return int(regA), nil
		case RetConstant:
			return int(ins.Val), nil
		case StoreScratch:
			regScratch = storeScratch(ins, regScratch, regA, regX)
		case TAX:
			regX = regA
		case TXA:
			regA = regX
		default:
			return 0, fmt.Errorf("unknown Instruction at index %d: %T", i, ins)
		}
	}
	return 0, nil
}
package bpf_test
import (
	"fmt"
	"testing"
	"golang.org
)
var _ bpf.Instruction = unknown{}
type unknown struct{}
func (unknown) Assemble() (bpf.RawInstruction, error) {
	return bpf.RawInstruction{}, nil
}
func TestVMUnknownInstruction(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadConstant{
			Dst: bpf.RegA,
			Val: 100,
		},
		
		unknown{},
		bpf.RetA{},
	})
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	defer done()
	_, err = vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		0x00, 0x00,
	})
	if errStr(err) != "unknown Instruction at index 1: bpf_test.unknown" {
		t.Fatalf("unexpected error while running program: %v", err)
	}
}
func TestVMNoReturnInstruction(t *testing.T) {
	_, _, err := testVM(t, []bpf.Instruction{
		bpf.LoadConstant{
			Dst: bpf.RegA,
			Val: 1,
		},
	})
	if errStr(err) != "BPF program must end with RetA or RetConstant" {
		t.Fatalf("unexpected error: %v", err)
	}
}
func TestVMNoInputInstructions(t *testing.T) {
	_, _, err := testVM(t, []bpf.Instruction{})
	if errStr(err) != "one or more Instructions must be specified" {
		t.Fatalf("unexpected error: %v", err)
	}
}
func ExampleNewVM() {
	
	
	
	
	
	const (
		etOff = 12
		etLen = 2
		etARP = 0x0806
	)
	
	
	vm, err := bpf.NewVM([]bpf.Instruction{
		
		bpf.LoadAbsolute{
			Off:  etOff,
			Size: etLen,
		},
		
		
		bpf.JumpIf{
			Cond:     bpf.JumpEqual,
			Val:      etARP,
			SkipTrue: 1,
		},
		
		bpf.RetConstant{
			Val: 0,
		},
		
		
		bpf.RetConstant{
			Val: 1500,
		},
	})
	if err != nil {
		panic(fmt.Sprintf("failed to load BPF program: %v", err))
	}
	
	frame := []byte{
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
		0x08, 0x06,
		
	}
	
	out, err := vm.Run(frame)
	if err != nil {
		panic(fmt.Sprintf("failed to accept Ethernet frame: %v", err))
	}
	
	
	if out > len(frame) {
		out = len(frame)
	}
	fmt.Printf("out: %d bytes", out)
	
	
}
func errStr(err error) string {
	if err == nil {
		return "<nil>"
	}
	return err.Error()
}
package bpf
type Register uint16
const (
	
	
	RegA Register = iota
	
	
	RegX
)
type ALUOp uint16
const (
	ALUOpAdd ALUOp = iota << 4
	ALUOpSub
	ALUOpMul
	ALUOpDiv
	ALUOpOr
	ALUOpAnd
	ALUOpShiftLeft
	ALUOpShiftRight
	aluOpNeg 
	ALUOpMod
	ALUOpXor
)
type JumpTest uint16
const (
	
	JumpEqual JumpTest = iota
	
	JumpNotEqual
	
	JumpGreaterThan
	
	JumpLessThan
	
	JumpGreaterOrEqual
	
	JumpLessOrEqual
	
	JumpBitsSet
	
	JumpBitsNotSet
)
type Extension int
const (
	
	
	extOffset = -0x1000
	
	ExtLen Extension = 1
	
	ExtProto Extension = 0
	
	
	
	
	ExtType Extension = 4
	
	
	
	ExtPayloadOffset Extension = 52
	
	
	ExtInterfaceIndex Extension = 8
	
	
	ExtNetlinkAttr Extension = 12
	
	
	ExtNetlinkAttrNested Extension = 16
	
	ExtMark Extension = 20
	
	ExtQueue Extension = 24
	
	
	ExtLinkLayerType Extension = 28
	
	
	
	ExtRXHash Extension = 32
	
	
	ExtCPUID Extension = 36
	
	ExtVLANTag Extension = 44
	
	
	
	
	
	
	ExtVLANTagPresent Extension = 48
	
	
	
	ExtVLANProto Extension = 60
	
	ExtRand Extension = 56
)
const (
	opMaskCls uint16 = 0x7
	
	opMaskLoadDest  = 0x01
	opMaskLoadWidth = 0x18
	opMaskLoadMode  = 0xe0
	
	opMaskOperandSrc = 0x08
	opMaskOperator   = 0xf0
	
	opMaskJumpConst = 0x0f
	opMaskJumpCond  = 0xf0
)
const (
	
	
	
	opClsLoadA uint16 = iota
	
	
	
	opClsLoadX
	
	
	
	opClsStoreA
	
	
	
	opClsStoreX
	
	
	
	opClsALU
	
	
	
	opClsJump
	
	
	
	opClsReturn
	
	
	
	opClsMisc
)
const (
	opAddrModeImmediate uint16 = iota << 5
	opAddrModeAbsolute
	opAddrModeIndirect
	opAddrModeScratch
	opAddrModePacketLen 
	opAddrModeMemShift
)
const (
	opLoadWidth4 uint16 = iota << 3
	opLoadWidth2
	opLoadWidth1
)
const (
	opALUSrcConstant uint16 = iota << 3
	opALUSrcX
)
const (
	opJumpAlways = iota << 4
	opJumpEqual
	opJumpGT
	opJumpGE
	opJumpSet
)
const (
	opRetSrcConstant uint16 = iota << 4
	opRetSrcA
)
const (
	opMiscTAX = 0x00
	opMiscTXA = 0x80
)
package bpf_test
import (
	"testing"
	"golang.org
)
func TestVMALUOpAdd(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Off:  8,
			Size: 1,
		},
		bpf.ALUOpConstant{
			Op:  bpf.ALUOpAdd,
			Val: 3,
		},
		bpf.RetA{},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		8, 2, 3,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 3, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMALUOpSub(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Off:  8,
			Size: 1,
		},
		bpf.TAX{},
		bpf.ALUOpX{
			Op: bpf.ALUOpSub,
		},
		bpf.RetA{},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		1, 2, 3,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 0, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMALUOpMul(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Off:  8,
			Size: 1,
		},
		bpf.ALUOpConstant{
			Op:  bpf.ALUOpMul,
			Val: 2,
		},
		bpf.RetA{},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		6, 2, 3, 4,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 4, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMALUOpDiv(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Off:  8,
			Size: 1,
		},
		bpf.ALUOpConstant{
			Op:  bpf.ALUOpDiv,
			Val: 2,
		},
		bpf.RetA{},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		20, 2, 3, 4,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 2, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMALUOpDivByZeroALUOpConstant(t *testing.T) {
	_, _, err := testVM(t, []bpf.Instruction{
		bpf.ALUOpConstant{
			Op:  bpf.ALUOpDiv,
			Val: 0,
		},
		bpf.RetA{},
	})
	if errStr(err) != "cannot divide by zero using ALUOpConstant" {
		t.Fatalf("unexpected error: %v", err)
	}
}
func TestVMALUOpDivByZeroALUOpX(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		
		bpf.LoadAbsolute{
			Off:  8,
			Size: 1,
		},
		bpf.TAX{},
		
		bpf.LoadAbsolute{
			Off:  9,
			Size: 1,
		},
		
		bpf.ALUOpX{
			Op: bpf.ALUOpDiv,
		},
		
		bpf.LoadConstant{
			Val: 12,
		},
		bpf.RetA{},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		0, 1, 3, 4,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 0, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMALUOpOr(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Off:  8,
			Size: 2,
		},
		bpf.ALUOpConstant{
			Op:  bpf.ALUOpOr,
			Val: 0x01,
		},
		bpf.RetA{},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		0x00, 0x10, 0x03, 0x04,
		0x05, 0x06, 0x07, 0x08,
		0x09, 0xff,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 9, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMALUOpAnd(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Off:  8,
			Size: 2,
		},
		bpf.ALUOpConstant{
			Op:  bpf.ALUOpAnd,
			Val: 0x0019,
		},
		bpf.RetA{},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		0xaa, 0x09,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 1, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMALUOpShiftLeft(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Off:  8,
			Size: 1,
		},
		bpf.ALUOpConstant{
			Op:  bpf.ALUOpShiftLeft,
			Val: 0x01,
		},
		bpf.JumpIf{
			Cond:     bpf.JumpEqual,
			Val:      0x02,
			SkipTrue: 1,
		},
		bpf.RetConstant{
			Val: 0,
		},
		bpf.RetConstant{
			Val: 9,
		},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		0x01, 0xaa,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 1, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMALUOpShiftRight(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Off:  8,
			Size: 1,
		},
		bpf.ALUOpConstant{
			Op:  bpf.ALUOpShiftRight,
			Val: 0x01,
		},
		bpf.JumpIf{
			Cond:     bpf.JumpEqual,
			Val:      0x04,
			SkipTrue: 1,
		},
		bpf.RetConstant{
			Val: 0,
		},
		bpf.RetConstant{
			Val: 9,
		},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		0x08, 0xff, 0xff,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 1, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMALUOpMod(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Off:  8,
			Size: 1,
		},
		bpf.ALUOpConstant{
			Op:  bpf.ALUOpMod,
			Val: 20,
		},
		bpf.RetA{},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		30, 0, 0,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 2, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMALUOpModByZeroALUOpConstant(t *testing.T) {
	_, _, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Off:  8,
			Size: 1,
		},
		bpf.ALUOpConstant{
			Op:  bpf.ALUOpMod,
			Val: 0,
		},
		bpf.RetA{},
	})
	if errStr(err) != "cannot divide by zero using ALUOpConstant" {
		t.Fatalf("unexpected error: %v", err)
	}
}
func TestVMALUOpModByZeroALUOpX(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		
		bpf.LoadAbsolute{
			Off:  8,
			Size: 1,
		},
		bpf.TAX{},
		
		bpf.LoadAbsolute{
			Off:  9,
			Size: 1,
		},
		
		bpf.ALUOpX{
			Op: bpf.ALUOpMod,
		},
		
		bpf.LoadConstant{
			Val: 12,
		},
		bpf.RetA{},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		0, 1, 3, 4,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 0, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMALUOpXor(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Off:  8,
			Size: 1,
		},
		bpf.ALUOpConstant{
			Op:  bpf.ALUOpXor,
			Val: 0x0a,
		},
		bpf.JumpIf{
			Cond:     bpf.JumpEqual,
			Val:      0x01,
			SkipTrue: 1,
		},
		bpf.RetConstant{
			Val: 0,
		},
		bpf.RetConstant{
			Val: 9,
		},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		0x0b, 0x00, 0x00, 0x00,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 1, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMALUOpUnknown(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Off:  8,
			Size: 1,
		},
		bpf.ALUOpConstant{
			Op:  bpf.ALUOpAdd,
			Val: 1,
		},
		
		bpf.ALUOpConstant{
			Op: 100,
		},
		bpf.JumpIf{
			Cond:     bpf.JumpEqual,
			Val:      0x02,
			SkipTrue: 1,
		},
		bpf.RetConstant{
			Val: 0,
		},
		bpf.RetConstant{
			Val: 9,
		},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		1,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 1, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
package bpf_test
import (
	"net"
	"runtime"
	"testing"
	"time"
	"golang.org
	"golang.org
)
type virtualMachine interface {
	Run(in []byte) (int, error)
}
func canUseOSVM() bool {
	
	
	switch runtime.GOOS {
	case "linux":
		return true
	}
	return false
}
func testVM(t *testing.T, filter []bpf.Instruction) (virtualMachine, func(), error) {
	goVM, err := bpf.NewVM(filter)
	if err != nil {
		
		
		return nil, nil, err
	}
	mvm := &multiVirtualMachine{
		goVM: goVM,
		t: t,
	}
	
	
	
	done := func() {}
	if canUseOSVM() {
		osVM, osVMDone := testOSVM(t, filter)
		done = func() { osVMDone() }
		mvm.osVM = osVM
	}
	return mvm, done, nil
}
const udpHeaderLen = 8
type multiVirtualMachine struct {
	goVM virtualMachine
	osVM virtualMachine
	t *testing.T
}
func (mvm *multiVirtualMachine) Run(in []byte) (int, error) {
	if len(in) < udpHeaderLen {
		mvm.t.Fatalf("input must be at least length of UDP header (%d), got: %d",
			udpHeaderLen, len(in))
	}
	
	
	
	goOut, goErr := mvm.goVM.Run(in)
	if goOut >= udpHeaderLen {
		goOut -= udpHeaderLen
	}
	
	
	
	
	trim := len(in) - udpHeaderLen
	if goOut > trim {
		goOut = trim
	}
	
	if mvm.osVM == nil {
		return goOut, goErr
	}
	
	
	osOut, err := mvm.osVM.Run(in[udpHeaderLen:])
	if err != nil {
		mvm.t.Fatalf("error while running OS VM: %v", err)
	}
	
	var mismatch bool
	if goOut != osOut {
		mismatch = true
		mvm.t.Logf("output byte count does not match:\n- go: %v\n- os: %v", goOut, osOut)
	}
	if mismatch {
		mvm.t.Fatal("Go BPF and OS BPF packet outputs do not match")
	}
	return goOut, goErr
}
type osVirtualMachine struct {
	l net.PacketConn
	s net.Conn
}
func testOSVM(t *testing.T, filter []bpf.Instruction) (virtualMachine, func()) {
	l, err := net.ListenPacket("udp4", "127.0.0.1:0")
	if err != nil {
		t.Fatalf("failed to open OS VM UDP listener: %v", err)
	}
	prog, err := bpf.Assemble(filter)
	if err != nil {
		t.Fatalf("failed to compile BPF program: %v", err)
	}
	p := ipv4.NewPacketConn(l)
	if err = p.SetBPF(prog); err != nil {
		t.Fatalf("failed to attach BPF program to listener: %v", err)
	}
	s, err := net.Dial("udp4", l.LocalAddr().String())
	if err != nil {
		t.Fatalf("failed to dial connection to listener: %v", err)
	}
	done := func() {
		_ = s.Close()
		_ = l.Close()
	}
	return &osVirtualMachine{
		l: l,
		s: s,
	}, done
}
func (vm *osVirtualMachine) Run(in []byte) (int, error) {
	go func() {
		_, _ = vm.s.Write(in)
	}()
	vm.l.SetDeadline(time.Now().Add(50 * time.Millisecond))
	var b [512]byte
	n, _, err := vm.l.ReadFrom(b[:])
	if err != nil {
		
		
		if nerr, ok := err.(net.Error); ok && nerr.Timeout() {
			return n, nil
		}
		return n, err
	}
	return n, nil
}
Package bpf implements marshaling and unmarshaling of programs for the
Berkeley Packet Filter virtual machine, and provides a Go implementation
of the virtual machine.
BPF's main use is to specify a packet filter for network taps, so that
the kernel doesn't have to expensively copy every packet it sees to
userspace. However, it's been repurposed to other areas where running
user code in-kernel is needed. For example, Linux's seccomp uses BPF
to apply security policies to system calls. For simplicity, this
documentation refers only to packets, but other uses of BPF have their
own data payloads.
BPF programs run in a restricted virtual machine. It has almost no
access to kernel functions, and while conditional branches are
allowed, they can only jump forwards, to guarantee that there are no
infinite loops.
The virtual machine
The BPF VM is an accumulator machine. Its main register, called
register A, is an implicit source and destination in all arithmetic
and logic operations. The machine also has 16 scratch registers for
temporary storage, and an indirection register (register X) for
indirect memory access. All registers are 32 bits wide.
Each run of a BPF program is given one packet, which is placed in the
VM's read-only "main memory". LoadAbsolute and LoadIndirect
instructions can fetch up to 32 bits at a time into register A for
examination.
The goal of a BPF program is to produce and return a verdict (uint32),
which tells the kernel what to do with the packet. In the context of
packet filtering, the returned value is the number of bytes of the
packet to forward to userspace, or 0 to ignore the packet. Other
contexts like seccomp define their own return values.
In order to simplify programs, attempts to read past the end of the
packet terminate the program execution with a verdict of 0 (ignore
packet). This means that the vast majority of BPF programs don't need
to do any explicit bounds checking.
In addition to the bytes of the packet, some BPF programs have access
to extensions, which are essentially calls to kernel utility
functions. Currently, the only extensions supported by this package
are the Linux packet filter extensions.
Examples
This packet filter selects all ARP packets.
	bpf.Assemble([]bpf.Instruction{
		
		bpf.LoadAbsolute{Off: 12, Size: 2},
		
		bpf.JumpIf{Cond: bpf.JumpNotEqual, Val: 0x0806, SkipTrue: 1},
		
		bpf.RetConstant{Val: 4096},
		
		bpf.RetConstant{Val: 0},
	})
This packet filter captures a random 1% sample of traffic.
	bpf.Assemble([]bpf.Instruction{
		
		bpf.LoadExtension{Num: bpf.ExtRand},
		
		bpf.JumpIf{Cond: bpf.JumpLessThan, Val: 2^32
		
		bpf.RetConstant{Val: 4096},
		
		bpf.RetConstant{Val: 0},
	})
*
package bpf 
package bpf_test
import (
	"net"
	"testing"
	"golang.org
	"golang.org
)
func TestVMLoadAbsoluteOffsetOutOfBounds(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Off:  100,
			Size: 2,
		},
		bpf.RetA{},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		0, 1, 2, 3,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 0, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMLoadAbsoluteOffsetPlusSizeOutOfBounds(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Off:  8,
			Size: 2,
		},
		bpf.RetA{},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		0,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 0, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMLoadAbsoluteBadInstructionSize(t *testing.T) {
	_, _, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Size: 5,
		},
		bpf.RetA{},
	})
	if errStr(err) != "assembling instruction 1: invalid load byte length 0" {
		t.Fatalf("unexpected error: %v", err)
	}
}
func TestVMLoadConstantOK(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadConstant{
			Dst: bpf.RegX,
			Val: 9,
		},
		bpf.TXA{},
		bpf.RetA{},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		0,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 1, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMLoadIndirectOutOfBounds(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadIndirect{
			Off:  100,
			Size: 1,
		},
		bpf.RetA{},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		0,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 0, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMLoadMemShiftOutOfBounds(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadMemShift{
			Off: 100,
		},
		bpf.RetA{},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		0,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 0, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
const (
	dhcp4Port = 53
)
func TestVMLoadMemShiftLoadIndirectNoResult(t *testing.T) {
	vm, in, done := testDHCPv4(t)
	defer done()
	
	in = append(in, []byte{
		0, 0,
		0, dhcp4Port + 1,
		0, 0,
		0, 0,
	}...)
	out, err := vm.Run(in)
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 0, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMLoadMemShiftLoadIndirectOK(t *testing.T) {
	vm, in, done := testDHCPv4(t)
	defer done()
	
	in = append(in, []byte{
		0, 0,
		0, dhcp4Port,
		0, 0,
		0, 0,
	}...)
	out, err := vm.Run(in)
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := len(in)-8, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func testDHCPv4(t *testing.T) (virtualMachine, []byte, func()) {
	
	
	vm, done, err := testVM(t, []bpf.Instruction{
		
		bpf.LoadMemShift{Off: 8},
		
		bpf.LoadIndirect{Off: 8 + 2, Size: 2},
		
		bpf.JumpIf{Cond: bpf.JumpEqual, Val: dhcp4Port, SkipFalse: 1},
		
		bpf.RetConstant{Val: 1500},
		
		bpf.RetConstant{Val: 0},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	
	h := &ipv4.Header{
		Len: ipv4.HeaderLen,
		Src: net.IPv4(192, 168, 1, 1),
		Dst: net.IPv4(192, 168, 1, 2),
	}
	hb, err := h.Marshal()
	if err != nil {
		t.Fatalf("failed to marshal IPv4 header: %v", err)
	}
	hb = append([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
	}, hb...)
	return vm, hb, done
}
package bpf
import (
	"fmt"
	"io
	"reflect"
	"strconv"
	"strings"
	"testing"
)
var allInstructions = []Instruction{
	LoadConstant{Dst: RegA, Val: 42},
	LoadConstant{Dst: RegX, Val: 42},
	LoadScratch{Dst: RegA, N: 3},
	LoadScratch{Dst: RegX, N: 3},
	LoadAbsolute{Off: 42, Size: 1},
	LoadAbsolute{Off: 42, Size: 2},
	LoadAbsolute{Off: 42, Size: 4},
	LoadIndirect{Off: 42, Size: 1},
	LoadIndirect{Off: 42, Size: 2},
	LoadIndirect{Off: 42, Size: 4},
	LoadMemShift{Off: 42},
	LoadExtension{Num: ExtLen},
	LoadExtension{Num: ExtProto},
	LoadExtension{Num: ExtType},
	LoadExtension{Num: ExtRand},
	StoreScratch{Src: RegA, N: 3},
	StoreScratch{Src: RegX, N: 3},
	ALUOpConstant{Op: ALUOpAdd, Val: 42},
	ALUOpConstant{Op: ALUOpSub, Val: 42},
	ALUOpConstant{Op: ALUOpMul, Val: 42},
	ALUOpConstant{Op: ALUOpDiv, Val: 42},
	ALUOpConstant{Op: ALUOpOr, Val: 42},
	ALUOpConstant{Op: ALUOpAnd, Val: 42},
	ALUOpConstant{Op: ALUOpShiftLeft, Val: 42},
	ALUOpConstant{Op: ALUOpShiftRight, Val: 42},
	ALUOpConstant{Op: ALUOpMod, Val: 42},
	ALUOpConstant{Op: ALUOpXor, Val: 42},
	ALUOpX{Op: ALUOpAdd},
	ALUOpX{Op: ALUOpSub},
	ALUOpX{Op: ALUOpMul},
	ALUOpX{Op: ALUOpDiv},
	ALUOpX{Op: ALUOpOr},
	ALUOpX{Op: ALUOpAnd},
	ALUOpX{Op: ALUOpShiftLeft},
	ALUOpX{Op: ALUOpShiftRight},
	ALUOpX{Op: ALUOpMod},
	ALUOpX{Op: ALUOpXor},
	NegateA{},
	Jump{Skip: 10},
	JumpIf{Cond: JumpEqual, Val: 42, SkipTrue: 8, SkipFalse: 9},
	JumpIf{Cond: JumpNotEqual, Val: 42, SkipTrue: 8},
	JumpIf{Cond: JumpLessThan, Val: 42, SkipTrue: 7},
	JumpIf{Cond: JumpLessOrEqual, Val: 42, SkipTrue: 6},
	JumpIf{Cond: JumpGreaterThan, Val: 42, SkipTrue: 4, SkipFalse: 5},
	JumpIf{Cond: JumpGreaterOrEqual, Val: 42, SkipTrue: 3, SkipFalse: 4},
	JumpIf{Cond: JumpBitsSet, Val: 42, SkipTrue: 2, SkipFalse: 3},
	TAX{},
	TXA{},
	RetA{},
	RetConstant{Val: 42},
}
var allInstructionsExpected = "testdata
func TestInterop(t *testing.T) {
	out, err := Assemble(allInstructions)
	if err != nil {
		t.Fatalf("assembly of allInstructions program failed: %s", err)
	}
	t.Logf("Assembled program is %d instructions long", len(out))
	bs, err := ioutil.ReadFile(allInstructionsExpected)
	if err != nil {
		t.Fatalf("reading %s: %s", allInstructionsExpected, err)
	}
	
	
	stmts := strings.Split(string(bs), ",")
	if len(stmts)-2 != len(out) {
		t.Fatalf("test program lengths don't match: %s has %d, Go implementation has %d", allInstructionsExpected, len(stmts)-2, len(allInstructions))
	}
	for i, stmt := range stmts[1 : len(stmts)-2] {
		nums := strings.Split(stmt, " ")
		if len(nums) != 4 {
			t.Fatalf("malformed instruction %d in %s: %s", i+1, allInstructionsExpected, stmt)
		}
		actual := out[i]
		op, err := strconv.ParseUint(nums[0], 10, 16)
		if err != nil {
			t.Fatalf("malformed opcode %s in instruction %d of %s", nums[0], i+1, allInstructionsExpected)
		}
		if actual.Op != uint16(op) {
			t.Errorf("opcode mismatch on instruction %d (%#v): got 0x%02x, want 0x%02x", i+1, allInstructions[i], actual.Op, op)
		}
		jt, err := strconv.ParseUint(nums[1], 10, 8)
		if err != nil {
			t.Fatalf("malformed jt offset %s in instruction %d of %s", nums[1], i+1, allInstructionsExpected)
		}
		if actual.Jt != uint8(jt) {
			t.Errorf("jt mismatch on instruction %d (%#v): got %d, want %d", i+1, allInstructions[i], actual.Jt, jt)
		}
		jf, err := strconv.ParseUint(nums[2], 10, 8)
		if err != nil {
			t.Fatalf("malformed jf offset %s in instruction %d of %s", nums[2], i+1, allInstructionsExpected)
		}
		if actual.Jf != uint8(jf) {
			t.Errorf("jf mismatch on instruction %d (%#v): got %d, want %d", i+1, allInstructions[i], actual.Jf, jf)
		}
		k, err := strconv.ParseUint(nums[3], 10, 32)
		if err != nil {
			t.Fatalf("malformed constant %s in instruction %d of %s", nums[3], i+1, allInstructionsExpected)
		}
		if actual.K != uint32(k) {
			t.Errorf("constant mismatch on instruction %d (%#v): got %d, want %d", i+1, allInstructions[i], actual.K, k)
		}
	}
}
func TestAsmDisasm(t *testing.T) {
	prog1, err := Assemble(allInstructions)
	if err != nil {
		t.Fatalf("assembly of allInstructions program failed: %s", err)
	}
	t.Logf("Assembled program is %d instructions long", len(prog1))
	got, allDecoded := Disassemble(prog1)
	if !allDecoded {
		t.Errorf("Disassemble(Assemble(allInstructions)) produced unrecognized instructions:")
		for i, inst := range got {
			if r, ok := inst.(RawInstruction); ok {
				t.Logf("  insn %d, %#v --> %#v", i+1, allInstructions[i], r)
			}
		}
	}
	if len(allInstructions) != len(got) {
		t.Fatalf("disassembly changed program size: %d insns before, %d insns after", len(allInstructions), len(got))
	}
	if !reflect.DeepEqual(allInstructions, got) {
		t.Errorf("program mutated by disassembly:")
		for i := range got {
			if !reflect.DeepEqual(allInstructions[i], got[i]) {
				t.Logf("  insn %d, s: %#v, p1: %#v, got: %#v", i+1, allInstructions[i], prog1[i], got[i])
			}
		}
	}
}
type InvalidInstruction struct{}
func (a InvalidInstruction) Assemble() (RawInstruction, error) {
	return RawInstruction{}, fmt.Errorf("Invalid Instruction")
}
func (a InvalidInstruction) String() string {
	return fmt.Sprintf("unknown instruction: %#v", a)
}
func TestString(t *testing.T) {
	testCases := []struct {
		instruction Instruction
		assembler   string
	}{
		{
			instruction: LoadConstant{Dst: RegA, Val: 42},
			assembler:   "ld #42",
		},
		{
			instruction: LoadConstant{Dst: RegX, Val: 42},
			assembler:   "ldx #42",
		},
		{
			instruction: LoadConstant{Dst: 0xffff, Val: 42},
			assembler:   "unknown instruction: bpf.LoadConstant{Dst:0xffff, Val:0x2a}",
		},
		{
			instruction: LoadScratch{Dst: RegA, N: 3},
			assembler:   "ld M[3]",
		},
		{
			instruction: LoadScratch{Dst: RegX, N: 3},
			assembler:   "ldx M[3]",
		},
		{
			instruction: LoadScratch{Dst: 0xffff, N: 3},
			assembler:   "unknown instruction: bpf.LoadScratch{Dst:0xffff, N:3}",
		},
		{
			instruction: LoadAbsolute{Off: 42, Size: 1},
			assembler:   "ldb [42]",
		},
		{
			instruction: LoadAbsolute{Off: 42, Size: 2},
			assembler:   "ldh [42]",
		},
		{
			instruction: LoadAbsolute{Off: 42, Size: 4},
			assembler:   "ld [42]",
		},
		{
			instruction: LoadAbsolute{Off: 42, Size: -1},
			assembler:   "unknown instruction: bpf.LoadAbsolute{Off:0x2a, Size:-1}",
		},
		{
			instruction: LoadIndirect{Off: 42, Size: 1},
			assembler:   "ldb [x + 42]",
		},
		{
			instruction: LoadIndirect{Off: 42, Size: 2},
			assembler:   "ldh [x + 42]",
		},
		{
			instruction: LoadIndirect{Off: 42, Size: 4},
			assembler:   "ld [x + 42]",
		},
		{
			instruction: LoadIndirect{Off: 42, Size: -1},
			assembler:   "unknown instruction: bpf.LoadIndirect{Off:0x2a, Size:-1}",
		},
		{
			instruction: LoadMemShift{Off: 42},
			assembler:   "ldx 4*([42]&0xf)",
		},
		{
			instruction: LoadExtension{Num: ExtLen},
			assembler:   "ld #len",
		},
		{
			instruction: LoadExtension{Num: ExtProto},
			assembler:   "ld #proto",
		},
		{
			instruction: LoadExtension{Num: ExtType},
			assembler:   "ld #type",
		},
		{
			instruction: LoadExtension{Num: ExtPayloadOffset},
			assembler:   "ld #poff",
		},
		{
			instruction: LoadExtension{Num: ExtInterfaceIndex},
			assembler:   "ld #ifidx",
		},
		{
			instruction: LoadExtension{Num: ExtNetlinkAttr},
			assembler:   "ld #nla",
		},
		{
			instruction: LoadExtension{Num: ExtNetlinkAttrNested},
			assembler:   "ld #nlan",
		},
		{
			instruction: LoadExtension{Num: ExtMark},
			assembler:   "ld #mark",
		},
		{
			instruction: LoadExtension{Num: ExtQueue},
			assembler:   "ld #queue",
		},
		{
			instruction: LoadExtension{Num: ExtLinkLayerType},
			assembler:   "ld #hatype",
		},
		{
			instruction: LoadExtension{Num: ExtRXHash},
			assembler:   "ld #rxhash",
		},
		{
			instruction: LoadExtension{Num: ExtCPUID},
			assembler:   "ld #cpu",
		},
		{
			instruction: LoadExtension{Num: ExtVLANTag},
			assembler:   "ld #vlan_tci",
		},
		{
			instruction: LoadExtension{Num: ExtVLANTagPresent},
			assembler:   "ld #vlan_avail",
		},
		{
			instruction: LoadExtension{Num: ExtVLANProto},
			assembler:   "ld #vlan_tpid",
		},
		{
			instruction: LoadExtension{Num: ExtRand},
			assembler:   "ld #rand",
		},
		{
			instruction: LoadAbsolute{Off: 0xfffff038, Size: 4},
			assembler:   "ld #rand",
		},
		{
			instruction: LoadExtension{Num: 0xfff},
			assembler:   "unknown instruction: bpf.LoadExtension{Num:4095}",
		},
		{
			instruction: StoreScratch{Src: RegA, N: 3},
			assembler:   "st M[3]",
		},
		{
			instruction: StoreScratch{Src: RegX, N: 3},
			assembler:   "stx M[3]",
		},
		{
			instruction: StoreScratch{Src: 0xffff, N: 3},
			assembler:   "unknown instruction: bpf.StoreScratch{Src:0xffff, N:3}",
		},
		{
			instruction: ALUOpConstant{Op: ALUOpAdd, Val: 42},
			assembler:   "add #42",
		},
		{
			instruction: ALUOpConstant{Op: ALUOpSub, Val: 42},
			assembler:   "sub #42",
		},
		{
			instruction: ALUOpConstant{Op: ALUOpMul, Val: 42},
			assembler:   "mul #42",
		},
		{
			instruction: ALUOpConstant{Op: ALUOpDiv, Val: 42},
			assembler:   "div #42",
		},
		{
			instruction: ALUOpConstant{Op: ALUOpOr, Val: 42},
			assembler:   "or #42",
		},
		{
			instruction: ALUOpConstant{Op: ALUOpAnd, Val: 42},
			assembler:   "and #42",
		},
		{
			instruction: ALUOpConstant{Op: ALUOpShiftLeft, Val: 42},
			assembler:   "lsh #42",
		},
		{
			instruction: ALUOpConstant{Op: ALUOpShiftRight, Val: 42},
			assembler:   "rsh #42",
		},
		{
			instruction: ALUOpConstant{Op: ALUOpMod, Val: 42},
			assembler:   "mod #42",
		},
		{
			instruction: ALUOpConstant{Op: ALUOpXor, Val: 42},
			assembler:   "xor #42",
		},
		{
			instruction: ALUOpConstant{Op: 0xffff, Val: 42},
			assembler:   "unknown instruction: bpf.ALUOpConstant{Op:0xffff, Val:0x2a}",
		},
		{
			instruction: ALUOpX{Op: ALUOpAdd},
			assembler:   "add x",
		},
		{
			instruction: ALUOpX{Op: ALUOpSub},
			assembler:   "sub x",
		},
		{
			instruction: ALUOpX{Op: ALUOpMul},
			assembler:   "mul x",
		},
		{
			instruction: ALUOpX{Op: ALUOpDiv},
			assembler:   "div x",
		},
		{
			instruction: ALUOpX{Op: ALUOpOr},
			assembler:   "or x",
		},
		{
			instruction: ALUOpX{Op: ALUOpAnd},
			assembler:   "and x",
		},
		{
			instruction: ALUOpX{Op: ALUOpShiftLeft},
			assembler:   "lsh x",
		},
		{
			instruction: ALUOpX{Op: ALUOpShiftRight},
			assembler:   "rsh x",
		},
		{
			instruction: ALUOpX{Op: ALUOpMod},
			assembler:   "mod x",
		},
		{
			instruction: ALUOpX{Op: ALUOpXor},
			assembler:   "xor x",
		},
		{
			instruction: ALUOpX{Op: 0xffff},
			assembler:   "unknown instruction: bpf.ALUOpX{Op:0xffff}",
		},
		{
			instruction: NegateA{},
			assembler:   "neg",
		},
		{
			instruction: Jump{Skip: 10},
			assembler:   "ja 10",
		},
		{
			instruction: JumpIf{Cond: JumpEqual, Val: 42, SkipTrue: 8, SkipFalse: 9},
			assembler:   "jeq #42,8,9",
		},
		{
			instruction: JumpIf{Cond: JumpEqual, Val: 42, SkipTrue: 8},
			assembler:   "jeq #42,8",
		},
		{
			instruction: JumpIf{Cond: JumpEqual, Val: 42, SkipFalse: 8},
			assembler:   "jneq #42,8",
		},
		{
			instruction: JumpIf{Cond: JumpNotEqual, Val: 42, SkipTrue: 8},
			assembler:   "jneq #42,8",
		},
		{
			instruction: JumpIf{Cond: JumpLessThan, Val: 42, SkipTrue: 7},
			assembler:   "jlt #42,7",
		},
		{
			instruction: JumpIf{Cond: JumpLessOrEqual, Val: 42, SkipTrue: 6},
			assembler:   "jle #42,6",
		},
		{
			instruction: JumpIf{Cond: JumpGreaterThan, Val: 42, SkipTrue: 4, SkipFalse: 5},
			assembler:   "jgt #42,4,5",
		},
		{
			instruction: JumpIf{Cond: JumpGreaterThan, Val: 42, SkipTrue: 4},
			assembler:   "jgt #42,4",
		},
		{
			instruction: JumpIf{Cond: JumpGreaterOrEqual, Val: 42, SkipTrue: 3, SkipFalse: 4},
			assembler:   "jge #42,3,4",
		},
		{
			instruction: JumpIf{Cond: JumpGreaterOrEqual, Val: 42, SkipTrue: 3},
			assembler:   "jge #42,3",
		},
		{
			instruction: JumpIf{Cond: JumpBitsSet, Val: 42, SkipTrue: 2, SkipFalse: 3},
			assembler:   "jset #42,2,3",
		},
		{
			instruction: JumpIf{Cond: JumpBitsSet, Val: 42, SkipTrue: 2},
			assembler:   "jset #42,2",
		},
		{
			instruction: JumpIf{Cond: JumpBitsNotSet, Val: 42, SkipTrue: 2, SkipFalse: 3},
			assembler:   "jset #42,3,2",
		},
		{
			instruction: JumpIf{Cond: JumpBitsNotSet, Val: 42, SkipTrue: 2},
			assembler:   "jset #42,0,2",
		},
		{
			instruction: JumpIf{Cond: 0xffff, Val: 42, SkipTrue: 1, SkipFalse: 2},
			assembler:   "unknown instruction: bpf.JumpIf{Cond:0xffff, Val:0x2a, SkipTrue:0x1, SkipFalse:0x2}",
		},
		{
			instruction: TAX{},
			assembler:   "tax",
		},
		{
			instruction: TXA{},
			assembler:   "txa",
		},
		{
			instruction: RetA{},
			assembler:   "ret a",
		},
		{
			instruction: RetConstant{Val: 42},
			assembler:   "ret #42",
		},
		
		{
			instruction: InvalidInstruction{},
			assembler:   "unknown instruction: bpf.InvalidInstruction{}",
		},
	}
	for _, testCase := range testCases {
		if input, ok := testCase.instruction.(fmt.Stringer); ok {
			got := input.String()
			if got != testCase.assembler {
				t.Errorf("String did not return expected assembler notation, expected: %s, got: %s", testCase.assembler, got)
			}
		} else {
			t.Errorf("Instruction %#v is not a fmt.Stringer", testCase.instruction)
		}
	}
}
package bpf_test
import (
	"testing"
	"golang.org
)
func TestVMStoreScratchInvalidScratchRegisterTooSmall(t *testing.T) {
	_, _, err := testVM(t, []bpf.Instruction{
		bpf.StoreScratch{
			Src: bpf.RegA,
			N:   -1,
		},
		bpf.RetA{},
	})
	if errStr(err) != "assembling instruction 1: invalid scratch slot -1" {
		t.Fatalf("unexpected error: %v", err)
	}
}
func TestVMStoreScratchInvalidScratchRegisterTooLarge(t *testing.T) {
	_, _, err := testVM(t, []bpf.Instruction{
		bpf.StoreScratch{
			Src: bpf.RegA,
			N:   16,
		},
		bpf.RetA{},
	})
	if errStr(err) != "assembling instruction 1: invalid scratch slot 16" {
		t.Fatalf("unexpected error: %v", err)
	}
}
func TestVMStoreScratchUnknownSourceRegister(t *testing.T) {
	_, _, err := testVM(t, []bpf.Instruction{
		bpf.StoreScratch{
			Src: 100,
			N:   0,
		},
		bpf.RetA{},
	})
	if errStr(err) != "assembling instruction 1: invalid source register 100" {
		t.Fatalf("unexpected error: %v", err)
	}
}
func TestVMLoadScratchInvalidScratchRegisterTooSmall(t *testing.T) {
	_, _, err := testVM(t, []bpf.Instruction{
		bpf.LoadScratch{
			Dst: bpf.RegX,
			N:   -1,
		},
		bpf.RetA{},
	})
	if errStr(err) != "assembling instruction 1: invalid scratch slot -1" {
		t.Fatalf("unexpected error: %v", err)
	}
}
func TestVMLoadScratchInvalidScratchRegisterTooLarge(t *testing.T) {
	_, _, err := testVM(t, []bpf.Instruction{
		bpf.LoadScratch{
			Dst: bpf.RegX,
			N:   16,
		},
		bpf.RetA{},
	})
	if errStr(err) != "assembling instruction 1: invalid scratch slot 16" {
		t.Fatalf("unexpected error: %v", err)
	}
}
func TestVMLoadScratchUnknownDestinationRegister(t *testing.T) {
	_, _, err := testVM(t, []bpf.Instruction{
		bpf.LoadScratch{
			Dst: 100,
			N:   0,
		},
		bpf.RetA{},
	})
	if errStr(err) != "assembling instruction 1: invalid target register 100" {
		t.Fatalf("unexpected error: %v", err)
	}
}
func TestVMStoreScratchLoadScratchOneValue(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		
		bpf.LoadAbsolute{
			Off:  8,
			Size: 1,
		},
		
		bpf.TAX{},
		bpf.StoreScratch{
			Src: bpf.RegX,
			N:   0,
		},
		
		bpf.LoadAbsolute{
			Off:  9,
			Size: 1,
		},
		
		bpf.LoadScratch{
			Dst: bpf.RegA,
			N:   0,
		},
		
		bpf.RetA{},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		255, 1, 2,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 3, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMStoreScratchLoadScratchMultipleValues(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		
		bpf.LoadAbsolute{
			Off:  8,
			Size: 1,
		},
		
		bpf.StoreScratch{
			Src: bpf.RegA,
			N:   0,
		},
		
		bpf.LoadAbsolute{
			Off:  9,
			Size: 1,
		},
		
		bpf.StoreScratch{
			Src: bpf.RegA,
			N:   1,
		},
		
		bpf.LoadAbsolute{
			Off:  10,
			Size: 1,
		},
		
		bpf.StoreScratch{
			Src: bpf.RegA,
			N:   2,
		},
		
		bpf.LoadAbsolute{
			Off:  11,
			Size: 1,
		},
		
		bpf.StoreScratch{
			Src: bpf.RegA,
			N:   3,
		},
		
		bpf.LoadScratch{
			Dst: bpf.RegX,
			N:   0,
		},
		
		bpf.TXA{},
		
		bpf.JumpIf{
			Cond:     bpf.JumpEqual,
			Val:      10,
			SkipTrue: 1,
		},
		
		bpf.RetConstant{
			Val: 0,
		},
		
		bpf.LoadScratch{
			Dst: bpf.RegA,
			N:   1,
		},
		
		bpf.JumpIf{
			Cond:     bpf.JumpEqual,
			Val:      20,
			SkipTrue: 1,
		},
		
		bpf.RetConstant{
			Val: 0,
		},
		
		bpf.LoadScratch{
			Dst: bpf.RegA,
			N:   2,
		},
		
		bpf.JumpIf{
			Cond:     bpf.JumpEqual,
			Val:      30,
			SkipTrue: 1,
		},
		
		bpf.RetConstant{
			Val: 0,
		},
		
		bpf.RetConstant{
			Val: 10,
		},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		10, 20, 30, 1,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 2, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
package bpf_test
import (
	"testing"
	"golang.org
)
func TestVMJumpOne(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Off:  8,
			Size: 1,
		},
		bpf.Jump{
			Skip: 1,
		},
		bpf.RetConstant{
			Val: 0,
		},
		bpf.RetConstant{
			Val: 9,
		},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		1,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 1, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMJumpOutOfProgram(t *testing.T) {
	_, _, err := testVM(t, []bpf.Instruction{
		bpf.Jump{
			Skip: 1,
		},
		bpf.RetA{},
	})
	if errStr(err) != "cannot jump 1 instructions; jumping past program bounds" {
		t.Fatalf("unexpected error: %v", err)
	}
}
func TestVMJumpIfTrueOutOfProgram(t *testing.T) {
	_, _, err := testVM(t, []bpf.Instruction{
		bpf.JumpIf{
			Cond:     bpf.JumpEqual,
			SkipTrue: 2,
		},
		bpf.RetA{},
	})
	if errStr(err) != "cannot jump 2 instructions in true case; jumping past program bounds" {
		t.Fatalf("unexpected error: %v", err)
	}
}
func TestVMJumpIfFalseOutOfProgram(t *testing.T) {
	_, _, err := testVM(t, []bpf.Instruction{
		bpf.JumpIf{
			Cond:      bpf.JumpEqual,
			SkipFalse: 3,
		},
		bpf.RetA{},
	})
	if errStr(err) != "cannot jump 3 instructions in false case; jumping past program bounds" {
		t.Fatalf("unexpected error: %v", err)
	}
}
func TestVMJumpIfEqual(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Off:  8,
			Size: 1,
		},
		bpf.JumpIf{
			Cond:     bpf.JumpEqual,
			Val:      1,
			SkipTrue: 1,
		},
		bpf.RetConstant{
			Val: 0,
		},
		bpf.RetConstant{
			Val: 9,
		},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		1,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 1, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMJumpIfNotEqual(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Off:  8,
			Size: 1,
		},
		bpf.JumpIf{
			Cond:      bpf.JumpNotEqual,
			Val:       1,
			SkipFalse: 1,
		},
		bpf.RetConstant{
			Val: 0,
		},
		bpf.RetConstant{
			Val: 9,
		},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		1,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 1, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMJumpIfGreaterThan(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Off:  8,
			Size: 4,
		},
		bpf.JumpIf{
			Cond:     bpf.JumpGreaterThan,
			Val:      0x00010202,
			SkipTrue: 1,
		},
		bpf.RetConstant{
			Val: 0,
		},
		bpf.RetConstant{
			Val: 12,
		},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		0, 1, 2, 3,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 4, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMJumpIfLessThan(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Off:  8,
			Size: 4,
		},
		bpf.JumpIf{
			Cond:     bpf.JumpLessThan,
			Val:      0xff010203,
			SkipTrue: 1,
		},
		bpf.RetConstant{
			Val: 0,
		},
		bpf.RetConstant{
			Val: 12,
		},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		0, 1, 2, 3,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 4, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMJumpIfGreaterOrEqual(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Off:  8,
			Size: 4,
		},
		bpf.JumpIf{
			Cond:     bpf.JumpGreaterOrEqual,
			Val:      0x00010203,
			SkipTrue: 1,
		},
		bpf.RetConstant{
			Val: 0,
		},
		bpf.RetConstant{
			Val: 12,
		},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		0, 1, 2, 3,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 4, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMJumpIfLessOrEqual(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Off:  8,
			Size: 4,
		},
		bpf.JumpIf{
			Cond:     bpf.JumpLessOrEqual,
			Val:      0xff010203,
			SkipTrue: 1,
		},
		bpf.RetConstant{
			Val: 0,
		},
		bpf.RetConstant{
			Val: 12,
		},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		0, 1, 2, 3,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 4, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMJumpIfBitsSet(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Off:  8,
			Size: 2,
		},
		bpf.JumpIf{
			Cond:     bpf.JumpBitsSet,
			Val:      0x1122,
			SkipTrue: 1,
		},
		bpf.RetConstant{
			Val: 0,
		},
		bpf.RetConstant{
			Val: 10,
		},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		0x01, 0x02,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 2, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMJumpIfBitsNotSet(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Off:  8,
			Size: 2,
		},
		bpf.JumpIf{
			Cond:     bpf.JumpBitsNotSet,
			Val:      0x1221,
			SkipTrue: 1,
		},
		bpf.RetConstant{
			Val: 0,
		},
		bpf.RetConstant{
			Val: 10,
		},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		0x01, 0x02,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 2, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
package bpf
import "fmt"
func Assemble(insts []Instruction) ([]RawInstruction, error) {
	ret := make([]RawInstruction, len(insts))
	var err error
	for i, inst := range insts {
		ret[i], err = inst.Assemble()
		if err != nil {
			return nil, fmt.Errorf("assembling instruction %d: %s", i+1, err)
		}
	}
	return ret, nil
}
func Disassemble(raw []RawInstruction) (insts []Instruction, allDecoded bool) {
	insts = make([]Instruction, len(raw))
	allDecoded = true
	for i, r := range raw {
		insts[i] = r.Disassemble()
		if _, ok := insts[i].(RawInstruction); ok {
			allDecoded = false
		}
	}
	return insts, allDecoded
}
package bpf_test
import (
	"testing"
	"golang.org
)
func TestVMRetA(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Off:  8,
			Size: 1,
		},
		bpf.RetA{},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		9,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 1, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMRetALargerThanInput(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.LoadAbsolute{
			Off:  8,
			Size: 2,
		},
		bpf.RetA{},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		0, 255,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 2, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMRetConstant(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.RetConstant{
			Val: 9,
		},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		0, 1,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 1, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
func TestVMRetConstantLargerThanInput(t *testing.T) {
	vm, done, err := testVM(t, []bpf.Instruction{
		bpf.RetConstant{
			Val: 16,
		},
	})
	if err != nil {
		t.Fatalf("failed to load BPF program: %v", err)
	}
	defer done()
	out, err := vm.Run([]byte{
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff,
		0, 1,
	})
	if err != nil {
		t.Fatalf("unexpected error while running program: %v", err)
	}
	if want, got := 2, out; want != got {
		t.Fatalf("unexpected number of output bytes:\n- want: %d\n-  got: %d",
			want, got)
	}
}
package bpf
type Setter interface {
	SetBPF(filter []RawInstruction) error
}
package proxy
import (
	"errors"
	"io"
	"net"
	"strconv"
)
func SOCKS5(network, addr string, auth *Auth, forward Dialer) (Dialer, error) {
	s := &socks5{
		network: network,
		addr:    addr,
		forward: forward,
	}
	if auth != nil {
		s.user = auth.User
		s.password = auth.Password
	}
	return s, nil
}
type socks5 struct {
	user, password string
	network, addr  string
	forward        Dialer
}
const socks5Version = 5
const (
	socks5AuthNone     = 0
	socks5AuthPassword = 2
)
const socks5Connect = 1
const (
	socks5IP4    = 1
	socks5Domain = 3
	socks5IP6    = 4
)
var socks5Errors = []string{
	"",
	"general failure",
	"connection forbidden",
	"network unreachable",
	"host unreachable",
	"connection refused",
	"TTL expired",
	"command not supported",
	"address type not supported",
}
func (s *socks5) Dial(network, addr string) (net.Conn, error) {
	switch network {
	case "tcp", "tcp6", "tcp4":
	default:
		return nil, errors.New("proxy: no support for SOCKS5 proxy connections of type " + network)
	}
	conn, err := s.forward.Dial(s.network, s.addr)
	if err != nil {
		return nil, err
	}
	if err := s.connect(conn, addr); err != nil {
		conn.Close()
		return nil, err
	}
	return conn, nil
}
func (s *socks5) connect(conn net.Conn, target string) error {
	host, portStr, err := net.SplitHostPort(target)
	if err != nil {
		return err
	}
	port, err := strconv.Atoi(portStr)
	if err != nil {
		return errors.New("proxy: failed to parse port number: " + portStr)
	}
	if port < 1 || port > 0xffff {
		return errors.New("proxy: port number out of range: " + portStr)
	}
	
	buf := make([]byte, 0, 6+len(host))
	buf = append(buf, socks5Version)
	if len(s.user) > 0 && len(s.user) < 256 && len(s.password) < 256 {
		buf = append(buf, 2 
	} else {
		buf = append(buf, 1 
	}
	if _, err := conn.Write(buf); err != nil {
		return errors.New("proxy: failed to write greeting to SOCKS5 proxy at " + s.addr + ": " + err.Error())
	}
	if _, err := io.ReadFull(conn, buf[:2]); err != nil {
		return errors.New("proxy: failed to read greeting from SOCKS5 proxy at " + s.addr + ": " + err.Error())
	}
	if buf[0] != 5 {
		return errors.New("proxy: SOCKS5 proxy at " + s.addr + " has unexpected version " + strconv.Itoa(int(buf[0])))
	}
	if buf[1] == 0xff {
		return errors.New("proxy: SOCKS5 proxy at " + s.addr + " requires authentication")
	}
	if buf[1] == socks5AuthPassword {
		buf = buf[:0]
		buf = append(buf, 1 
		buf = append(buf, uint8(len(s.user)))
		buf = append(buf, s.user...)
		buf = append(buf, uint8(len(s.password)))
		buf = append(buf, s.password...)
		if _, err := conn.Write(buf); err != nil {
			return errors.New("proxy: failed to write authentication request to SOCKS5 proxy at " + s.addr + ": " + err.Error())
		}
		if _, err := io.ReadFull(conn, buf[:2]); err != nil {
			return errors.New("proxy: failed to read authentication reply from SOCKS5 proxy at " + s.addr + ": " + err.Error())
		}
		if buf[1] != 0 {
			return errors.New("proxy: SOCKS5 proxy at " + s.addr + " rejected username
		}
	}
	buf = buf[:0]
	buf = append(buf, socks5Version, socks5Connect, 0 
	if ip := net.ParseIP(host); ip != nil {
		if ip4 := ip.To4(); ip4 != nil {
			buf = append(buf, socks5IP4)
			ip = ip4
		} else {
			buf = append(buf, socks5IP6)
		}
		buf = append(buf, ip...)
	} else {
		if len(host) > 255 {
			return errors.New("proxy: destination host name too long: " + host)
		}
		buf = append(buf, socks5Domain)
		buf = append(buf, byte(len(host)))
		buf = append(buf, host...)
	}
	buf = append(buf, byte(port>>8), byte(port))
	if _, err := conn.Write(buf); err != nil {
		return errors.New("proxy: failed to write connect request to SOCKS5 proxy at " + s.addr + ": " + err.Error())
	}
	if _, err := io.ReadFull(conn, buf[:4]); err != nil {
		return errors.New("proxy: failed to read connect reply from SOCKS5 proxy at " + s.addr + ": " + err.Error())
	}
	failure := "unknown error"
	if int(buf[1]) < len(socks5Errors) {
		failure = socks5Errors[buf[1]]
	}
	if len(failure) > 0 {
		return errors.New("proxy: SOCKS5 proxy at " + s.addr + " failed to connect: " + failure)
	}
	bytesToDiscard := 0
	switch buf[3] {
	case socks5IP4:
		bytesToDiscard = net.IPv4len
	case socks5IP6:
		bytesToDiscard = net.IPv6len
	case socks5Domain:
		_, err := io.ReadFull(conn, buf[:1])
		if err != nil {
			return errors.New("proxy: failed to read domain length from SOCKS5 proxy at " + s.addr + ": " + err.Error())
		}
		bytesToDiscard = int(buf[0])
	default:
		return errors.New("proxy: got unknown address type " + strconv.Itoa(int(buf[3])) + " from SOCKS5 proxy at " + s.addr)
	}
	if cap(buf) < bytesToDiscard {
		buf = make([]byte, bytesToDiscard)
	} else {
		buf = buf[:bytesToDiscard]
	}
	if _, err := io.ReadFull(conn, buf); err != nil {
		return errors.New("proxy: failed to read address from SOCKS5 proxy at " + s.addr + ": " + err.Error())
	}
	
	if _, err := io.ReadFull(conn, buf[:2]); err != nil {
		return errors.New("proxy: failed to read port from SOCKS5 proxy at " + s.addr + ": " + err.Error())
	}
	return nil
}
package proxy
import (
	"net"
	"strings"
)
type PerHost struct {
	def, bypass Dialer
	bypassNetworks []*net.IPNet
	bypassIPs      []net.IP
	bypassZones    []string
	bypassHosts    []string
}
func NewPerHost(defaultDialer, bypass Dialer) *PerHost {
	return &PerHost{
		def:    defaultDialer,
		bypass: bypass,
	}
}
func (p *PerHost) Dial(network, addr string) (c net.Conn, err error) {
	host, _, err := net.SplitHostPort(addr)
	if err != nil {
		return nil, err
	}
	return p.dialerForRequest(host).Dial(network, addr)
}
func (p *PerHost) dialerForRequest(host string) Dialer {
	if ip := net.ParseIP(host); ip != nil {
		for _, net := range p.bypassNetworks {
			if net.Contains(ip) {
				return p.bypass
			}
		}
		for _, bypassIP := range p.bypassIPs {
			if bypassIP.Equal(ip) {
				return p.bypass
			}
		}
		return p.def
	}
	for _, zone := range p.bypassZones {
		if strings.HasSuffix(host, zone) {
			return p.bypass
		}
		if host == zone[1:] {
			
			
			return p.bypass
		}
	}
	for _, bypassHost := range p.bypassHosts {
		if bypassHost == host {
			return p.bypass
		}
	}
	return p.def
}
func (p *PerHost) AddFromString(s string) {
	hosts := strings.Split(s, ",")
	for _, host := range hosts {
		host = strings.TrimSpace(host)
		if len(host) == 0 {
			continue
		}
		if strings.Contains(host, "
			
			if _, net, err := net.ParseCIDR(host); err == nil {
				p.AddNetwork(net)
			}
			continue
		}
		if ip := net.ParseIP(host); ip != nil {
			p.AddIP(ip)
			continue
		}
		if strings.HasPrefix(host, "*.") {
			p.AddZone(host[1:])
			continue
		}
		p.AddHost(host)
	}
}
func (p *PerHost) AddIP(ip net.IP) {
	p.bypassIPs = append(p.bypassIPs, ip)
}
func (p *PerHost) AddNetwork(net *net.IPNet) {
	p.bypassNetworks = append(p.bypassNetworks, net)
}
func (p *PerHost) AddZone(zone string) {
	if strings.HasSuffix(zone, ".") {
		zone = zone[:len(zone)-1]
	}
	if !strings.HasPrefix(zone, ".") {
		zone = "." + zone
	}
	p.bypassZones = append(p.bypassZones, zone)
}
func (p *PerHost) AddHost(host string) {
	if strings.HasSuffix(host, ".") {
		host = host[:len(host)-1]
	}
	p.bypassHosts = append(p.bypassHosts, host)
}
package proxy 
import (
	"errors"
	"net"
	"net
	"os"
	"sync"
)
type Dialer interface {
	
	Dial(network, addr string) (c net.Conn, err error)
}
type Auth struct {
	User, Password string
}
func FromEnvironment() Dialer {
	allProxy := allProxyEnv.Get()
	if len(allProxy) == 0 {
		return Direct
	}
	proxyURL, err := url.Parse(allProxy)
	if err != nil {
		return Direct
	}
	proxy, err := FromURL(proxyURL, Direct)
	if err != nil {
		return Direct
	}
	noProxy := noProxyEnv.Get()
	if len(noProxy) == 0 {
		return proxy
	}
	perHost := NewPerHost(proxy, Direct)
	perHost.AddFromString(noProxy)
	return perHost
}
var proxySchemes map[string]func(*url.URL, Dialer) (Dialer, error)
func RegisterDialerType(scheme string, f func(*url.URL, Dialer) (Dialer, error)) {
	if proxySchemes == nil {
		proxySchemes = make(map[string]func(*url.URL, Dialer) (Dialer, error))
	}
	proxySchemes[scheme] = f
}
func FromURL(u *url.URL, forward Dialer) (Dialer, error) {
	var auth *Auth
	if u.User != nil {
		auth = new(Auth)
		auth.User = u.User.Username()
		if p, ok := u.User.Password(); ok {
			auth.Password = p
		}
	}
	switch u.Scheme {
	case "socks5":
		return SOCKS5("tcp", u.Host, auth, forward)
	}
	
	
	if proxySchemes != nil {
		if f, ok := proxySchemes[u.Scheme]; ok {
			return f(u, forward)
		}
	}
	return nil, errors.New("proxy: unknown scheme: " + u.Scheme)
}
var (
	allProxyEnv = &envOnce{
		names: []string{"ALL_PROXY", "all_proxy"},
	}
	noProxyEnv = &envOnce{
		names: []string{"NO_PROXY", "no_proxy"},
	}
)
type envOnce struct {
	names []string
	once  sync.Once
	val   string
}
func (e *envOnce) Get() string {
	e.once.Do(e.init)
	return e.val
}
func (e *envOnce) init() {
	for _, n := range e.names {
		e.val = os.Getenv(n)
		if e.val != "" {
			return
		}
	}
}
func (e *envOnce) reset() {
	e.once = sync.Once{}
	e.val = ""
}
package proxy
import (
	"net"
)
type direct struct{}
var Direct = direct{}
func (direct) Dial(network, addr string) (net.Conn, error) {
	return net.Dial(network, addr)
}
package proxy
import (
	"errors"
	"net"
	"reflect"
	"testing"
)
type recordingProxy struct {
	addrs []string
}
func (r *recordingProxy) Dial(network, addr string) (net.Conn, error) {
	r.addrs = append(r.addrs, addr)
	return nil, errors.New("recordingProxy")
}
func TestPerHost(t *testing.T) {
	var def, bypass recordingProxy
	perHost := NewPerHost(&def, &bypass)
	perHost.AddFromString("localhost,*.zone,127.0.0.1,10.0.0.1
	expectedDef := []string{
		"example.com:123",
		"1.2.3.4:123",
		"[1001::]:123",
	}
	expectedBypass := []string{
		"localhost:123",
		"zone:123",
		"foo.zone:123",
		"127.0.0.1:123",
		"10.1.2.3:123",
		"[1000::]:123",
	}
	for _, addr := range expectedDef {
		perHost.Dial("tcp", addr)
	}
	for _, addr := range expectedBypass {
		perHost.Dial("tcp", addr)
	}
	if !reflect.DeepEqual(expectedDef, def.addrs) {
		t.Errorf("Hosts which went to the default proxy didn't match. Got %v, want %v", def.addrs, expectedDef)
	}
	if !reflect.DeepEqual(expectedBypass, bypass.addrs) {
		t.Errorf("Hosts which went to the bypass proxy didn't match. Got %v, want %v", bypass.addrs, expectedBypass)
	}
}
package proxy
import (
	"bytes"
	"fmt"
	"io"
	"net"
	"net
	"os"
	"strconv"
	"strings"
	"sync"
	"testing"
)
type proxyFromEnvTest struct {
	allProxyEnv string
	noProxyEnv  string
	wantTypeOf  Dialer
}
func (t proxyFromEnvTest) String() string {
	var buf bytes.Buffer
	space := func() {
		if buf.Len() > 0 {
			buf.WriteByte(' ')
		}
	}
	if t.allProxyEnv != "" {
		fmt.Fprintf(&buf, "all_proxy=%q", t.allProxyEnv)
	}
	if t.noProxyEnv != "" {
		space()
		fmt.Fprintf(&buf, "no_proxy=%q", t.noProxyEnv)
	}
	return strings.TrimSpace(buf.String())
}
func TestFromEnvironment(t *testing.T) {
	ResetProxyEnv()
	type dummyDialer struct {
		direct
	}
	RegisterDialerType("irc", func(_ *url.URL, _ Dialer) (Dialer, error) {
		return dummyDialer{}, nil
	})
	proxyFromEnvTests := []proxyFromEnvTest{
		{allProxyEnv: "127.0.0.1:8080", noProxyEnv: "localhost, 127.0.0.1", wantTypeOf: direct{}},
		{allProxyEnv: "ftp:
		{allProxyEnv: "socks5:
		{allProxyEnv: "irc:
		{noProxyEnv: "localhost, 127.0.0.1", wantTypeOf: direct{}},
		{wantTypeOf: direct{}},
	}
	for _, tt := range proxyFromEnvTests {
		os.Setenv("ALL_PROXY", tt.allProxyEnv)
		os.Setenv("NO_PROXY", tt.noProxyEnv)
		ResetCachedEnvironment()
		d := FromEnvironment()
		if got, want := fmt.Sprintf("%T", d), fmt.Sprintf("%T", tt.wantTypeOf); got != want {
			t.Errorf("%v: got type = %T, want %T", tt, d, tt.wantTypeOf)
		}
	}
}
func TestFromURL(t *testing.T) {
	endSystem, err := net.Listen("tcp", "127.0.0.1:0")
	if err != nil {
		t.Fatalf("net.Listen failed: %v", err)
	}
	defer endSystem.Close()
	gateway, err := net.Listen("tcp", "127.0.0.1:0")
	if err != nil {
		t.Fatalf("net.Listen failed: %v", err)
	}
	defer gateway.Close()
	var wg sync.WaitGroup
	wg.Add(1)
	go socks5Gateway(t, gateway, endSystem, socks5Domain, &wg)
	url, err := url.Parse("socks5:
	if err != nil {
		t.Fatalf("url.Parse failed: %v", err)
	}
	proxy, err := FromURL(url, Direct)
	if err != nil {
		t.Fatalf("FromURL failed: %v", err)
	}
	_, port, err := net.SplitHostPort(endSystem.Addr().String())
	if err != nil {
		t.Fatalf("net.SplitHostPort failed: %v", err)
	}
	if c, err := proxy.Dial("tcp", "localhost:"+port); err != nil {
		t.Fatalf("FromURL.Dial failed: %v", err)
	} else {
		c.Close()
	}
	wg.Wait()
}
func TestSOCKS5(t *testing.T) {
	endSystem, err := net.Listen("tcp", "127.0.0.1:0")
	if err != nil {
		t.Fatalf("net.Listen failed: %v", err)
	}
	defer endSystem.Close()
	gateway, err := net.Listen("tcp", "127.0.0.1:0")
	if err != nil {
		t.Fatalf("net.Listen failed: %v", err)
	}
	defer gateway.Close()
	var wg sync.WaitGroup
	wg.Add(1)
	go socks5Gateway(t, gateway, endSystem, socks5IP4, &wg)
	proxy, err := SOCKS5("tcp", gateway.Addr().String(), nil, Direct)
	if err != nil {
		t.Fatalf("SOCKS5 failed: %v", err)
	}
	if c, err := proxy.Dial("tcp", endSystem.Addr().String()); err != nil {
		t.Fatalf("SOCKS5.Dial failed: %v", err)
	} else {
		c.Close()
	}
	wg.Wait()
}
func socks5Gateway(t *testing.T, gateway, endSystem net.Listener, typ byte, wg *sync.WaitGroup) {
	defer wg.Done()
	c, err := gateway.Accept()
	if err != nil {
		t.Errorf("net.Listener.Accept failed: %v", err)
		return
	}
	defer c.Close()
	b := make([]byte, 32)
	var n int
	if typ == socks5Domain {
		n = 4
	} else {
		n = 3
	}
	if _, err := io.ReadFull(c, b[:n]); err != nil {
		t.Errorf("io.ReadFull failed: %v", err)
		return
	}
	if _, err := c.Write([]byte{socks5Version, socks5AuthNone}); err != nil {
		t.Errorf("net.Conn.Write failed: %v", err)
		return
	}
	if typ == socks5Domain {
		n = 16
	} else {
		n = 10
	}
	if _, err := io.ReadFull(c, b[:n]); err != nil {
		t.Errorf("io.ReadFull failed: %v", err)
		return
	}
	if b[0] != socks5Version || b[1] != socks5Connect || b[2] != 0x00 || b[3] != typ {
		t.Errorf("got an unexpected packet: %#02x %#02x %#02x %#02x", b[0], b[1], b[2], b[3])
		return
	}
	if typ == socks5Domain {
		copy(b[:5], []byte{socks5Version, 0x00, 0x00, socks5Domain, 9})
		b = append(b, []byte("localhost")...)
	} else {
		copy(b[:4], []byte{socks5Version, 0x00, 0x00, socks5IP4})
	}
	host, port, err := net.SplitHostPort(endSystem.Addr().String())
	if err != nil {
		t.Errorf("net.SplitHostPort failed: %v", err)
		return
	}
	b = append(b, []byte(net.ParseIP(host).To4())...)
	p, err := strconv.Atoi(port)
	if err != nil {
		t.Errorf("strconv.Atoi failed: %v", err)
		return
	}
	b = append(b, []byte{byte(p >> 8), byte(p)}...)
	if _, err := c.Write(b); err != nil {
		t.Errorf("net.Conn.Write failed: %v", err)
		return
	}
}
func ResetProxyEnv() {
	for _, env := range []*envOnce{allProxyEnv, noProxyEnv} {
		for _, v := range env.names {
			os.Setenv(v, "")
		}
	}
	ResetCachedEnvironment()
}
func ResetCachedEnvironment() {
	allProxyEnv.reset()
	noProxyEnv.reset()
}
package http2 
import (
	"bufio"
	"crypto
	"errors"
	"fmt"
	"io"
	"net
	"os"
	"sort"
	"strconv"
	"strings"
	"sync"
	"golang.org
)
var (
	VerboseLogs    bool
	logFrameWrites bool
	logFrameReads  bool
	inTests        bool
)
func init() {
	e := os.Getenv("GODEBUG")
	if strings.Contains(e, "http2debug=1") {
		VerboseLogs = true
	}
	if strings.Contains(e, "http2debug=2") {
		VerboseLogs = true
		logFrameWrites = true
		logFrameReads = true
	}
}
const (
	
	
	ClientPreface = "PRI * HTTP
	
	
	initialMaxFrameSize = 16384
	
	
	NextProtoTLS = "h2"
	
	initialHeaderTableSize = 4096
	initialWindowSize = 65535 
	defaultMaxReadFrameSize = 1 << 20
)
var (
	clientPreface = []byte(ClientPreface)
)
type streamState int
const (
	stateIdle streamState = iota
	stateOpen
	stateHalfClosedLocal
	stateHalfClosedRemote
	stateClosed
)
var stateName = [...]string{
	stateIdle:             "Idle",
	stateOpen:             "Open",
	stateHalfClosedLocal:  "HalfClosedLocal",
	stateHalfClosedRemote: "HalfClosedRemote",
	stateClosed:           "Closed",
}
func (st streamState) String() string {
	return stateName[st]
}
type Setting struct {
	
	
	ID SettingID
	
	Val uint32
}
func (s Setting) String() string {
	return fmt.Sprintf("[%v = %d]", s.ID, s.Val)
}
func (s Setting) Valid() error {
	
	switch s.ID {
	case SettingEnablePush:
		if s.Val != 1 && s.Val != 0 {
			return ConnectionError(ErrCodeProtocol)
		}
	case SettingInitialWindowSize:
		if s.Val > 1<<31-1 {
			return ConnectionError(ErrCodeFlowControl)
		}
	case SettingMaxFrameSize:
		if s.Val < 16384 || s.Val > 1<<24-1 {
			return ConnectionError(ErrCodeProtocol)
		}
	}
	return nil
}
type SettingID uint16
const (
	SettingHeaderTableSize      SettingID = 0x1
	SettingEnablePush           SettingID = 0x2
	SettingMaxConcurrentStreams SettingID = 0x3
	SettingInitialWindowSize    SettingID = 0x4
	SettingMaxFrameSize         SettingID = 0x5
	SettingMaxHeaderListSize    SettingID = 0x6
)
var settingName = map[SettingID]string{
	SettingHeaderTableSize:      "HEADER_TABLE_SIZE",
	SettingEnablePush:           "ENABLE_PUSH",
	SettingMaxConcurrentStreams: "MAX_CONCURRENT_STREAMS",
	SettingInitialWindowSize:    "INITIAL_WINDOW_SIZE",
	SettingMaxFrameSize:         "MAX_FRAME_SIZE",
	SettingMaxHeaderListSize:    "MAX_HEADER_LIST_SIZE",
}
func (s SettingID) String() string {
	if v, ok := settingName[s]; ok {
		return v
	}
	return fmt.Sprintf("UNKNOWN_SETTING_%d", uint16(s))
}
var (
	errInvalidHeaderFieldName  = errors.New("http2: invalid header field name")
	errInvalidHeaderFieldValue = errors.New("http2: invalid header field value")
)
func validWireHeaderFieldName(v string) bool {
	if len(v) == 0 {
		return false
	}
	for _, r := range v {
		if !httplex.IsTokenRune(r) {
			return false
		}
		if 'A' <= r && r <= 'Z' {
			return false
		}
	}
	return true
}
var httpCodeStringCommon = map[int]string{} 
func init() {
	for i := 100; i <= 999; i++ {
		if v := http.StatusText(i); v != "" {
			httpCodeStringCommon[i] = strconv.Itoa(i)
		}
	}
}
func httpCodeString(code int) string {
	if s, ok := httpCodeStringCommon[code]; ok {
		return s
	}
	return strconv.Itoa(code)
}
type stringWriter interface {
	WriteString(s string) (n int, err error)
}
type gate chan struct{}
func (g gate) Done() { g <- struct{}{} }
func (g gate) Wait() { <-g }
type closeWaiter chan struct{}
func (cw *closeWaiter) Init() {
	*cw = make(chan struct{})
}
func (cw closeWaiter) Close() {
	close(cw)
}
func (cw closeWaiter) Wait() {
	<-cw
}
type bufferedWriter struct {
	w  io.Writer     
	bw *bufio.Writer 
}
func newBufferedWriter(w io.Writer) *bufferedWriter {
	return &bufferedWriter{w: w}
}
const bufWriterPoolBufferSize = 4 << 10
var bufWriterPool = sync.Pool{
	New: func() interface{} {
		return bufio.NewWriterSize(nil, bufWriterPoolBufferSize)
	},
}
func (w *bufferedWriter) Available() int {
	if w.bw == nil {
		return bufWriterPoolBufferSize
	}
	return w.bw.Available()
}
func (w *bufferedWriter) Write(p []byte) (n int, err error) {
	if w.bw == nil {
		bw := bufWriterPool.Get().(*bufio.Writer)
		bw.Reset(w.w)
		w.bw = bw
	}
	return w.bw.Write(p)
}
func (w *bufferedWriter) Flush() error {
	bw := w.bw
	if bw == nil {
		return nil
	}
	err := bw.Flush()
	bw.Reset(nil)
	bufWriterPool.Put(bw)
	w.bw = nil
	return err
}
func mustUint31(v int32) uint32 {
	if v < 0 || v > 2147483647 {
		panic("out of range")
	}
	return uint32(v)
}
func bodyAllowedForStatus(status int) bool {
	switch {
	case status >= 100 && status <= 199:
		return false
	case status == 204:
		return false
	case status == 304:
		return false
	}
	return true
}
type httpError struct {
	msg     string
	timeout bool
}
func (e *httpError) Error() string   { return e.msg }
func (e *httpError) Timeout() bool   { return e.timeout }
func (e *httpError) Temporary() bool { return true }
var errTimeout error = &httpError{msg: "http2: timeout awaiting response headers", timeout: true}
type connectionStater interface {
	ConnectionState() tls.ConnectionState
}
var sorterPool = sync.Pool{New: func() interface{} { return new(sorter) }}
type sorter struct {
	v []string 
}
func (s *sorter) Len() int           { return len(s.v) }
func (s *sorter) Swap(i, j int)      { s.v[i], s.v[j] = s.v[j], s.v[i] }
func (s *sorter) Less(i, j int) bool { return s.v[i] < s.v[j] }
func (s *sorter) Keys(h http.Header) []string {
	keys := s.v[:0]
	for k := range h {
		keys = append(keys, k)
	}
	s.v = keys
	sort.Sort(s)
	return keys
}
func (s *sorter) SortStrings(ss []string) {
	
	
	save := s.v
	s.v = ss
	sort.Sort(s)
	s.v = save
}
func validPseudoPath(v string) bool {
	return (len(v) > 0 && v[0] == '
}
package hpack
import (
	"bytes"
	"errors"
	"io"
	"sync"
)
var bufPool = sync.Pool{
	New: func() interface{} { return new(bytes.Buffer) },
}
func HuffmanDecode(w io.Writer, v []byte) (int, error) {
	buf := bufPool.Get().(*bytes.Buffer)
	buf.Reset()
	defer bufPool.Put(buf)
	if err := huffmanDecode(buf, 0, v); err != nil {
		return 0, err
	}
	return w.Write(buf.Bytes())
}
func HuffmanDecodeToString(v []byte) (string, error) {
	buf := bufPool.Get().(*bytes.Buffer)
	buf.Reset()
	defer bufPool.Put(buf)
	if err := huffmanDecode(buf, 0, v); err != nil {
		return "", err
	}
	return buf.String(), nil
}
var ErrInvalidHuffman = errors.New("hpack: invalid Huffman-encoded data")
func huffmanDecode(buf *bytes.Buffer, maxLen int, v []byte) error {
	n := rootHuffmanNode
	
	
	
	cur, cbits, sbits := uint(0), uint8(0), uint8(0)
	for _, b := range v {
		cur = cur<<8 | uint(b)
		cbits += 8
		sbits += 8
		for cbits >= 8 {
			idx := byte(cur >> (cbits - 8))
			n = n.children[idx]
			if n == nil {
				return ErrInvalidHuffman
			}
			if n.children == nil {
				if maxLen != 0 && buf.Len() == maxLen {
					return ErrStringLength
				}
				buf.WriteByte(n.sym)
				cbits -= n.codeLen
				n = rootHuffmanNode
				sbits = cbits
			} else {
				cbits -= 8
			}
		}
	}
	for cbits > 0 {
		n = n.children[byte(cur<<(8-cbits))]
		if n == nil {
			return ErrInvalidHuffman
		}
		if n.children != nil || n.codeLen > cbits {
			break
		}
		if maxLen != 0 && buf.Len() == maxLen {
			return ErrStringLength
		}
		buf.WriteByte(n.sym)
		cbits -= n.codeLen
		n = rootHuffmanNode
		sbits = cbits
	}
	if sbits > 7 {
		
		
		return ErrInvalidHuffman
	}
	if mask := uint(1<<cbits - 1); cur&mask != mask {
		
		return ErrInvalidHuffman
	}
	return nil
}
type node struct {
	
	children []*node
	
	codeLen uint8 
	sym     byte  
}
func newInternalNode() *node {
	return &node{children: make([]*node, 256)}
}
var rootHuffmanNode = newInternalNode()
func init() {
	if len(huffmanCodes) != 256 {
		panic("unexpected size")
	}
	for i, code := range huffmanCodes {
		addDecoderNode(byte(i), code, huffmanCodeLen[i])
	}
}
func addDecoderNode(sym byte, code uint32, codeLen uint8) {
	cur := rootHuffmanNode
	for codeLen > 8 {
		codeLen -= 8
		i := uint8(code >> codeLen)
		if cur.children[i] == nil {
			cur.children[i] = newInternalNode()
		}
		cur = cur.children[i]
	}
	shift := 8 - codeLen
	start, end := int(uint8(code<<shift)), int(1<<shift)
	for i := start; i < start+end; i++ {
		cur.children[i] = &node{sym: sym, codeLen: codeLen}
	}
}
func AppendHuffmanString(dst []byte, s string) []byte {
	rembits := uint8(8)
	for i := 0; i < len(s); i++ {
		if rembits == 8 {
			dst = append(dst, 0)
		}
		dst, rembits = appendByteToHuffmanCode(dst, rembits, s[i])
	}
	if rembits < 8 {
		
		code := uint32(0x3fffffff)
		nbits := uint8(30)
		t := uint8(code >> (nbits - rembits))
		dst[len(dst)-1] |= t
	}
	return dst
}
func HuffmanEncodeLength(s string) uint64 {
	n := uint64(0)
	for i := 0; i < len(s); i++ {
		n += uint64(huffmanCodeLen[s[i]])
	}
	return (n + 7) 
}
func appendByteToHuffmanCode(dst []byte, rembits uint8, c byte) ([]byte, uint8) {
	code := huffmanCodes[c]
	nbits := huffmanCodeLen[c]
	for {
		if rembits > nbits {
			t := uint8(code << (rembits - nbits))
			dst[len(dst)-1] |= t
			rembits -= nbits
			break
		}
		t := uint8(code >> (nbits - rembits))
		dst[len(dst)-1] |= t
		nbits -= rembits
		rembits = 8
		if nbits == 0 {
			break
		}
		dst = append(dst, 0)
	}
	return dst, rembits
}
package hpack
import (
	"bytes"
	"encoding
	"fmt"
	"math
	"reflect"
	"strings"
	"testing"
)
func TestEncoderTableSizeUpdate(t *testing.T) {
	tests := []struct {
		size1, size2 uint32
		wantHex      string
	}{
		
		{2048, 4096, "3fe10f 3fe11f 82"},
		
		{16384, 2048, "3fe10f 82"},
	}
	for _, tt := range tests {
		var buf bytes.Buffer
		e := NewEncoder(&buf)
		e.SetMaxDynamicTableSize(tt.size1)
		e.SetMaxDynamicTableSize(tt.size2)
		if err := e.WriteField(pair(":method", "GET")); err != nil {
			t.Fatal(err)
		}
		want := removeSpace(tt.wantHex)
		if got := hex.EncodeToString(buf.Bytes()); got != want {
			t.Errorf("e.SetDynamicTableSize %v, %v = %q; want %q", tt.size1, tt.size2, got, want)
		}
	}
}
func TestEncoderWriteField(t *testing.T) {
	var buf bytes.Buffer
	e := NewEncoder(&buf)
	var got []HeaderField
	d := NewDecoder(4<<10, func(f HeaderField) {
		got = append(got, f)
	})
	tests := []struct {
		hdrs []HeaderField
	}{
		{[]HeaderField{
			pair(":method", "GET"),
			pair(":scheme", "http"),
			pair(":path", "
			pair(":authority", "www.example.com"),
		}},
		{[]HeaderField{
			pair(":method", "GET"),
			pair(":scheme", "http"),
			pair(":path", "
			pair(":authority", "www.example.com"),
			pair("cache-control", "no-cache"),
		}},
		{[]HeaderField{
			pair(":method", "GET"),
			pair(":scheme", "https"),
			pair(":path", "
			pair(":authority", "www.example.com"),
			pair("custom-key", "custom-value"),
		}},
	}
	for i, tt := range tests {
		buf.Reset()
		got = got[:0]
		for _, hf := range tt.hdrs {
			if err := e.WriteField(hf); err != nil {
				t.Fatal(err)
			}
		}
		_, err := d.Write(buf.Bytes())
		if err != nil {
			t.Errorf("%d. Decoder Write = %v", i, err)
		}
		if !reflect.DeepEqual(got, tt.hdrs) {
			t.Errorf("%d. Decoded %+v; want %+v", i, got, tt.hdrs)
		}
	}
}
func TestEncoderSearchTable(t *testing.T) {
	e := NewEncoder(nil)
	e.dynTab.add(pair("foo", "bar"))
	e.dynTab.add(pair("blake", "miz"))
	e.dynTab.add(pair(":method", "GET"))
	tests := []struct {
		hf        HeaderField
		wantI     uint64
		wantMatch bool
	}{
		
		{pair("foo", "bar"), uint64(staticTable.len()) + 3, true},
		{pair("blake", "miz"), uint64(staticTable.len()) + 2, true},
		{pair(":method", "GET"), 2, true},
		
		
		
		{HeaderField{":method", "GET", true}, 3, false},
		
		{pair("foo", "..."), uint64(staticTable.len()) + 3, false},
		{pair("blake", "..."), uint64(staticTable.len()) + 2, false},
		
		{pair(":method", "..."), 3, false},
		
		{pair("foo-", "bar"), 0, false},
	}
	for _, tt := range tests {
		if gotI, gotMatch := e.searchTable(tt.hf); gotI != tt.wantI || gotMatch != tt.wantMatch {
			t.Errorf("d.search(%+v) = %v, %v; want %v, %v", tt.hf, gotI, gotMatch, tt.wantI, tt.wantMatch)
		}
	}
}
func TestAppendVarInt(t *testing.T) {
	tests := []struct {
		n    byte
		i    uint64
		want []byte
	}{
		
		{1, 0, []byte{0}},
		{2, 2, []byte{2}},
		{3, 6, []byte{6}},
		{4, 14, []byte{14}},
		{5, 30, []byte{30}},
		{6, 62, []byte{62}},
		{7, 126, []byte{126}},
		{8, 254, []byte{254}},
		
		{5, 1337, []byte{31, 154, 10}},
	}
	for _, tt := range tests {
		got := appendVarInt(nil, tt.n, tt.i)
		if !bytes.Equal(got, tt.want) {
			t.Errorf("appendVarInt(nil, %v, %v) = %v; want %v", tt.n, tt.i, got, tt.want)
		}
	}
}
func TestAppendHpackString(t *testing.T) {
	tests := []struct {
		s, wantHex string
	}{
		
		{"www.example.com", "8c f1e3 c2e5 f23a 6ba0 ab90 f4ff"},
		
		{"a", "01 61"},
		
		{"", "00"},
	}
	for _, tt := range tests {
		want := removeSpace(tt.wantHex)
		buf := appendHpackString(nil, tt.s)
		if got := hex.EncodeToString(buf); want != got {
			t.Errorf("appendHpackString(nil, %q) = %q; want %q", tt.s, got, want)
		}
	}
}
func TestAppendIndexed(t *testing.T) {
	tests := []struct {
		i       uint64
		wantHex string
	}{
		
		{1, "81"},
		{126, "fe"},
		
		{127, "ff00"},
		{128, "ff01"},
	}
	for _, tt := range tests {
		want := removeSpace(tt.wantHex)
		buf := appendIndexed(nil, tt.i)
		if got := hex.EncodeToString(buf); want != got {
			t.Errorf("appendIndex(nil, %v) = %q; want %q", tt.i, got, want)
		}
	}
}
func TestAppendNewName(t *testing.T) {
	tests := []struct {
		f        HeaderField
		indexing bool
		wantHex  string
	}{
		
		{HeaderField{"custom-key", "custom-value", false}, true, "40 88 25a8 49e9 5ba9 7d7f 89 25a8 49e9 5bb8 e8b4 bf"},
		
		{HeaderField{"custom-key", "custom-value", false}, false, "00 88 25a8 49e9 5ba9 7d7f 89 25a8 49e9 5bb8 e8b4 bf"},
		
		{HeaderField{"custom-key", "custom-value", true}, true, "10 88 25a8 49e9 5ba9 7d7f 89 25a8 49e9 5bb8 e8b4 bf"},
		{HeaderField{"custom-key", "custom-value", true}, false, "10 88 25a8 49e9 5ba9 7d7f 89 25a8 49e9 5bb8 e8b4 bf"},
	}
	for _, tt := range tests {
		want := removeSpace(tt.wantHex)
		buf := appendNewName(nil, tt.f, tt.indexing)
		if got := hex.EncodeToString(buf); want != got {
			t.Errorf("appendNewName(nil, %+v, %v) = %q; want %q", tt.f, tt.indexing, got, want)
		}
	}
}
func TestAppendIndexedName(t *testing.T) {
	tests := []struct {
		f        HeaderField
		i        uint64
		indexing bool
		wantHex  string
	}{
		
		{HeaderField{":status", "302", false}, 8, true, "48 82 6402"},
		
		{HeaderField{":status", "302", false}, 8, false, "08 82 6402"},
		
		{HeaderField{":status", "302", true}, 8, true, "18 82 6402"},
		{HeaderField{":status", "302", true}, 8, false, "18 82 6402"},
	}
	for _, tt := range tests {
		want := removeSpace(tt.wantHex)
		buf := appendIndexedName(nil, tt.f, tt.i, tt.indexing)
		if got := hex.EncodeToString(buf); want != got {
			t.Errorf("appendIndexedName(nil, %+v, %v) = %q; want %q", tt.f, tt.indexing, got, want)
		}
	}
}
func TestAppendTableSize(t *testing.T) {
	tests := []struct {
		i       uint32
		wantHex string
	}{
		
		{30, "3e"},
		
		{31, "3f00"},
		{32, "3f01"},
	}
	for _, tt := range tests {
		want := removeSpace(tt.wantHex)
		buf := appendTableSize(nil, tt.i)
		if got := hex.EncodeToString(buf); want != got {
			t.Errorf("appendTableSize(nil, %v) = %q; want %q", tt.i, got, want)
		}
	}
}
func TestEncoderSetMaxDynamicTableSize(t *testing.T) {
	var buf bytes.Buffer
	e := NewEncoder(&buf)
	tests := []struct {
		v           uint32
		wantUpdate  bool
		wantMinSize uint32
		wantMaxSize uint32
	}{
		
		{2048, true, 2048, 2048},
		
		
		{16384, true, 2048, 4096},
	}
	for _, tt := range tests {
		e.SetMaxDynamicTableSize(tt.v)
		if got := e.tableSizeUpdate; tt.wantUpdate != got {
			t.Errorf("e.tableSizeUpdate = %v; want %v", got, tt.wantUpdate)
		}
		if got := e.minSize; tt.wantMinSize != got {
			t.Errorf("e.minSize = %v; want %v", got, tt.wantMinSize)
		}
		if got := e.dynTab.maxSize; tt.wantMaxSize != got {
			t.Errorf("e.maxSize = %v; want %v", got, tt.wantMaxSize)
		}
	}
}
func TestEncoderSetMaxDynamicTableSizeLimit(t *testing.T) {
	e := NewEncoder(nil)
	
	
	e.SetMaxDynamicTableSizeLimit(4095)
	if got, want := e.dynTab.maxSize, uint32(4095); got != want {
		t.Errorf("e.dynTab.maxSize = %v; want %v", got, want)
	}
	if got, want := e.maxSizeLimit, uint32(4095); got != want {
		t.Errorf("e.maxSizeLimit = %v; want %v", got, want)
	}
	if got, want := e.tableSizeUpdate, true; got != want {
		t.Errorf("e.tableSizeUpdate = %v; want %v", got, want)
	}
	
	e.SetMaxDynamicTableSize(16384)
	if got, want := e.dynTab.maxSize, uint32(4095); got != want {
		t.Errorf("e.dynTab.maxSize = %v; want %v", got, want)
	}
	
	e.SetMaxDynamicTableSizeLimit(8192)
	if got, want := e.dynTab.maxSize, uint32(4095); got != want {
		t.Errorf("e.dynTab.maxSize = %v; want %v", got, want)
	}
	if got, want := e.maxSizeLimit, uint32(8192); got != want {
		t.Errorf("e.maxSizeLimit = %v; want %v", got, want)
	}
}
func removeSpace(s string) string {
	return strings.Replace(s, " ", "", -1)
}
func BenchmarkEncoderSearchTable(b *testing.B) {
	e := NewEncoder(nil)
	
	
	var possible []HeaderField
	for _, f := range staticTable.ents {
		if f.Value == "" {
			possible = append(possible, f)
			continue
		}
		
		
		num := 5
		if f.Name == "cookie" || f.Name == "set-cookie" {
			num = 25
		}
		for i := 0; i < num; i++ {
			f.Value = fmt.Sprintf("%s-%d", f.Name, i)
			possible = append(possible, f)
		}
	}
	for k := 0; k < 10; k++ {
		f := HeaderField{
			Name:      fmt.Sprintf("x-header-%d", k),
			Sensitive: rand.Int()%2 == 0,
		}
		for i := 0; i < 5; i++ {
			f.Value = fmt.Sprintf("%s-%d", f.Name, i)
			possible = append(possible, f)
		}
	}
	
	
	for r := 0; r < 100*20; r++ {
		f := possible[rand.Int31n(int32(len(possible)))]
		
		if _, has := staticTable.search(f); !has {
			e.dynTab.add(f)
		}
	}
	b.ResetTimer()
	for n := 0; n < b.N; n++ {
		for _, f := range possible {
			e.searchTable(f)
		}
	}
}
package hpack
import (
	"bytes"
	"encoding
	"fmt"
	"math
	"reflect"
	"strings"
	"testing"
	"time"
)
func (d *Decoder) mustAt(idx int) HeaderField {
	if hf, ok := d.at(uint64(idx)); !ok {
		panic(fmt.Sprintf("bogus index %d", idx))
	} else {
		return hf
	}
}
func TestDynamicTableAt(t *testing.T) {
	d := NewDecoder(4096, nil)
	at := d.mustAt
	if got, want := at(2), (pair(":method", "GET")); got != want {
		t.Errorf("at(2) = %v; want %v", got, want)
	}
	d.dynTab.add(pair("foo", "bar"))
	d.dynTab.add(pair("blake", "miz"))
	if got, want := at(staticTable.len()+1), (pair("blake", "miz")); got != want {
		t.Errorf("at(dyn 1) = %v; want %v", got, want)
	}
	if got, want := at(staticTable.len()+2), (pair("foo", "bar")); got != want {
		t.Errorf("at(dyn 2) = %v; want %v", got, want)
	}
	if got, want := at(3), (pair(":method", "POST")); got != want {
		t.Errorf("at(3) = %v; want %v", got, want)
	}
}
func TestDynamicTableSizeEvict(t *testing.T) {
	d := NewDecoder(4096, nil)
	if want := uint32(0); d.dynTab.size != want {
		t.Fatalf("size = %d; want %d", d.dynTab.size, want)
	}
	add := d.dynTab.add
	add(pair("blake", "eats pizza"))
	if want := uint32(15 + 32); d.dynTab.size != want {
		t.Fatalf("after pizza, size = %d; want %d", d.dynTab.size, want)
	}
	add(pair("foo", "bar"))
	if want := uint32(15 + 32 + 6 + 32); d.dynTab.size != want {
		t.Fatalf("after foo bar, size = %d; want %d", d.dynTab.size, want)
	}
	d.dynTab.setMaxSize(15 + 32 + 1 
	if want := uint32(6 + 32); d.dynTab.size != want {
		t.Fatalf("after setMaxSize, size = %d; want %d", d.dynTab.size, want)
	}
	if got, want := d.mustAt(staticTable.len()+1), (pair("foo", "bar")); got != want {
		t.Errorf("at(dyn 1) = %v; want %v", got, want)
	}
	add(pair("long", strings.Repeat("x", 500)))
	if want := uint32(0); d.dynTab.size != want {
		t.Fatalf("after big one, size = %d; want %d", d.dynTab.size, want)
	}
}
func TestDecoderDecode(t *testing.T) {
	tests := []struct {
		name       string
		in         []byte
		want       []HeaderField
		wantDynTab []HeaderField 
	}{
		
		
		{"C.2.1", dehex("400a 6375 7374 6f6d 2d6b 6579 0d63 7573 746f 6d2d 6865 6164 6572"),
			[]HeaderField{pair("custom-key", "custom-header")},
			[]HeaderField{pair("custom-key", "custom-header")},
		},
		
		
		{"C.2.2", dehex("040c 2f73 616d 706c 652f 7061 7468"),
			[]HeaderField{pair(":path", "
			[]HeaderField{}},
		
		
		{"C.2.3", dehex("1008 7061 7373 776f 7264 0673 6563 7265 74"),
			[]HeaderField{{"password", "secret", true}},
			[]HeaderField{}},
		
		
		{"C.2.4", []byte("\x82"),
			[]HeaderField{pair(":method", "GET")},
			[]HeaderField{}},
	}
	for _, tt := range tests {
		d := NewDecoder(4096, nil)
		hf, err := d.DecodeFull(tt.in)
		if err != nil {
			t.Errorf("%s: %v", tt.name, err)
			continue
		}
		if !reflect.DeepEqual(hf, tt.want) {
			t.Errorf("%s: Got %v; want %v", tt.name, hf, tt.want)
		}
		gotDynTab := d.dynTab.reverseCopy()
		if !reflect.DeepEqual(gotDynTab, tt.wantDynTab) {
			t.Errorf("%s: dynamic table after = %v; want %v", tt.name, gotDynTab, tt.wantDynTab)
		}
	}
}
func (dt *dynamicTable) reverseCopy() (hf []HeaderField) {
	hf = make([]HeaderField, len(dt.table.ents))
	for i := range hf {
		hf[i] = dt.table.ents[len(dt.table.ents)-1-i]
	}
	return
}
type encAndWant struct {
	enc         []byte
	want        []HeaderField
	wantDynTab  []HeaderField
	wantDynSize uint32
}
func TestDecodeC3_NoHuffman(t *testing.T) {
	testDecodeSeries(t, 4096, []encAndWant{
		{dehex("8286 8441 0f77 7777 2e65 7861 6d70 6c65 2e63 6f6d"),
			[]HeaderField{
				pair(":method", "GET"),
				pair(":scheme", "http"),
				pair(":path", "
				pair(":authority", "www.example.com"),
			},
			[]HeaderField{
				pair(":authority", "www.example.com"),
			},
			57,
		},
		{dehex("8286 84be 5808 6e6f 2d63 6163 6865"),
			[]HeaderField{
				pair(":method", "GET"),
				pair(":scheme", "http"),
				pair(":path", "
				pair(":authority", "www.example.com"),
				pair("cache-control", "no-cache"),
			},
			[]HeaderField{
				pair("cache-control", "no-cache"),
				pair(":authority", "www.example.com"),
			},
			110,
		},
		{dehex("8287 85bf 400a 6375 7374 6f6d 2d6b 6579 0c63 7573 746f 6d2d 7661 6c75 65"),
			[]HeaderField{
				pair(":method", "GET"),
				pair(":scheme", "https"),
				pair(":path", "
				pair(":authority", "www.example.com"),
				pair("custom-key", "custom-value"),
			},
			[]HeaderField{
				pair("custom-key", "custom-value"),
				pair("cache-control", "no-cache"),
				pair(":authority", "www.example.com"),
			},
			164,
		},
	})
}
func TestDecodeC4_Huffman(t *testing.T) {
	testDecodeSeries(t, 4096, []encAndWant{
		{dehex("8286 8441 8cf1 e3c2 e5f2 3a6b a0ab 90f4 ff"),
			[]HeaderField{
				pair(":method", "GET"),
				pair(":scheme", "http"),
				pair(":path", "
				pair(":authority", "www.example.com"),
			},
			[]HeaderField{
				pair(":authority", "www.example.com"),
			},
			57,
		},
		{dehex("8286 84be 5886 a8eb 1064 9cbf"),
			[]HeaderField{
				pair(":method", "GET"),
				pair(":scheme", "http"),
				pair(":path", "
				pair(":authority", "www.example.com"),
				pair("cache-control", "no-cache"),
			},
			[]HeaderField{
				pair("cache-control", "no-cache"),
				pair(":authority", "www.example.com"),
			},
			110,
		},
		{dehex("8287 85bf 4088 25a8 49e9 5ba9 7d7f 8925 a849 e95b b8e8 b4bf"),
			[]HeaderField{
				pair(":method", "GET"),
				pair(":scheme", "https"),
				pair(":path", "
				pair(":authority", "www.example.com"),
				pair("custom-key", "custom-value"),
			},
			[]HeaderField{
				pair("custom-key", "custom-value"),
				pair("cache-control", "no-cache"),
				pair(":authority", "www.example.com"),
			},
			164,
		},
	})
}
func TestDecodeC5_ResponsesNoHuff(t *testing.T) {
	testDecodeSeries(t, 256, []encAndWant{
		{dehex(`
4803 3330 3258 0770 7269 7661 7465 611d
4d6f 6e2c 2032 3120 4f63 7420 3230 3133
2032 303a 3133 3a32 3120 474d 546e 1768
7474 7073 3a2f 2f77 7777 2e65 7861 6d70
6c65 2e63 6f6d
`),
			[]HeaderField{
				pair(":status", "302"),
				pair("cache-control", "private"),
				pair("date", "Mon, 21 Oct 2013 20:13:21 GMT"),
				pair("location", "https:
			},
			[]HeaderField{
				pair("location", "https:
				pair("date", "Mon, 21 Oct 2013 20:13:21 GMT"),
				pair("cache-control", "private"),
				pair(":status", "302"),
			},
			222,
		},
		{dehex("4803 3330 37c1 c0bf"),
			[]HeaderField{
				pair(":status", "307"),
				pair("cache-control", "private"),
				pair("date", "Mon, 21 Oct 2013 20:13:21 GMT"),
				pair("location", "https:
			},
			[]HeaderField{
				pair(":status", "307"),
				pair("location", "https:
				pair("date", "Mon, 21 Oct 2013 20:13:21 GMT"),
				pair("cache-control", "private"),
			},
			222,
		},
		{dehex(`
88c1 611d 4d6f 6e2c 2032 3120 4f63 7420
3230 3133 2032 303a 3133 3a32 3220 474d
54c0 5a04 677a 6970 7738 666f 6f3d 4153
444a 4b48 514b 425a 584f 5157 454f 5049
5541 5851 5745 4f49 553b 206d 6178 2d61
6765 3d33 3630 303b 2076 6572 7369 6f6e
3d31
`),
			[]HeaderField{
				pair(":status", "200"),
				pair("cache-control", "private"),
				pair("date", "Mon, 21 Oct 2013 20:13:22 GMT"),
				pair("location", "https:
				pair("content-encoding", "gzip"),
				pair("set-cookie", "foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age=3600; version=1"),
			},
			[]HeaderField{
				pair("set-cookie", "foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age=3600; version=1"),
				pair("content-encoding", "gzip"),
				pair("date", "Mon, 21 Oct 2013 20:13:22 GMT"),
			},
			215,
		},
	})
}
func TestDecodeC6_ResponsesHuffman(t *testing.T) {
	testDecodeSeries(t, 256, []encAndWant{
		{dehex(`
4882 6402 5885 aec3 771a 4b61 96d0 7abe
9410 54d4 44a8 2005 9504 0b81 66e0 82a6
2d1b ff6e 919d 29ad 1718 63c7 8f0b 97c8
e9ae 82ae 43d3
`),
			[]HeaderField{
				pair(":status", "302"),
				pair("cache-control", "private"),
				pair("date", "Mon, 21 Oct 2013 20:13:21 GMT"),
				pair("location", "https:
			},
			[]HeaderField{
				pair("location", "https:
				pair("date", "Mon, 21 Oct 2013 20:13:21 GMT"),
				pair("cache-control", "private"),
				pair(":status", "302"),
			},
			222,
		},
		{dehex("4883 640e ffc1 c0bf"),
			[]HeaderField{
				pair(":status", "307"),
				pair("cache-control", "private"),
				pair("date", "Mon, 21 Oct 2013 20:13:21 GMT"),
				pair("location", "https:
			},
			[]HeaderField{
				pair(":status", "307"),
				pair("location", "https:
				pair("date", "Mon, 21 Oct 2013 20:13:21 GMT"),
				pair("cache-control", "private"),
			},
			222,
		},
		{dehex(`
88c1 6196 d07a be94 1054 d444 a820 0595
040b 8166 e084 a62d 1bff c05a 839b d9ab
77ad 94e7 821d d7f2 e6c7 b335 dfdf cd5b
3960 d5af 2708 7f36 72c1 ab27 0fb5 291f
9587 3160 65c0 03ed 4ee5 b106 3d50 07
`),
			[]HeaderField{
				pair(":status", "200"),
				pair("cache-control", "private"),
				pair("date", "Mon, 21 Oct 2013 20:13:22 GMT"),
				pair("location", "https:
				pair("content-encoding", "gzip"),
				pair("set-cookie", "foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age=3600; version=1"),
			},
			[]HeaderField{
				pair("set-cookie", "foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age=3600; version=1"),
				pair("content-encoding", "gzip"),
				pair("date", "Mon, 21 Oct 2013 20:13:22 GMT"),
			},
			215,
		},
	})
}
func testDecodeSeries(t *testing.T, size uint32, steps []encAndWant) {
	d := NewDecoder(size, nil)
	for i, step := range steps {
		hf, err := d.DecodeFull(step.enc)
		if err != nil {
			t.Fatalf("Error at step index %d: %v", i, err)
		}
		if !reflect.DeepEqual(hf, step.want) {
			t.Fatalf("At step index %d: Got headers %v; want %v", i, hf, step.want)
		}
		gotDynTab := d.dynTab.reverseCopy()
		if !reflect.DeepEqual(gotDynTab, step.wantDynTab) {
			t.Errorf("After step index %d, dynamic table = %v; want %v", i, gotDynTab, step.wantDynTab)
		}
		if d.dynTab.size != step.wantDynSize {
			t.Errorf("After step index %d, dynamic table size = %v; want %v", i, d.dynTab.size, step.wantDynSize)
		}
	}
}
func TestHuffmanDecodeExcessPadding(t *testing.T) {
	tests := [][]byte{
		{0xff},                                   
		{0x1f, 0xff},                             
		{0x1f, 0xff, 0xff},                       
		{0x1f, 0xff, 0xff, 0xff},                 
		{0xff, 0x9f, 0xff, 0xff, 0xff},           
		{'R', 0xbc, '0', 0xff, 0xff, 0xff, 0xff}, 
	}
	for i, in := range tests {
		var buf bytes.Buffer
		if _, err := HuffmanDecode(&buf, in); err != ErrInvalidHuffman {
			t.Errorf("test-%d: decode(%q) = %v; want ErrInvalidHuffman", i, in, err)
		}
	}
}
func TestHuffmanDecodeEOS(t *testing.T) {
	in := []byte{0xff, 0xff, 0xff, 0xff, 0xfc} 
	var buf bytes.Buffer
	if _, err := HuffmanDecode(&buf, in); err != ErrInvalidHuffman {
		t.Errorf("error = %v; want ErrInvalidHuffman", err)
	}
}
func TestHuffmanDecodeMaxLengthOnTrailingByte(t *testing.T) {
	in := []byte{0x00, 0x01} 
	var buf bytes.Buffer
	if err := huffmanDecode(&buf, 2, in); err != ErrStringLength {
		t.Errorf("error = %v; want ErrStringLength", err)
	}
}
func TestHuffmanDecodeCorruptPadding(t *testing.T) {
	in := []byte{0x00}
	var buf bytes.Buffer
	if _, err := HuffmanDecode(&buf, in); err != ErrInvalidHuffman {
		t.Errorf("error = %v; want ErrInvalidHuffman", err)
	}
}
func TestHuffmanDecode(t *testing.T) {
	tests := []struct {
		inHex, want string
	}{
		{"f1e3 c2e5 f23a 6ba0 ab90 f4ff", "www.example.com"},
		{"a8eb 1064 9cbf", "no-cache"},
		{"25a8 49e9 5ba9 7d7f", "custom-key"},
		{"25a8 49e9 5bb8 e8b4 bf", "custom-value"},
		{"6402", "302"},
		{"aec3 771a 4b", "private"},
		{"d07a be94 1054 d444 a820 0595 040b 8166 e082 a62d 1bff", "Mon, 21 Oct 2013 20:13:21 GMT"},
		{"9d29 ad17 1863 c78f 0b97 c8e9 ae82 ae43 d3", "https:
		{"9bd9 ab", "gzip"},
		{"94e7 821d d7f2 e6c7 b335 dfdf cd5b 3960 d5af 2708 7f36 72c1 ab27 0fb5 291f 9587 3160 65c0 03ed 4ee5 b106 3d50 07",
			"foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age=3600; version=1"},
	}
	for i, tt := range tests {
		var buf bytes.Buffer
		in, err := hex.DecodeString(strings.Replace(tt.inHex, " ", "", -1))
		if err != nil {
			t.Errorf("%d. hex input error: %v", i, err)
			continue
		}
		if _, err := HuffmanDecode(&buf, in); err != nil {
			t.Errorf("%d. decode error: %v", i, err)
			continue
		}
		if got := buf.String(); tt.want != got {
			t.Errorf("%d. decode = %q; want %q", i, got, tt.want)
		}
	}
}
func TestAppendHuffmanString(t *testing.T) {
	tests := []struct {
		in, want string
	}{
		{"www.example.com", "f1e3 c2e5 f23a 6ba0 ab90 f4ff"},
		{"no-cache", "a8eb 1064 9cbf"},
		{"custom-key", "25a8 49e9 5ba9 7d7f"},
		{"custom-value", "25a8 49e9 5bb8 e8b4 bf"},
		{"302", "6402"},
		{"private", "aec3 771a 4b"},
		{"Mon, 21 Oct 2013 20:13:21 GMT", "d07a be94 1054 d444 a820 0595 040b 8166 e082 a62d 1bff"},
		{"https:
		{"gzip", "9bd9 ab"},
		{"foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age=3600; version=1",
			"94e7 821d d7f2 e6c7 b335 dfdf cd5b 3960 d5af 2708 7f36 72c1 ab27 0fb5 291f 9587 3160 65c0 03ed 4ee5 b106 3d50 07"},
	}
	for i, tt := range tests {
		buf := []byte{}
		want := strings.Replace(tt.want, " ", "", -1)
		buf = AppendHuffmanString(buf, tt.in)
		if got := hex.EncodeToString(buf); want != got {
			t.Errorf("%d. encode = %q; want %q", i, got, want)
		}
	}
}
func TestHuffmanMaxStrLen(t *testing.T) {
	const msg = "Some string"
	huff := AppendHuffmanString(nil, msg)
	testGood := func(max int) {
		var out bytes.Buffer
		if err := huffmanDecode(&out, max, huff); err != nil {
			t.Errorf("For maxLen=%d, unexpected error: %v", max, err)
		}
		if out.String() != msg {
			t.Errorf("For maxLen=%d, out = %q; want %q", max, out.String(), msg)
		}
	}
	testGood(0)
	testGood(len(msg))
	testGood(len(msg) + 1)
	var out bytes.Buffer
	if err := huffmanDecode(&out, len(msg)-1, huff); err != ErrStringLength {
		t.Errorf("err = %v; want ErrStringLength", err)
	}
}
func TestHuffmanRoundtripStress(t *testing.T) {
	const Len = 50 
	input := make([]byte, Len)
	var output bytes.Buffer
	var huff []byte
	n := 5000
	if testing.Short() {
		n = 100
	}
	seed := time.Now().UnixNano()
	t.Logf("Seed = %v", seed)
	src := rand.New(rand.NewSource(seed))
	var encSize int64
	for i := 0; i < n; i++ {
		for l := range input {
			input[l] = byte(src.Intn(256))
		}
		huff = AppendHuffmanString(huff[:0], string(input))
		encSize += int64(len(huff))
		output.Reset()
		if err := huffmanDecode(&output, 0, huff); err != nil {
			t.Errorf("Failed to decode %q -> %q -> error %v", input, huff, err)
			continue
		}
		if !bytes.Equal(output.Bytes(), input) {
			t.Errorf("Roundtrip failure on %q -> %q -> %q", input, huff, output.Bytes())
		}
	}
	t.Logf("Compressed size of original: %0.02f%% (%v -> %v)", 100*(float64(encSize)
}
func TestHuffmanDecodeFuzz(t *testing.T) {
	const Len = 50 
	var buf, zbuf bytes.Buffer
	n := 5000
	if testing.Short() {
		n = 100
	}
	seed := time.Now().UnixNano()
	t.Logf("Seed = %v", seed)
	src := rand.New(rand.NewSource(seed))
	numFail := 0
	for i := 0; i < n; i++ {
		zbuf.Reset()
		if i == 0 {
			
			zbuf.WriteString("00\x91\xff\xff\xff\xff\xc8")
		} else {
			for l := 0; l < Len; l++ {
				zbuf.WriteByte(byte(src.Intn(256)))
			}
		}
		buf.Reset()
		if err := huffmanDecode(&buf, 0, zbuf.Bytes()); err != nil {
			if err == ErrInvalidHuffman {
				numFail++
				continue
			}
			t.Errorf("Failed to decode %q: %v", zbuf.Bytes(), err)
			continue
		}
	}
	t.Logf("%0.02f%% are invalid (%d 
	if numFail < 1 {
		t.Error("expected at least one invalid huffman encoding (test starts with one)")
	}
}
func TestReadVarInt(t *testing.T) {
	type res struct {
		i        uint64
		consumed int
		err      error
	}
	tests := []struct {
		n    byte
		p    []byte
		want res
	}{
		
		{1, []byte{0}, res{0, 1, nil}},
		{2, []byte{2}, res{2, 1, nil}},
		{3, []byte{6}, res{6, 1, nil}},
		{4, []byte{14}, res{14, 1, nil}},
		{5, []byte{30}, res{30, 1, nil}},
		{6, []byte{62}, res{62, 1, nil}},
		{7, []byte{126}, res{126, 1, nil}},
		{8, []byte{254}, res{254, 1, nil}},
		
		{1, []byte{1}, res{0, 0, errNeedMore}},
		{2, []byte{3}, res{0, 0, errNeedMore}},
		{3, []byte{7}, res{0, 0, errNeedMore}},
		{4, []byte{15}, res{0, 0, errNeedMore}},
		{5, []byte{31}, res{0, 0, errNeedMore}},
		{6, []byte{63}, res{0, 0, errNeedMore}},
		{7, []byte{127}, res{0, 0, errNeedMore}},
		{8, []byte{255}, res{0, 0, errNeedMore}},
		
		{5, []byte{255, 154, 10}, res{1337, 3, nil}}, 
		{5, []byte{159, 154, 10}, res{1337, 3, nil}}, 
		{5, []byte{191, 154, 10}, res{1337, 3, nil}}, 
		
		{5, []byte{191, 154, 10, 2}, res{1337, 3, nil}}, 
		
		{5, []byte{191, 154}, res{0, 0, errNeedMore}},
		
		{1, []byte{255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}, res{0, 0, errVarintOverflow}},
	}
	for _, tt := range tests {
		i, remain, err := readVarInt(tt.n, tt.p)
		consumed := len(tt.p) - len(remain)
		got := res{i, consumed, err}
		if got != tt.want {
			t.Errorf("readVarInt(%d, %v ~ %x) = %+v; want %+v", tt.n, tt.p, tt.p, got, tt.want)
		}
	}
}
func TestHuffmanFuzzCrash(t *testing.T) {
	got, err := HuffmanDecodeToString([]byte("00\x91\xff\xff\xff\xff\xc8"))
	if got != "" {
		t.Errorf("Got %q; want empty string", got)
	}
	if err != ErrInvalidHuffman {
		t.Errorf("Err = %v; want ErrInvalidHuffman", err)
	}
}
func pair(name, value string) HeaderField {
	return HeaderField{Name: name, Value: value}
}
func dehex(s string) []byte {
	s = strings.Replace(s, " ", "", -1)
	s = strings.Replace(s, "\n", "", -1)
	b, err := hex.DecodeString(s)
	if err != nil {
		panic(err)
	}
	return b
}
func TestEmitEnabled(t *testing.T) {
	var buf bytes.Buffer
	enc := NewEncoder(&buf)
	enc.WriteField(HeaderField{Name: "foo", Value: "bar"})
	enc.WriteField(HeaderField{Name: "foo", Value: "bar"})
	numCallback := 0
	var dec *Decoder
	dec = NewDecoder(8<<20, func(HeaderField) {
		numCallback++
		dec.SetEmitEnabled(false)
	})
	if !dec.EmitEnabled() {
		t.Errorf("initial emit enabled = false; want true")
	}
	if _, err := dec.Write(buf.Bytes()); err != nil {
		t.Error(err)
	}
	if numCallback != 1 {
		t.Errorf("num callbacks = %d; want 1", numCallback)
	}
	if dec.EmitEnabled() {
		t.Errorf("emit enabled = true; want false")
	}
}
func TestSaveBufLimit(t *testing.T) {
	const maxStr = 1 << 10
	var got []HeaderField
	dec := NewDecoder(initialHeaderTableSize, func(hf HeaderField) {
		got = append(got, hf)
	})
	dec.SetMaxStringLength(maxStr)
	var frag []byte
	frag = append(frag[:0], encodeTypeByte(false, false))
	frag = appendVarInt(frag, 7, 3)
	frag = append(frag, "foo"...)
	frag = appendVarInt(frag, 7, 3)
	frag = append(frag, "bar"...)
	if _, err := dec.Write(frag); err != nil {
		t.Fatal(err)
	}
	want := []HeaderField{{Name: "foo", Value: "bar"}}
	if !reflect.DeepEqual(got, want) {
		t.Errorf("After small writes, got %v; want %v", got, want)
	}
	frag = append(frag[:0], encodeTypeByte(false, false))
	frag = appendVarInt(frag, 7, maxStr*3)
	frag = append(frag, make([]byte, maxStr*3)...)
	_, err := dec.Write(frag)
	if err != ErrStringLength {
		t.Fatalf("Write error = %v; want ErrStringLength", err)
	}
}
package hpack
import (
	"bytes"
	"errors"
	"fmt"
)
type DecodingError struct {
	Err error
}
func (de DecodingError) Error() string {
	return fmt.Sprintf("decoding error: %v", de.Err)
}
type InvalidIndexError int
func (e InvalidIndexError) Error() string {
	return fmt.Sprintf("invalid indexed representation index %d", int(e))
}
type HeaderField struct {
	Name, Value string
	
	
	Sensitive bool
}
func (hf HeaderField) IsPseudo() bool {
	return len(hf.Name) != 0 && hf.Name[0] == ':'
}
func (hf HeaderField) String() string {
	var suffix string
	if hf.Sensitive {
		suffix = " (sensitive)"
	}
	return fmt.Sprintf("header field %q = %q%s", hf.Name, hf.Value, suffix)
}
func (hf HeaderField) Size() uint32 {
	
	
	
	
	
	
	
	
	
	
	
	return uint32(len(hf.Name) + len(hf.Value) + 32)
}
type Decoder struct {
	dynTab dynamicTable
	emit   func(f HeaderField)
	emitEnabled bool 
	maxStrLen   int  
	
	
	
	
	buf []byte 
	
	
	saveBuf bytes.Buffer
}
func NewDecoder(maxDynamicTableSize uint32, emitFunc func(f HeaderField)) *Decoder {
	d := &Decoder{
		emit:        emitFunc,
		emitEnabled: true,
	}
	d.dynTab.table.init()
	d.dynTab.allowedMaxSize = maxDynamicTableSize
	d.dynTab.setMaxSize(maxDynamicTableSize)
	return d
}
var ErrStringLength = errors.New("hpack: string too long")
func (d *Decoder) SetMaxStringLength(n int) {
	d.maxStrLen = n
}
func (d *Decoder) SetEmitFunc(emitFunc func(f HeaderField)) {
	d.emit = emitFunc
}
func (d *Decoder) SetEmitEnabled(v bool) { d.emitEnabled = v }
func (d *Decoder) EmitEnabled() bool { return d.emitEnabled }
func (d *Decoder) SetMaxDynamicTableSize(v uint32) {
	d.dynTab.setMaxSize(v)
}
func (d *Decoder) SetAllowedMaxDynamicTableSize(v uint32) {
	d.dynTab.allowedMaxSize = v
}
type dynamicTable struct {
	
	table          headerFieldTable
	size           uint32 
	maxSize        uint32 
	allowedMaxSize uint32 
}
func (dt *dynamicTable) setMaxSize(v uint32) {
	dt.maxSize = v
	dt.evict()
}
func (dt *dynamicTable) add(f HeaderField) {
	dt.table.addEntry(f)
	dt.size += f.Size()
	dt.evict()
}
func (dt *dynamicTable) evict() {
	var n int
	for dt.size > dt.maxSize && n < dt.table.len() {
		dt.size -= dt.table.ents[n].Size()
		n++
	}
	dt.table.evictOldest(n)
}
func (d *Decoder) maxTableIndex() int {
	
	
	
	return d.dynTab.table.len() + staticTable.len()
}
func (d *Decoder) at(i uint64) (hf HeaderField, ok bool) {
	
	if i == 0 {
		return
	}
	if i <= uint64(staticTable.len()) {
		return staticTable.ents[i-1], true
	}
	if i > uint64(d.maxTableIndex()) {
		return
	}
	
	
	
	dt := d.dynTab.table
	return dt.ents[dt.len()-(int(i)-staticTable.len())], true
}
func (d *Decoder) DecodeFull(p []byte) ([]HeaderField, error) {
	var hf []HeaderField
	saveFunc := d.emit
	defer func() { d.emit = saveFunc }()
	d.emit = func(f HeaderField) { hf = append(hf, f) }
	if _, err := d.Write(p); err != nil {
		return nil, err
	}
	if err := d.Close(); err != nil {
		return nil, err
	}
	return hf, nil
}
func (d *Decoder) Close() error {
	if d.saveBuf.Len() > 0 {
		d.saveBuf.Reset()
		return DecodingError{errors.New("truncated headers")}
	}
	return nil
}
func (d *Decoder) Write(p []byte) (n int, err error) {
	if len(p) == 0 {
		
		
		
		return
	}
	
	
	if d.saveBuf.Len() == 0 {
		d.buf = p
	} else {
		d.saveBuf.Write(p)
		d.buf = d.saveBuf.Bytes()
		d.saveBuf.Reset()
	}
	for len(d.buf) > 0 {
		err = d.parseHeaderFieldRepr()
		if err == errNeedMore {
			
			
			
			
			
			const varIntOverhead = 8 
			if d.maxStrLen != 0 && int64(len(d.buf)) > 2*(int64(d.maxStrLen)+varIntOverhead) {
				return 0, ErrStringLength
			}
			d.saveBuf.Write(d.buf)
			return len(p), nil
		}
		if err != nil {
			break
		}
	}
	return len(p), err
}
var errNeedMore = errors.New("need more data")
type indexType int
const (
	indexedTrue indexType = iota
	indexedFalse
	indexedNever
)
func (v indexType) indexed() bool   { return v == indexedTrue }
func (v indexType) sensitive() bool { return v == indexedNever }
func (d *Decoder) parseHeaderFieldRepr() error {
	b := d.buf[0]
	switch {
	case b&128 != 0:
		
		
		
		return d.parseFieldIndexed()
	case b&192 == 64:
		
		
		
		return d.parseFieldLiteral(6, indexedTrue)
	case b&240 == 0:
		
		
		
		return d.parseFieldLiteral(4, indexedFalse)
	case b&240 == 16:
		
		
		
		return d.parseFieldLiteral(4, indexedNever)
	case b&224 == 32:
		
		
		
		return d.parseDynamicTableSizeUpdate()
	}
	return DecodingError{errors.New("invalid encoding")}
}
func (d *Decoder) parseFieldIndexed() error {
	buf := d.buf
	idx, buf, err := readVarInt(7, buf)
	if err != nil {
		return err
	}
	hf, ok := d.at(idx)
	if !ok {
		return DecodingError{InvalidIndexError(idx)}
	}
	d.buf = buf
	return d.callEmit(HeaderField{Name: hf.Name, Value: hf.Value})
}
func (d *Decoder) parseFieldLiteral(n uint8, it indexType) error {
	buf := d.buf
	nameIdx, buf, err := readVarInt(n, buf)
	if err != nil {
		return err
	}
	var hf HeaderField
	wantStr := d.emitEnabled || it.indexed()
	if nameIdx > 0 {
		ihf, ok := d.at(nameIdx)
		if !ok {
			return DecodingError{InvalidIndexError(nameIdx)}
		}
		hf.Name = ihf.Name
	} else {
		hf.Name, buf, err = d.readString(buf, wantStr)
		if err != nil {
			return err
		}
	}
	hf.Value, buf, err = d.readString(buf, wantStr)
	if err != nil {
		return err
	}
	d.buf = buf
	if it.indexed() {
		d.dynTab.add(hf)
	}
	hf.Sensitive = it.sensitive()
	return d.callEmit(hf)
}
func (d *Decoder) callEmit(hf HeaderField) error {
	if d.maxStrLen != 0 {
		if len(hf.Name) > d.maxStrLen || len(hf.Value) > d.maxStrLen {
			return ErrStringLength
		}
	}
	if d.emitEnabled {
		d.emit(hf)
	}
	return nil
}
func (d *Decoder) parseDynamicTableSizeUpdate() error {
	buf := d.buf
	size, buf, err := readVarInt(5, buf)
	if err != nil {
		return err
	}
	if size > uint64(d.dynTab.allowedMaxSize) {
		return DecodingError{errors.New("dynamic table size update too large")}
	}
	d.dynTab.setMaxSize(uint32(size))
	d.buf = buf
	return nil
}
var errVarintOverflow = DecodingError{errors.New("varint integer overflow")}
func readVarInt(n byte, p []byte) (i uint64, remain []byte, err error) {
	if n < 1 || n > 8 {
		panic("bad n")
	}
	if len(p) == 0 {
		return 0, p, errNeedMore
	}
	i = uint64(p[0])
	if n < 8 {
		i &= (1 << uint64(n)) - 1
	}
	if i < (1<<uint64(n))-1 {
		return i, p[1:], nil
	}
	origP := p
	p = p[1:]
	var m uint64
	for len(p) > 0 {
		b := p[0]
		p = p[1:]
		i += uint64(b&127) << m
		if b&128 == 0 {
			return i, p, nil
		}
		m += 7
		if m >= 63 { 
			return 0, origP, errVarintOverflow
		}
	}
	return 0, origP, errNeedMore
}
func (d *Decoder) readString(p []byte, wantStr bool) (s string, remain []byte, err error) {
	if len(p) == 0 {
		return "", p, errNeedMore
	}
	isHuff := p[0]&128 != 0
	strLen, p, err := readVarInt(7, p)
	if err != nil {
		return "", p, err
	}
	if d.maxStrLen != 0 && strLen > uint64(d.maxStrLen) {
		return "", nil, ErrStringLength
	}
	if uint64(len(p)) < strLen {
		return "", p, errNeedMore
	}
	if !isHuff {
		if wantStr {
			s = string(p[:strLen])
		}
		return s, p[strLen:], nil
	}
	if wantStr {
		buf := bufPool.Get().(*bytes.Buffer)
		buf.Reset() 
		defer bufPool.Put(buf)
		if err := huffmanDecode(buf, d.maxStrLen, p[:strLen]); err != nil {
			buf.Reset()
			return "", nil, err
		}
		s = buf.String()
		buf.Reset() 
	}
	return s, p[strLen:], nil
}
package hpack
import (
	"fmt"
)
type headerFieldTable struct {
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	ents       []HeaderField
	evictCount uint64
	
	
	byName map[string]uint64
	
	
	byNameValue map[pairNameValue]uint64
}
type pairNameValue struct {
	name, value string
}
func (t *headerFieldTable) init() {
	t.byName = make(map[string]uint64)
	t.byNameValue = make(map[pairNameValue]uint64)
}
func (t *headerFieldTable) len() int {
	return len(t.ents)
}
func (t *headerFieldTable) addEntry(f HeaderField) {
	id := uint64(t.len()) + t.evictCount + 1
	t.byName[f.Name] = id
	t.byNameValue[pairNameValue{f.Name, f.Value}] = id
	t.ents = append(t.ents, f)
}
func (t *headerFieldTable) evictOldest(n int) {
	if n > t.len() {
		panic(fmt.Sprintf("evictOldest(%v) on table with %v entries", n, t.len()))
	}
	for k := 0; k < n; k++ {
		f := t.ents[k]
		id := t.evictCount + uint64(k) + 1
		if t.byName[f.Name] == id {
			delete(t.byName, f.Name)
		}
		if p := (pairNameValue{f.Name, f.Value}); t.byNameValue[p] == id {
			delete(t.byNameValue, p)
		}
	}
	copy(t.ents, t.ents[n:])
	for k := t.len() - n; k < t.len(); k++ {
		t.ents[k] = HeaderField{} 
	}
	t.ents = t.ents[:t.len()-n]
	if t.evictCount+uint64(n) < t.evictCount {
		panic("evictCount overflow")
	}
	t.evictCount += uint64(n)
}
func (t *headerFieldTable) search(f HeaderField) (i uint64, nameValueMatch bool) {
	if !f.Sensitive {
		if id := t.byNameValue[pairNameValue{f.Name, f.Value}]; id != 0 {
			return t.idToIndex(id), true
		}
	}
	if id := t.byName[f.Name]; id != 0 {
		return t.idToIndex(id), false
	}
	return 0, false
}
func (t *headerFieldTable) idToIndex(id uint64) uint64 {
	if id <= t.evictCount {
		panic(fmt.Sprintf("id (%v) <= evictCount (%v)", id, t.evictCount))
	}
	k := id - t.evictCount - 1 
	if t != staticTable {
		return uint64(t.len()) - k 
	}
	return k + 1
}
var staticTable = newStaticTable()
var staticTableEntries = [...]HeaderField{
	{Name: ":authority"},
	{Name: ":method", Value: "GET"},
	{Name: ":method", Value: "POST"},
	{Name: ":path", Value: "
	{Name: ":path", Value: "
	{Name: ":scheme", Value: "http"},
	{Name: ":scheme", Value: "https"},
	{Name: ":status", Value: "200"},
	{Name: ":status", Value: "204"},
	{Name: ":status", Value: "206"},
	{Name: ":status", Value: "304"},
	{Name: ":status", Value: "400"},
	{Name: ":status", Value: "404"},
	{Name: ":status", Value: "500"},
	{Name: "accept-charset"},
	{Name: "accept-encoding", Value: "gzip, deflate"},
	{Name: "accept-language"},
	{Name: "accept-ranges"},
	{Name: "accept"},
	{Name: "access-control-allow-origin"},
	{Name: "age"},
	{Name: "allow"},
	{Name: "authorization"},
	{Name: "cache-control"},
	{Name: "content-disposition"},
	{Name: "content-encoding"},
	{Name: "content-language"},
	{Name: "content-length"},
	{Name: "content-location"},
	{Name: "content-range"},
	{Name: "content-type"},
	{Name: "cookie"},
	{Name: "date"},
	{Name: "etag"},
	{Name: "expect"},
	{Name: "expires"},
	{Name: "from"},
	{Name: "host"},
	{Name: "if-match"},
	{Name: "if-modified-since"},
	{Name: "if-none-match"},
	{Name: "if-range"},
	{Name: "if-unmodified-since"},
	{Name: "last-modified"},
	{Name: "link"},
	{Name: "location"},
	{Name: "max-forwards"},
	{Name: "proxy-authenticate"},
	{Name: "proxy-authorization"},
	{Name: "range"},
	{Name: "referer"},
	{Name: "refresh"},
	{Name: "retry-after"},
	{Name: "server"},
	{Name: "set-cookie"},
	{Name: "strict-transport-security"},
	{Name: "transfer-encoding"},
	{Name: "user-agent"},
	{Name: "vary"},
	{Name: "via"},
	{Name: "www-authenticate"},
}
func newStaticTable() *headerFieldTable {
	t := &headerFieldTable{}
	t.init()
	for _, e := range staticTableEntries[:] {
		t.addEntry(e)
	}
	return t
}
var huffmanCodes = [256]uint32{
	0x1ff8,
	0x7fffd8,
	0xfffffe2,
	0xfffffe3,
	0xfffffe4,
	0xfffffe5,
	0xfffffe6,
	0xfffffe7,
	0xfffffe8,
	0xffffea,
	0x3ffffffc,
	0xfffffe9,
	0xfffffea,
	0x3ffffffd,
	0xfffffeb,
	0xfffffec,
	0xfffffed,
	0xfffffee,
	0xfffffef,
	0xffffff0,
	0xffffff1,
	0xffffff2,
	0x3ffffffe,
	0xffffff3,
	0xffffff4,
	0xffffff5,
	0xffffff6,
	0xffffff7,
	0xffffff8,
	0xffffff9,
	0xffffffa,
	0xffffffb,
	0x14,
	0x3f8,
	0x3f9,
	0xffa,
	0x1ff9,
	0x15,
	0xf8,
	0x7fa,
	0x3fa,
	0x3fb,
	0xf9,
	0x7fb,
	0xfa,
	0x16,
	0x17,
	0x18,
	0x0,
	0x1,
	0x2,
	0x19,
	0x1a,
	0x1b,
	0x1c,
	0x1d,
	0x1e,
	0x1f,
	0x5c,
	0xfb,
	0x7ffc,
	0x20,
	0xffb,
	0x3fc,
	0x1ffa,
	0x21,
	0x5d,
	0x5e,
	0x5f,
	0x60,
	0x61,
	0x62,
	0x63,
	0x64,
	0x65,
	0x66,
	0x67,
	0x68,
	0x69,
	0x6a,
	0x6b,
	0x6c,
	0x6d,
	0x6e,
	0x6f,
	0x70,
	0x71,
	0x72,
	0xfc,
	0x73,
	0xfd,
	0x1ffb,
	0x7fff0,
	0x1ffc,
	0x3ffc,
	0x22,
	0x7ffd,
	0x3,
	0x23,
	0x4,
	0x24,
	0x5,
	0x25,
	0x26,
	0x27,
	0x6,
	0x74,
	0x75,
	0x28,
	0x29,
	0x2a,
	0x7,
	0x2b,
	0x76,
	0x2c,
	0x8,
	0x9,
	0x2d,
	0x77,
	0x78,
	0x79,
	0x7a,
	0x7b,
	0x7ffe,
	0x7fc,
	0x3ffd,
	0x1ffd,
	0xffffffc,
	0xfffe6,
	0x3fffd2,
	0xfffe7,
	0xfffe8,
	0x3fffd3,
	0x3fffd4,
	0x3fffd5,
	0x7fffd9,
	0x3fffd6,
	0x7fffda,
	0x7fffdb,
	0x7fffdc,
	0x7fffdd,
	0x7fffde,
	0xffffeb,
	0x7fffdf,
	0xffffec,
	0xffffed,
	0x3fffd7,
	0x7fffe0,
	0xffffee,
	0x7fffe1,
	0x7fffe2,
	0x7fffe3,
	0x7fffe4,
	0x1fffdc,
	0x3fffd8,
	0x7fffe5,
	0x3fffd9,
	0x7fffe6,
	0x7fffe7,
	0xffffef,
	0x3fffda,
	0x1fffdd,
	0xfffe9,
	0x3fffdb,
	0x3fffdc,
	0x7fffe8,
	0x7fffe9,
	0x1fffde,
	0x7fffea,
	0x3fffdd,
	0x3fffde,
	0xfffff0,
	0x1fffdf,
	0x3fffdf,
	0x7fffeb,
	0x7fffec,
	0x1fffe0,
	0x1fffe1,
	0x3fffe0,
	0x1fffe2,
	0x7fffed,
	0x3fffe1,
	0x7fffee,
	0x7fffef,
	0xfffea,
	0x3fffe2,
	0x3fffe3,
	0x3fffe4,
	0x7ffff0,
	0x3fffe5,
	0x3fffe6,
	0x7ffff1,
	0x3ffffe0,
	0x3ffffe1,
	0xfffeb,
	0x7fff1,
	0x3fffe7,
	0x7ffff2,
	0x3fffe8,
	0x1ffffec,
	0x3ffffe2,
	0x3ffffe3,
	0x3ffffe4,
	0x7ffffde,
	0x7ffffdf,
	0x3ffffe5,
	0xfffff1,
	0x1ffffed,
	0x7fff2,
	0x1fffe3,
	0x3ffffe6,
	0x7ffffe0,
	0x7ffffe1,
	0x3ffffe7,
	0x7ffffe2,
	0xfffff2,
	0x1fffe4,
	0x1fffe5,
	0x3ffffe8,
	0x3ffffe9,
	0xffffffd,
	0x7ffffe3,
	0x7ffffe4,
	0x7ffffe5,
	0xfffec,
	0xfffff3,
	0xfffed,
	0x1fffe6,
	0x3fffe9,
	0x1fffe7,
	0x1fffe8,
	0x7ffff3,
	0x3fffea,
	0x3fffeb,
	0x1ffffee,
	0x1ffffef,
	0xfffff4,
	0xfffff5,
	0x3ffffea,
	0x7ffff4,
	0x3ffffeb,
	0x7ffffe6,
	0x3ffffec,
	0x3ffffed,
	0x7ffffe7,
	0x7ffffe8,
	0x7ffffe9,
	0x7ffffea,
	0x7ffffeb,
	0xffffffe,
	0x7ffffec,
	0x7ffffed,
	0x7ffffee,
	0x7ffffef,
	0x7fffff0,
	0x3ffffee,
}
var huffmanCodeLen = [256]uint8{
	13, 23, 28, 28, 28, 28, 28, 28, 28, 24, 30, 28, 28, 30, 28, 28,
	28, 28, 28, 28, 28, 28, 30, 28, 28, 28, 28, 28, 28, 28, 28, 28,
	6, 10, 10, 12, 13, 6, 8, 11, 10, 10, 8, 11, 8, 6, 6, 6,
	5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 7, 8, 15, 6, 12, 10,
	13, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
	7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 8, 13, 19, 13, 14, 6,
	15, 5, 6, 5, 6, 5, 6, 6, 6, 5, 7, 7, 6, 6, 6, 5,
	6, 7, 6, 5, 5, 6, 7, 7, 7, 7, 7, 15, 11, 14, 13, 28,
	20, 22, 20, 20, 22, 22, 22, 23, 22, 23, 23, 23, 23, 23, 24, 23,
	24, 24, 22, 23, 24, 23, 23, 23, 23, 21, 22, 23, 22, 23, 23, 24,
	22, 21, 20, 22, 22, 23, 23, 21, 23, 22, 22, 24, 21, 22, 23, 23,
	21, 21, 22, 21, 23, 22, 23, 23, 20, 22, 22, 22, 23, 22, 22, 23,
	26, 26, 20, 19, 22, 23, 22, 25, 26, 26, 26, 27, 27, 26, 24, 25,
	19, 21, 26, 27, 27, 26, 27, 24, 21, 21, 26, 26, 28, 27, 27, 27,
	20, 24, 20, 21, 22, 21, 21, 23, 22, 22, 25, 25, 24, 24, 26, 23,
	26, 27, 26, 26, 27, 27, 27, 27, 27, 28, 27, 27, 27, 27, 27, 26,
}
package hpack
import (
	"bufio"
	"regexp"
	"strconv"
	"strings"
	"testing"
)
func TestHeaderFieldTable(t *testing.T) {
	table := &headerFieldTable{}
	table.init()
	table.addEntry(pair("key1", "value1-1"))
	table.addEntry(pair("key2", "value2-1"))
	table.addEntry(pair("key1", "value1-2"))
	table.addEntry(pair("key3", "value3-1"))
	table.addEntry(pair("key4", "value4-1"))
	table.addEntry(pair("key2", "value2-2"))
	
	
	tests := []struct {
		f                 HeaderField
		beforeWantStaticI uint64
		beforeWantMatch   bool
		afterWantStaticI  uint64
		afterWantMatch    bool
	}{
		{HeaderField{"key1", "value1-1", false}, 1, true, 0, false},
		{HeaderField{"key1", "value1-2", false}, 3, true, 0, false},
		{HeaderField{"key1", "value1-3", false}, 3, false, 0, false},
		{HeaderField{"key2", "value2-1", false}, 2, true, 3, false},
		{HeaderField{"key2", "value2-2", false}, 6, true, 3, true},
		{HeaderField{"key2", "value2-3", false}, 6, false, 3, false},
		{HeaderField{"key4", "value4-1", false}, 5, true, 2, true},
		
		{HeaderField{"key4", "value4-1", true}, 5, false, 2, false},
		
		{HeaderField{"key5", "value5-x", false}, 0, false, 0, false},
	}
	staticToDynamic := func(i uint64) uint64 {
		if i == 0 {
			return 0
		}
		return uint64(table.len()) - i + 1 
	}
	searchStatic := func(f HeaderField) (uint64, bool) {
		old := staticTable
		staticTable = table
		defer func() { staticTable = old }()
		return staticTable.search(f)
	}
	searchDynamic := func(f HeaderField) (uint64, bool) {
		return table.search(f)
	}
	for _, test := range tests {
		gotI, gotMatch := searchStatic(test.f)
		if wantI, wantMatch := test.beforeWantStaticI, test.beforeWantMatch; gotI != wantI || gotMatch != wantMatch {
			t.Errorf("before evictions: searchStatic(%+v)=%v,%v want %v,%v", test.f, gotI, gotMatch, wantI, wantMatch)
		}
		gotI, gotMatch = searchDynamic(test.f)
		wantDynamicI := staticToDynamic(test.beforeWantStaticI)
		if wantI, wantMatch := wantDynamicI, test.beforeWantMatch; gotI != wantI || gotMatch != wantMatch {
			t.Errorf("before evictions: searchDynamic(%+v)=%v,%v want %v,%v", test.f, gotI, gotMatch, wantI, wantMatch)
		}
	}
	table.evictOldest(3)
	for _, test := range tests {
		gotI, gotMatch := searchStatic(test.f)
		if wantI, wantMatch := test.afterWantStaticI, test.afterWantMatch; gotI != wantI || gotMatch != wantMatch {
			t.Errorf("after evictions: searchStatic(%+v)=%v,%v want %v,%v", test.f, gotI, gotMatch, wantI, wantMatch)
		}
		gotI, gotMatch = searchDynamic(test.f)
		wantDynamicI := staticToDynamic(test.afterWantStaticI)
		if wantI, wantMatch := wantDynamicI, test.afterWantMatch; gotI != wantI || gotMatch != wantMatch {
			t.Errorf("after evictions: searchDynamic(%+v)=%v,%v want %v,%v", test.f, gotI, gotMatch, wantI, wantMatch)
		}
	}
}
func TestHeaderFieldTable_LookupMapEviction(t *testing.T) {
	table := &headerFieldTable{}
	table.init()
	table.addEntry(pair("key1", "value1-1"))
	table.addEntry(pair("key2", "value2-1"))
	table.addEntry(pair("key1", "value1-2"))
	table.addEntry(pair("key3", "value3-1"))
	table.addEntry(pair("key4", "value4-1"))
	table.addEntry(pair("key2", "value2-2"))
	
	table.evictOldest(table.len())
	if l := table.len(); l > 0 {
		t.Errorf("table.len() = %d, want 0", l)
	}
	if l := len(table.byName); l > 0 {
		t.Errorf("len(table.byName) = %d, want 0", l)
	}
	if l := len(table.byNameValue); l > 0 {
		t.Errorf("len(table.byNameValue) = %d, want 0", l)
	}
}
func TestStaticTable(t *testing.T) {
	fromSpec := `
          +-------+-----------------------------+---------------+
          | 1     | :authority                  |               |
          | 2     | :method                     | GET           |
          | 3     | :method                     | POST          |
          | 4     | :path                       | 
          | 5     | :path                       | 
          | 6     | :scheme                     | http          |
          | 7     | :scheme                     | https         |
          | 8     | :status                     | 200           |
          | 9     | :status                     | 204           |
          | 10    | :status                     | 206           |
          | 11    | :status                     | 304           |
          | 12    | :status                     | 400           |
          | 13    | :status                     | 404           |
          | 14    | :status                     | 500           |
          | 15    | accept-charset              |               |
          | 16    | accept-encoding             | gzip, deflate |
          | 17    | accept-language             |               |
          | 18    | accept-ranges               |               |
          | 19    | accept                      |               |
          | 20    | access-control-allow-origin |               |
          | 21    | age                         |               |
          | 22    | allow                       |               |
          | 23    | authorization               |               |
          | 24    | cache-control               |               |
          | 25    | content-disposition         |               |
          | 26    | content-encoding            |               |
          | 27    | content-language            |               |
          | 28    | content-length              |               |
          | 29    | content-location            |               |
          | 30    | content-range               |               |
          | 31    | content-type                |               |
          | 32    | cookie                      |               |
          | 33    | date                        |               |
          | 34    | etag                        |               |
          | 35    | expect                      |               |
          | 36    | expires                     |               |
          | 37    | from                        |               |
          | 38    | host                        |               |
          | 39    | if-match                    |               |
          | 40    | if-modified-since           |               |
          | 41    | if-none-match               |               |
          | 42    | if-range                    |               |
          | 43    | if-unmodified-since         |               |
          | 44    | last-modified               |               |
          | 45    | link                        |               |
          | 46    | location                    |               |
          | 47    | max-forwards                |               |
          | 48    | proxy-authenticate          |               |
          | 49    | proxy-authorization         |               |
          | 50    | range                       |               |
          | 51    | referer                     |               |
          | 52    | refresh                     |               |
          | 53    | retry-after                 |               |
          | 54    | server                      |               |
          | 55    | set-cookie                  |               |
          | 56    | strict-transport-security   |               |
          | 57    | transfer-encoding           |               |
          | 58    | user-agent                  |               |
          | 59    | vary                        |               |
          | 60    | via                         |               |
          | 61    | www-authenticate            |               |
          +-------+-----------------------------+---------------+
`
	bs := bufio.NewScanner(strings.NewReader(fromSpec))
	re := regexp.MustCompile(`\| (\d+)\s+\| (\S+)\s*\| (\S(.*\S)?)?\s+\|`)
	for bs.Scan() {
		l := bs.Text()
		if !strings.Contains(l, "|") {
			continue
		}
		m := re.FindStringSubmatch(l)
		if m == nil {
			continue
		}
		i, err := strconv.Atoi(m[1])
		if err != nil {
			t.Errorf("Bogus integer on line %q", l)
			continue
		}
		if i < 1 || i > staticTable.len() {
			t.Errorf("Bogus index %d on line %q", i, l)
			continue
		}
		if got, want := staticTable.ents[i-1].Name, m[2]; got != want {
			t.Errorf("header index %d name = %q; want %q", i, got, want)
		}
		if got, want := staticTable.ents[i-1].Value, m[3]; got != want {
			t.Errorf("header index %d value = %q; want %q", i, got, want)
		}
	}
	if err := bs.Err(); err != nil {
		t.Error(err)
	}
}
package hpack
import (
	"io"
)
const (
	uint32Max              = ^uint32(0)
	initialHeaderTableSize = 4096
)
type Encoder struct {
	dynTab dynamicTable
	
	
	
	minSize uint32
	
	
	
	maxSizeLimit uint32
	
	
	tableSizeUpdate bool
	w               io.Writer
	buf             []byte
}
func NewEncoder(w io.Writer) *Encoder {
	e := &Encoder{
		minSize:         uint32Max,
		maxSizeLimit:    initialHeaderTableSize,
		tableSizeUpdate: false,
		w:               w,
	}
	e.dynTab.table.init()
	e.dynTab.setMaxSize(initialHeaderTableSize)
	return e
}
func (e *Encoder) WriteField(f HeaderField) error {
	e.buf = e.buf[:0]
	if e.tableSizeUpdate {
		e.tableSizeUpdate = false
		if e.minSize < e.dynTab.maxSize {
			e.buf = appendTableSize(e.buf, e.minSize)
		}
		e.minSize = uint32Max
		e.buf = appendTableSize(e.buf, e.dynTab.maxSize)
	}
	idx, nameValueMatch := e.searchTable(f)
	if nameValueMatch {
		e.buf = appendIndexed(e.buf, idx)
	} else {
		indexing := e.shouldIndex(f)
		if indexing {
			e.dynTab.add(f)
		}
		if idx == 0 {
			e.buf = appendNewName(e.buf, f, indexing)
		} else {
			e.buf = appendIndexedName(e.buf, f, idx, indexing)
		}
	}
	n, err := e.w.Write(e.buf)
	if err == nil && n != len(e.buf) {
		err = io.ErrShortWrite
	}
	return err
}
func (e *Encoder) searchTable(f HeaderField) (i uint64, nameValueMatch bool) {
	i, nameValueMatch = staticTable.search(f)
	if nameValueMatch {
		return i, true
	}
	j, nameValueMatch := e.dynTab.table.search(f)
	if nameValueMatch || (i == 0 && j != 0) {
		return j + uint64(staticTable.len()), nameValueMatch
	}
	return i, false
}
func (e *Encoder) SetMaxDynamicTableSize(v uint32) {
	if v > e.maxSizeLimit {
		v = e.maxSizeLimit
	}
	if v < e.minSize {
		e.minSize = v
	}
	e.tableSizeUpdate = true
	e.dynTab.setMaxSize(v)
}
func (e *Encoder) SetMaxDynamicTableSizeLimit(v uint32) {
	e.maxSizeLimit = v
	if e.dynTab.maxSize > v {
		e.tableSizeUpdate = true
		e.dynTab.setMaxSize(v)
	}
}
func (e *Encoder) shouldIndex(f HeaderField) bool {
	return !f.Sensitive && f.Size() <= e.dynTab.maxSize
}
func appendIndexed(dst []byte, i uint64) []byte {
	first := len(dst)
	dst = appendVarInt(dst, 7, i)
	dst[first] |= 0x80
	return dst
}
func appendNewName(dst []byte, f HeaderField, indexing bool) []byte {
	dst = append(dst, encodeTypeByte(indexing, f.Sensitive))
	dst = appendHpackString(dst, f.Name)
	return appendHpackString(dst, f.Value)
}
func appendIndexedName(dst []byte, f HeaderField, i uint64, indexing bool) []byte {
	first := len(dst)
	var n byte
	if indexing {
		n = 6
	} else {
		n = 4
	}
	dst = appendVarInt(dst, n, i)
	dst[first] |= encodeTypeByte(indexing, f.Sensitive)
	return appendHpackString(dst, f.Value)
}
func appendTableSize(dst []byte, v uint32) []byte {
	first := len(dst)
	dst = appendVarInt(dst, 5, uint64(v))
	dst[first] |= 0x20
	return dst
}
func appendVarInt(dst []byte, n byte, i uint64) []byte {
	k := uint64((1 << n) - 1)
	if i < k {
		return append(dst, byte(i))
	}
	dst = append(dst, byte(k))
	i -= k
	for ; i >= 128; i >>= 7 {
		dst = append(dst, byte(0x80|(i&0x7f)))
	}
	return append(dst, byte(i))
}
func appendHpackString(dst []byte, s string) []byte {
	huffmanLength := HuffmanEncodeLength(s)
	if huffmanLength < uint64(len(s)) {
		first := len(dst)
		dst = appendVarInt(dst, 7, huffmanLength)
		dst = AppendHuffmanString(dst, s)
		dst[first] |= 0x80
	} else {
		dst = appendVarInt(dst, 7, uint64(len(s)))
		dst = append(dst, s...)
	}
	return dst
}
func encodeTypeByte(indexing, sensitive bool) byte {
	if sensitive {
		return 0x10
	}
	if indexing {
		return 0x40
	}
	return 0
}
package http2
import (
	"bytes"
	"errors"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"sync"
)
var DebugGoroutines = os.Getenv("DEBUG_HTTP2_GOROUTINES") == "1"
type goroutineLock uint64
func newGoroutineLock() goroutineLock {
	if !DebugGoroutines {
		return 0
	}
	return goroutineLock(curGoroutineID())
}
func (g goroutineLock) check() {
	if !DebugGoroutines {
		return
	}
	if curGoroutineID() != uint64(g) {
		panic("running on the wrong goroutine")
	}
}
func (g goroutineLock) checkNotOn() {
	if !DebugGoroutines {
		return
	}
	if curGoroutineID() == uint64(g) {
		panic("running on the wrong goroutine")
	}
}
var goroutineSpace = []byte("goroutine ")
func curGoroutineID() uint64 {
	bp := littleBuf.Get().(*[]byte)
	defer littleBuf.Put(bp)
	b := *bp
	b = b[:runtime.Stack(b, false)]
	
	b = bytes.TrimPrefix(b, goroutineSpace)
	i := bytes.IndexByte(b, ' ')
	if i < 0 {
		panic(fmt.Sprintf("No space found in %q", b))
	}
	b = b[:i]
	n, err := parseUintBytes(b, 10, 64)
	if err != nil {
		panic(fmt.Sprintf("Failed to parse goroutine ID out of %q: %v", b, err))
	}
	return n
}
var littleBuf = sync.Pool{
	New: func() interface{} {
		buf := make([]byte, 64)
		return &buf
	},
}
func parseUintBytes(s []byte, base int, bitSize int) (n uint64, err error) {
	var cutoff, maxVal uint64
	if bitSize == 0 {
		bitSize = int(strconv.IntSize)
	}
	s0 := s
	switch {
	case len(s) < 1:
		err = strconv.ErrSyntax
		goto Error
	case 2 <= base && base <= 36:
		
	case base == 0:
		
		switch {
		case s[0] == '0' && len(s) > 1 && (s[1] == 'x' || s[1] == 'X'):
			base = 16
			s = s[2:]
			if len(s) < 1 {
				err = strconv.ErrSyntax
				goto Error
			}
		case s[0] == '0':
			base = 8
		default:
			base = 10
		}
	default:
		err = errors.New("invalid base " + strconv.Itoa(base))
		goto Error
	}
	n = 0
	cutoff = cutoff64(base)
	maxVal = 1<<uint(bitSize) - 1
	for i := 0; i < len(s); i++ {
		var v byte
		d := s[i]
		switch {
		case '0' <= d && d <= '9':
			v = d - '0'
		case 'a' <= d && d <= 'z':
			v = d - 'a' + 10
		case 'A' <= d && d <= 'Z':
			v = d - 'A' + 10
		default:
			n = 0
			err = strconv.ErrSyntax
			goto Error
		}
		if int(v) >= base {
			n = 0
			err = strconv.ErrSyntax
			goto Error
		}
		if n >= cutoff {
			
			n = 1<<64 - 1
			err = strconv.ErrRange
			goto Error
		}
		n *= uint64(base)
		n1 := n + uint64(v)
		if n1 < n || n1 > maxVal {
			
			n = 1<<64 - 1
			err = strconv.ErrRange
			goto Error
		}
		n = n1
	}
	return n, nil
Error:
	return n, &strconv.NumError{Func: "ParseUint", Num: string(s0), Err: err}
}
func cutoff64(base int) uint64 {
	if base < 2 {
		return 0
	}
	return (1<<64-1)
}
package http2
import (
	"errors"
	"io"
	"sync"
)
type pipe struct {
	mu       sync.Mutex
	c        sync.Cond     
	b        pipeBuffer    
	err      error         
	breakErr error         
	donec    chan struct{} 
	readFn   func()        
}
type pipeBuffer interface {
	Len() int
	io.Writer
	io.Reader
}
func (p *pipe) Len() int {
	p.mu.Lock()
	defer p.mu.Unlock()
	if p.b == nil {
		return 0
	}
	return p.b.Len()
}
func (p *pipe) Read(d []byte) (n int, err error) {
	p.mu.Lock()
	defer p.mu.Unlock()
	if p.c.L == nil {
		p.c.L = &p.mu
	}
	for {
		if p.breakErr != nil {
			return 0, p.breakErr
		}
		if p.b != nil && p.b.Len() > 0 {
			return p.b.Read(d)
		}
		if p.err != nil {
			if p.readFn != nil {
				p.readFn()     
				p.readFn = nil 
			}
			p.b = nil
			return 0, p.err
		}
		p.c.Wait()
	}
}
var errClosedPipeWrite = errors.New("write on closed buffer")
func (p *pipe) Write(d []byte) (n int, err error) {
	p.mu.Lock()
	defer p.mu.Unlock()
	if p.c.L == nil {
		p.c.L = &p.mu
	}
	defer p.c.Signal()
	if p.err != nil {
		return 0, errClosedPipeWrite
	}
	if p.breakErr != nil {
		return len(d), nil 
	}
	return p.b.Write(d)
}
func (p *pipe) CloseWithError(err error) { p.closeWithError(&p.err, err, nil) }
func (p *pipe) BreakWithError(err error) { p.closeWithError(&p.breakErr, err, nil) }
func (p *pipe) closeWithErrorAndCode(err error, fn func()) { p.closeWithError(&p.err, err, fn) }
func (p *pipe) closeWithError(dst *error, err error, fn func()) {
	if err == nil {
		panic("err must be non-nil")
	}
	p.mu.Lock()
	defer p.mu.Unlock()
	if p.c.L == nil {
		p.c.L = &p.mu
	}
	defer p.c.Signal()
	if *dst != nil {
		
		return
	}
	p.readFn = fn
	if dst == &p.breakErr {
		p.b = nil
	}
	*dst = err
	p.closeDoneLocked()
}
func (p *pipe) closeDoneLocked() {
	if p.donec == nil {
		return
	}
	
	
	select {
	case <-p.donec:
	default:
		close(p.donec)
	}
}
func (p *pipe) Err() error {
	p.mu.Lock()
	defer p.mu.Unlock()
	if p.breakErr != nil {
		return p.breakErr
	}
	return p.err
}
func (p *pipe) Done() <-chan struct{} {
	p.mu.Lock()
	defer p.mu.Unlock()
	if p.donec == nil {
		p.donec = make(chan struct{})
		if p.err != nil || p.breakErr != nil {
			
			p.closeDoneLocked()
		}
	}
	return p.donec
}
package http2
import (
	"net
	"time"
)
func transportExpectContinueTimeout(t1 *http.Transport) time.Duration {
	return t1.ExpectContinueTimeout
}
package http2
import (
	"bytes"
	"encoding
	"flag"
	"fmt"
	"io"
	"os"
	"reflect"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"testing"
)
var coverSpec = flag.Bool("coverspec", false, "Run spec coverage tests")
var defaultSpecCoverage specCoverage
var loadSpecOnce sync.Once
func loadSpec() {
	if f, err := os.Open("testdata
		panic(err)
	} else {
		defaultSpecCoverage = readSpecCov(f)
		f.Close()
	}
}
func covers(sec, sentences string) {
	loadSpecOnce.Do(loadSpec)
	defaultSpecCoverage.cover(sec, sentences)
}
type specPart struct {
	section  string
	sentence string
}
func (ss specPart) Less(oo specPart) bool {
	atoi := func(s string) int {
		n, err := strconv.Atoi(s)
		if err != nil {
			panic(err)
		}
		return n
	}
	a := strings.Split(ss.section, ".")
	b := strings.Split(oo.section, ".")
	for len(a) > 0 {
		if len(b) == 0 {
			return false
		}
		x, y := atoi(a[0]), atoi(b[0])
		if x == y {
			a, b = a[1:], b[1:]
			continue
		}
		return x < y
	}
	if len(b) > 0 {
		return true
	}
	return false
}
type bySpecSection []specPart
func (a bySpecSection) Len() int           { return len(a) }
func (a bySpecSection) Less(i, j int) bool { return a[i].Less(a[j]) }
func (a bySpecSection) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
type specCoverage struct {
	coverage map[specPart]bool
	d        *xml.Decoder
}
func joinSection(sec []int) string {
	s := fmt.Sprintf("%d", sec[0])
	for _, n := range sec[1:] {
		s = fmt.Sprintf("%s.%d", s, n)
	}
	return s
}
func (sc specCoverage) readSection(sec []int) {
	var (
		buf = new(bytes.Buffer)
		sub = 0
	)
	for {
		tk, err := sc.d.Token()
		if err != nil {
			if err == io.EOF {
				return
			}
			panic(err)
		}
		switch v := tk.(type) {
		case xml.StartElement:
			if skipElement(v) {
				if err := sc.d.Skip(); err != nil {
					panic(err)
				}
				if v.Name.Local == "section" {
					sub++
				}
				break
			}
			switch v.Name.Local {
			case "section":
				sub++
				sc.readSection(append(sec, sub))
			case "xref":
				buf.Write(sc.readXRef(v))
			}
		case xml.CharData:
			if len(sec) == 0 {
				break
			}
			buf.Write(v)
		case xml.EndElement:
			if v.Name.Local == "section" {
				sc.addSentences(joinSection(sec), buf.String())
				return
			}
		}
	}
}
func (sc specCoverage) readXRef(se xml.StartElement) []byte {
	var b []byte
	for {
		tk, err := sc.d.Token()
		if err != nil {
			panic(err)
		}
		switch v := tk.(type) {
		case xml.CharData:
			if b != nil {
				panic("unexpected CharData")
			}
			b = []byte(string(v))
		case xml.EndElement:
			if v.Name.Local != "xref" {
				panic("expected <
			}
			if b != nil {
				return b
			}
			sig := attrSig(se)
			switch sig {
			case "target":
				return []byte(fmt.Sprintf("[%s]", attrValue(se, "target")))
			case "fmt-of,rel,target", "fmt-,,rel,target":
				return []byte(fmt.Sprintf("[%s, %s]", attrValue(se, "target"), attrValue(se, "rel")))
			case "fmt-of,sec,target", "fmt-,,sec,target":
				return []byte(fmt.Sprintf("[section %s of %s]", attrValue(se, "sec"), attrValue(se, "target")))
			case "fmt-of,rel,sec,target":
				return []byte(fmt.Sprintf("[section %s of %s, %s]", attrValue(se, "sec"), attrValue(se, "target"), attrValue(se, "rel")))
			default:
				panic(fmt.Sprintf("unknown attribute signature %q in %#v", sig, fmt.Sprintf("%#v", se)))
			}
		default:
			panic(fmt.Sprintf("unexpected tag %q", v))
		}
	}
}
var skipAnchor = map[string]bool{
	"intro":    true,
	"Overview": true,
}
var skipTitle = map[string]bool{
	"Acknowledgements":            true,
	"Change Log":                  true,
	"Document Organization":       true,
	"Conventions and Terminology": true,
}
func skipElement(s xml.StartElement) bool {
	switch s.Name.Local {
	case "artwork":
		return true
	case "section":
		for _, attr := range s.Attr {
			switch attr.Name.Local {
			case "anchor":
				if skipAnchor[attr.Value] || strings.HasPrefix(attr.Value, "changes.since.") {
					return true
				}
			case "title":
				if skipTitle[attr.Value] {
					return true
				}
			}
		}
	}
	return false
}
func readSpecCov(r io.Reader) specCoverage {
	sc := specCoverage{
		coverage: map[specPart]bool{},
		d:        xml.NewDecoder(r)}
	sc.readSection(nil)
	return sc
}
func (sc specCoverage) addSentences(sec string, sentence string) {
	for _, s := range parseSentences(sentence) {
		sc.coverage[specPart{sec, s}] = false
	}
}
func (sc specCoverage) cover(sec string, sentence string) {
	for _, s := range parseSentences(sentence) {
		p := specPart{sec, s}
		if _, ok := sc.coverage[p]; !ok {
			panic(fmt.Sprintf("Not found in spec: %q, %q", sec, s))
		}
		sc.coverage[specPart{sec, s}] = true
	}
}
var whitespaceRx = regexp.MustCompile(`\s+`)
func parseSentences(sens string) []string {
	sens = strings.TrimSpace(sens)
	if sens == "" {
		return nil
	}
	ss := strings.Split(whitespaceRx.ReplaceAllString(sens, " "), ". ")
	for i, s := range ss {
		s = strings.TrimSpace(s)
		if !strings.HasSuffix(s, ".") {
			s += "."
		}
		ss[i] = s
	}
	return ss
}
func TestSpecParseSentences(t *testing.T) {
	tests := []struct {
		ss   string
		want []string
	}{
		{"Sentence 1. Sentence 2.",
			[]string{
				"Sentence 1.",
				"Sentence 2.",
			}},
		{"Sentence 1.  \nSentence 2.\tSentence 3.",
			[]string{
				"Sentence 1.",
				"Sentence 2.",
				"Sentence 3.",
			}},
	}
	for i, tt := range tests {
		got := parseSentences(tt.ss)
		if !reflect.DeepEqual(got, tt.want) {
			t.Errorf("%d: got = %q, want %q", i, got, tt.want)
		}
	}
}
func TestSpecCoverage(t *testing.T) {
	if !*coverSpec {
		t.Skip()
	}
	loadSpecOnce.Do(loadSpec)
	var (
		list     []specPart
		cv       = defaultSpecCoverage.coverage
		total    = len(cv)
		complete = 0
	)
	for sp, touched := range defaultSpecCoverage.coverage {
		if touched {
			complete++
		} else {
			list = append(list, sp)
		}
	}
	sort.Stable(bySpecSection(list))
	if testing.Short() && len(list) > 5 {
		list = list[:5]
	}
	for _, p := range list {
		t.Errorf("\tSECTION %s: %s", p.section, p.sentence)
	}
	t.Logf("%d
}
func attrSig(se xml.StartElement) string {
	var names []string
	for _, attr := range se.Attr {
		if attr.Name.Local == "fmt" {
			names = append(names, "fmt-"+attr.Value)
		} else {
			names = append(names, attr.Name.Local)
		}
	}
	sort.Strings(names)
	return strings.Join(names, ",")
}
func attrValue(se xml.StartElement, attr string) string {
	for _, a := range se.Attr {
		if a.Name.Local == attr {
			return a.Value
		}
	}
	panic("unknown attribute " + attr)
}
func TestSpecPartLess(t *testing.T) {
	tests := []struct {
		sec1, sec2 string
		want       bool
	}{
		{"6.2.1", "6.2", false},
		{"6.2", "6.2.1", true},
		{"6.10", "6.10.1", true},
		{"6.10", "6.1.1", false}, 
		{"6.1", "6.1", false},    
	}
	for _, tt := range tests {
		got := (specPart{tt.sec1, "foo"}).Less(specPart{tt.sec2, "foo"})
		if got != tt.want {
			t.Errorf("Less(%q, %q) = %v; want %v", tt.sec1, tt.sec2, got, tt.want)
		}
	}
}
package http2
import (
	"net
	"time"
)
func configureTransport(t1 *http.Transport) (*Transport, error) {
	return nil, errTransportVersion
}
func transportExpectContinueTimeout(t1 *http.Transport) time.Duration {
	return 0
}
package http2
import (
	"io"
	"net
)
func configureServer18(h1 *http.Server, h2 *Server) error {
	
	return nil
}
func shouldLogPanic(panicValue interface{}) bool {
	return panicValue != nil
}
func reqGetBody(req *http.Request) func() (io.ReadCloser, error) {
	return nil
}
func reqBodyIsNoBody(io.ReadCloser) bool { return false }
func go18httpNoBody() io.ReadCloser { return nil } 
package http2
import (
	"fmt"
	"math"
	"sort"
)
const priorityDefaultWeight = 15 
type PriorityWriteSchedulerConfig struct {
	
	
	
	
	
	
	
	
	
	
	
	
	MaxClosedNodesInTree int
	
	
	
	
	
	
	
	
	
	
	MaxIdleNodesInTree int
	
	
	
	
	
	
	
	
	ThrottleOutOfOrderWrites bool
}
func NewPriorityWriteScheduler(cfg *PriorityWriteSchedulerConfig) WriteScheduler {
	if cfg == nil {
		
		
		cfg = &PriorityWriteSchedulerConfig{
			MaxClosedNodesInTree:     10,
			MaxIdleNodesInTree:       10,
			ThrottleOutOfOrderWrites: false,
		}
	}
	ws := &priorityWriteScheduler{
		nodes:                make(map[uint32]*priorityNode),
		maxClosedNodesInTree: cfg.MaxClosedNodesInTree,
		maxIdleNodesInTree:   cfg.MaxIdleNodesInTree,
		enableWriteThrottle:  cfg.ThrottleOutOfOrderWrites,
	}
	ws.nodes[0] = &ws.root
	if cfg.ThrottleOutOfOrderWrites {
		ws.writeThrottleLimit = 1024
	} else {
		ws.writeThrottleLimit = math.MaxInt32
	}
	return ws
}
type priorityNodeState int
const (
	priorityNodeOpen priorityNodeState = iota
	priorityNodeClosed
	priorityNodeIdle
)
type priorityNode struct {
	q            writeQueue        
	id           uint32            
	weight       uint8             
	state        priorityNodeState 
	bytes        int64             
	subtreeBytes int64             
	
	parent     *priorityNode
	kids       *priorityNode 
	prev, next *priorityNode 
}
func (n *priorityNode) setParent(parent *priorityNode) {
	if n == parent {
		panic("setParent to self")
	}
	if n.parent == parent {
		return
	}
	
	if parent := n.parent; parent != nil {
		if n.prev == nil {
			parent.kids = n.next
		} else {
			n.prev.next = n.next
		}
		if n.next != nil {
			n.next.prev = n.prev
		}
	}
	
	
	
	n.parent = parent
	if parent == nil {
		n.next = nil
		n.prev = nil
	} else {
		n.next = parent.kids
		n.prev = nil
		if n.next != nil {
			n.next.prev = n
		}
		parent.kids = n
	}
}
func (n *priorityNode) addBytes(b int64) {
	n.bytes += b
	for ; n != nil; n = n.parent {
		n.subtreeBytes += b
	}
}
func (n *priorityNode) walkReadyInOrder(openParent bool, tmp *[]*priorityNode, f func(*priorityNode, bool) bool) bool {
	if !n.q.empty() && f(n, openParent) {
		return true
	}
	if n.kids == nil {
		return false
	}
	
	
	if n.id != 0 {
		openParent = openParent || (n.state == priorityNodeOpen)
	}
	
	
	
	w := n.kids.weight
	needSort := false
	for k := n.kids.next; k != nil; k = k.next {
		if k.weight != w {
			needSort = true
			break
		}
	}
	if !needSort {
		for k := n.kids; k != nil; k = k.next {
			if k.walkReadyInOrder(openParent, tmp, f) {
				return true
			}
		}
		return false
	}
	
	
	*tmp = (*tmp)[:0]
	for n.kids != nil {
		*tmp = append(*tmp, n.kids)
		n.kids.setParent(nil)
	}
	sort.Sort(sortPriorityNodeSiblings(*tmp))
	for i := len(*tmp) - 1; i >= 0; i-- {
		(*tmp)[i].setParent(n) 
	}
	for k := n.kids; k != nil; k = k.next {
		if k.walkReadyInOrder(openParent, tmp, f) {
			return true
		}
	}
	return false
}
type sortPriorityNodeSiblings []*priorityNode
func (z sortPriorityNodeSiblings) Len() int      { return len(z) }
func (z sortPriorityNodeSiblings) Swap(i, k int) { z[i], z[k] = z[k], z[i] }
func (z sortPriorityNodeSiblings) Less(i, k int) bool {
	
	
	wi, bi := float64(z[i].weight+1), float64(z[i].subtreeBytes)
	wk, bk := float64(z[k].weight+1), float64(z[k].subtreeBytes)
	if bi == 0 && bk == 0 {
		return wi >= wk
	}
	if bk == 0 {
		return false
	}
	return bi
}
type priorityWriteScheduler struct {
	
	
	root priorityNode
	
	nodes map[uint32]*priorityNode
	
	maxID uint32
	
	
	
	closedNodes, idleNodes []*priorityNode
	
	maxClosedNodesInTree int
	maxIdleNodesInTree   int
	writeThrottleLimit   int32
	enableWriteThrottle  bool
	
	tmp []*priorityNode
	
	queuePool writeQueuePool
}
func (ws *priorityWriteScheduler) OpenStream(streamID uint32, options OpenStreamOptions) {
	
	if curr := ws.nodes[streamID]; curr != nil {
		if curr.state != priorityNodeIdle {
			panic(fmt.Sprintf("stream %d already opened", streamID))
		}
		curr.state = priorityNodeOpen
		return
	}
	
	
	
	
	parent := ws.nodes[options.PusherID]
	if parent == nil {
		parent = &ws.root
	}
	n := &priorityNode{
		q:      *ws.queuePool.get(),
		id:     streamID,
		weight: priorityDefaultWeight,
		state:  priorityNodeOpen,
	}
	n.setParent(parent)
	ws.nodes[streamID] = n
	if streamID > ws.maxID {
		ws.maxID = streamID
	}
}
func (ws *priorityWriteScheduler) CloseStream(streamID uint32) {
	if streamID == 0 {
		panic("violation of WriteScheduler interface: cannot close stream 0")
	}
	if ws.nodes[streamID] == nil {
		panic(fmt.Sprintf("violation of WriteScheduler interface: unknown stream %d", streamID))
	}
	if ws.nodes[streamID].state != priorityNodeOpen {
		panic(fmt.Sprintf("violation of WriteScheduler interface: stream %d already closed", streamID))
	}
	n := ws.nodes[streamID]
	n.state = priorityNodeClosed
	n.addBytes(-n.bytes)
	q := n.q
	ws.queuePool.put(&q)
	n.q.s = nil
	if ws.maxClosedNodesInTree > 0 {
		ws.addClosedOrIdleNode(&ws.closedNodes, ws.maxClosedNodesInTree, n)
	} else {
		ws.removeNode(n)
	}
}
func (ws *priorityWriteScheduler) AdjustStream(streamID uint32, priority PriorityParam) {
	if streamID == 0 {
		panic("adjustPriority on root")
	}
	
	
	
	n := ws.nodes[streamID]
	if n == nil {
		if streamID <= ws.maxID || ws.maxIdleNodesInTree == 0 {
			return
		}
		ws.maxID = streamID
		n = &priorityNode{
			q:      *ws.queuePool.get(),
			id:     streamID,
			weight: priorityDefaultWeight,
			state:  priorityNodeIdle,
		}
		n.setParent(&ws.root)
		ws.nodes[streamID] = n
		ws.addClosedOrIdleNode(&ws.idleNodes, ws.maxIdleNodesInTree, n)
	}
	
	
	parent := ws.nodes[priority.StreamDep]
	if parent == nil {
		n.setParent(&ws.root)
		n.weight = priorityDefaultWeight
		return
	}
	
	if n == parent {
		return
	}
	
	
	
	
	
	
	
	for x := parent.parent; x != nil; x = x.parent {
		if x == n {
			parent.setParent(n.parent)
			break
		}
	}
	
	
	
	if priority.Exclusive {
		k := parent.kids
		for k != nil {
			next := k.next
			if k != n {
				k.setParent(n)
			}
			k = next
		}
	}
	n.setParent(parent)
	n.weight = priority.Weight
}
func (ws *priorityWriteScheduler) Push(wr FrameWriteRequest) {
	var n *priorityNode
	if id := wr.StreamID(); id == 0 {
		n = &ws.root
	} else {
		n = ws.nodes[id]
		if n == nil {
			
			
			
			
			
			if wr.DataSize() > 0 {
				panic("add DATA on non-open stream")
			}
			n = &ws.root
		}
	}
	n.q.push(wr)
}
func (ws *priorityWriteScheduler) Pop() (wr FrameWriteRequest, ok bool) {
	ws.root.walkReadyInOrder(false, &ws.tmp, func(n *priorityNode, openParent bool) bool {
		limit := int32(math.MaxInt32)
		if openParent {
			limit = ws.writeThrottleLimit
		}
		wr, ok = n.q.consume(limit)
		if !ok {
			return false
		}
		n.addBytes(int64(wr.DataSize()))
		
		
		
		if openParent {
			ws.writeThrottleLimit += 1024
			if ws.writeThrottleLimit < 0 {
				ws.writeThrottleLimit = math.MaxInt32
			}
		} else if ws.enableWriteThrottle {
			ws.writeThrottleLimit = 1024
		}
		return true
	})
	return wr, ok
}
func (ws *priorityWriteScheduler) addClosedOrIdleNode(list *[]*priorityNode, maxSize int, n *priorityNode) {
	if maxSize == 0 {
		return
	}
	if len(*list) == maxSize {
		
		ws.removeNode((*list)[0])
		x := (*list)[1:]
		copy(*list, x)
		*list = (*list)[:len(x)]
	}
	*list = append(*list, n)
}
func (ws *priorityWriteScheduler) removeNode(n *priorityNode) {
	for k := n.kids; k != nil; k = k.next {
		k.setParent(n.parent)
	}
	n.setParent(nil)
	delete(ws.nodes, n.id)
}
package http2
import (
	"errors"
	"fmt"
	"sync"
)
var (
	dataChunkSizeClasses = []int{
		1 << 10,
		2 << 10,
		4 << 10,
		8 << 10,
		16 << 10,
	}
	dataChunkPools = [...]sync.Pool{
		{New: func() interface{} { return make([]byte, 1<<10) }},
		{New: func() interface{} { return make([]byte, 2<<10) }},
		{New: func() interface{} { return make([]byte, 4<<10) }},
		{New: func() interface{} { return make([]byte, 8<<10) }},
		{New: func() interface{} { return make([]byte, 16<<10) }},
	}
)
func getDataBufferChunk(size int64) []byte {
	i := 0
	for ; i < len(dataChunkSizeClasses)-1; i++ {
		if size <= int64(dataChunkSizeClasses[i]) {
			break
		}
	}
	return dataChunkPools[i].Get().([]byte)
}
func putDataBufferChunk(p []byte) {
	for i, n := range dataChunkSizeClasses {
		if len(p) == n {
			dataChunkPools[i].Put(p)
			return
		}
	}
	panic(fmt.Sprintf("unexpected buffer len=%v", len(p)))
}
type dataBuffer struct {
	chunks   [][]byte
	r        int   
	w        int   
	size     int   
	expected int64 
}
var errReadEmpty = errors.New("read from empty dataBuffer")
func (b *dataBuffer) Read(p []byte) (int, error) {
	if b.size == 0 {
		return 0, errReadEmpty
	}
	var ntotal int
	for len(p) > 0 && b.size > 0 {
		readFrom := b.bytesFromFirstChunk()
		n := copy(p, readFrom)
		p = p[n:]
		ntotal += n
		b.r += n
		b.size -= n
		
		if b.r == len(b.chunks[0]) {
			putDataBufferChunk(b.chunks[0])
			end := len(b.chunks) - 1
			copy(b.chunks[:end], b.chunks[1:])
			b.chunks[end] = nil
			b.chunks = b.chunks[:end]
			b.r = 0
		}
	}
	return ntotal, nil
}
func (b *dataBuffer) bytesFromFirstChunk() []byte {
	if len(b.chunks) == 1 {
		return b.chunks[0][b.r:b.w]
	}
	return b.chunks[0][b.r:]
}
func (b *dataBuffer) Len() int {
	return b.size
}
func (b *dataBuffer) Write(p []byte) (int, error) {
	ntotal := len(p)
	for len(p) > 0 {
		
		
		
		want := int64(len(p))
		if b.expected > want {
			want = b.expected
		}
		chunk := b.lastChunkOrAlloc(want)
		n := copy(chunk[b.w:], p)
		p = p[n:]
		b.w += n
		b.size += n
		b.expected -= int64(n)
	}
	return ntotal, nil
}
func (b *dataBuffer) lastChunkOrAlloc(want int64) []byte {
	if len(b.chunks) != 0 {
		last := b.chunks[len(b.chunks)-1]
		if b.w < len(last) {
			return last
		}
	}
	chunk := getDataBufferChunk(want)
	b.chunks = append(b.chunks, chunk)
	b.w = 0
	return chunk
}
package http2
import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"net
	"os
	"strconv"
	"strings"
	"testing"
	"golang.org
)
var knownFailing = flag.Bool("known_failing", false, "Run known-failing tests.")
func condSkipFailingTest(t *testing.T) {
	if !*knownFailing {
		t.Skip("Skipping known-failing test without --known_failing")
	}
}
func init() {
	inTests = true
	DebugGoroutines = true
	flag.BoolVar(&VerboseLogs, "verboseh2", VerboseLogs, "Verbose HTTP
}
func TestSettingString(t *testing.T) {
	tests := []struct {
		s    Setting
		want string
	}{
		{Setting{SettingMaxFrameSize, 123}, "[MAX_FRAME_SIZE = 123]"},
		{Setting{1<<16 - 1, 123}, "[UNKNOWN_SETTING_65535 = 123]"},
	}
	for i, tt := range tests {
		got := fmt.Sprint(tt.s)
		if got != tt.want {
			t.Errorf("%d. for %#v, string = %q; want %q", i, tt.s, got, tt.want)
		}
	}
}
type twriter struct {
	t  testing.TB
	st *serverTester 
}
func (w twriter) Write(p []byte) (n int, err error) {
	if w.st != nil {
		ps := string(p)
		for _, phrase := range w.st.logFilter {
			if strings.Contains(ps, phrase) {
				return len(p), nil 
			}
		}
	}
	w.t.Logf("%s", p)
	return len(p), nil
}
func encodeHeaderNoImplicit(t *testing.T, headers ...string) []byte {
	var buf bytes.Buffer
	enc := hpack.NewEncoder(&buf)
	for len(headers) > 0 {
		k, v := headers[0], headers[1]
		headers = headers[2:]
		if err := enc.WriteField(hpack.HeaderField{Name: k, Value: v}); err != nil {
			t.Fatalf("HPACK encoding error for %q
		}
	}
	return buf.Bytes()
}
func requireCurl(t *testing.T) {
	out, err := dockerLogs(curl(t, "--version"))
	if err != nil {
		t.Skipf("failed to determine curl features; skipping test")
	}
	if !strings.Contains(string(out), "HTTP2") {
		t.Skip("curl doesn't support HTTP2; skipping test")
	}
}
func curl(t *testing.T, args ...string) (container string) {
	out, err := exec.Command("docker", append([]string{"run", "-d", "--net=host", "gohttp2
	if err != nil {
		t.Skipf("Failed to run curl in docker: %v, %s", err, out)
	}
	return strings.TrimSpace(string(out))
}
func requireH2load(t *testing.T) {
	out, err := dockerLogs(h2load(t, "--version"))
	if err != nil {
		t.Skipf("failed to probe h2load; skipping test: %s", out)
	}
	if !strings.Contains(string(out), "h2load nghttp2
		t.Skipf("h2load not present; skipping test. (Output=%q)", out)
	}
}
func h2load(t *testing.T, args ...string) (container string) {
	out, err := exec.Command("docker", append([]string{"run", "-d", "--net=host", "--entrypoint=
	if err != nil {
		t.Skipf("Failed to run h2load in docker: %v, %s", err, out)
	}
	return strings.TrimSpace(string(out))
}
type puppetCommand struct {
	fn   func(w http.ResponseWriter, r *http.Request)
	done chan<- bool
}
type handlerPuppet struct {
	ch chan puppetCommand
}
func newHandlerPuppet() *handlerPuppet {
	return &handlerPuppet{
		ch: make(chan puppetCommand),
	}
}
func (p *handlerPuppet) act(w http.ResponseWriter, r *http.Request) {
	for cmd := range p.ch {
		cmd.fn(w, r)
		cmd.done <- true
	}
}
func (p *handlerPuppet) done() { close(p.ch) }
func (p *handlerPuppet) do(fn func(http.ResponseWriter, *http.Request)) {
	done := make(chan bool)
	p.ch <- puppetCommand{fn, done}
	<-done
}
func dockerLogs(container string) ([]byte, error) {
	out, err := exec.Command("docker", "wait", container).CombinedOutput()
	if err != nil {
		return out, err
	}
	exitStatus, err := strconv.Atoi(strings.TrimSpace(string(out)))
	if err != nil {
		return out, errors.New("unexpected exit status from docker wait")
	}
	out, err = exec.Command("docker", "logs", container).CombinedOutput()
	exec.Command("docker", "rm", container).Run()
	if err == nil && exitStatus != 0 {
		err = fmt.Errorf("exit status %d: %s", exitStatus, out)
	}
	return out, err
}
func kill(container string) {
	exec.Command("docker", "kill", container).Run()
	exec.Command("docker", "rm", container).Run()
}
func cleanDate(res *http.Response) {
	if d := res.Header["Date"]; len(d) == 1 {
		d[0] = "XXX"
	}
}
func TestSorterPoolAllocs(t *testing.T) {
	ss := []string{"a", "b", "c"}
	h := http.Header{
		"a": nil,
		"b": nil,
		"c": nil,
	}
	sorter := new(sorter)
	if allocs := testing.AllocsPerRun(100, func() {
		sorter.SortStrings(ss)
	}); allocs >= 1 {
		t.Logf("SortStrings allocs = %v; want <1", allocs)
	}
	if allocs := testing.AllocsPerRun(5, func() {
		if len(sorter.Keys(h)) != 3 {
			t.Fatal("wrong result")
		}
	}); allocs > 0 {
		t.Logf("Keys allocs = %v; want <1", allocs)
	}
}
package http2
import (
	"bytes"
	"fmt"
	"sort"
	"testing"
)
func defaultPriorityWriteScheduler() *priorityWriteScheduler {
	return NewPriorityWriteScheduler(nil).(*priorityWriteScheduler)
}
func checkPriorityWellFormed(ws *priorityWriteScheduler) error {
	for id, n := range ws.nodes {
		if id != n.id {
			return fmt.Errorf("bad ws.nodes: ws.nodes[%d] = %d", id, n.id)
		}
		if n.parent == nil {
			if n.next != nil || n.prev != nil {
				return fmt.Errorf("bad node %d: nil parent but prev
			}
			continue
		}
		found := false
		for k := n.parent.kids; k != nil; k = k.next {
			if k.id == id {
				found = true
				break
			}
		}
		if !found {
			return fmt.Errorf("bad node %d: not found in parent %d kids list", id, n.parent.id)
		}
	}
	return nil
}
func fmtTree(ws *priorityWriteScheduler, fmtNode func(*priorityNode) string) string {
	var ids []int
	for _, n := range ws.nodes {
		ids = append(ids, int(n.id))
	}
	sort.Ints(ids)
	var buf bytes.Buffer
	for _, id := range ids {
		if buf.Len() != 0 {
			buf.WriteString(" ")
		}
		if id == 0 {
			buf.WriteString(fmtNode(&ws.root))
		} else {
			buf.WriteString(fmtNode(ws.nodes[uint32(id)]))
		}
	}
	return buf.String()
}
func fmtNodeParentSkipRoot(n *priorityNode) string {
	switch {
	case n.id == 0:
		return ""
	case n.parent == nil:
		return fmt.Sprintf("%d{parent:nil}", n.id)
	default:
		return fmt.Sprintf("%d{parent:%d}", n.id, n.parent.id)
	}
}
func fmtNodeWeightParentSkipRoot(n *priorityNode) string {
	switch {
	case n.id == 0:
		return ""
	case n.parent == nil:
		return fmt.Sprintf("%d{weight:%d,parent:nil}", n.id, n.weight)
	default:
		return fmt.Sprintf("%d{weight:%d,parent:%d}", n.id, n.weight, n.parent.id)
	}
}
func TestPriorityTwoStreams(t *testing.T) {
	ws := defaultPriorityWriteScheduler()
	ws.OpenStream(1, OpenStreamOptions{})
	ws.OpenStream(2, OpenStreamOptions{})
	want := "1{weight:15,parent:0} 2{weight:15,parent:0}"
	if got := fmtTree(ws, fmtNodeWeightParentSkipRoot); got != want {
		t.Errorf("After open\ngot  %q\nwant %q", got, want)
	}
	
	ws.AdjustStream(1, PriorityParam{
		StreamDep: 2,
		Weight:    32,
		Exclusive: false,
	})
	want = "1{weight:32,parent:2} 2{weight:15,parent:0}"
	if got := fmtTree(ws, fmtNodeWeightParentSkipRoot); got != want {
		t.Errorf("After adjust\ngot  %q\nwant %q", got, want)
	}
	if err := checkPriorityWellFormed(ws); err != nil {
		t.Error(err)
	}
}
func TestPriorityAdjustExclusiveZero(t *testing.T) {
	
	
	
	ws := defaultPriorityWriteScheduler()
	ws.OpenStream(1, OpenStreamOptions{})
	ws.OpenStream(2, OpenStreamOptions{})
	ws.OpenStream(3, OpenStreamOptions{})
	want := "1{weight:15,parent:0} 2{weight:15,parent:0} 3{weight:15,parent:0}"
	if got := fmtTree(ws, fmtNodeWeightParentSkipRoot); got != want {
		t.Errorf("After open\ngot  %q\nwant %q", got, want)
	}
	ws.AdjustStream(2, PriorityParam{
		StreamDep: 0,
		Weight:    20,
		Exclusive: true,
	})
	want = "1{weight:15,parent:2} 2{weight:20,parent:0} 3{weight:15,parent:2}"
	if got := fmtTree(ws, fmtNodeWeightParentSkipRoot); got != want {
		t.Errorf("After adjust\ngot  %q\nwant %q", got, want)
	}
	if err := checkPriorityWellFormed(ws); err != nil {
		t.Error(err)
	}
}
func TestPriorityAdjustOwnParent(t *testing.T) {
	
	ws := defaultPriorityWriteScheduler()
	ws.OpenStream(1, OpenStreamOptions{})
	ws.OpenStream(2, OpenStreamOptions{})
	ws.AdjustStream(2, PriorityParam{
		StreamDep: 2,
		Weight:    20,
		Exclusive: true,
	})
	want := "1{weight:15,parent:0} 2{weight:15,parent:0}"
	if got := fmtTree(ws, fmtNodeWeightParentSkipRoot); got != want {
		t.Errorf("After adjust\ngot  %q\nwant %q", got, want)
	}
	if err := checkPriorityWellFormed(ws); err != nil {
		t.Error(err)
	}
}
func TestPriorityClosedStreams(t *testing.T) {
	ws := NewPriorityWriteScheduler(&PriorityWriteSchedulerConfig{MaxClosedNodesInTree: 2}).(*priorityWriteScheduler)
	ws.OpenStream(1, OpenStreamOptions{})
	ws.OpenStream(2, OpenStreamOptions{PusherID: 1})
	ws.OpenStream(3, OpenStreamOptions{PusherID: 2})
	ws.OpenStream(4, OpenStreamOptions{PusherID: 3})
	
	ws.CloseStream(1)
	ws.CloseStream(2)
	ws.CloseStream(3)
	want := "2{weight:15,parent:0} 3{weight:15,parent:2} 4{weight:15,parent:3}"
	if got := fmtTree(ws, fmtNodeWeightParentSkipRoot); got != want {
		t.Errorf("After close\ngot  %q\nwant %q", got, want)
	}
	if err := checkPriorityWellFormed(ws); err != nil {
		t.Error(err)
	}
	
	
	ws.OpenStream(5, OpenStreamOptions{})
	ws.AdjustStream(5, PriorityParam{StreamDep: 1, Weight: 15, Exclusive: true})
	
	ws.OpenStream(6, OpenStreamOptions{})
	ws.AdjustStream(6, PriorityParam{StreamDep: 2, Weight: 15, Exclusive: true})
	want = "2{weight:15,parent:0} 3{weight:15,parent:6} 4{weight:15,parent:3} 5{weight:15,parent:0} 6{weight:15,parent:2}"
	if got := fmtTree(ws, fmtNodeWeightParentSkipRoot); got != want {
		t.Errorf("After add streams\ngot  %q\nwant %q", got, want)
	}
	if err := checkPriorityWellFormed(ws); err != nil {
		t.Error(err)
	}
}
func TestPriorityClosedStreamsDisabled(t *testing.T) {
	ws := NewPriorityWriteScheduler(&PriorityWriteSchedulerConfig{}).(*priorityWriteScheduler)
	ws.OpenStream(1, OpenStreamOptions{})
	ws.OpenStream(2, OpenStreamOptions{PusherID: 1})
	ws.OpenStream(3, OpenStreamOptions{PusherID: 2})
	
	ws.CloseStream(1)
	ws.CloseStream(2)
	want := "3{weight:15,parent:0}"
	if got := fmtTree(ws, fmtNodeWeightParentSkipRoot); got != want {
		t.Errorf("After close\ngot  %q\nwant %q", got, want)
	}
	if err := checkPriorityWellFormed(ws); err != nil {
		t.Error(err)
	}
}
func TestPriorityIdleStreams(t *testing.T) {
	ws := NewPriorityWriteScheduler(&PriorityWriteSchedulerConfig{MaxIdleNodesInTree: 2}).(*priorityWriteScheduler)
	ws.AdjustStream(1, PriorityParam{StreamDep: 0, Weight: 15}) 
	ws.AdjustStream(2, PriorityParam{StreamDep: 0, Weight: 15}) 
	ws.AdjustStream(3, PriorityParam{StreamDep: 2, Weight: 20}) 
	ws.OpenStream(4, OpenStreamOptions{})
	ws.OpenStream(5, OpenStreamOptions{})
	ws.OpenStream(6, OpenStreamOptions{})
	ws.AdjustStream(4, PriorityParam{StreamDep: 1, Weight: 15})
	ws.AdjustStream(5, PriorityParam{StreamDep: 2, Weight: 15})
	ws.AdjustStream(6, PriorityParam{StreamDep: 3, Weight: 15})
	want := "2{weight:15,parent:0} 3{weight:20,parent:2} 4{weight:15,parent:0} 5{weight:15,parent:2} 6{weight:15,parent:3}"
	if got := fmtTree(ws, fmtNodeWeightParentSkipRoot); got != want {
		t.Errorf("After open\ngot  %q\nwant %q", got, want)
	}
	if err := checkPriorityWellFormed(ws); err != nil {
		t.Error(err)
	}
}
func TestPriorityIdleStreamsDisabled(t *testing.T) {
	ws := NewPriorityWriteScheduler(&PriorityWriteSchedulerConfig{}).(*priorityWriteScheduler)
	ws.AdjustStream(1, PriorityParam{StreamDep: 0, Weight: 15}) 
	ws.AdjustStream(2, PriorityParam{StreamDep: 0, Weight: 15}) 
	ws.AdjustStream(3, PriorityParam{StreamDep: 2, Weight: 20}) 
	ws.OpenStream(4, OpenStreamOptions{})
	want := "4{weight:15,parent:0}"
	if got := fmtTree(ws, fmtNodeWeightParentSkipRoot); got != want {
		t.Errorf("After open\ngot  %q\nwant %q", got, want)
	}
	if err := checkPriorityWellFormed(ws); err != nil {
		t.Error(err)
	}
}
func TestPrioritySection531NonExclusive(t *testing.T) {
	
	
	ws := defaultPriorityWriteScheduler()
	ws.OpenStream(1, OpenStreamOptions{})
	ws.OpenStream(2, OpenStreamOptions{PusherID: 1})
	ws.OpenStream(3, OpenStreamOptions{PusherID: 1})
	ws.OpenStream(4, OpenStreamOptions{})
	ws.AdjustStream(4, PriorityParam{
		StreamDep: 1,
		Weight:    15,
		Exclusive: false,
	})
	want := "1{parent:0} 2{parent:1} 3{parent:1} 4{parent:1}"
	if got := fmtTree(ws, fmtNodeParentSkipRoot); got != want {
		t.Errorf("After adjust\ngot  %q\nwant %q", got, want)
	}
	if err := checkPriorityWellFormed(ws); err != nil {
		t.Error(err)
	}
}
func TestPrioritySection531Exclusive(t *testing.T) {
	
	
	ws := defaultPriorityWriteScheduler()
	ws.OpenStream(1, OpenStreamOptions{})
	ws.OpenStream(2, OpenStreamOptions{PusherID: 1})
	ws.OpenStream(3, OpenStreamOptions{PusherID: 1})
	ws.OpenStream(4, OpenStreamOptions{})
	ws.AdjustStream(4, PriorityParam{
		StreamDep: 1,
		Weight:    15,
		Exclusive: true,
	})
	want := "1{parent:0} 2{parent:4} 3{parent:4} 4{parent:1}"
	if got := fmtTree(ws, fmtNodeParentSkipRoot); got != want {
		t.Errorf("After adjust\ngot  %q\nwant %q", got, want)
	}
	if err := checkPriorityWellFormed(ws); err != nil {
		t.Error(err)
	}
}
func makeSection533Tree() *priorityWriteScheduler {
	
	
	ws := defaultPriorityWriteScheduler()
	ws.OpenStream(1, OpenStreamOptions{})
	ws.OpenStream(2, OpenStreamOptions{PusherID: 1})
	ws.OpenStream(3, OpenStreamOptions{PusherID: 1})
	ws.OpenStream(4, OpenStreamOptions{PusherID: 3})
	ws.OpenStream(5, OpenStreamOptions{PusherID: 3})
	ws.OpenStream(6, OpenStreamOptions{PusherID: 4})
	return ws
}
func TestPrioritySection533NonExclusive(t *testing.T) {
	
	
	ws := defaultPriorityWriteScheduler()
	ws.OpenStream(1, OpenStreamOptions{})
	ws.OpenStream(2, OpenStreamOptions{PusherID: 1})
	ws.OpenStream(3, OpenStreamOptions{PusherID: 1})
	ws.OpenStream(4, OpenStreamOptions{PusherID: 3})
	ws.OpenStream(5, OpenStreamOptions{PusherID: 3})
	ws.OpenStream(6, OpenStreamOptions{PusherID: 4})
	ws.AdjustStream(1, PriorityParam{
		StreamDep: 4,
		Weight:    15,
		Exclusive: false,
	})
	want := "1{parent:4} 2{parent:1} 3{parent:1} 4{parent:0} 5{parent:3} 6{parent:4}"
	if got := fmtTree(ws, fmtNodeParentSkipRoot); got != want {
		t.Errorf("After adjust\ngot  %q\nwant %q", got, want)
	}
	if err := checkPriorityWellFormed(ws); err != nil {
		t.Error(err)
	}
}
func TestPrioritySection533Exclusive(t *testing.T) {
	
	
	ws := defaultPriorityWriteScheduler()
	ws.OpenStream(1, OpenStreamOptions{})
	ws.OpenStream(2, OpenStreamOptions{PusherID: 1})
	ws.OpenStream(3, OpenStreamOptions{PusherID: 1})
	ws.OpenStream(4, OpenStreamOptions{PusherID: 3})
	ws.OpenStream(5, OpenStreamOptions{PusherID: 3})
	ws.OpenStream(6, OpenStreamOptions{PusherID: 4})
	ws.AdjustStream(1, PriorityParam{
		StreamDep: 4,
		Weight:    15,
		Exclusive: true,
	})
	want := "1{parent:4} 2{parent:1} 3{parent:1} 4{parent:0} 5{parent:3} 6{parent:1}"
	if got := fmtTree(ws, fmtNodeParentSkipRoot); got != want {
		t.Errorf("After adjust\ngot  %q\nwant %q", got, want)
	}
	if err := checkPriorityWellFormed(ws); err != nil {
		t.Error(err)
	}
}
func checkPopAll(ws WriteScheduler, order []uint32) error {
	for k, id := range order {
		wr, ok := ws.Pop()
		if !ok {
			return fmt.Errorf("Pop[%d]: got ok=false, want %d (order=%v)", k, id, order)
		}
		if got := wr.StreamID(); got != id {
			return fmt.Errorf("Pop[%d]: got %v, want %d (order=%v)", k, got, id, order)
		}
	}
	wr, ok := ws.Pop()
	if ok {
		return fmt.Errorf("Pop[%d]: got %v, want ok=false (order=%v)", len(order), wr.StreamID(), order)
	}
	return nil
}
func TestPriorityPopFrom533Tree(t *testing.T) {
	ws := makeSection533Tree()
	ws.Push(makeWriteHeadersRequest(3 
	ws.Push(makeWriteNonStreamRequest())
	ws.Push(makeWriteHeadersRequest(5 
	ws.Push(makeWriteHeadersRequest(1 
	t.Log("tree:", fmtTree(ws, fmtNodeParentSkipRoot))
	if err := checkPopAll(ws, []uint32{0 
		t.Error(err)
	}
}
func TestPriorityPopFromLinearTree(t *testing.T) {
	ws := defaultPriorityWriteScheduler()
	ws.OpenStream(1, OpenStreamOptions{})
	ws.OpenStream(2, OpenStreamOptions{PusherID: 1})
	ws.OpenStream(3, OpenStreamOptions{PusherID: 2})
	ws.OpenStream(4, OpenStreamOptions{PusherID: 3})
	ws.Push(makeWriteHeadersRequest(3))
	ws.Push(makeWriteHeadersRequest(4))
	ws.Push(makeWriteHeadersRequest(1))
	ws.Push(makeWriteHeadersRequest(2))
	ws.Push(makeWriteNonStreamRequest())
	ws.Push(makeWriteNonStreamRequest())
	t.Log("tree:", fmtTree(ws, fmtNodeParentSkipRoot))
	if err := checkPopAll(ws, []uint32{0, 0 
		t.Error(err)
	}
}
func TestPriorityFlowControl(t *testing.T) {
	ws := NewPriorityWriteScheduler(&PriorityWriteSchedulerConfig{ThrottleOutOfOrderWrites: false})
	ws.OpenStream(1, OpenStreamOptions{})
	ws.OpenStream(2, OpenStreamOptions{PusherID: 1})
	sc := &serverConn{maxFrameSize: 16}
	st1 := &stream{id: 1, sc: sc}
	st2 := &stream{id: 2, sc: sc}
	ws.Push(FrameWriteRequest{&writeData{1, make([]byte, 16), false}, st1, nil})
	ws.Push(FrameWriteRequest{&writeData{2, make([]byte, 16), false}, st2, nil})
	ws.AdjustStream(2, PriorityParam{StreamDep: 1})
	
	if wr, ok := ws.Pop(); ok {
		t.Fatalf("Pop(limited by flow control)=%v,true, want false", wr)
	}
	
	
	for i := 1; i <= 2; i++ {
		st2.flow.add(8)
		wr, ok := ws.Pop()
		if !ok {
			t.Fatalf("Pop(%d)=false, want true", i)
		}
		if got, want := wr.DataSize(), 8; got != want {
			t.Fatalf("Pop(%d)=%d bytes, want %d bytes", i, got, want)
		}
	}
}
func TestPriorityThrottleOutOfOrderWrites(t *testing.T) {
	ws := NewPriorityWriteScheduler(&PriorityWriteSchedulerConfig{ThrottleOutOfOrderWrites: true})
	ws.OpenStream(1, OpenStreamOptions{})
	ws.OpenStream(2, OpenStreamOptions{PusherID: 1})
	sc := &serverConn{maxFrameSize: 4096}
	st1 := &stream{id: 1, sc: sc}
	st2 := &stream{id: 2, sc: sc}
	st1.flow.add(4096)
	st2.flow.add(4096)
	ws.Push(FrameWriteRequest{&writeData{2, make([]byte, 4096), false}, st2, nil})
	ws.AdjustStream(2, PriorityParam{StreamDep: 1})
	
	
	
	wr, ok := ws.Pop()
	if !ok {
		t.Fatalf("Pop(st2.first)=false, want true")
	}
	if got, want := wr.StreamID(), uint32(2); got != want {
		t.Fatalf("Pop(st2.first)=stream %d, want stream %d", got, want)
	}
	if got, want := wr.DataSize(), 1024; got != want {
		t.Fatalf("Pop(st2.first)=%d bytes, want %d bytes", got, want)
	}
	
	ws.Push(FrameWriteRequest{&writeData{1, make([]byte, 4096), false}, st1, nil})
	wr, ok = ws.Pop()
	if !ok {
		t.Fatalf("Pop(st1)=false, want true")
	}
	if got, want := wr.StreamID(), uint32(1); got != want {
		t.Fatalf("Pop(st1)=stream %d, want stream %d", got, want)
	}
	if got, want := wr.DataSize(), 4096; got != want {
		t.Fatalf("Pop(st1)=%d bytes, want %d bytes", got, want)
	}
	
	wr, ok = ws.Pop()
	if !ok {
		t.Fatalf("Pop(st2.last)=false, want true")
	}
	if got, want := wr.StreamID(), uint32(2); got != want {
		t.Fatalf("Pop(st2.last)=stream %d, want stream %d", got, want)
	}
	if got, want := wr.DataSize(), 1024; got != want {
		t.Fatalf("Pop(st2.last)=%d bytes, want %d bytes", got, want)
	}
}
func TestPriorityWeights(t *testing.T) {
	ws := defaultPriorityWriteScheduler()
	ws.OpenStream(1, OpenStreamOptions{})
	ws.OpenStream(2, OpenStreamOptions{})
	sc := &serverConn{maxFrameSize: 8}
	st1 := &stream{id: 1, sc: sc}
	st2 := &stream{id: 2, sc: sc}
	st1.flow.add(40)
	st2.flow.add(40)
	ws.Push(FrameWriteRequest{&writeData{1, make([]byte, 40), false}, st1, nil})
	ws.Push(FrameWriteRequest{&writeData{2, make([]byte, 40), false}, st2, nil})
	ws.AdjustStream(1, PriorityParam{StreamDep: 0, Weight: 34})
	ws.AdjustStream(2, PriorityParam{StreamDep: 0, Weight: 9})
	
	
	
	
	
	
	
	
	
	
	
	
	if err := checkPopAll(ws, []uint32{1, 2, 1, 1, 1, 2, 1, 2, 2, 2}); err != nil {
		t.Error(err)
	}
}
func TestPriorityRstStreamOnNonOpenStreams(t *testing.T) {
	ws := NewPriorityWriteScheduler(&PriorityWriteSchedulerConfig{
		MaxClosedNodesInTree: 0,
		MaxIdleNodesInTree:   0,
	})
	ws.OpenStream(1, OpenStreamOptions{})
	ws.CloseStream(1)
	ws.Push(FrameWriteRequest{write: streamError(1, ErrCodeProtocol)})
	ws.Push(FrameWriteRequest{write: streamError(2, ErrCodeProtocol)})
	if err := checkPopAll(ws, []uint32{1, 2}); err != nil {
		t.Error(err)
	}
}
package main
import (
	"bufio"
	"bytes"
	"encoding
	"flag"
	"fmt"
	"io"
	"io
	"log"
	"net
	"os"
	"strings"
	"time"
	"golang.org
	"golang.org
	compute "google.golang.org
)
var (
	proj     = flag.String("project", "symbolic-datum-552", "name of Project")
	zone     = flag.String("zone", "us-central1-a", "GCE zone")
	mach     = flag.String("machinetype", "n1-standard-1", "Machine type")
	instName = flag.String("instance_name", "http2-demo", "Name of VM instance.")
	sshPub   = flag.String("ssh_public_key", "", "ssh public key file to authorize. Can modify later in Google's web UI anyway.")
	staticIP = flag.String("static_ip", "130.211.116.44", "Static IP to use. If empty, automatic.")
	writeObject  = flag.String("write_object", "", "If non-empty, a VM isn't created and the flag value is Google Cloud Storage bucket
	publicObject = flag.Bool("write_object_is_public", false, "Whether the object created by --write_object should be public.")
)
func readFile(v string) string {
	slurp, err := ioutil.ReadFile(v)
	if err != nil {
		log.Fatalf("Error reading %s: %v", v, err)
	}
	return strings.TrimSpace(string(slurp))
}
var config = &oauth2.Config{
	
	
	ClientID:     readFile("client-id.dat"),
	ClientSecret: readFile("client-secret.dat"),
	Endpoint:     google.Endpoint,
	Scopes: []string{
		compute.DevstorageFullControlScope,
		compute.ComputeScope,
		"https:
		"https:
	},
	RedirectURL: "urn:ietf:wg:oauth:2.0:oob",
}
const baseConfig = `#cloud-config
coreos:
  units:
    - name: h2demo.service
      command: start
      content: |
        [Unit]
        Description=HTTP2 Demo
        
        [Service]
        ExecStartPre=
        ExecStart=
        RestartSec=5s
        Restart=always
        Type=simple
        
        [Install]
        WantedBy=multi-user.target
`
func main() {
	flag.Parse()
	if *proj == "" {
		log.Fatalf("Missing --project flag")
	}
	prefix := "https:
	machType := prefix + "
	const tokenFileName = "token.dat"
	tokenFile := tokenCacheFile(tokenFileName)
	tokenSource := oauth2.ReuseTokenSource(nil, tokenFile)
	token, err := tokenSource.Token()
	if err != nil {
		if *writeObject != "" {
			log.Fatalf("Can't use --write_object without a valid token.dat file already cached.")
		}
		log.Printf("Error getting token from %s: %v", tokenFileName, err)
		log.Printf("Get auth code from %v", config.AuthCodeURL("my-state"))
		fmt.Print("\nEnter auth code: ")
		sc := bufio.NewScanner(os.Stdin)
		sc.Scan()
		authCode := strings.TrimSpace(sc.Text())
		token, err = config.Exchange(oauth2.NoContext, authCode)
		if err != nil {
			log.Fatalf("Error exchanging auth code for a token: %v", err)
		}
		if err := tokenFile.WriteToken(token); err != nil {
			log.Fatalf("Error writing to %s: %v", tokenFileName, err)
		}
		tokenSource = oauth2.ReuseTokenSource(token, nil)
	}
	oauthClient := oauth2.NewClient(oauth2.NoContext, tokenSource)
	if *writeObject != "" {
		writeCloudStorageObject(oauthClient)
		return
	}
	computeService, _ := compute.New(oauthClient)
	natIP := *staticIP
	if natIP == "" {
		
		aggAddrList, err := computeService.Addresses.AggregatedList(*proj).Do()
		if err != nil {
			log.Fatal(err)
		}
		
	IPLoop:
		for _, asl := range aggAddrList.Items {
			for _, addr := range asl.Addresses {
				if addr.Name == *instName+"-ip" && addr.Status == "RESERVED" {
					natIP = addr.Address
					break IPLoop
				}
			}
		}
	}
	cloudConfig := baseConfig
	if *sshPub != "" {
		key := strings.TrimSpace(readFile(*sshPub))
		cloudConfig += fmt.Sprintf("\nssh_authorized_keys:\n    - %s\n", key)
	}
	if os.Getenv("USER") == "bradfitz" {
		cloudConfig += fmt.Sprintf("\nssh_authorized_keys:\n    - %s\n", "ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAIEAwks9dwWKlRC+73gRbvYtVg0vdCwDSuIlyt4z6xa
	}
	const maxCloudConfig = 32 << 10 
	if len(cloudConfig) > maxCloudConfig {
		log.Fatalf("cloud config length of %d bytes is over %d byte limit", len(cloudConfig), maxCloudConfig)
	}
	instance := &compute.Instance{
		Name:        *instName,
		Description: "Go Builder",
		MachineType: machType,
		Disks:       []*compute.AttachedDisk{instanceDisk(computeService)},
		Tags: &compute.Tags{
			Items: []string{"http-server", "https-server"},
		},
		Metadata: &compute.Metadata{
			Items: []*compute.MetadataItems{
				{
					Key:   "user-data",
					Value: &cloudConfig,
				},
			},
		},
		NetworkInterfaces: []*compute.NetworkInterface{
			{
				AccessConfigs: []*compute.AccessConfig{
					{
						Type:  "ONE_TO_ONE_NAT",
						Name:  "External NAT",
						NatIP: natIP,
					},
				},
				Network: prefix + "
			},
		},
		ServiceAccounts: []*compute.ServiceAccount{
			{
				Email: "default",
				Scopes: []string{
					compute.DevstorageFullControlScope,
					compute.ComputeScope,
				},
			},
		},
	}
	log.Printf("Creating instance...")
	op, err := computeService.Instances.Insert(*proj, *zone, instance).Do()
	if err != nil {
		log.Fatalf("Failed to create instance: %v", err)
	}
	opName := op.Name
	log.Printf("Created. Waiting on operation %v", opName)
OpLoop:
	for {
		time.Sleep(2 * time.Second)
		op, err := computeService.ZoneOperations.Get(*proj, *zone, opName).Do()
		if err != nil {
			log.Fatalf("Failed to get op %s: %v", opName, err)
		}
		switch op.Status {
		case "PENDING", "RUNNING":
			log.Printf("Waiting on operation %v", opName)
			continue
		case "DONE":
			if op.Error != nil {
				for _, operr := range op.Error.Errors {
					log.Printf("Error: %+v", operr)
				}
				log.Fatalf("Failed to start.")
			}
			log.Printf("Success. %+v", op)
			break OpLoop
		default:
			log.Fatalf("Unknown status %q: %+v", op.Status, op)
		}
	}
	inst, err := computeService.Instances.Get(*proj, *zone, *instName).Do()
	if err != nil {
		log.Fatalf("Error getting instance after creation: %v", err)
	}
	ij, _ := json.MarshalIndent(inst, "", "    ")
	log.Printf("Instance: %s", ij)
}
func instanceDisk(svc *compute.Service) *compute.AttachedDisk {
	const imageURL = "https:
	diskName := *instName + "-disk"
	return &compute.AttachedDisk{
		AutoDelete: true,
		Boot:       true,
		Type:       "PERSISTENT",
		InitializeParams: &compute.AttachedDiskInitializeParams{
			DiskName:    diskName,
			SourceImage: imageURL,
			DiskSizeGb:  50,
		},
	}
}
func writeCloudStorageObject(httpClient *http.Client) {
	content := os.Stdin
	const maxSlurp = 1 << 20
	var buf bytes.Buffer
	n, err := io.CopyN(&buf, content, maxSlurp)
	if err != nil && err != io.EOF {
		log.Fatalf("Error reading from stdin: %v, %v", n, err)
	}
	contentType := http.DetectContentType(buf.Bytes())
	req, err := http.NewRequest("PUT", "https:
	if err != nil {
		log.Fatal(err)
	}
	req.Header.Set("x-goog-api-version", "2")
	if *publicObject {
		req.Header.Set("x-goog-acl", "public-read")
	}
	req.Header.Set("Content-Type", contentType)
	res, err := httpClient.Do(req)
	if err != nil {
		log.Fatal(err)
	}
	if res.StatusCode != 200 {
		res.Write(os.Stderr)
		log.Fatalf("Failed.")
	}
	log.Printf("Success.")
	os.Exit(0)
}
type tokenCacheFile string
func (f tokenCacheFile) Token() (*oauth2.Token, error) {
	slurp, err := ioutil.ReadFile(string(f))
	if err != nil {
		return nil, err
	}
	t := new(oauth2.Token)
	if err := json.Unmarshal(slurp, t); err != nil {
		return nil, err
	}
	return t, nil
}
func (f tokenCacheFile) WriteToken(t *oauth2.Token) error {
	jt, err := json.Marshal(t)
	if err != nil {
		return err
	}
	return ioutil.WriteFile(string(f), jt, 0600)
}
package main
import "html
var pushTmpl = template.Must(template.New("serverpush").Parse(`
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">
  <title>HTTP
<link type="text
<script>
window.initFuncs = [];
<
<script>
function showtimes() {
	var times = 'DOM loaded: ' + (window.performance.timing.domContentLoadedEventEnd - window.performance.timing.navigationStart) + 'ms, '
	times += 'DOM complete (all loaded): ' + (window.performance.timing.domComplete - window.performance.timing.navigationStart) + 'ms, '
	times += 'Load event fired: ' + (window.performance.timing.loadEventStart - window.performance.timing.navigationStart) + 'ms'
	document.getElementById('loadtimes').innerHTML = times
}
<
<
<body onload="showtimes()">
<div style="background:#fff9a4;padding:10px">
Note: This page exists for demonstration purposes. For the actual cmd
<
<div style="padding:20px">
<a href="https:
<div id="loadtimes"><
<
<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
<
<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="
<div class="top-heading" id="heading-narrow"><a href="
<a href="#" id="menu-button"><span id="menu-button-arrow">&#9661;<
<form method="GET" action="
<div id="menu">
<a href="
<a href="
<a href="
<a href="
<a href="
<a id="playgroundButton" href="http:
<input type="text" id="search" name="q" class="inactive" value="Search" placeholder="Search">
<
<
<
<div id="playground" class="play">
	<div class="input"><textarea class="code" spellcheck="false">package main
import "fmt"
func main() {
	fmt.Println("Hello, 世界")
}<
	<div class="output"><
	<div class="buttons">
		<a class="run" title="Run this code [shift-enter]">Run<
		<a class="fmt" title="Format this code">Format<
		
		<a class="share" title="Share this code">Share<
		
	<
<
<div id="page" class="wide">
<div class="container">
  <h1>Command go<
<div id="nav"><
<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->
	<script type='text
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	<
	
		
		<p>
Go is a tool for managing Go source code.
<
<p>
Usage:
<
<pre>go command [arguments]
<
<p>
The commands are:
<
<pre>build       compile packages and dependencies
clean       remove object files
doc         show documentation for package or symbol
env         print Go environment information
bug         start a bug report
fix         run go tool fix on packages
fmt         run gofmt on package sources
generate    generate Go files by processing source
get         download and install packages and dependencies
install     compile and install packages and dependencies
list        list packages
run         compile and run Go program
test        test packages
tool        run specified go tool
version     print Go version
vet         run go tool vet on packages
<
<p>
Use &#34;go help [command]&#34; for more information about a command.
<
<p>
Additional help topics:
<
<pre>c           calling between Go and C
buildmode   description of build modes
filetype    file types
gopath      GOPATH environment variable
environment environment variables
importpath  import path syntax
packages    description of package lists
testflag    description of testing flags
testfunc    description of testing functions
<
<p>
Use &#34;go help [topic]&#34; for more information about that topic.
<
<h3 id="hdr-Compile_packages_and_dependencies">Compile packages and dependencies<
<p>
Usage:
<
<pre>go build [-o output] [-i] [build flags] [packages]
<
<p>
Build compiles the packages named by the import paths,
along with their dependencies, but it does not install the results.
<
<p>
If the arguments to build are a list of .go files, build treats
them as a list of source files specifying a single package.
<
<p>
When compiling a single main package, build writes
the resulting executable to an output file named after
the first source file (&#39;go build ed.go rx.go&#39; writes &#39;ed&#39; or &#39;ed.exe&#39;)
or the source code directory (&#39;go build unix
The &#39;.exe&#39; suffix is added when writing a Windows executable.
<
<p>
When compiling multiple packages or a single non-main package,
build compiles the packages but discards the resulting object,
serving only as a check that the packages can be built.
<
<p>
When compiling packages, build ignores files that end in &#39;_test.go&#39;.
<
<p>
The -o flag, only allowed when compiling a single package,
forces build to write the resulting executable or object
to the named output file, instead of the default behavior described
in the last two paragraphs.
<
<p>
The -i flag installs the packages that are dependencies of the target.
<
<p>
The build flags are shared by the build, clean, get, install, list, run,
and test commands:
<
<pre>-a
	force rebuilding of packages that are already up-to-date.
-n
	print the commands but do not run them.
-p n
	the number of programs, such as build commands or
	test binaries, that can be run in parallel.
	The default is the number of CPUs available.
-race
	enable data race detection.
	Supported only on linux
-msan
	enable interoperation with memory sanitizer.
	Supported only on linux
	and only with Clang
-v
	print the names of packages as they are compiled.
-work
	print the name of the temporary work directory and
	do not delete it when exiting.
-x
	print the commands.
-asmflags &#39;flag list&#39;
	arguments to pass on each go tool asm invocation.
-buildmode mode
	build mode to use. See &#39;go help buildmode&#39; for more.
-compiler name
	name of compiler to use, as in runtime.Compiler (gccgo or gc).
-gccgoflags &#39;arg list&#39;
	arguments to pass on each gccgo compiler
-gcflags &#39;arg list&#39;
	arguments to pass on each go tool compile invocation.
-installsuffix suffix
	a suffix to use in the name of the package installation directory,
	in order to keep output separate from default builds.
	If using the -race flag, the install suffix is automatically set to race
	or, if set explicitly, has _race appended to it.  Likewise for the -msan
	flag.  Using a -buildmode option that requires non-default compile flags
	has a similar effect.
-ldflags &#39;flag list&#39;
	arguments to pass on each go tool link invocation.
-linkshared
	link against shared libraries previously created with
	-buildmode=shared.
-pkgdir dir
	install and load all packages from dir instead of the usual locations.
	For example, when building with a non-standard configuration,
	use -pkgdir to keep generated packages in a separate location.
-tags &#39;tag list&#39;
	a list of build tags to consider satisfied during the build.
	For more information about build tags, see the description of
	build constraints in the documentation for the go
-toolexec &#39;cmd args&#39;
	a program to use to invoke toolchain programs like vet and asm.
	For example, instead of running asm, the go command will run
	&#39;cmd args 
<
<p>
The list flags accept a space-separated list of strings. To embed spaces
in an element in the list, surround it with either single or double quotes.
<
<p>
For more about specifying packages, see &#39;go help packages&#39;.
For more about where packages and binaries are installed,
run &#39;go help gopath&#39;.
For more about calling between Go and C
<
<p>
Note: Build adheres to certain conventions such as those described
by &#39;go help gopath&#39;. Not all projects can follow these conventions,
however. Installations that have their own conventions or that use
a separate software build system may choose to use lower-level
invocations such as &#39;go tool compile&#39; and &#39;go tool link&#39; to avoid
some of the overheads and design decisions of the build tool.
<
<p>
See also: go install, go get, go clean.
<
<h3 id="hdr-Remove_object_files">Remove object files<
<p>
Usage:
<
<pre>go clean [-i] [-r] [-n] [-x] [build flags] [packages]
<
<p>
Clean removes object files from package source directories.
The go command builds most objects in a temporary directory,
so go clean is mainly concerned with object files left by other
tools or by manual invocations of go build.
<
<p>
Specifically, clean removes the following files from each of the
source directories corresponding to the import paths:
<
<pre>_obj
_test
_testmain.go     old gotest file, left from Makefiles
test.out         old test log, left from Makefiles
build.out        old test log, left from Makefiles
*.[568ao]        object files, left from Makefiles
DIR(.exe)        from go build
DIR.test(.exe)   from go test -c
MAINFILE(.exe)   from go build MAINFILE.go
*.so             from SWIG
<
<p>
In the list, DIR represents the final path element of the
directory, and MAINFILE is the base name of any Go source
file in the directory that is not included when building
the package.
<
<p>
The -i flag causes clean to remove the corresponding installed
archive or binary (what &#39;go install&#39; would create).
<
<p>
The -n flag causes clean to print the remove commands it would execute,
but not run them.
<
<p>
The -r flag causes clean to be applied recursively to all the
dependencies of the packages named by the import paths.
<
<p>
The -x flag causes clean to print remove commands as it executes them.
<
<p>
For more about build flags, see &#39;go help build&#39;.
<
<p>
For more about specifying packages, see &#39;go help packages&#39;.
<
<h3 id="hdr-Show_documentation_for_package_or_symbol">Show documentation for package or symbol<
<p>
Usage:
<
<pre>go doc [-u] [-c] [package|[package.]symbol[.method]]
<
<p>
Doc prints the documentation comments associated with the item identified by its
arguments (a package, const, func, type, var, or method) followed by a one-line
summary of each of the first-level items &#34;under&#34; that item (package-level
declarations for a package, methods for a type, etc.).
<
<p>
Doc accepts zero, one, or two arguments.
<
<p>
Given no arguments, that is, when run as
<
<pre>go doc
<
<p>
it prints the package documentation for the package in the current directory.
If the package is a command (package main), the exported symbols of the package
are elided from the presentation unless the -cmd flag is provided.
<
<p>
When run with one argument, the argument is treated as a Go-syntax-like
representation of the item to be documented. What the argument selects depends
on what is installed in GOROOT and GOPATH, as well as the form of the argument,
which is schematically one of these:
<
<pre>go doc &lt;pkg&gt;
go doc &lt;sym&gt;[.&lt;method&gt;]
go doc [&lt;pkg&gt;.]&lt;sym&gt;[.&lt;method&gt;]
go doc [&lt;pkg&gt;.][&lt;sym&gt;.]&lt;method&gt;
<
<p>
The first item in this list matched by the argument is the one whose documentation
is printed. (See the examples below.) However, if the argument starts with a capital
letter it is assumed to identify a symbol or method in the current directory.
<
<p>
For packages, the order of scanning is determined lexically in breadth-first order.
That is, the package presented is the one that matches the search and is nearest
the root and lexically first at its level of the hierarchy.  The GOROOT tree is
always scanned in its entirety before GOPATH.
<
<p>
If there is no package specified or matched, the package in the current
directory is selected, so &#34;go doc Foo&#34; shows the documentation for symbol Foo in
the current package.
<
<p>
The package path must be either a qualified path or a proper suffix of a
path. The go tool&#39;s usual package mechanism does not apply: package path
elements like . and ... are not implemented by go doc.
<
<p>
When run with two arguments, the first must be a full package path (not just a
suffix), and the second is a symbol or symbol and method; this is similar to the
syntax accepted by godoc:
<
<pre>go doc &lt;pkg&gt; &lt;sym&gt;[.&lt;method&gt;]
<
<p>
In all forms, when matching symbols, lower-case letters in the argument match
either case but upper-case letters match exactly. This means that there may be
multiple matches of a lower-case argument in a package if different symbols have
different cases. If this occurs, documentation for all matches is printed.
<
<p>
Examples:
<
<pre>go doc
	Show documentation for current package.
go doc Foo
	Show documentation for Foo in the current package.
	(Foo starts with a capital letter so it cannot match
	a package path.)
go doc encoding
	Show documentation for the encoding
go doc json
	Shorthand for encoding
go doc json.Number (or go doc json.number)
	Show documentation and method summary for json.Number.
go doc json.Number.Int64 (or go doc json.number.int64)
	Show documentation for json.Number&#39;s Int64 method.
go doc cmd
	Show package docs for the doc command.
go doc -cmd cmd
	Show package docs and exported symbols within the doc command.
go doc template.new
	Show documentation for html
	(html
go doc text
	Show documentation for text
go doc text
	Show documentation for text
At least in the current tree, these invocations all print the
documentation for json.Decoder&#39;s Decode method:
go doc json.Decoder.Decode
go doc json.decoder.decode
go doc json.decode
cd go
<
<p>
Flags:
<
<pre>-c
	Respect case when matching symbols.
-cmd
	Treat a command (package main) like a regular package.
	Otherwise package main&#39;s exported symbols are hidden
	when showing the package&#39;s top-level documentation.
-u
	Show documentation for unexported as well as exported
	symbols and methods.
<
<h3 id="hdr-Print_Go_environment_information">Print Go environment information<
<p>
Usage:
<
<pre>go env [var ...]
<
<p>
Env prints Go environment information.
<
<p>
By default env prints information as a shell script
(on Windows, a batch file).  If one or more variable
names is given as arguments,  env prints the value of
each named variable on its own line.
<
<h3 id="hdr-Start_a_bug_report">Start a bug report<
<p>
Usage:
<
<pre>go bug
<
<p>
Bug opens the default browser and starts a new bug report.
The report includes useful system information.
<
<h3 id="hdr-Run_go_tool_fix_on_packages">Run go tool fix on packages<
<p>
Usage:
<
<pre>go fix [packages]
<
<p>
Fix runs the Go fix command on the packages named by the import paths.
<
<p>
For more about fix, see &#39;go doc cmd
For more about specifying packages, see &#39;go help packages&#39;.
<
<p>
To run fix with specific options, run &#39;go tool fix&#39;.
<
<p>
See also: go fmt, go vet.
<
<h3 id="hdr-Run_gofmt_on_package_sources">Run gofmt on package sources<
<p>
Usage:
<
<pre>go fmt [-n] [-x] [packages]
<
<p>
Fmt runs the command &#39;gofmt -l -w&#39; on the packages named
by the import paths.  It prints the names of the files that are modified.
<
<p>
For more about gofmt, see &#39;go doc cmd
For more about specifying packages, see &#39;go help packages&#39;.
<
<p>
The -n flag prints commands that would be executed.
The -x flag prints commands as they are executed.
<
<p>
To run gofmt with specific options, run gofmt itself.
<
<p>
See also: go fix, go vet.
<
<h3 id="hdr-Generate_Go_files_by_processing_source">Generate Go files by processing source<
<p>
Usage:
<
<pre>go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go... | packages]
<
<p>
Generate runs commands described by directives within existing
files. Those commands can run any process but the intent is to
create or update Go source files.
<
<p>
Go generate is never run automatically by go build, go get, go test,
and so on. It must be run explicitly.
<
<p>
Go generate scans the file for directives, which are lines of
the form,
<
<pre>
<
<p>
(note: no leading spaces and no space in &#34;
is the generator to be run, corresponding to an executable file
that can be run locally. It must either be in the shell path
(gofmt), a fully qualified path (
command alias, described below.
<
<p>
Note that go generate does not parse the file, so lines that look
like directives in comments or multiline strings will be treated
as directives.
<
<p>
The arguments to the directive are space-separated tokens or
double-quoted strings passed to the generator as individual
arguments when it is run.
<
<p>
Quoted strings use Go syntax and are evaluated before execution; a
quoted string appears as a single argument to the generator.
<
<p>
Go generate sets several variables when it runs the generator:
<
<pre>$GOARCH
	The execution architecture (arm, amd64, etc.)
$GOOS
	The execution operating system (linux, windows, etc.)
$GOFILE
	The base name of the file.
$GOLINE
	The line number of the directive in the source file.
$GOPACKAGE
	The name of the package of the file containing the directive.
$DOLLAR
	A dollar sign.
<
<p>
Other than variable substitution and quoted-string evaluation, no
special processing such as &#34;globbing&#34; is performed on the command
line.
<
<p>
As a last step before running the command, any invocations of any
environment variables with alphanumeric names, such as $GOFILE or
$HOME, are expanded throughout the command line. The syntax for
variable expansion is $NAME on all operating systems.  Due to the
order of evaluation, variables are expanded even inside quoted
strings. If the variable NAME is not set, $NAME expands to the
empty string.
<
<p>
A directive of the form,
<
<pre>
<
<p>
specifies, for the remainder of this source file only, that the
string xxx represents the command identified by the arguments. This
can be used to create aliases or to handle multiword generators.
For example,
<
<pre>
<
<p>
specifies that the command &#34;foo&#34; represents the generator
&#34;go tool foo&#34;.
<
<p>
Generate processes packages in the order given on the command line,
one at a time. If the command line lists .go files, they are treated
as a single package. Within a package, generate processes the
source files in a package in file name order, one at a time. Within
a source file, generate runs generators in the order they appear
in the file, one at a time.
<
<p>
If any generator returns an error exit status, &#34;go generate&#34; skips
all further processing for that package.
<
<p>
The generator is run in the package&#39;s source directory.
<
<p>
Go generate accepts one specific flag:
<
<pre>-run=&#34;&#34;
	if non-empty, specifies a regular expression to select
	directives whose full original source text (excluding
	any trailing spaces and final newline) matches the
	expression.
<
<p>
It also accepts the standard build flags including -v, -n, and -x.
The -v flag prints the names of packages and files as they are
processed.
The -n flag prints commands that would be executed.
The -x flag prints commands as they are executed.
<
<p>
For more about build flags, see &#39;go help build&#39;.
<
<p>
For more about specifying packages, see &#39;go help packages&#39;.
<
<h3 id="hdr-Download_and_install_packages_and_dependencies">Download and install packages and dependencies<
<p>
Usage:
<
<pre>go get [-d] [-f] [-fix] [-insecure] [-t] [-u] [build flags] [packages]
<
<p>
Get downloads the packages named by the import paths, along with their
dependencies. It then installs the named packages, like &#39;go install&#39;.
<
<p>
The -d flag instructs get to stop after downloading the packages; that is,
it instructs get not to install the packages.
<
<p>
The -f flag, valid only when -u is set, forces get -u not to verify that
each package has been checked out from the source control repository
implied by its import path. This can be useful if the source is a local fork
of the original.
<
<p>
The -fix flag instructs get to run the fix tool on the downloaded packages
before resolving dependencies or building the code.
<
<p>
The -insecure flag permits fetching from repositories and resolving
custom domains using insecure schemes such as HTTP. Use with caution.
<
<p>
The -t flag instructs get to also download the packages required to build
the tests for the specified packages.
<
<p>
The -u flag instructs get to use the network to update the named packages
and their dependencies.  By default, get uses the network to check out
missing packages but does not use it to look for updates to existing packages.
<
<p>
The -v flag enables verbose progress and debug output.
<
<p>
Get also accepts build flags to control the installation. See &#39;go help build&#39;.
<
<p>
When checking out a new package, get creates the target directory
GOPATH
get uses the first one. For more details see: &#39;go help gopath&#39;.
<
<p>
When checking out or updating a package, get looks for a branch or tag
that matches the locally installed version of Go. The most important
rule is that if the local installation is running version &#34;go1&#34;, get
searches for a branch or tag named &#34;go1&#34;. If no such version exists it
retrieves the most recent version of the package.
<
<p>
When go get checks out or updates a Git repository,
it also updates any git submodules referenced by the repository.
<
<p>
Get never checks out or updates code stored in vendor directories.
<
<p>
For more about specifying packages, see &#39;go help packages&#39;.
<
<p>
For more about how &#39;go get&#39; finds source code to
download, see &#39;go help importpath&#39;.
<
<p>
See also: go build, go install, go clean.
<
<h3 id="hdr-Compile_and_install_packages_and_dependencies">Compile and install packages and dependencies<
<p>
Usage:
<
<pre>go install [build flags] [packages]
<
<p>
Install compiles and installs the packages named by the import paths,
along with their dependencies.
<
<p>
For more about the build flags, see &#39;go help build&#39;.
For more about specifying packages, see &#39;go help packages&#39;.
<
<p>
See also: go build, go get, go clean.
<
<h3 id="hdr-List_packages">List packages<
<p>
Usage:
<
<pre>go list [-e] [-f format] [-json] [build flags] [packages]
<
<p>
List lists the packages named by the import paths, one per line.
<
<p>
The default output shows the package import path:
<
<pre>bytes
encoding
github.com
golang.org
<
<p>
The -f flag specifies an alternate format for the list, using the
syntax of package template.  The default output is equivalent to -f
&#39;&#39;. The struct being passed to the template is:
<
<pre>type Package struct {
    Dir           string 
    ImportPath    string 
    ImportComment string 
    Name          string 
    Doc           string 
    Target        string 
    Shlib         string 
    Goroot        bool   
    Standard      bool   
    Stale         bool   
    StaleReason   string 
    Root          string 
    ConflictDir   string 
    BinaryOnly    bool   
    
    GoFiles        []string 
    CgoFiles       []string 
    IgnoredGoFiles []string 
    CFiles         []string 
    CXXFiles       []string 
    MFiles         []string 
    HFiles         []string 
    FFiles         []string 
    SFiles         []string 
    SwigFiles      []string 
    SwigCXXFiles   []string 
    SysoFiles      []string 
    TestGoFiles    []string 
    XTestGoFiles   []string 
    
    CgoCFLAGS    []string 
    CgoCPPFLAGS  []string 
    CgoCXXFLAGS  []string 
    CgoFFLAGS    []string 
    CgoLDFLAGS   []string 
    CgoPkgConfig []string 
    
    Imports      []string 
    Deps         []string 
    TestImports  []string 
    XTestImports []string 
    
    Incomplete bool            
    Error      *PackageError   
    DepsErrors []*PackageError 
}
<
<p>
Packages stored in vendor directories report an ImportPath that includes the
path to the vendor directory (for example, &#34;d
so that the ImportPath uniquely identifies a given copy of a package.
The Imports, Deps, TestImports, and XTestImports lists also contain these
expanded imports paths. See golang.org
<
<p>
The error information, if any, is
<
<pre>type PackageError struct {
    ImportStack   []string 
    Pos           string   
    Err           string   
}
<
<p>
The template function &#34;join&#34; calls strings.Join.
<
<p>
The template function &#34;context&#34; returns the build context, defined as:
<
<pre>type Context struct {
	GOARCH        string   
	GOOS          string   
	GOROOT        string   
	GOPATH        string   
	CgoEnabled    bool     
	UseAllFiles   bool     
	Compiler      string   
	BuildTags     []string 
	ReleaseTags   []string 
	InstallSuffix string   
}
<
<p>
For more information about the meaning of these fields see the documentation
for the go
<
<p>
The -json flag causes the package data to be printed in JSON format
instead of using the template format.
<
<p>
The -e flag changes the handling of erroneous packages, those that
cannot be found or are malformed.  By default, the list command
prints an error to standard error for each erroneous package and
omits the packages from consideration during the usual printing.
With the -e flag, the list command never prints errors to standard
error and instead processes the erroneous packages with the usual
printing.  Erroneous packages will have a non-empty ImportPath and
a non-nil Error field; other information may or may not be missing
(zeroed).
<
<p>
For more about build flags, see &#39;go help build&#39;.
<
<p>
For more about specifying packages, see &#39;go help packages&#39;.
<
<h3 id="hdr-Compile_and_run_Go_program">Compile and run Go program<
<p>
Usage:
<
<pre>go run [build flags] [-exec xprog] gofiles... [arguments...]
<
<p>
Run compiles and runs the main package comprising the named Go source files.
A Go source file is defined to be a file ending in a literal &#34;.go&#34; suffix.
<
<p>
By default, &#39;go run&#39; runs the compiled binary directly: &#39;a.out arguments...&#39;.
If the -exec flag is given, &#39;go run&#39; invokes the binary using xprog:
<
<pre>&#39;xprog a.out arguments...&#39;.
<
<p>
If the -exec flag is not given, GOOS or GOARCH is different from the system
default, and a program named go_$GOOS_$GOARCH_exec can be found
on the current search path, &#39;go run&#39; invokes the binary using that program,
for example &#39;go_nacl_386_exec a.out arguments...&#39;. This allows execution of
cross-compiled programs when a simulator or other execution method is
available.
<
<p>
For more about build flags, see &#39;go help build&#39;.
<
<p>
See also: go build.
<
<h3 id="hdr-Test_packages">Test packages<
<p>
Usage:
<
<pre>go test [build
<
<p>
&#39;Go test&#39; automates testing the packages named by the import paths.
It prints a summary of the test results in the format:
<
<pre>ok   archive
FAIL archive
ok   compress
...
<
<p>
followed by detailed output for each failed package.
<
<p>
&#39;Go test&#39; recompiles each package along with any files with names matching
the file pattern &#34;*_test.go&#34;.
Files whose names begin with &#34;_&#34; (including &#34;_test.go&#34;) or &#34;.&#34; are ignored.
These additional files can contain test functions, benchmark functions, and
example functions.  See &#39;go help testfunc&#39; for more.
Each listed package causes the execution of a separate test binary.
<
<p>
Test files that declare a package with the suffix &#34;_test&#34; will be compiled as a
separate package, and then linked and run with the main test binary.
<
<p>
The go tool will ignore a directory named &#34;testdata&#34;, making it available
to hold ancillary data needed by the tests.
<
<p>
By default, go test needs no arguments.  It compiles and tests the package
with source in the current directory, including tests, and runs the tests.
<
<p>
The package is built in a temporary directory so it does not interfere with the
non-test installation.
<
<p>
In addition to the build flags, the flags handled by &#39;go test&#39; itself are:
<
<pre>-args
    Pass the remainder of the command line (everything after -args)
    to the test binary, uninterpreted and unchanged.
    Because this flag consumes the remainder of the command line,
    the package list (if present) must appear before this flag.
-c
    Compile the test binary to pkg.test but do not run it
    (where pkg is the last element of the package&#39;s import path).
    The file name can be changed with the -o flag.
-exec xprog
    Run the test binary using xprog. The behavior is the same as
    in &#39;go run&#39;. See &#39;go help run&#39; for details.
-i
    Install packages that are dependencies of the test.
    Do not run the test.
-o file
    Compile the test binary to the named file.
    The test still runs (unless -c or -i is specified).
<
<p>
The test binary also accepts flags that control execution of the test; these
flags are also accessible by &#39;go test&#39;. See &#39;go help testflag&#39; for details.
<
<p>
For more about build flags, see &#39;go help build&#39;.
For more about specifying packages, see &#39;go help packages&#39;.
<
<p>
See also: go build, go vet.
<
<h3 id="hdr-Run_specified_go_tool">Run specified go tool<
<p>
Usage:
<
<pre>go tool [-n] command [args...]
<
<p>
Tool runs the go tool command identified by the arguments.
With no arguments it prints the list of known tools.
<
<p>
The -n flag causes tool to print the command that would be
executed but not execute it.
<
<p>
For more about each tool command, see &#39;go tool command -h&#39;.
<
<h3 id="hdr-Print_Go_version">Print Go version<
<p>
Usage:
<
<pre>go version
<
<p>
Version prints the Go version, as reported by runtime.Version.
<
<h3 id="hdr-Run_go_tool_vet_on_packages">Run go tool vet on packages<
<p>
Usage:
<
<pre>go vet [-n] [-x] [build flags] [packages]
<
<p>
Vet runs the Go vet command on the packages named by the import paths.
<
<p>
For more about vet, see &#39;go doc cmd
For more about specifying packages, see &#39;go help packages&#39;.
<
<p>
To run the vet tool with specific options, run &#39;go tool vet&#39;.
<
<p>
The -n flag prints commands that would be executed.
The -x flag prints commands as they are executed.
<
<p>
For more about build flags, see &#39;go help build&#39;.
<
<p>
See also: go fmt, go fix.
<
<h3 id="hdr-Calling_between_Go_and_C">Calling between Go and C<
<p>
There are two different ways to call between Go and C
<
<p>
The first is the cgo tool, which is part of the Go distribution.  For
information on how to use it see the cgo documentation (go doc cmd
<
<p>
The second is the SWIG program, which is a general tool for
interfacing between languages.  For information on SWIG see
<a href="http:
extension will be passed to SWIG.  Any file with a .swigcxx extension
will be passed to SWIG with the -c++ option.
<
<p>
When either cgo or SWIG is used, go build will pass any .c, .m, .s,
or .S files to the C compiler, and any .cc, .cpp, .cxx files to the C++
compiler.  The CC or CXX environment variables may be set to determine
the C or C++ compiler, respectively, to use.
<
<h3 id="hdr-Description_of_build_modes">Description of build modes<
<p>
The &#39;go build&#39; and &#39;go install&#39; commands take a -buildmode argument which
indicates which kind of object file is to be built. Currently supported values
are:
<
<pre>-buildmode=archive
	Build the listed non-main packages into .a files. Packages named
	main are ignored.
-buildmode=c-archive
	Build the listed main package, plus all packages it imports,
	into a C archive file. The only callable symbols will be those
	functions exported using a cgo 
	exactly one main package to be listed.
-buildmode=c-shared
	Build the listed main packages, plus all packages that they
	import, into C shared libraries. The only callable symbols will
	be those functions exported using a cgo 
	Non-main packages are ignored.
-buildmode=default
	Listed main packages are built into executables and listed
	non-main packages are built into .a files (the default
	behavior).
-buildmode=shared
	Combine all the listed non-main packages into a single shared
	library that will be used when building with the -linkshared
	option. Packages named main are ignored.
-buildmode=exe
	Build the listed main packages and everything they import into
	executables. Packages not named main are ignored.
-buildmode=pie
	Build the listed main packages and everything they import into
	position independent executables (PIE). Packages not named
	main are ignored.
-buildmode=plugin
	Build the listed main packages, plus all packages that they
	import, into a Go plugin. Packages not named main are ignored.
<
<h3 id="hdr-File_types">File types<
<p>
The go command examines the contents of a restricted set of files
in each directory. It identifies which files to examine based on
the extension of the file name. These extensions are:
<
<pre>.go
	Go source files.
.c, .h
	C source files.
	If the package uses cgo or SWIG, these will be compiled with the
	OS-native compiler (typically gcc); otherwise they will
	trigger an error.
.cc, .cpp, .cxx, .hh, .hpp, .hxx
	C++ source files. Only useful with cgo or SWIG, and always
	compiled with the OS-native compiler.
.m
	Objective-C source files. Only useful with cgo, and always
	compiled with the OS-native compiler.
.s, .S
	Assembler source files.
	If the package uses cgo or SWIG, these will be assembled with the
	OS-native assembler (typically gcc (sic)); otherwise they
	will be assembled with the Go assembler.
.swig, .swigcxx
	SWIG definition files.
.syso
	System object files.
<
<p>
Files of each of these types except .syso may contain build
constraints, but the go command stops scanning for build constraints
at the first item in the file that is not a blank line or 
line comment. See the go
more details.
<
<p>
Non-test Go source files can also include a 
comment, indicating that the package sources are included
for documentation only and must not be used to build the
package binary. This enables distribution of Go packages in
their compiled form alone. See the go
for more details.
<
<h3 id="hdr-GOPATH_environment_variable">GOPATH environment variable<
<p>
The Go path is used to resolve import statements.
It is implemented by and documented in the go
<
<p>
The GOPATH environment variable lists places to look for Go code.
On Unix, the value is a colon-separated string.
On Windows, the value is a semicolon-separated string.
On Plan 9, the value is a list.
<
<p>
If the environment variable is unset, GOPATH defaults
to a subdirectory named &#34;go&#34; in the user&#39;s home directory
($HOME
unless that directory holds a Go distribution.
Run &#34;go env GOPATH&#34; to see the current GOPATH.
<
<p>
See <a href="https:
<
<p>
Each directory listed in GOPATH must have a prescribed structure:
<
<p>
The src directory holds source code.  The path below src
determines the import path or executable name.
<
<p>
The pkg directory holds installed package objects.
As in the Go tree, each target operating system and
architecture pair has its own subdirectory of pkg
(pkg
<
<p>
If DIR is a directory listed in the GOPATH, a package with
source in DIR
has its compiled form installed to &#34;DIR
<
<p>
The bin directory holds compiled commands.
Each command is named for its source directory, but only
the final element, not the entire path.  That is, the
command with source in DIR
DIR
so that you can add DIR
installed commands.  If the GOBIN environment variable is
set, commands are installed to the directory it names instead
of DIR
<
<p>
Here&#39;s an example directory layout:
<
<pre>GOPATH=
    src
        foo
            bar
                x.go
            quux
                y.go
    bin
        quux                   (installed command)
    pkg
        linux_amd64
            foo
                bar.a          (installed package object)
<
<p>
Go searches each directory listed in GOPATH to find source code,
but new packages are always downloaded into the first directory
in the list.
<
<p>
See <a href="https:
<
<h3 id="hdr-Internal_Directories">Internal Directories<
<p>
Code in or below a directory named &#34;internal&#34; is importable only
by code in the directory tree rooted at the parent of &#34;internal&#34;.
Here&#39;s an extended version of the directory layout above:
<
<pre>
    src
        crash
            bang
                b.go
        foo
            f.go
            bar
                x.go
            internal
                baz
                    z.go
            quux
                y.go
<
<p>
The code in z.go is imported as &#34;foo
import statement can only appear in source files in the subtree
rooted at foo. The source files foo
foo
crash
<
<p>
See <a href="https:
<
<h3 id="hdr-Vendor_Directories">Vendor Directories<
<p>
Go 1.6 includes support for using local copies of external dependencies
to satisfy imports of those dependencies, often referred to as vendoring.
<
<p>
Code below a directory named &#34;vendor&#34; is importable only
by code in the directory tree rooted at the parent of &#34;vendor&#34;,
and only using an import path that omits the prefix up to and
including the vendor element.
<
<p>
Here&#39;s the example from the previous section,
but with the &#34;internal&#34; directory renamed to &#34;vendor&#34;
and a new foo
<
<pre>
    src
        crash
            bang
                b.go
        foo
            f.go
            bar
                x.go
            vendor
                crash
                    bang
                        b.go
                baz
                    z.go
            quux
                y.go
<
<p>
The same visibility rules apply as for internal, but the code
in z.go is imported as &#34;baz&#34;, not as &#34;foo
<
<p>
Code in vendor directories deeper in the source tree shadows
code in higher directories. Within the subtree rooted at foo, an import
of &#34;crash
top-level &#34;crash
<
<p>
Code in vendor directories is not subject to import path
checking (see &#39;go help importpath&#39;).
<
<p>
When &#39;go get&#39; checks out or updates a git repository, it now also
updates submodules.
<
<p>
Vendor directories do not affect the placement of new repositories
being checked out for the first time by &#39;go get&#39;: those are always
placed in the main GOPATH, never in a vendor subtree.
<
<p>
See <a href="https:
<
<h3 id="hdr-Environment_variables">Environment variables<
<p>
The go command, and the tools it invokes, examine a few different
environment variables. For many of these, you can see the default
value of on your system by running &#39;go env NAME&#39;, where NAME is the
name of the variable.
<
<p>
General-purpose environment variables:
<
<pre>GCCGO
	The gccgo command to run for &#39;go build -compiler=gccgo&#39;.
GOARCH
	The architecture, or processor, for which to compile code.
	Examples are amd64, 386, arm, ppc64.
GOBIN
	The directory where &#39;go install&#39; will install a command.
GOOS
	The operating system for which to compile code.
	Examples are linux, darwin, windows, netbsd.
GOPATH
	For more details see: &#39;go help gopath&#39;.
GORACE
	Options for the race detector.
	See <a href="https:
GOROOT
	The root of the go tree.
<
<p>
Environment variables for use with cgo:
<
<pre>CC
	The command to use to compile C code.
CGO_ENABLED
	Whether the cgo command is supported.  Either 0 or 1.
CGO_CFLAGS
	Flags that cgo will pass to the compiler when compiling
	C code.
CGO_CPPFLAGS
	Flags that cgo will pass to the compiler when compiling
	C or C++ code.
CGO_CXXFLAGS
	Flags that cgo will pass to the compiler when compiling
	C++ code.
CGO_FFLAGS
	Flags that cgo will pass to the compiler when compiling
	Fortran code.
CGO_LDFLAGS
	Flags that cgo will pass to the compiler when linking.
CXX
	The command to use to compile C++ code.
PKG_CONFIG
	Path to pkg-config tool.
<
<p>
Architecture-specific environment variables:
<
<pre>GOARM
	For GOARCH=arm, the ARM architecture for which to compile.
	Valid values are 5, 6, 7.
GO386
	For GOARCH=386, the floating point instruction set.
	Valid values are 387, sse2.
<
<p>
Special-purpose environment variables:
<
<pre>GOROOT_FINAL
	The root of the installed Go tree, when it is
	installed in a location other than where it is built.
	File names in stack traces are rewritten from GOROOT to
	GOROOT_FINAL.
GO_EXTLINK_ENABLED
	Whether the linker should use external linking mode
	when using -linkmode=auto with code that uses cgo.
	Set to 0 to disable external linking mode, 1 to enable it.
GIT_ALLOW_PROTOCOL
	Defined by Git. A colon-separated list of schemes that are allowed to be used
	with git fetch
	considered insecure by &#39;go get&#39;.
<
<h3 id="hdr-Import_path_syntax">Import path syntax<
<p>
An import path (see &#39;go help packages&#39;) denotes a package stored in the local
file system.  In general, an import path denotes either a standard package (such
as &#34;unicode
details see: &#39;go help gopath&#39;).
<
<h3 id="hdr-Relative_import_paths">Relative import paths<
<p>
An import path beginning with .
The toolchain supports relative import paths as a shortcut in two ways.
<
<p>
First, a relative path can be used as a shorthand on the command line.
If you are working in the directory containing the code imported as
&#34;unicode&#34; and want to run the tests for &#34;unicode
&#34;go test .
Similarly, in the reverse situation, &#34;go test ..&#34; will test &#34;unicode&#34; from
the &#34;unicode
&#34;go test .
on the pattern syntax.
<
<p>
Second, if you are compiling a Go program not in a work space,
you can use a relative path in an import statement in that program
to refer to nearby code also not in a work space.
This makes it easy to experiment with small multipackage programs
outside of the usual work spaces, but such programs cannot be
installed with &#34;go install&#34; (there is no work space in which to install them),
so they are rebuilt from scratch each time they are built.
To avoid ambiguity, Go programs cannot use relative import paths
within a work space.
<
<h3 id="hdr-Remote_import_paths">Remote import paths<
<p>
Certain import paths also
describe how to obtain the source code for the package using
a revision control system.
<
<p>
A few common code hosting sites have special syntax:
<
<pre>Bitbucket (Git, Mercurial)
	import &#34;bitbucket.org
	import &#34;bitbucket.org
GitHub (Git)
	import &#34;github.com
	import &#34;github.com
Launchpad (Bazaar)
	import &#34;launchpad.net
	import &#34;launchpad.net
	import &#34;launchpad.net
	import &#34;launchpad.net
	import &#34;launchpad.net
IBM DevOps Services (Git)
	import &#34;hub.jazz.net
	import &#34;hub.jazz.net
<
<p>
For code hosted on other servers, import paths may either be qualified
with the version control type, or the go tool can dynamically fetch
the import path over https
from a &lt;meta&gt; tag in the HTML.
<
<p>
To declare the code location, an import path of the form
<
<pre>repository.vcs
<
<p>
specifies the given repository, with or without the .vcs suffix,
using the named version control system, and then the path inside
that repository.  The supported version control systems are:
<
<pre>Bazaar      .bzr
Git         .git
Mercurial   .hg
Subversion  .svn
<
<p>
For example,
<
<pre>import &#34;example.org
<
<p>
denotes the root directory of the Mercurial repository at
example.org
<
<pre>import &#34;example.org
<
<p>
denotes the foo
example.org
<
<p>
When a version control system supports multiple protocols,
each is tried in turn when downloading.  For example, a Git
download tries https:
<
<p>
By default, downloads are restricted to known secure protocols
(e.g. https, ssh). To override this setting for Git downloads, the
GIT_ALLOW_PROTOCOL environment variable can be set (For more details see:
&#39;go help environment&#39;).
<
<p>
If the import path is not a known code hosting site and also lacks a
version control qualifier, the go tool attempts to fetch the import
over https
&lt;head&gt;.
<
<p>
The meta tag has the form:
<
<pre>&lt;meta name=&#34;go-import&#34; content=&#34;import-prefix vcs repo-root&#34;&gt;
<
<p>
The import-prefix is the import path corresponding to the repository
root. It must be a prefix or an exact match of the package being
fetched with &#34;go get&#34;. If it&#39;s not an exact match, another http
request is made at the prefix to verify the &lt;meta&gt; tags match.
<
<p>
The meta tag should appear as early in the file as possible.
In particular, it should appear before any raw JavaScript or CSS,
to avoid confusing the go command&#39;s restricted parser.
<
<p>
The vcs is one of &#34;git&#34;, &#34;hg&#34;, &#34;svn&#34;, etc,
<
<p>
The repo-root is the root of the version control system
containing a scheme and not containing a .vcs qualifier.
<
<p>
For example,
<
<pre>import &#34;example.org
<
<p>
will result in the following requests:
<
<pre><a href="https:
<a href="http:
<
<p>
If that page contains the meta tag
<
<pre>&lt;meta name=&#34;go-import&#34; content=&#34;example.org git <a href="https:
<
<p>
the go tool will verify that <a href="https:
same meta tag and then git clone <a href="https:
GOPATH
<
<p>
New downloaded packages are written to the first directory listed in the GOPATH
environment variable (For more details see: &#39;go help gopath&#39;).
<
<p>
The go command attempts to download the version of the
package appropriate for the Go release being used.
Run &#39;go help get&#39; for more.
<
<h3 id="hdr-Import_path_checking">Import path checking<
<p>
When the custom import path feature described above redirects to a
known code hosting site, each of the resulting packages has two possible
import paths, using the custom domain or the known hosting site.
<
<p>
A package statement is said to have an &#34;import comment&#34; if it is immediately
followed (before the next newline) by a comment of one of these two forms:
<
<pre>package math 
package math 
<
<p>
The go command will refuse to install a package with an import comment
unless it is being referred to by that import path. In this way, import comments
let package authors make sure the custom import path is used and not a
direct path to the underlying code hosting site.
<
<p>
Import path checking is disabled for code found within vendor trees.
This makes it possible to copy code into alternate locations in vendor trees
without needing to update import comments.
<
<p>
See <a href="https:
<
<h3 id="hdr-Description_of_package_lists">Description of package lists<
<p>
Many commands apply to a set of packages:
<
<pre>go action [packages]
<
<p>
Usually, [packages] is a list of import paths.
<
<p>
An import path that is a rooted path or that begins with
a . or .. element is interpreted as a file system path and
denotes the package in that directory.
<
<p>
Otherwise, the import path P denotes the package found in
the directory DIR
environment variable (For more details see: &#39;go help gopath&#39;).
<
<p>
If no import paths are given, the action applies to the
package in the current directory.
<
<p>
There are four reserved names for paths that should not be used
for packages to be built with the go tool:
<
<p>
- &#34;main&#34; denotes the top-level package in a stand-alone executable.
<
<p>
- &#34;all&#34; expands to all package directories found in all the GOPATH
trees. For example, &#39;go list all&#39; lists all the packages on the local
system.
<
<p>
- &#34;std&#34; is like all but expands to just the packages in the standard
Go library.
<
<p>
- &#34;cmd&#34; expands to the Go repository&#39;s commands and their
internal libraries.
<
<p>
Import paths beginning with &#34;cmd
the Go repository.
<
<p>
An import path is a pattern if it includes one or more &#34;...&#34; wildcards,
each of which can match any string, including the empty string and
strings containing slashes.  Such a pattern expands to all package
directories found in the GOPATH trees with names matching the
patterns.  As a special case, x
For example, net
<
<p>
An import path can also name a package to be downloaded from
a remote repository.  Run &#39;go help importpath&#39; for details.
<
<p>
Every package in a program must have a unique import path.
By convention, this is arranged by starting each path with a
unique prefix that belongs to you.  For example, paths used
internally at Google all begin with &#39;google&#39;, and paths
denoting remote repositories begin with the path to the code,
such as &#39;github.com
<
<p>
Packages in a program need not have unique package names,
but there are two reserved package names with special meaning.
The name main indicates a command, not a library.
Commands are built into binaries and cannot be imported.
The name documentation indicates documentation for
a non-Go program in the directory. Files in package documentation
are ignored by the go command.
<
<p>
As a special case, if the package list is a list of .go files from a
single directory, the command is applied to a single synthesized
package made up of exactly those files, ignoring any build constraints
in those files and ignoring any other files in the directory.
<
<p>
Directory and file names that begin with &#34;.&#34; or &#34;_&#34; are ignored
by the go tool, as are directories named &#34;testdata&#34;.
<
<h3 id="hdr-Description_of_testing_flags">Description of testing flags<
<p>
The &#39;go test&#39; command takes both flags that apply to &#39;go test&#39; itself
and flags that apply to the resulting test binary.
<
<p>
Several of the flags control profiling and write an execution profile
suitable for &#34;go tool pprof&#34;; run &#34;go tool pprof -h&#34; for more
information.  The --alloc_space, --alloc_objects, and --show_bytes
options of pprof control how the information is presented.
<
<p>
The following flags are recognized by the &#39;go test&#39; command and
control the execution of any test:
<
<pre>-bench regexp
    Run (sub)benchmarks matching a regular expression.
    The given regular expression is split into smaller ones by
    top-level &#39;
    benchmark&#39;s identifier.
    By default, no benchmarks run. To run all benchmarks,
    use &#39;-bench .&#39; or &#39;-bench=.&#39;.
-benchtime t
    Run enough iterations of each benchmark to take t, specified
    as a time.Duration (for example, -benchtime 1h30s).
    The default is 1 second (1s).
-count n
    Run each test and benchmark n times (default 1).
    If -cpu is set, run n times for each GOMAXPROCS value.
    Examples are always run once.
-cover
    Enable coverage analysis.
-covermode set,count,atomic
    Set the mode for coverage analysis for the package[s]
    being tested. The default is &#34;set&#34; unless -race is enabled,
    in which case it is &#34;atomic&#34;.
    The values:
	set: bool: does this statement run?
	count: int: how many times does this statement run?
	atomic: int: count, but correct in multithreaded tests;
		significantly more expensive.
    Sets -cover.
-coverpkg pkg1,pkg2,pkg3
    Apply coverage analysis in each test to the given list of packages.
    The default is for each test to analyze only the package being tested.
    Packages are specified as import paths.
    Sets -cover.
-cpu 1,2,4
    Specify a list of GOMAXPROCS values for which the tests or
    benchmarks should be executed.  The default is the current value
    of GOMAXPROCS.
-parallel n
    Allow parallel execution of test functions that call t.Parallel.
    The value of this flag is the maximum number of tests to run
    simultaneously; by default, it is set to the value of GOMAXPROCS.
    Note that -parallel only applies within a single test binary.
    The &#39;go test&#39; command may run tests for different packages
    in parallel as well, according to the setting of the -p flag
    (see &#39;go help build&#39;).
-run regexp
    Run only those tests and examples matching the regular expression.
    For tests the regular expression is split into smaller ones by
    top-level &#39;
    test&#39;s identifier.
-short
    Tell long-running tests to shorten their run time.
    It is off by default but set during all.bash so that installing
    the Go tree can run a sanity check but not spend time running
    exhaustive tests.
-timeout t
    If a test runs longer than t, panic.
    The default is 10 minutes (10m).
-v
    Verbose output: log all tests as they are run. Also print all
    text from Log and Logf calls even if the test succeeds.
<
<p>
The following flags are also recognized by &#39;go test&#39; and can be used to
profile the tests during execution:
<
<pre>-benchmem
    Print memory allocation statistics for benchmarks.
-blockprofile block.out
    Write a goroutine blocking profile to the specified file
    when all tests are complete.
    Writes test binary as -c would.
-blockprofilerate n
    Control the detail provided in goroutine blocking profiles by
    calling runtime.SetBlockProfileRate with n.
    See &#39;go doc runtime.SetBlockProfileRate&#39;.
    The profiler aims to sample, on average, one blocking event every
    n nanoseconds the program spends blocked.  By default,
    if -test.blockprofile is set without this flag, all blocking events
    are recorded, equivalent to -test.blockprofilerate=1.
-coverprofile cover.out
    Write a coverage profile to the file after all tests have passed.
    Sets -cover.
-cpuprofile cpu.out
    Write a CPU profile to the specified file before exiting.
    Writes test binary as -c would.
-memprofile mem.out
    Write a memory profile to the file after all tests have passed.
    Writes test binary as -c would.
-memprofilerate n
    Enable more precise (and expensive) memory profiles by setting
    runtime.MemProfileRate.  See &#39;go doc runtime.MemProfileRate&#39;.
    To profile all memory allocations, use -test.memprofilerate=1
    and pass --alloc_space flag to the pprof tool.
-mutexprofile mutex.out
    Write a mutex contention profile to the specified file
    when all tests are complete.
    Writes test binary as -c would.
-mutexprofilefraction n
    Sample 1 in n stack traces of goroutines holding a
    contended mutex.
-outputdir directory
    Place output files from profiling in the specified directory,
    by default the directory in which &#34;go test&#34; is running.
-trace trace.out
    Write an execution trace to the specified file before exiting.
<
<p>
Each of these flags is also recognized with an optional &#39;test.&#39; prefix,
as in -test.v. When invoking the generated test binary (the result of
&#39;go test -c&#39;) directly, however, the prefix is mandatory.
<
<p>
The &#39;go test&#39; command rewrites or removes recognized flags,
as appropriate, both before and after the optional package list,
before invoking the test binary.
<
<p>
For instance, the command
<
<pre>go test -v -myflag testdata -cpuprofile=prof.out -x
<
<p>
will compile the test binary and then run it as
<
<pre>pkg.test -test.v -myflag testdata -test.cpuprofile=prof.out
<
<p>
(The -x flag is removed because it applies only to the go command&#39;s
execution, not to the test itself.)
<
<p>
The test flags that generate profiles (other than for coverage) also
leave the test binary in pkg.test for use when analyzing the profiles.
<
<p>
When &#39;go test&#39; runs a test binary, it does so from within the
corresponding package&#39;s source code directory. Depending on the test,
it may be necessary to do the same when invoking a generated test
binary directly.
<
<p>
The command-line package list, if present, must appear before any
flag not known to the go test command. Continuing the example above,
the package list would have to appear before -myflag, but could appear
on either side of -v.
<
<p>
To keep an argument for a test binary from being interpreted as a
known flag or a package name, use -args (see &#39;go help test&#39;) which
passes the remainder of the command line through to the test binary
uninterpreted and unaltered.
<
<p>
For instance, the command
<
<pre>go test -v -args -x -v
<
<p>
will compile the test binary and then run it as
<
<pre>pkg.test -test.v -x -v
<
<p>
Similarly,
<
<pre>go test -args math
<
<p>
will compile the test binary and then run it as
<
<pre>pkg.test math
<
<p>
In the first example, the -x and the second -v are passed through to the
test binary unchanged and with no effect on the go command itself.
In the second example, the argument math is passed through to the test
binary, instead of being interpreted as the package list.
<
<h3 id="hdr-Description_of_testing_functions">Description of testing functions<
<p>
The &#39;go test&#39; command expects to find test, benchmark, and example functions
in the &#34;*_test.go&#34; files corresponding to the package under test.
<
<p>
A test function is one named TestXXX (where XXX is any alphanumeric string
not starting with a lower case letter) and should have the signature,
<
<pre>func TestXXX(t *testing.T) { ... }
<
<p>
A benchmark function is one named BenchmarkXXX and should have the signature,
<
<pre>func BenchmarkXXX(b *testing.B) { ... }
<
<p>
An example function is similar to a test function but, instead of using
*testing.T to report success or failure, prints output to os.Stdout.
If the last comment in the function starts with &#34;Output:&#34; then the output
is compared exactly against the comment (see examples below). If the last
comment begins with &#34;Unordered output:&#34; then the output is compared to the
comment, however the order of the lines is ignored. An example with no such
comment is compiled but not executed. An example with no text after
&#34;Output:&#34; is compiled, executed, and expected to produce no output.
<
<p>
Godoc displays the body of ExampleXXX to demonstrate the use
of the function, constant, or variable XXX.  An example of a method M with
receiver type T or *T is named ExampleT_M.  There may be multiple examples
for a given function, constant, or variable, distinguished by a trailing _xxx,
where xxx is a suffix not beginning with an upper case letter.
<
<p>
Here is an example of an example:
<
<pre>func ExamplePrintln() {
	Println(&#34;The output of\nthis example.&#34;)
	
	
}
<
<p>
Here is another example where the ordering of the output is ignored:
<
<pre>func ExamplePerm() {
	for _, value := range Perm(4) {
		fmt.Println(value)
	}
	
	
	
	
	
}
<
<p>
The entire test file is presented as the example when it contains a single
example function, at least one other function, type, variable, or constant
declaration, and no test or benchmark functions.
<
<p>
See the documentation of the testing package for more information.
<
<div id="footer">
Build version go1.8.<br>
Except as <a href="https:
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="
<a href="
<a href="http:
<
<
<
<!-- TODO(adonovan): load these from <head> using "defer" attribute? -->
<script type="text
<script type="text
<script>var goVersion = "go1.8";<
<script type="text
<
<
`))
package main
import (
	"bytes"
	"crypto
	"flag"
	"fmt"
	"hash
	"image"
	"image
	"io"
	"io
	"log"
	"net"
	"net
	"os"
	"path"
	"regexp"
	"runtime"
	"strconv"
	"strings"
	"sync"
	"time"
	"go4.org
	"golang.org
	"golang.org
)
var (
	prod = flag.Bool("prod", false, "Whether to configure itself to be the production http2.golang.org server.")
	httpsAddr = flag.String("https_addr", "localhost:4430", "TLS address to listen on ('host:port' or ':port'). Required.")
	httpAddr  = flag.String("http_addr", "", "Plain HTTP address to listen on ('host:port', or ':port'). Empty means no HTTP.")
	hostHTTP  = flag.String("http_host", "", "Optional host or host:port to use for http:
	hostHTTPS = flag.String("https_host", "", "Optional host or host:port to use for http:
)
func homeOldHTTP(w http.ResponseWriter, r *http.Request) {
	io.WriteString(w, `<html>
<body>
<h1>Go + HTTP
<p>Welcome to <a href="https:
<p>Unfortunately, you're <b>not<
<ul>
   <li>Use Firefox Nightly or go to <b>about:config<
   <li>Use Google Chrome Canary and
<
<p>See code & instructions for connecting at <a href="https:
<
}
func home(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path != "
		http.NotFound(w, r)
		return
	}
	io.WriteString(w, `<html>
<body>
<h1>Go + HTTP
<p>Welcome to <a href="https:
href="https:
<p>Congratulations, <b>you're using HTTP
<p>This server exists for others in the HTTP
<p>
The code is at <a href="https:
is used transparently by the Go standard library from Go 1.6 and later.
<
<p>Contact info: <i>bradfitz@golang.org<
href="https:
<h2>Handlers for testing<
<ul>
  <li>GET <a href="
  <li>GET <a href="
  <li>GET <a href="
  <li>GET <a href="
  <li>GET <a href="
  <li>GET <a href="
  <li>GET <a href="
  <li>GET <a href="
  <li>PUT something to <a href="
  <li>PUT something to <a href="
<
<
}
func reqInfoHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text
	fmt.Fprintf(w, "Method: %s\n", r.Method)
	fmt.Fprintf(w, "Protocol: %s\n", r.Proto)
	fmt.Fprintf(w, "Host: %s\n", r.Host)
	fmt.Fprintf(w, "RemoteAddr: %s\n", r.RemoteAddr)
	fmt.Fprintf(w, "RequestURI: %q\n", r.RequestURI)
	fmt.Fprintf(w, "URL: %#v\n", r.URL)
	fmt.Fprintf(w, "Body.ContentLength: %d (-1 means unknown)\n", r.ContentLength)
	fmt.Fprintf(w, "Close: %v (relevant for HTTP
	fmt.Fprintf(w, "TLS: %#v\n", r.TLS)
	fmt.Fprintf(w, "\nHeaders:\n")
	r.Header.Write(w)
}
func crcHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != "PUT" {
		http.Error(w, "PUT required.", 400)
		return
	}
	crc := crc32.NewIEEE()
	n, err := io.Copy(crc, r.Body)
	if err == nil {
		w.Header().Set("Content-Type", "text
		fmt.Fprintf(w, "bytes=%d, CRC32=%x", n, crc.Sum(nil))
	}
}
type capitalizeReader struct {
	r io.Reader
}
func (cr capitalizeReader) Read(p []byte) (n int, err error) {
	n, err = cr.r.Read(p)
	for i, b := range p[:n] {
		if b >= 'a' && b <= 'z' {
			p[i] = b - ('a' - 'A')
		}
	}
	return
}
type flushWriter struct {
	w io.Writer
}
func (fw flushWriter) Write(p []byte) (n int, err error) {
	n, err = fw.w.Write(p)
	if f, ok := fw.w.(http.Flusher); ok {
		f.Flush()
	}
	return
}
func echoCapitalHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != "PUT" {
		http.Error(w, "PUT required.", 400)
		return
	}
	io.Copy(flushWriter{w}, capitalizeReader{r.Body})
}
var (
	fsGrp   singleflight.Group
	fsMu    sync.Mutex 
	fsCache = map[string]http.Handler{}
)
func fileServer(url string, latency time.Duration) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if latency > 0 {
			time.Sleep(latency)
		}
		hi, err := fsGrp.Do(url, func() (interface{}, error) {
			fsMu.Lock()
			if h, ok := fsCache[url]; ok {
				fsMu.Unlock()
				return h, nil
			}
			fsMu.Unlock()
			res, err := http.Get(url)
			if err != nil {
				return nil, err
			}
			defer res.Body.Close()
			slurp, err := ioutil.ReadAll(res.Body)
			if err != nil {
				return nil, err
			}
			modTime := time.Now()
			var h http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				http.ServeContent(w, r, path.Base(url), modTime, bytes.NewReader(slurp))
			})
			fsMu.Lock()
			fsCache[url] = h
			fsMu.Unlock()
			return h, nil
		})
		if err != nil {
			http.Error(w, err.Error(), 500)
			return
		}
		hi.(http.Handler).ServeHTTP(w, r)
	})
}
func clockStreamHandler(w http.ResponseWriter, r *http.Request) {
	clientGone := w.(http.CloseNotifier).CloseNotify()
	w.Header().Set("Content-Type", "text
	ticker := time.NewTicker(1 * time.Second)
	defer ticker.Stop()
	fmt.Fprintf(w, "# ~1KB of junk to force browsers to start rendering immediately: \n")
	io.WriteString(w, strings.Repeat("# xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n", 13))
	for {
		fmt.Fprintf(w, "%v\n", time.Now())
		w.(http.Flusher).Flush()
		select {
		case <-ticker.C:
		case <-clientGone:
			log.Printf("Client %v disconnected from the clock", r.RemoteAddr)
			return
		}
	}
}
func registerHandlers() {
	tiles := newGopherTilesHandler()
	push := newPushHandler()
	mux2 := http.NewServeMux()
	http.HandleFunc("
		switch {
		case r.URL.Path == "
			tiles.ServeHTTP(w, r) 
			return
		case strings.HasPrefix(r.URL.Path, "
			push.ServeHTTP(w, r) 
			return
		case r.TLS == nil: 
			http.Redirect(w, r, "https:
			return
		}
		if r.ProtoMajor == 1 {
			if r.URL.Path == "
				reqInfoHandler(w, r)
				return
			}
			homeOldHTTP(w, r)
			return
		}
		mux2.ServeHTTP(w, r)
	})
	mux2.HandleFunc("
	mux2.Handle("
	mux2.Handle("
	mux2.HandleFunc("
	mux2.HandleFunc("
	mux2.HandleFunc("
	mux2.HandleFunc("
	mux2.Handle("
	mux2.HandleFunc("
		http.Redirect(w, r, "
	})
	stripHomedir := regexp.MustCompile(`
	mux2.HandleFunc("
		w.Header().Set("Content-Type", "text
		buf := make([]byte, 2<<20)
		w.Write(stripHomedir.ReplaceAll(buf[:runtime.Stack(buf, true)], nil))
	})
}
var pushResources = map[string]http.Handler{
	"
	"
	"
	"
}
func newPushHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		for path, handler := range pushResources {
			if r.URL.Path == path {
				handler.ServeHTTP(w, r)
				return
			}
		}
		cacheBust := time.Now().UnixNano()
		if pusher, ok := w.(http.Pusher); ok {
			for path := range pushResources {
				url := fmt.Sprintf("%s?%d", path, cacheBust)
				if err := pusher.Push(url, nil); err != nil {
					log.Printf("Failed to push %v: %v", path, err)
				}
			}
		}
		time.Sleep(100 * time.Millisecond) 
		if err := pushTmpl.Execute(w, struct {
			CacheBust int64
			HTTPSHost string
			HTTPHost  string
		}{
			CacheBust: cacheBust,
			HTTPSHost: httpsHost(),
			HTTPHost:  httpHost(),
		}); err != nil {
			log.Printf("Executing server push template: %v", err)
		}
	})
}
func newGopherTilesHandler() http.Handler {
	const gopherURL = "https:
	res, err := http.Get(gopherURL)
	if err != nil {
		log.Fatal(err)
	}
	if res.StatusCode != 200 {
		log.Fatalf("Error fetching %s: %v", gopherURL, res.Status)
	}
	slurp, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	if err != nil {
		log.Fatal(err)
	}
	im, err := jpeg.Decode(bytes.NewReader(slurp))
	if err != nil {
		if len(slurp) > 1024 {
			slurp = slurp[:1024]
		}
		log.Fatalf("Failed to decode gopher image: %v (got %q)", err, slurp)
	}
	type subImager interface {
		SubImage(image.Rectangle) image.Image
	}
	const tileSize = 32
	xt := im.Bounds().Max.X 
	yt := im.Bounds().Max.Y 
	var tile [][][]byte 
	for yi := 0; yi < yt; yi++ {
		var row [][]byte
		for xi := 0; xi < xt; xi++ {
			si := im.(subImager).SubImage(image.Rectangle{
				Min: image.Point{xi * tileSize, yi * tileSize},
				Max: image.Point{(xi + 1) * tileSize, (yi + 1) * tileSize},
			})
			buf := new(bytes.Buffer)
			if err := jpeg.Encode(buf, si, &jpeg.Options{Quality: 90}); err != nil {
				log.Fatal(err)
			}
			row = append(row, buf.Bytes())
		}
		tile = append(tile, row)
	}
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ms, _ := strconv.Atoi(r.FormValue("latency"))
		const nanosPerMilli = 1e6
		if r.FormValue("x") != "" {
			x, _ := strconv.Atoi(r.FormValue("x"))
			y, _ := strconv.Atoi(r.FormValue("y"))
			if ms <= 1000 {
				time.Sleep(time.Duration(ms) * nanosPerMilli)
			}
			if x >= 0 && x < xt && y >= 0 && y < yt {
				http.ServeContent(w, r, "", time.Time{}, bytes.NewReader(tile[y][x]))
				return
			}
		}
		io.WriteString(w, "<html><body onload='showtimes()'>")
		fmt.Fprintf(w, "A grid of %d tiled images is below. Compare:<p>", xt*yt)
		for _, ms := range []int{0, 30, 200, 1000} {
			d := time.Duration(ms) * nanosPerMilli
			fmt.Fprintf(w, "[<a href='https:
				httpsHost(), ms, d,
				httpHost(), ms, d,
			)
		}
		io.WriteString(w, "<p>\n")
		cacheBust := time.Now().UnixNano()
		for y := 0; y < yt; y++ {
			for x := 0; x < xt; x++ {
				fmt.Fprintf(w, "<img width=%d height=%d src='
					tileSize, tileSize, x, y, cacheBust, ms)
			}
			io.WriteString(w, "<br
		}
		io.WriteString(w, `<p><div id='loadtimes'><
<script>
function showtimes() {
	var times = 'Times from connection start:<br>'
	times += 'DOM loaded: ' + (window.performance.timing.domContentLoadedEventEnd - window.performance.timing.connectStart) + 'ms<br>'
	times += 'DOM complete (images loaded): ' + (window.performance.timing.domComplete - window.performance.timing.connectStart) + 'ms<br>'
	document.getElementById('loadtimes').innerHTML = times
}
<
<hr><a href='
	})
}
func httpsHost() string {
	if *hostHTTPS != "" {
		return *hostHTTPS
	}
	if v := *httpsAddr; strings.HasPrefix(v, ":") {
		return "localhost" + v
	} else {
		return v
	}
}
func httpHost() string {
	if *hostHTTP != "" {
		return *hostHTTP
	}
	if v := *httpAddr; strings.HasPrefix(v, ":") {
		return "localhost" + v
	} else {
		return v
	}
}
func serveProdTLS() error {
	const cacheDir = "
	if err := os.MkdirAll(cacheDir, 0700); err != nil {
		return err
	}
	m := autocert.Manager{
		Cache:      autocert.DirCache(cacheDir),
		Prompt:     autocert.AcceptTOS,
		HostPolicy: autocert.HostWhitelist("http2.golang.org"),
	}
	srv := &http.Server{
		TLSConfig: &tls.Config{
			GetCertificate: m.GetCertificate,
		},
	}
	http2.ConfigureServer(srv, &http2.Server{
		NewWriteScheduler: func() http2.WriteScheduler {
			return http2.NewPriorityWriteScheduler(nil)
		},
	})
	ln, err := net.Listen("tcp", ":443")
	if err != nil {
		return err
	}
	return srv.Serve(tls.NewListener(tcpKeepAliveListener{ln.(*net.TCPListener)}, srv.TLSConfig))
}
type tcpKeepAliveListener struct {
	*net.TCPListener
}
func (ln tcpKeepAliveListener) Accept() (c net.Conn, err error) {
	tc, err := ln.AcceptTCP()
	if err != nil {
		return
	}
	tc.SetKeepAlive(true)
	tc.SetKeepAlivePeriod(3 * time.Minute)
	return tc, nil
}
func serveProd() error {
	errc := make(chan error, 2)
	go func() { errc <- http.ListenAndServe(":80", nil) }()
	go func() { errc <- serveProdTLS() }()
	return <-errc
}
const idleTimeout = 5 * time.Minute
const activeTimeout = 10 * time.Minute
func idleTimeoutHook() func(net.Conn, http.ConnState) {
	var mu sync.Mutex
	m := map[net.Conn]*time.Timer{}
	return func(c net.Conn, cs http.ConnState) {
		mu.Lock()
		defer mu.Unlock()
		if t, ok := m[c]; ok {
			delete(m, c)
			t.Stop()
		}
		var d time.Duration
		switch cs {
		case http.StateNew, http.StateIdle:
			d = idleTimeout
		case http.StateActive:
			d = activeTimeout
		default:
			return
		}
		m[c] = time.AfterFunc(d, func() {
			log.Printf("closing idle conn %v after %v", c.RemoteAddr(), d)
			go c.Close()
		})
	}
}
func main() {
	var srv http.Server
	flag.BoolVar(&http2.VerboseLogs, "verbose", false, "Verbose HTTP
	flag.Parse()
	srv.Addr = *httpsAddr
	srv.ConnState = idleTimeoutHook()
	registerHandlers()
	if *prod {
		*hostHTTP = "http2.golang.org"
		*hostHTTPS = "http2.golang.org"
		log.Fatal(serveProd())
	}
	url := "https:
	log.Printf("Listening on " + url)
	http2.ConfigureServer(&srv, &http2.Server{})
	if *httpAddr != "" {
		go func() {
			log.Printf("Listening on http:
			log.Fatal(http.ListenAndServe(*httpAddr, nil))
		}()
	}
	go func() {
		log.Fatal(srv.ListenAndServeTLS("server.crt", "server.key"))
	}()
	select {}
}
package http2
import (
	"net
)
func configureServer19(s *http.Server, conf *Server) error {
	s.RegisterOnShutdown(conf.state.startGracefulShutdown)
	return nil
}
package http2
import "crypto
func cloneTLSConfig(c *tls.Config) *tls.Config {
	return &tls.Config{
		Rand:                        c.Rand,
		Time:                        c.Time,
		Certificates:                c.Certificates,
		NameToCertificate:           c.NameToCertificate,
		GetCertificate:              c.GetCertificate,
		RootCAs:                     c.RootCAs,
		NextProtos:                  c.NextProtos,
		ServerName:                  c.ServerName,
		ClientAuth:                  c.ClientAuth,
		ClientCAs:                   c.ClientCAs,
		InsecureSkipVerify:          c.InsecureSkipVerify,
		CipherSuites:                c.CipherSuites,
		PreferServerCipherSuites:    c.PreferServerCipherSuites,
		SessionTicketsDisabled:      c.SessionTicketsDisabled,
		SessionTicketKey:            c.SessionTicketKey,
		ClientSessionCache:          c.ClientSessionCache,
		MinVersion:                  c.MinVersion,
		MaxVersion:                  c.MaxVersion,
		CurvePreferences:            c.CurvePreferences,
		DynamicRecordSizingDisabled: c.DynamicRecordSizingDisabled,
		Renegotiation:               c.Renegotiation,
	}
}
package http2
import (
	"bufio"
	"bytes"
	"crypto
	"errors"
	"fmt"
	"io"
	"log"
	"math"
	"net"
	"net
	"net
	"net
	"os"
	"reflect"
	"runtime"
	"strconv"
	"strings"
	"sync"
	"time"
	"golang.org
)
const (
	prefaceTimeout        = 10 * time.Second
	firstSettingsTimeout  = 2 * time.Second 
	handlerChunkWriteSize = 4 << 10
	defaultMaxStreams     = 250 
)
var (
	errClientDisconnected = errors.New("client disconnected")
	errClosedBody         = errors.New("body closed by handler")
	errHandlerComplete    = errors.New("http2: request body closed due to handler exiting")
	errStreamClosed       = errors.New("http2: stream closed")
)
var responseWriterStatePool = sync.Pool{
	New: func() interface{} {
		rws := &responseWriterState{}
		rws.bw = bufio.NewWriterSize(chunkWriter{rws}, handlerChunkWriteSize)
		return rws
	},
}
var (
	testHookOnConn        func()
	testHookGetServerConn func(*serverConn)
	testHookOnPanicMu     *sync.Mutex 
	testHookOnPanic       func(sc *serverConn, panicVal interface{}) (rePanic bool)
)
type Server struct {
	
	
	
	
	MaxHandlers int
	
	
	
	
	
	
	MaxConcurrentStreams uint32
	
	
	
	
	MaxReadFrameSize uint32
	
	
	PermitProhibitedCipherSuites bool
	
	
	
	IdleTimeout time.Duration
	
	
	
	
	
	MaxUploadBufferPerConnection int32
	
	
	
	
	MaxUploadBufferPerStream int32
	
	
	NewWriteScheduler func() WriteScheduler
	
	
	
	state *serverInternalState
}
func (s *Server) initialConnRecvWindowSize() int32 {
	if s.MaxUploadBufferPerConnection > initialWindowSize {
		return s.MaxUploadBufferPerConnection
	}
	return 1 << 20
}
func (s *Server) initialStreamRecvWindowSize() int32 {
	if s.MaxUploadBufferPerStream > 0 {
		return s.MaxUploadBufferPerStream
	}
	return 1 << 20
}
func (s *Server) maxReadFrameSize() uint32 {
	if v := s.MaxReadFrameSize; v >= minMaxFrameSize && v <= maxFrameSize {
		return v
	}
	return defaultMaxReadFrameSize
}
func (s *Server) maxConcurrentStreams() uint32 {
	if v := s.MaxConcurrentStreams; v > 0 {
		return v
	}
	return defaultMaxStreams
}
type serverInternalState struct {
	mu          sync.Mutex
	activeConns map[*serverConn]struct{}
}
func (s *serverInternalState) registerConn(sc *serverConn) {
	if s == nil {
		return 
	}
	s.mu.Lock()
	s.activeConns[sc] = struct{}{}
	s.mu.Unlock()
}
func (s *serverInternalState) unregisterConn(sc *serverConn) {
	if s == nil {
		return 
	}
	s.mu.Lock()
	delete(s.activeConns, sc)
	s.mu.Unlock()
}
func (s *serverInternalState) startGracefulShutdown() {
	if s == nil {
		return 
	}
	s.mu.Lock()
	for sc := range s.activeConns {
		sc.startGracefulShutdown()
	}
	s.mu.Unlock()
}
func ConfigureServer(s *http.Server, conf *Server) error {
	if s == nil {
		panic("nil *http.Server")
	}
	if conf == nil {
		conf = new(Server)
	}
	conf.state = &serverInternalState{activeConns: make(map[*serverConn]struct{})}
	if err := configureServer18(s, conf); err != nil {
		return err
	}
	if err := configureServer19(s, conf); err != nil {
		return err
	}
	if s.TLSConfig == nil {
		s.TLSConfig = new(tls.Config)
	} else if s.TLSConfig.CipherSuites != nil {
		
		
		
		const requiredCipher = tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
		haveRequired := false
		sawBad := false
		for i, cs := range s.TLSConfig.CipherSuites {
			if cs == requiredCipher {
				haveRequired = true
			}
			if isBadCipher(cs) {
				sawBad = true
			} else if sawBad {
				return fmt.Errorf("http2: TLSConfig.CipherSuites index %d contains an HTTP
			}
		}
		if !haveRequired {
			return fmt.Errorf("http2: TLSConfig.CipherSuites is missing HTTP
		}
	}
	
	
	
	
	
	
	s.TLSConfig.PreferServerCipherSuites = true
	haveNPN := false
	for _, p := range s.TLSConfig.NextProtos {
		if p == NextProtoTLS {
			haveNPN = true
			break
		}
	}
	if !haveNPN {
		s.TLSConfig.NextProtos = append(s.TLSConfig.NextProtos, NextProtoTLS)
	}
	if s.TLSNextProto == nil {
		s.TLSNextProto = map[string]func(*http.Server, *tls.Conn, http.Handler){}
	}
	protoHandler := func(hs *http.Server, c *tls.Conn, h http.Handler) {
		if testHookOnConn != nil {
			testHookOnConn()
		}
		conf.ServeConn(c, &ServeConnOpts{
			Handler:    h,
			BaseConfig: hs,
		})
	}
	s.TLSNextProto[NextProtoTLS] = protoHandler
	return nil
}
type ServeConnOpts struct {
	
	
	BaseConfig *http.Server
	
	
	
	Handler http.Handler
}
func (o *ServeConnOpts) baseConfig() *http.Server {
	if o != nil && o.BaseConfig != nil {
		return o.BaseConfig
	}
	return new(http.Server)
}
func (o *ServeConnOpts) handler() http.Handler {
	if o != nil {
		if o.Handler != nil {
			return o.Handler
		}
		if o.BaseConfig != nil && o.BaseConfig.Handler != nil {
			return o.BaseConfig.Handler
		}
	}
	return http.DefaultServeMux
}
func (s *Server) ServeConn(c net.Conn, opts *ServeConnOpts) {
	baseCtx, cancel := serverConnBaseContext(c, opts)
	defer cancel()
	sc := &serverConn{
		srv:                         s,
		hs:                          opts.baseConfig(),
		conn:                        c,
		baseCtx:                     baseCtx,
		remoteAddrStr:               c.RemoteAddr().String(),
		bw:                          newBufferedWriter(c),
		handler:                     opts.handler(),
		streams:                     make(map[uint32]*stream),
		readFrameCh:                 make(chan readFrameResult),
		wantWriteFrameCh:            make(chan FrameWriteRequest, 8),
		serveMsgCh:                  make(chan interface{}, 8),
		wroteFrameCh:                make(chan frameWriteResult, 1), 
		bodyReadCh:                  make(chan bodyReadMsg),         
		doneServing:                 make(chan struct{}),
		clientMaxStreams:            math.MaxUint32, 
		advMaxStreams:               s.maxConcurrentStreams(),
		initialStreamSendWindowSize: initialWindowSize,
		maxFrameSize:                initialMaxFrameSize,
		headerTableSize:             initialHeaderTableSize,
		serveG:                      newGoroutineLock(),
		pushEnabled:                 true,
	}
	s.state.registerConn(sc)
	defer s.state.unregisterConn(sc)
	
	
	
	
	
	if sc.hs.WriteTimeout != 0 {
		sc.conn.SetWriteDeadline(time.Time{})
	}
	if s.NewWriteScheduler != nil {
		sc.writeSched = s.NewWriteScheduler()
	} else {
		sc.writeSched = NewRandomWriteScheduler()
	}
	
	
	
	sc.flow.add(initialWindowSize)
	sc.inflow.add(initialWindowSize)
	sc.hpackEncoder = hpack.NewEncoder(&sc.headerWriteBuf)
	fr := NewFramer(sc.bw, c)
	fr.ReadMetaHeaders = hpack.NewDecoder(initialHeaderTableSize, nil)
	fr.MaxHeaderListSize = sc.maxHeaderListSize()
	fr.SetMaxReadFrameSize(s.maxReadFrameSize())
	sc.framer = fr
	if tc, ok := c.(connectionStater); ok {
		sc.tlsState = new(tls.ConnectionState)
		*sc.tlsState = tc.ConnectionState()
		
		
		
		
		
		
		
		
		
		
		if sc.tlsState.Version < tls.VersionTLS12 {
			sc.rejectConn(ErrCodeInadequateSecurity, "TLS version too low")
			return
		}
		if sc.tlsState.ServerName == "" {
			
			
			
			
			
			
			
			
			
		}
		if !s.PermitProhibitedCipherSuites && isBadCipher(sc.tlsState.CipherSuite) {
			
			
			
			
			
			
			
			
			
			
			sc.rejectConn(ErrCodeInadequateSecurity, fmt.Sprintf("Prohibited TLS 1.2 Cipher Suite: %x", sc.tlsState.CipherSuite))
			return
		}
	}
	if hook := testHookGetServerConn; hook != nil {
		hook(sc)
	}
	sc.serve()
}
func (sc *serverConn) rejectConn(err ErrCode, debug string) {
	sc.vlogf("http2: server rejecting conn: %v, %s", err, debug)
	
	sc.framer.WriteGoAway(0, err, []byte(debug))
	sc.bw.Flush()
	sc.conn.Close()
}
type serverConn struct {
	
	srv              *Server
	hs               *http.Server
	conn             net.Conn
	bw               *bufferedWriter 
	handler          http.Handler
	baseCtx          contextContext
	framer           *Framer
	doneServing      chan struct{}          
	readFrameCh      chan readFrameResult   
	wantWriteFrameCh chan FrameWriteRequest 
	wroteFrameCh     chan frameWriteResult  
	bodyReadCh       chan bodyReadMsg       
	serveMsgCh       chan interface{}       
	flow             flow                   
	inflow           flow                   
	tlsState         *tls.ConnectionState   
	remoteAddrStr    string
	writeSched       WriteScheduler
	
	serveG                      goroutineLock 
	pushEnabled                 bool
	sawFirstSettings            bool 
	needToSendSettingsAck       bool
	unackedSettings             int    
	clientMaxStreams            uint32 
	advMaxStreams               uint32 
	curClientStreams            uint32 
	curPushedStreams            uint32 
	maxClientStreamID           uint32 
	maxPushPromiseID            uint32 
	streams                     map[uint32]*stream
	initialStreamSendWindowSize int32
	maxFrameSize                int32
	headerTableSize             uint32
	peerMaxHeaderListSize       uint32            
	canonHeader                 map[string]string 
	writingFrame                bool              
	writingFrameAsync           bool              
	needsFrameFlush             bool              
	inGoAway                    bool              
	inFrameScheduleLoop         bool              
	needToSendGoAway            bool              
	goAwayCode                  ErrCode
	shutdownTimer               *time.Timer 
	idleTimer                   *time.Timer 
	
	headerWriteBuf bytes.Buffer
	hpackEncoder   *hpack.Encoder
	
	shutdownOnce sync.Once
}
func (sc *serverConn) maxHeaderListSize() uint32 {
	n := sc.hs.MaxHeaderBytes
	if n <= 0 {
		n = http.DefaultMaxHeaderBytes
	}
	
	
	const perFieldOverhead = 32 
	const typicalHeaders = 10   
	return uint32(n + typicalHeaders*perFieldOverhead)
}
func (sc *serverConn) curOpenStreams() uint32 {
	sc.serveG.check()
	return sc.curClientStreams + sc.curPushedStreams
}
type stream struct {
	
	sc        *serverConn
	id        uint32
	body      *pipe       
	cw        closeWaiter 
	ctx       contextContext
	cancelCtx func()
	
	bodyBytes        int64   
	declBodyBytes    int64   
	flow             flow    
	inflow           flow    
	parent           *stream 
	numTrailerValues int64
	weight           uint8
	state            streamState
	resetQueued      bool        
	gotTrailerHeader bool        
	wroteHeaders     bool        
	writeDeadline    *time.Timer 
	trailer    http.Header 
	reqTrailer http.Header 
}
func (sc *serverConn) Framer() *Framer  { return sc.framer }
func (sc *serverConn) CloseConn() error { return sc.conn.Close() }
func (sc *serverConn) Flush() error     { return sc.bw.Flush() }
func (sc *serverConn) HeaderEncoder() (*hpack.Encoder, *bytes.Buffer) {
	return sc.hpackEncoder, &sc.headerWriteBuf
}
func (sc *serverConn) state(streamID uint32) (streamState, *stream) {
	sc.serveG.check()
	
	if st, ok := sc.streams[streamID]; ok {
		return st.state, st
	}
	
	
	
	
	
	
	if streamID%2 == 1 {
		if streamID <= sc.maxClientStreamID {
			return stateClosed, nil
		}
	} else {
		if streamID <= sc.maxPushPromiseID {
			return stateClosed, nil
		}
	}
	return stateIdle, nil
}
func (sc *serverConn) setConnState(state http.ConnState) {
	if sc.hs.ConnState != nil {
		sc.hs.ConnState(sc.conn, state)
	}
}
func (sc *serverConn) vlogf(format string, args ...interface{}) {
	if VerboseLogs {
		sc.logf(format, args...)
	}
}
func (sc *serverConn) logf(format string, args ...interface{}) {
	if lg := sc.hs.ErrorLog; lg != nil {
		lg.Printf(format, args...)
	} else {
		log.Printf(format, args...)
	}
}
func errno(v error) uintptr {
	if rv := reflect.ValueOf(v); rv.Kind() == reflect.Uintptr {
		return uintptr(rv.Uint())
	}
	return 0
}
func isClosedConnError(err error) bool {
	if err == nil {
		return false
	}
	
	
	
	str := err.Error()
	if strings.Contains(str, "use of closed network connection") {
		return true
	}
	
	
	
	
	if runtime.GOOS == "windows" {
		if oe, ok := err.(*net.OpError); ok && oe.Op == "read" {
			if se, ok := oe.Err.(*os.SyscallError); ok && se.Syscall == "wsarecv" {
				const WSAECONNABORTED = 10053
				const WSAECONNRESET = 10054
				if n := errno(se.Err); n == WSAECONNRESET || n == WSAECONNABORTED {
					return true
				}
			}
		}
	}
	return false
}
func (sc *serverConn) condlogf(err error, format string, args ...interface{}) {
	if err == nil {
		return
	}
	if err == io.EOF || err == io.ErrUnexpectedEOF || isClosedConnError(err) {
		
		sc.vlogf(format, args...)
	} else {
		sc.logf(format, args...)
	}
}
func (sc *serverConn) canonicalHeader(v string) string {
	sc.serveG.check()
	cv, ok := commonCanonHeader[v]
	if ok {
		return cv
	}
	cv, ok = sc.canonHeader[v]
	if ok {
		return cv
	}
	if sc.canonHeader == nil {
		sc.canonHeader = make(map[string]string)
	}
	cv = http.CanonicalHeaderKey(v)
	sc.canonHeader[v] = cv
	return cv
}
type readFrameResult struct {
	f   Frame 
	err error
	
	
	
	readMore func()
}
func (sc *serverConn) readFrames() {
	gate := make(gate)
	gateDone := gate.Done
	for {
		f, err := sc.framer.ReadFrame()
		select {
		case sc.readFrameCh <- readFrameResult{f, err, gateDone}:
		case <-sc.doneServing:
			return
		}
		select {
		case <-gate:
		case <-sc.doneServing:
			return
		}
		if terminalReadFrameError(err) {
			return
		}
	}
}
type frameWriteResult struct {
	wr  FrameWriteRequest 
	err error             
}
func (sc *serverConn) writeFrameAsync(wr FrameWriteRequest) {
	err := wr.write.writeFrame(sc)
	sc.wroteFrameCh <- frameWriteResult{wr, err}
}
func (sc *serverConn) closeAllStreamsOnConnClose() {
	sc.serveG.check()
	for _, st := range sc.streams {
		sc.closeStream(st, errClientDisconnected)
	}
}
func (sc *serverConn) stopShutdownTimer() {
	sc.serveG.check()
	if t := sc.shutdownTimer; t != nil {
		t.Stop()
	}
}
func (sc *serverConn) notePanic() {
	
	if testHookOnPanicMu != nil {
		testHookOnPanicMu.Lock()
		defer testHookOnPanicMu.Unlock()
	}
	if testHookOnPanic != nil {
		if e := recover(); e != nil {
			if testHookOnPanic(sc, e) {
				panic(e)
			}
		}
	}
}
func (sc *serverConn) serve() {
	sc.serveG.check()
	defer sc.notePanic()
	defer sc.conn.Close()
	defer sc.closeAllStreamsOnConnClose()
	defer sc.stopShutdownTimer()
	defer close(sc.doneServing) 
	if VerboseLogs {
		sc.vlogf("http2: server connection from %v on %p", sc.conn.RemoteAddr(), sc.hs)
	}
	sc.writeFrame(FrameWriteRequest{
		write: writeSettings{
			{SettingMaxFrameSize, sc.srv.maxReadFrameSize()},
			{SettingMaxConcurrentStreams, sc.advMaxStreams},
			{SettingMaxHeaderListSize, sc.maxHeaderListSize()},
			{SettingInitialWindowSize, uint32(sc.srv.initialStreamRecvWindowSize())},
		},
	})
	sc.unackedSettings++
	
	
	if diff := sc.srv.initialConnRecvWindowSize() - initialWindowSize; diff > 0 {
		sc.sendWindowUpdate(nil, int(diff))
	}
	if err := sc.readPreface(); err != nil {
		sc.condlogf(err, "http2: server: error reading preface from client %v: %v", sc.conn.RemoteAddr(), err)
		return
	}
	
	
	
	
	sc.setConnState(http.StateActive)
	sc.setConnState(http.StateIdle)
	if sc.srv.IdleTimeout != 0 {
		sc.idleTimer = time.AfterFunc(sc.srv.IdleTimeout, sc.onIdleTimer)
		defer sc.idleTimer.Stop()
	}
	go sc.readFrames() 
	settingsTimer := time.AfterFunc(firstSettingsTimeout, sc.onSettingsTimer)
	defer settingsTimer.Stop()
	loopNum := 0
	for {
		loopNum++
		select {
		case wr := <-sc.wantWriteFrameCh:
			if se, ok := wr.write.(StreamError); ok {
				sc.resetStream(se)
				break
			}
			sc.writeFrame(wr)
		case res := <-sc.wroteFrameCh:
			sc.wroteFrame(res)
		case res := <-sc.readFrameCh:
			if !sc.processFrameFromReader(res) {
				return
			}
			res.readMore()
			if settingsTimer != nil {
				settingsTimer.Stop()
				settingsTimer = nil
			}
		case m := <-sc.bodyReadCh:
			sc.noteBodyRead(m.st, m.n)
		case msg := <-sc.serveMsgCh:
			switch v := msg.(type) {
			case func(int):
				v(loopNum) 
			case *serverMessage:
				switch v {
				case settingsTimerMsg:
					sc.logf("timeout waiting for SETTINGS frames from %v", sc.conn.RemoteAddr())
					return
				case idleTimerMsg:
					sc.vlogf("connection is idle")
					sc.goAway(ErrCodeNo)
				case shutdownTimerMsg:
					sc.vlogf("GOAWAY close timer fired; closing conn from %v", sc.conn.RemoteAddr())
					return
				case gracefulShutdownMsg:
					sc.startGracefulShutdownInternal()
				default:
					panic("unknown timer")
				}
			case *startPushRequest:
				sc.startPush(v)
			default:
				panic(fmt.Sprintf("unexpected type %T", v))
			}
		}
		if sc.inGoAway && sc.curOpenStreams() == 0 && !sc.needToSendGoAway && !sc.writingFrame {
			return
		}
	}
}
func (sc *serverConn) awaitGracefulShutdown(sharedCh <-chan struct{}, privateCh chan struct{}) {
	select {
	case <-sc.doneServing:
	case <-sharedCh:
		close(privateCh)
	}
}
type serverMessage int
var (
	settingsTimerMsg    = new(serverMessage)
	idleTimerMsg        = new(serverMessage)
	shutdownTimerMsg    = new(serverMessage)
	gracefulShutdownMsg = new(serverMessage)
)
func (sc *serverConn) onSettingsTimer() { sc.sendServeMsg(settingsTimerMsg) }
func (sc *serverConn) onIdleTimer()     { sc.sendServeMsg(idleTimerMsg) }
func (sc *serverConn) onShutdownTimer() { sc.sendServeMsg(shutdownTimerMsg) }
func (sc *serverConn) sendServeMsg(msg interface{}) {
	sc.serveG.checkNotOn() 
	select {
	case sc.serveMsgCh <- msg:
	case <-sc.doneServing:
	}
}
func (sc *serverConn) readPreface() error {
	errc := make(chan error, 1)
	go func() {
		
		buf := make([]byte, len(ClientPreface))
		if _, err := io.ReadFull(sc.conn, buf); err != nil {
			errc <- err
		} else if !bytes.Equal(buf, clientPreface) {
			errc <- fmt.Errorf("bogus greeting %q", buf)
		} else {
			errc <- nil
		}
	}()
	timer := time.NewTimer(prefaceTimeout) 
	defer timer.Stop()
	select {
	case <-timer.C:
		return errors.New("timeout waiting for client preface")
	case err := <-errc:
		if err == nil {
			if VerboseLogs {
				sc.vlogf("http2: server: client %v said hello", sc.conn.RemoteAddr())
			}
		}
		return err
	}
}
var errChanPool = sync.Pool{
	New: func() interface{} { return make(chan error, 1) },
}
var writeDataPool = sync.Pool{
	New: func() interface{} { return new(writeData) },
}
func (sc *serverConn) writeDataFromHandler(stream *stream, data []byte, endStream bool) error {
	ch := errChanPool.Get().(chan error)
	writeArg := writeDataPool.Get().(*writeData)
	*writeArg = writeData{stream.id, data, endStream}
	err := sc.writeFrameFromHandler(FrameWriteRequest{
		write:  writeArg,
		stream: stream,
		done:   ch,
	})
	if err != nil {
		return err
	}
	var frameWriteDone bool 
	select {
	case err = <-ch:
		frameWriteDone = true
	case <-sc.doneServing:
		return errClientDisconnected
	case <-stream.cw:
		
		
		
		
		
		
		
		select {
		case err = <-ch:
			frameWriteDone = true
		default:
			return errStreamClosed
		}
	}
	errChanPool.Put(ch)
	if frameWriteDone {
		writeDataPool.Put(writeArg)
	}
	return err
}
func (sc *serverConn) writeFrameFromHandler(wr FrameWriteRequest) error {
	sc.serveG.checkNotOn() 
	select {
	case sc.wantWriteFrameCh <- wr:
		return nil
	case <-sc.doneServing:
		
		
		return errClientDisconnected
	}
}
func (sc *serverConn) writeFrame(wr FrameWriteRequest) {
	sc.serveG.check()
	
	var ignoreWrite bool
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	if wr.StreamID() != 0 {
		_, isReset := wr.write.(StreamError)
		if state, _ := sc.state(wr.StreamID()); state == stateClosed && !isReset {
			ignoreWrite = true
		}
	}
	
	
	switch wr.write.(type) {
	case *writeResHeaders:
		wr.stream.wroteHeaders = true
	case write100ContinueHeadersFrame:
		if wr.stream.wroteHeaders {
			
			
			if wr.done != nil {
				panic("wr.done != nil for write100ContinueHeadersFrame")
			}
			ignoreWrite = true
		}
	}
	if !ignoreWrite {
		sc.writeSched.Push(wr)
	}
	sc.scheduleFrameWrite()
}
func (sc *serverConn) startFrameWrite(wr FrameWriteRequest) {
	sc.serveG.check()
	if sc.writingFrame {
		panic("internal error: can only be writing one frame at a time")
	}
	st := wr.stream
	if st != nil {
		switch st.state {
		case stateHalfClosedLocal:
			switch wr.write.(type) {
			case StreamError, handlerPanicRST, writeWindowUpdate:
				
				
			default:
				panic(fmt.Sprintf("internal error: attempt to send frame on a half-closed-local stream: %v", wr))
			}
		case stateClosed:
			panic(fmt.Sprintf("internal error: attempt to send frame on a closed stream: %v", wr))
		}
	}
	if wpp, ok := wr.write.(*writePushPromise); ok {
		var err error
		wpp.promisedID, err = wpp.allocatePromisedID()
		if err != nil {
			sc.writingFrameAsync = false
			wr.replyToWriter(err)
			return
		}
	}
	sc.writingFrame = true
	sc.needsFrameFlush = true
	if wr.write.staysWithinBuffer(sc.bw.Available()) {
		sc.writingFrameAsync = false
		err := wr.write.writeFrame(sc)
		sc.wroteFrame(frameWriteResult{wr, err})
	} else {
		sc.writingFrameAsync = true
		go sc.writeFrameAsync(wr)
	}
}
var errHandlerPanicked = errors.New("http2: handler panicked")
func (sc *serverConn) wroteFrame(res frameWriteResult) {
	sc.serveG.check()
	if !sc.writingFrame {
		panic("internal error: expected to be already writing a frame")
	}
	sc.writingFrame = false
	sc.writingFrameAsync = false
	wr := res.wr
	if writeEndsStream(wr.write) {
		st := wr.stream
		if st == nil {
			panic("internal error: expecting non-nil stream")
		}
		switch st.state {
		case stateOpen:
			
			
			
			
			
			
			
			
			
			
			st.state = stateHalfClosedLocal
			
			
			
			
			sc.resetStream(streamError(st.id, ErrCodeNo))
		case stateHalfClosedRemote:
			sc.closeStream(st, errHandlerComplete)
		}
	} else {
		switch v := wr.write.(type) {
		case StreamError:
			
			if st, ok := sc.streams[v.StreamID]; ok {
				sc.closeStream(st, v)
			}
		case handlerPanicRST:
			sc.closeStream(wr.stream, errHandlerPanicked)
		}
	}
	
	wr.replyToWriter(res.err)
	sc.scheduleFrameWrite()
}
func (sc *serverConn) scheduleFrameWrite() {
	sc.serveG.check()
	if sc.writingFrame || sc.inFrameScheduleLoop {
		return
	}
	sc.inFrameScheduleLoop = true
	for !sc.writingFrameAsync {
		if sc.needToSendGoAway {
			sc.needToSendGoAway = false
			sc.startFrameWrite(FrameWriteRequest{
				write: &writeGoAway{
					maxStreamID: sc.maxClientStreamID,
					code:        sc.goAwayCode,
				},
			})
			continue
		}
		if sc.needToSendSettingsAck {
			sc.needToSendSettingsAck = false
			sc.startFrameWrite(FrameWriteRequest{write: writeSettingsAck{}})
			continue
		}
		if !sc.inGoAway || sc.goAwayCode == ErrCodeNo {
			if wr, ok := sc.writeSched.Pop(); ok {
				sc.startFrameWrite(wr)
				continue
			}
		}
		if sc.needsFrameFlush {
			sc.startFrameWrite(FrameWriteRequest{write: flushFrameWriter{}})
			sc.needsFrameFlush = false 
			continue
		}
		break
	}
	sc.inFrameScheduleLoop = false
}
func (sc *serverConn) startGracefulShutdown() {
	sc.serveG.checkNotOn() 
	sc.shutdownOnce.Do(func() { sc.sendServeMsg(gracefulShutdownMsg) })
}
func (sc *serverConn) startGracefulShutdownInternal() {
	sc.goAwayIn(ErrCodeNo, 0)
}
func (sc *serverConn) goAway(code ErrCode) {
	sc.serveG.check()
	var forceCloseIn time.Duration
	if code != ErrCodeNo {
		forceCloseIn = 250 * time.Millisecond
	} else {
		
		forceCloseIn = 1 * time.Second
	}
	sc.goAwayIn(code, forceCloseIn)
}
func (sc *serverConn) goAwayIn(code ErrCode, forceCloseIn time.Duration) {
	sc.serveG.check()
	if sc.inGoAway {
		return
	}
	if forceCloseIn != 0 {
		sc.shutDownIn(forceCloseIn)
	}
	sc.inGoAway = true
	sc.needToSendGoAway = true
	sc.goAwayCode = code
	sc.scheduleFrameWrite()
}
func (sc *serverConn) shutDownIn(d time.Duration) {
	sc.serveG.check()
	sc.shutdownTimer = time.AfterFunc(d, sc.onShutdownTimer)
}
func (sc *serverConn) resetStream(se StreamError) {
	sc.serveG.check()
	sc.writeFrame(FrameWriteRequest{write: se})
	if st, ok := sc.streams[se.StreamID]; ok {
		st.resetQueued = true
	}
}
func (sc *serverConn) processFrameFromReader(res readFrameResult) bool {
	sc.serveG.check()
	err := res.err
	if err != nil {
		if err == ErrFrameTooLarge {
			sc.goAway(ErrCodeFrameSize)
			return true 
		}
		clientGone := err == io.EOF || err == io.ErrUnexpectedEOF || isClosedConnError(err)
		if clientGone {
			
			
			
			
			
			
			
			
			return false
		}
	} else {
		f := res.f
		if VerboseLogs {
			sc.vlogf("http2: server read frame %v", summarizeFrame(f))
		}
		err = sc.processFrame(f)
		if err == nil {
			return true
		}
	}
	switch ev := err.(type) {
	case StreamError:
		sc.resetStream(ev)
		return true
	case goAwayFlowError:
		sc.goAway(ErrCodeFlowControl)
		return true
	case ConnectionError:
		sc.logf("http2: server connection error from %v: %v", sc.conn.RemoteAddr(), ev)
		sc.goAway(ErrCode(ev))
		return true 
	default:
		if res.err != nil {
			sc.vlogf("http2: server closing client connection; error reading frame from client %s: %v", sc.conn.RemoteAddr(), err)
		} else {
			sc.logf("http2: server closing client connection: %v", err)
		}
		return false
	}
}
func (sc *serverConn) processFrame(f Frame) error {
	sc.serveG.check()
	
	if !sc.sawFirstSettings {
		if _, ok := f.(*SettingsFrame); !ok {
			return ConnectionError(ErrCodeProtocol)
		}
		sc.sawFirstSettings = true
	}
	switch f := f.(type) {
	case *SettingsFrame:
		return sc.processSettings(f)
	case *MetaHeadersFrame:
		return sc.processHeaders(f)
	case *WindowUpdateFrame:
		return sc.processWindowUpdate(f)
	case *PingFrame:
		return sc.processPing(f)
	case *DataFrame:
		return sc.processData(f)
	case *RSTStreamFrame:
		return sc.processResetStream(f)
	case *PriorityFrame:
		return sc.processPriority(f)
	case *GoAwayFrame:
		return sc.processGoAway(f)
	case *PushPromiseFrame:
		
		
		return ConnectionError(ErrCodeProtocol)
	default:
		sc.vlogf("http2: server ignoring frame: %v", f.Header())
		return nil
	}
}
func (sc *serverConn) processPing(f *PingFrame) error {
	sc.serveG.check()
	if f.IsAck() {
		
		
		return nil
	}
	if f.StreamID != 0 {
		
		
		
		
		
		return ConnectionError(ErrCodeProtocol)
	}
	if sc.inGoAway && sc.goAwayCode != ErrCodeNo {
		return nil
	}
	sc.writeFrame(FrameWriteRequest{write: writePingAck{f}})
	return nil
}
func (sc *serverConn) processWindowUpdate(f *WindowUpdateFrame) error {
	sc.serveG.check()
	switch {
	case f.StreamID != 0: 
		state, st := sc.state(f.StreamID)
		if state == stateIdle {
			
			
			
			
			return ConnectionError(ErrCodeProtocol)
		}
		if st == nil {
			
			
			
			
			
			return nil
		}
		if !st.flow.add(int32(f.Increment)) {
			return streamError(f.StreamID, ErrCodeFlowControl)
		}
	default: 
		if !sc.flow.add(int32(f.Increment)) {
			return goAwayFlowError{}
		}
	}
	sc.scheduleFrameWrite()
	return nil
}
func (sc *serverConn) processResetStream(f *RSTStreamFrame) error {
	sc.serveG.check()
	state, st := sc.state(f.StreamID)
	if state == stateIdle {
		
		
		
		
		
		return ConnectionError(ErrCodeProtocol)
	}
	if st != nil {
		st.cancelCtx()
		sc.closeStream(st, streamError(f.StreamID, f.ErrCode))
	}
	return nil
}
func (sc *serverConn) closeStream(st *stream, err error) {
	sc.serveG.check()
	if st.state == stateIdle || st.state == stateClosed {
		panic(fmt.Sprintf("invariant; can't close stream in state %v", st.state))
	}
	st.state = stateClosed
	if st.writeDeadline != nil {
		st.writeDeadline.Stop()
	}
	if st.isPushed() {
		sc.curPushedStreams--
	} else {
		sc.curClientStreams--
	}
	delete(sc.streams, st.id)
	if len(sc.streams) == 0 {
		sc.setConnState(http.StateIdle)
		if sc.srv.IdleTimeout != 0 {
			sc.idleTimer.Reset(sc.srv.IdleTimeout)
		}
		if h1ServerKeepAlivesDisabled(sc.hs) {
			sc.startGracefulShutdownInternal()
		}
	}
	if p := st.body; p != nil {
		
		
		sc.sendWindowUpdate(nil, p.Len())
		p.CloseWithError(err)
	}
	st.cw.Close() 
	sc.writeSched.CloseStream(st.id)
}
func (sc *serverConn) processSettings(f *SettingsFrame) error {
	sc.serveG.check()
	if f.IsAck() {
		sc.unackedSettings--
		if sc.unackedSettings < 0 {
			
			
			
			return ConnectionError(ErrCodeProtocol)
		}
		return nil
	}
	if err := f.ForeachSetting(sc.processSetting); err != nil {
		return err
	}
	sc.needToSendSettingsAck = true
	sc.scheduleFrameWrite()
	return nil
}
func (sc *serverConn) processSetting(s Setting) error {
	sc.serveG.check()
	if err := s.Valid(); err != nil {
		return err
	}
	if VerboseLogs {
		sc.vlogf("http2: server processing setting %v", s)
	}
	switch s.ID {
	case SettingHeaderTableSize:
		sc.headerTableSize = s.Val
		sc.hpackEncoder.SetMaxDynamicTableSize(s.Val)
	case SettingEnablePush:
		sc.pushEnabled = s.Val != 0
	case SettingMaxConcurrentStreams:
		sc.clientMaxStreams = s.Val
	case SettingInitialWindowSize:
		return sc.processSettingInitialWindowSize(s.Val)
	case SettingMaxFrameSize:
		sc.maxFrameSize = int32(s.Val) 
	case SettingMaxHeaderListSize:
		sc.peerMaxHeaderListSize = s.Val
	default:
		
		
		
		if VerboseLogs {
			sc.vlogf("http2: server ignoring unknown setting %v", s)
		}
	}
	return nil
}
func (sc *serverConn) processSettingInitialWindowSize(val uint32) error {
	sc.serveG.check()
	
	
	
	
	
	
	
	
	old := sc.initialStreamSendWindowSize
	sc.initialStreamSendWindowSize = int32(val)
	growth := int32(val) - old 
	for _, st := range sc.streams {
		if !st.flow.add(growth) {
			
			
			
			
			
			
			return ConnectionError(ErrCodeFlowControl)
		}
	}
	return nil
}
func (sc *serverConn) processData(f *DataFrame) error {
	sc.serveG.check()
	if sc.inGoAway && sc.goAwayCode != ErrCodeNo {
		return nil
	}
	data := f.Data()
	
	
	
	id := f.Header().StreamID
	state, st := sc.state(id)
	if id == 0 || state == stateIdle {
		
		
		
		
		return ConnectionError(ErrCodeProtocol)
	}
	if st == nil || state != stateOpen || st.gotTrailerHeader || st.resetQueued {
		
		
		
		
		
		
		
		
		if sc.inflow.available() < int32(f.Length) {
			return streamError(id, ErrCodeFlowControl)
		}
		
		
		
		
		sc.inflow.take(int32(f.Length))
		sc.sendWindowUpdate(nil, int(f.Length)) 
		if st != nil && st.resetQueued {
			
			return nil
		}
		return streamError(id, ErrCodeStreamClosed)
	}
	if st.body == nil {
		panic("internal error: should have a body in this state")
	}
	
	if st.declBodyBytes != -1 && st.bodyBytes+int64(len(data)) > st.declBodyBytes {
		st.body.CloseWithError(fmt.Errorf("sender tried to send more than declared Content-Length of %d bytes", st.declBodyBytes))
		return streamError(id, ErrCodeStreamClosed)
	}
	if f.Length > 0 {
		
		if st.inflow.available() < int32(f.Length) {
			return streamError(id, ErrCodeFlowControl)
		}
		st.inflow.take(int32(f.Length))
		if len(data) > 0 {
			wrote, err := st.body.Write(data)
			if err != nil {
				return streamError(id, ErrCodeStreamClosed)
			}
			if wrote != len(data) {
				panic("internal error: bad Writer")
			}
			st.bodyBytes += int64(len(data))
		}
		
		
		if pad := int32(f.Length) - int32(len(data)); pad > 0 {
			sc.sendWindowUpdate32(nil, pad)
			sc.sendWindowUpdate32(st, pad)
		}
	}
	if f.StreamEnded() {
		st.endStream()
	}
	return nil
}
func (sc *serverConn) processGoAway(f *GoAwayFrame) error {
	sc.serveG.check()
	if f.ErrCode != ErrCodeNo {
		sc.logf("http2: received GOAWAY %+v, starting graceful shutdown", f)
	} else {
		sc.vlogf("http2: received GOAWAY %+v, starting graceful shutdown", f)
	}
	sc.startGracefulShutdownInternal()
	
	
	sc.pushEnabled = false
	return nil
}
func (st *stream) isPushed() bool {
	return st.id%2 == 0
}
func (st *stream) endStream() {
	sc := st.sc
	sc.serveG.check()
	if st.declBodyBytes != -1 && st.declBodyBytes != st.bodyBytes {
		st.body.CloseWithError(fmt.Errorf("request declared a Content-Length of %d but only wrote %d bytes",
			st.declBodyBytes, st.bodyBytes))
	} else {
		st.body.closeWithErrorAndCode(io.EOF, st.copyTrailersToHandlerRequest)
		st.body.CloseWithError(io.EOF)
	}
	st.state = stateHalfClosedRemote
}
func (st *stream) copyTrailersToHandlerRequest() {
	for k, vv := range st.trailer {
		if _, ok := st.reqTrailer[k]; ok {
			
			st.reqTrailer[k] = vv
		}
	}
}
func (st *stream) onWriteTimeout() {
	st.sc.writeFrameFromHandler(FrameWriteRequest{write: streamError(st.id, ErrCodeInternal)})
}
func (sc *serverConn) processHeaders(f *MetaHeadersFrame) error {
	sc.serveG.check()
	id := f.StreamID
	if sc.inGoAway {
		
		return nil
	}
	
	
	
	
	
	if id%2 != 1 {
		return ConnectionError(ErrCodeProtocol)
	}
	
	
	
	
	if st := sc.streams[f.StreamID]; st != nil {
		if st.resetQueued {
			
			
			return nil
		}
		return st.processTrailerHeaders(f)
	}
	
	
	
	
	
	if id <= sc.maxClientStreamID {
		return ConnectionError(ErrCodeProtocol)
	}
	sc.maxClientStreamID = id
	if sc.idleTimer != nil {
		sc.idleTimer.Stop()
	}
	
	
	
	
	
	
	if sc.curClientStreams+1 > sc.advMaxStreams {
		if sc.unackedSettings == 0 {
			
			return streamError(id, ErrCodeProtocol)
		}
		
		
		
		
		
		return streamError(id, ErrCodeRefusedStream)
	}
	initialState := stateOpen
	if f.StreamEnded() {
		initialState = stateHalfClosedRemote
	}
	st := sc.newStream(id, 0, initialState)
	if f.HasPriority() {
		if err := checkPriority(f.StreamID, f.Priority); err != nil {
			return err
		}
		sc.writeSched.AdjustStream(st.id, f.Priority)
	}
	rw, req, err := sc.newWriterAndRequest(st, f)
	if err != nil {
		return err
	}
	st.reqTrailer = req.Trailer
	if st.reqTrailer != nil {
		st.trailer = make(http.Header)
	}
	st.body = req.Body.(*requestBody).pipe 
	st.declBodyBytes = req.ContentLength
	handler := sc.handler.ServeHTTP
	if f.Truncated {
		
		handler = handleHeaderListTooLong
	} else if err := checkValidHTTP2RequestHeaders(req.Header); err != nil {
		handler = new400Handler(err)
	}
	
	
	
	
	
	
	
	if sc.hs.ReadTimeout != 0 {
		sc.conn.SetReadDeadline(time.Time{})
	}
	go sc.runHandler(rw, req, handler)
	return nil
}
func (st *stream) processTrailerHeaders(f *MetaHeadersFrame) error {
	sc := st.sc
	sc.serveG.check()
	if st.gotTrailerHeader {
		return ConnectionError(ErrCodeProtocol)
	}
	st.gotTrailerHeader = true
	if !f.StreamEnded() {
		return streamError(st.id, ErrCodeProtocol)
	}
	if len(f.PseudoFields()) > 0 {
		return streamError(st.id, ErrCodeProtocol)
	}
	if st.trailer != nil {
		for _, hf := range f.RegularFields() {
			key := sc.canonicalHeader(hf.Name)
			if !ValidTrailerHeader(key) {
				
				
				
				return streamError(st.id, ErrCodeProtocol)
			}
			st.trailer[key] = append(st.trailer[key], hf.Value)
		}
	}
	st.endStream()
	return nil
}
func checkPriority(streamID uint32, p PriorityParam) error {
	if streamID == p.StreamDep {
		
		
		
		
		return streamError(streamID, ErrCodeProtocol)
	}
	return nil
}
func (sc *serverConn) processPriority(f *PriorityFrame) error {
	if sc.inGoAway {
		return nil
	}
	if err := checkPriority(f.StreamID, f.PriorityParam); err != nil {
		return err
	}
	sc.writeSched.AdjustStream(f.StreamID, f.PriorityParam)
	return nil
}
func (sc *serverConn) newStream(id, pusherID uint32, state streamState) *stream {
	sc.serveG.check()
	if id == 0 {
		panic("internal error: cannot create stream with id 0")
	}
	ctx, cancelCtx := contextWithCancel(sc.baseCtx)
	st := &stream{
		sc:        sc,
		id:        id,
		state:     state,
		ctx:       ctx,
		cancelCtx: cancelCtx,
	}
	st.cw.Init()
	st.flow.conn = &sc.flow 
	st.flow.add(sc.initialStreamSendWindowSize)
	st.inflow.conn = &sc.inflow 
	st.inflow.add(sc.srv.initialStreamRecvWindowSize())
	if sc.hs.WriteTimeout != 0 {
		st.writeDeadline = time.AfterFunc(sc.hs.WriteTimeout, st.onWriteTimeout)
	}
	sc.streams[id] = st
	sc.writeSched.OpenStream(st.id, OpenStreamOptions{PusherID: pusherID})
	if st.isPushed() {
		sc.curPushedStreams++
	} else {
		sc.curClientStreams++
	}
	if sc.curOpenStreams() == 1 {
		sc.setConnState(http.StateActive)
	}
	return st
}
func (sc *serverConn) newWriterAndRequest(st *stream, f *MetaHeadersFrame) (*responseWriter, *http.Request, error) {
	sc.serveG.check()
	rp := requestParam{
		method:    f.PseudoValue("method"),
		scheme:    f.PseudoValue("scheme"),
		authority: f.PseudoValue("authority"),
		path:      f.PseudoValue("path"),
	}
	isConnect := rp.method == "CONNECT"
	if isConnect {
		if rp.path != "" || rp.scheme != "" || rp.authority == "" {
			return nil, nil, streamError(f.StreamID, ErrCodeProtocol)
		}
	} else if rp.method == "" || rp.path == "" || (rp.scheme != "https" && rp.scheme != "http") {
		
		
		
		
		
		
		
		
		
		
		return nil, nil, streamError(f.StreamID, ErrCodeProtocol)
	}
	bodyOpen := !f.StreamEnded()
	if rp.method == "HEAD" && bodyOpen {
		
		return nil, nil, streamError(f.StreamID, ErrCodeProtocol)
	}
	rp.header = make(http.Header)
	for _, hf := range f.RegularFields() {
		rp.header.Add(sc.canonicalHeader(hf.Name), hf.Value)
	}
	if rp.authority == "" {
		rp.authority = rp.header.Get("Host")
	}
	rw, req, err := sc.newWriterAndRequestNoBody(st, rp)
	if err != nil {
		return nil, nil, err
	}
	if bodyOpen {
		if vv, ok := rp.header["Content-Length"]; ok {
			req.ContentLength, _ = strconv.ParseInt(vv[0], 10, 64)
		} else {
			req.ContentLength = -1
		}
		req.Body.(*requestBody).pipe = &pipe{
			b: &dataBuffer{expected: req.ContentLength},
		}
	}
	return rw, req, nil
}
type requestParam struct {
	method                  string
	scheme, authority, path string
	header                  http.Header
}
func (sc *serverConn) newWriterAndRequestNoBody(st *stream, rp requestParam) (*responseWriter, *http.Request, error) {
	sc.serveG.check()
	var tlsState *tls.ConnectionState 
	if rp.scheme == "https" {
		tlsState = sc.tlsState
	}
	needsContinue := rp.header.Get("Expect") == "100-continue"
	if needsContinue {
		rp.header.Del("Expect")
	}
	
	if cookies := rp.header["Cookie"]; len(cookies) > 1 {
		rp.header.Set("Cookie", strings.Join(cookies, "; "))
	}
	
	var trailer http.Header
	for _, v := range rp.header["Trailer"] {
		for _, key := range strings.Split(v, ",") {
			key = http.CanonicalHeaderKey(strings.TrimSpace(key))
			switch key {
			case "Transfer-Encoding", "Trailer", "Content-Length":
				
				
			default:
				if trailer == nil {
					trailer = make(http.Header)
				}
				trailer[key] = nil
			}
		}
	}
	delete(rp.header, "Trailer")
	var url_ *url.URL
	var requestURI string
	if rp.method == "CONNECT" {
		url_ = &url.URL{Host: rp.authority}
		requestURI = rp.authority 
	} else {
		var err error
		url_, err = url.ParseRequestURI(rp.path)
		if err != nil {
			return nil, nil, streamError(st.id, ErrCodeProtocol)
		}
		requestURI = rp.path
	}
	body := &requestBody{
		conn:          sc,
		stream:        st,
		needsContinue: needsContinue,
	}
	req := &http.Request{
		Method:     rp.method,
		URL:        url_,
		RemoteAddr: sc.remoteAddrStr,
		Header:     rp.header,
		RequestURI: requestURI,
		Proto:      "HTTP
		ProtoMajor: 2,
		ProtoMinor: 0,
		TLS:        tlsState,
		Host:       rp.authority,
		Body:       body,
		Trailer:    trailer,
	}
	req = requestWithContext(req, st.ctx)
	rws := responseWriterStatePool.Get().(*responseWriterState)
	bwSave := rws.bw
	*rws = responseWriterState{} 
	rws.conn = sc
	rws.bw = bwSave
	rws.bw.Reset(chunkWriter{rws})
	rws.stream = st
	rws.req = req
	rws.body = body
	rw := &responseWriter{rws: rws}
	return rw, req, nil
}
func (sc *serverConn) runHandler(rw *responseWriter, req *http.Request, handler func(http.ResponseWriter, *http.Request)) {
	didPanic := true
	defer func() {
		rw.rws.stream.cancelCtx()
		if didPanic {
			e := recover()
			sc.writeFrameFromHandler(FrameWriteRequest{
				write:  handlerPanicRST{rw.rws.stream.id},
				stream: rw.rws.stream,
			})
			
			if shouldLogPanic(e) {
				const size = 64 << 10
				buf := make([]byte, size)
				buf = buf[:runtime.Stack(buf, false)]
				sc.logf("http2: panic serving %v: %v\n%s", sc.conn.RemoteAddr(), e, buf)
			}
			return
		}
		rw.handlerDone()
	}()
	handler(rw, req)
	didPanic = false
}
func handleHeaderListTooLong(w http.ResponseWriter, r *http.Request) {
	
	
	
	
	const statusRequestHeaderFieldsTooLarge = 431 
	w.WriteHeader(statusRequestHeaderFieldsTooLarge)
	io.WriteString(w, "<h1>HTTP Error 431<
}
func (sc *serverConn) writeHeaders(st *stream, headerData *writeResHeaders) error {
	sc.serveG.checkNotOn() 
	var errc chan error
	if headerData.h != nil {
		
		
		
		
		errc = errChanPool.Get().(chan error)
	}
	if err := sc.writeFrameFromHandler(FrameWriteRequest{
		write:  headerData,
		stream: st,
		done:   errc,
	}); err != nil {
		return err
	}
	if errc != nil {
		select {
		case err := <-errc:
			errChanPool.Put(errc)
			return err
		case <-sc.doneServing:
			return errClientDisconnected
		case <-st.cw:
			return errStreamClosed
		}
	}
	return nil
}
func (sc *serverConn) write100ContinueHeaders(st *stream) {
	sc.writeFrameFromHandler(FrameWriteRequest{
		write:  write100ContinueHeadersFrame{st.id},
		stream: st,
	})
}
type bodyReadMsg struct {
	st *stream
	n  int
}
func (sc *serverConn) noteBodyReadFromHandler(st *stream, n int, err error) {
	sc.serveG.checkNotOn() 
	if n > 0 {
		select {
		case sc.bodyReadCh <- bodyReadMsg{st, n}:
		case <-sc.doneServing:
		}
	}
}
func (sc *serverConn) noteBodyRead(st *stream, n int) {
	sc.serveG.check()
	sc.sendWindowUpdate(nil, n) 
	if st.state != stateHalfClosedRemote && st.state != stateClosed {
		
		
		sc.sendWindowUpdate(st, n)
	}
}
func (sc *serverConn) sendWindowUpdate(st *stream, n int) {
	sc.serveG.check()
	
	
	
	
	
	const maxUint31 = 1<<31 - 1
	for n >= maxUint31 {
		sc.sendWindowUpdate32(st, maxUint31)
		n -= maxUint31
	}
	sc.sendWindowUpdate32(st, int32(n))
}
func (sc *serverConn) sendWindowUpdate32(st *stream, n int32) {
	sc.serveG.check()
	if n == 0 {
		return
	}
	if n < 0 {
		panic("negative update")
	}
	var streamID uint32
	if st != nil {
		streamID = st.id
	}
	sc.writeFrame(FrameWriteRequest{
		write:  writeWindowUpdate{streamID: streamID, n: uint32(n)},
		stream: st,
	})
	var ok bool
	if st == nil {
		ok = sc.inflow.add(n)
	} else {
		ok = st.inflow.add(n)
	}
	if !ok {
		panic("internal error; sent too many window updates without decrements?")
	}
}
type requestBody struct {
	stream        *stream
	conn          *serverConn
	closed        bool  
	sawEOF        bool  
	pipe          *pipe 
	needsContinue bool  
}
func (b *requestBody) Close() error {
	if b.pipe != nil && !b.closed {
		b.pipe.BreakWithError(errClosedBody)
	}
	b.closed = true
	return nil
}
func (b *requestBody) Read(p []byte) (n int, err error) {
	if b.needsContinue {
		b.needsContinue = false
		b.conn.write100ContinueHeaders(b.stream)
	}
	if b.pipe == nil || b.sawEOF {
		return 0, io.EOF
	}
	n, err = b.pipe.Read(p)
	if err == io.EOF {
		b.sawEOF = true
	}
	if b.conn == nil && inTests {
		return
	}
	b.conn.noteBodyReadFromHandler(b.stream, n, err)
	return
}
type responseWriter struct {
	rws *responseWriterState
}
var (
	_ http.CloseNotifier = (*responseWriter)(nil)
	_ http.Flusher       = (*responseWriter)(nil)
	_ stringWriter       = (*responseWriter)(nil)
)
type responseWriterState struct {
	
	stream *stream
	req    *http.Request
	body   *requestBody 
	conn   *serverConn
	
	bw *bufio.Writer 
	
	handlerHeader http.Header 
	snapHeader    http.Header 
	trailers      []string    
	status        int         
	wroteHeader   bool        
	sentHeader    bool        
	handlerDone   bool        
	dirty         bool        
	sentContentLen int64 
	wroteBytes     int64
	closeNotifierMu sync.Mutex 
	closeNotifierCh chan bool  
}
type chunkWriter struct{ rws *responseWriterState }
func (cw chunkWriter) Write(p []byte) (n int, err error) { return cw.rws.writeChunk(p) }
func (rws *responseWriterState) hasTrailers() bool { return len(rws.trailers) != 0 }
func (rws *responseWriterState) declareTrailer(k string) {
	k = http.CanonicalHeaderKey(k)
	if !ValidTrailerHeader(k) {
		
		rws.conn.logf("ignoring invalid trailer %q", k)
		return
	}
	if !strSliceContains(rws.trailers, k) {
		rws.trailers = append(rws.trailers, k)
	}
}
func (rws *responseWriterState) writeChunk(p []byte) (n int, err error) {
	if !rws.wroteHeader {
		rws.writeHeader(200)
	}
	isHeadResp := rws.req.Method == "HEAD"
	if !rws.sentHeader {
		rws.sentHeader = true
		var ctype, clen string
		if clen = rws.snapHeader.Get("Content-Length"); clen != "" {
			rws.snapHeader.Del("Content-Length")
			clen64, err := strconv.ParseInt(clen, 10, 64)
			if err == nil && clen64 >= 0 {
				rws.sentContentLen = clen64
			} else {
				clen = ""
			}
		}
		if clen == "" && rws.handlerDone && bodyAllowedForStatus(rws.status) && (len(p) > 0 || !isHeadResp) {
			clen = strconv.Itoa(len(p))
		}
		_, hasContentType := rws.snapHeader["Content-Type"]
		if !hasContentType && bodyAllowedForStatus(rws.status) {
			ctype = http.DetectContentType(p)
		}
		var date string
		if _, ok := rws.snapHeader["Date"]; !ok {
			
			date = time.Now().UTC().Format(http.TimeFormat)
		}
		for _, v := range rws.snapHeader["Trailer"] {
			foreachHeaderElement(v, rws.declareTrailer)
		}
		endStream := (rws.handlerDone && !rws.hasTrailers() && len(p) == 0) || isHeadResp
		err = rws.conn.writeHeaders(rws.stream, &writeResHeaders{
			streamID:      rws.stream.id,
			httpResCode:   rws.status,
			h:             rws.snapHeader,
			endStream:     endStream,
			contentType:   ctype,
			contentLength: clen,
			date:          date,
		})
		if err != nil {
			rws.dirty = true
			return 0, err
		}
		if endStream {
			return 0, nil
		}
	}
	if isHeadResp {
		return len(p), nil
	}
	if len(p) == 0 && !rws.handlerDone {
		return 0, nil
	}
	if rws.handlerDone {
		rws.promoteUndeclaredTrailers()
	}
	endStream := rws.handlerDone && !rws.hasTrailers()
	if len(p) > 0 || endStream {
		
		if err := rws.conn.writeDataFromHandler(rws.stream, p, endStream); err != nil {
			rws.dirty = true
			return 0, err
		}
	}
	if rws.handlerDone && rws.hasTrailers() {
		err = rws.conn.writeHeaders(rws.stream, &writeResHeaders{
			streamID:  rws.stream.id,
			h:         rws.handlerHeader,
			trailers:  rws.trailers,
			endStream: true,
		})
		if err != nil {
			rws.dirty = true
		}
		return len(p), err
	}
	return len(p), nil
}
const TrailerPrefix = "Trailer:"
func (rws *responseWriterState) promoteUndeclaredTrailers() {
	for k, vv := range rws.handlerHeader {
		if !strings.HasPrefix(k, TrailerPrefix) {
			continue
		}
		trailerKey := strings.TrimPrefix(k, TrailerPrefix)
		rws.declareTrailer(trailerKey)
		rws.handlerHeader[http.CanonicalHeaderKey(trailerKey)] = vv
	}
	if len(rws.trailers) > 1 {
		sorter := sorterPool.Get().(*sorter)
		sorter.SortStrings(rws.trailers)
		sorterPool.Put(sorter)
	}
}
func (w *responseWriter) Flush() {
	rws := w.rws
	if rws == nil {
		panic("Header called after Handler finished")
	}
	if rws.bw.Buffered() > 0 {
		if err := rws.bw.Flush(); err != nil {
			
			return
		}
	} else {
		
		
		
		
		rws.writeChunk(nil)
	}
}
func (w *responseWriter) CloseNotify() <-chan bool {
	rws := w.rws
	if rws == nil {
		panic("CloseNotify called after Handler finished")
	}
	rws.closeNotifierMu.Lock()
	ch := rws.closeNotifierCh
	if ch == nil {
		ch = make(chan bool, 1)
		rws.closeNotifierCh = ch
		cw := rws.stream.cw
		go func() {
			cw.Wait() 
			ch <- true
		}()
	}
	rws.closeNotifierMu.Unlock()
	return ch
}
func (w *responseWriter) Header() http.Header {
	rws := w.rws
	if rws == nil {
		panic("Header called after Handler finished")
	}
	if rws.handlerHeader == nil {
		rws.handlerHeader = make(http.Header)
	}
	return rws.handlerHeader
}
func (w *responseWriter) WriteHeader(code int) {
	rws := w.rws
	if rws == nil {
		panic("WriteHeader called after Handler finished")
	}
	rws.writeHeader(code)
}
func (rws *responseWriterState) writeHeader(code int) {
	if !rws.wroteHeader {
		rws.wroteHeader = true
		rws.status = code
		if len(rws.handlerHeader) > 0 {
			rws.snapHeader = cloneHeader(rws.handlerHeader)
		}
	}
}
func cloneHeader(h http.Header) http.Header {
	h2 := make(http.Header, len(h))
	for k, vv := range h {
		vv2 := make([]string, len(vv))
		copy(vv2, vv)
		h2[k] = vv2
	}
	return h2
}
func (w *responseWriter) Write(p []byte) (n int, err error) {
	return w.write(len(p), p, "")
}
func (w *responseWriter) WriteString(s string) (n int, err error) {
	return w.write(len(s), nil, s)
}
func (w *responseWriter) write(lenData int, dataB []byte, dataS string) (n int, err error) {
	rws := w.rws
	if rws == nil {
		panic("Write called after Handler finished")
	}
	if !rws.wroteHeader {
		w.WriteHeader(200)
	}
	if !bodyAllowedForStatus(rws.status) {
		return 0, http.ErrBodyNotAllowed
	}
	rws.wroteBytes += int64(len(dataB)) + int64(len(dataS)) 
	if rws.sentContentLen != 0 && rws.wroteBytes > rws.sentContentLen {
		
		return 0, errors.New("http2: handler wrote more than declared Content-Length")
	}
	if dataB != nil {
		return rws.bw.Write(dataB)
	} else {
		return rws.bw.WriteString(dataS)
	}
}
func (w *responseWriter) handlerDone() {
	rws := w.rws
	dirty := rws.dirty
	rws.handlerDone = true
	w.Flush()
	w.rws = nil
	if !dirty {
		
		
		
		
		
		
		responseWriterStatePool.Put(rws)
	}
}
var (
	ErrRecursivePush    = errors.New("http2: recursive push not allowed")
	ErrPushLimitReached = errors.New("http2: push would exceed peer's SETTINGS_MAX_CONCURRENT_STREAMS")
)
type pushOptions struct {
	Method string
	Header http.Header
}
func (w *responseWriter) push(target string, opts pushOptions) error {
	st := w.rws.stream
	sc := st.sc
	sc.serveG.checkNotOn()
	
	
	if st.isPushed() {
		return ErrRecursivePush
	}
	
	if opts.Method == "" {
		opts.Method = "GET"
	}
	if opts.Header == nil {
		opts.Header = http.Header{}
	}
	wantScheme := "http"
	if w.rws.req.TLS != nil {
		wantScheme = "https"
	}
	
	u, err := url.Parse(target)
	if err != nil {
		return err
	}
	if u.Scheme == "" {
		if !strings.HasPrefix(target, "
			return fmt.Errorf("target must be an absolute URL or an absolute path: %q", target)
		}
		u.Scheme = wantScheme
		u.Host = w.rws.req.Host
	} else {
		if u.Scheme != wantScheme {
			return fmt.Errorf("cannot push URL with scheme %q from request with scheme %q", u.Scheme, wantScheme)
		}
		if u.Host == "" {
			return errors.New("URL must have a host")
		}
	}
	for k := range opts.Header {
		if strings.HasPrefix(k, ":") {
			return fmt.Errorf("promised request headers cannot include pseudo header %q", k)
		}
		
		
		
		
		switch strings.ToLower(k) {
		case "content-length", "content-encoding", "trailer", "te", "expect", "host":
			return fmt.Errorf("promised request headers cannot include %q", k)
		}
	}
	if err := checkValidHTTP2RequestHeaders(opts.Header); err != nil {
		return err
	}
	
	
	
	if opts.Method != "GET" && opts.Method != "HEAD" {
		return fmt.Errorf("method %q must be GET or HEAD", opts.Method)
	}
	msg := &startPushRequest{
		parent: st,
		method: opts.Method,
		url:    u,
		header: cloneHeader(opts.Header),
		done:   errChanPool.Get().(chan error),
	}
	select {
	case <-sc.doneServing:
		return errClientDisconnected
	case <-st.cw:
		return errStreamClosed
	case sc.serveMsgCh <- msg:
	}
	select {
	case <-sc.doneServing:
		return errClientDisconnected
	case <-st.cw:
		return errStreamClosed
	case err := <-msg.done:
		errChanPool.Put(msg.done)
		return err
	}
}
type startPushRequest struct {
	parent *stream
	method string
	url    *url.URL
	header http.Header
	done   chan error
}
func (sc *serverConn) startPush(msg *startPushRequest) {
	sc.serveG.check()
	
	
	
	if msg.parent.state != stateOpen && msg.parent.state != stateHalfClosedRemote {
		
		msg.done <- errStreamClosed
		return
	}
	
	if !sc.pushEnabled {
		msg.done <- http.ErrNotSupported
		return
	}
	
	
	
	allocatePromisedID := func() (uint32, error) {
		sc.serveG.check()
		
		
		if !sc.pushEnabled {
			return 0, http.ErrNotSupported
		}
		
		if sc.curPushedStreams+1 > sc.clientMaxStreams {
			return 0, ErrPushLimitReached
		}
		
		
		
		
		if sc.maxPushPromiseID+2 >= 1<<31 {
			sc.startGracefulShutdownInternal()
			return 0, ErrPushLimitReached
		}
		sc.maxPushPromiseID += 2
		promisedID := sc.maxPushPromiseID
		
		
		
		
		
		promised := sc.newStream(promisedID, msg.parent.id, stateHalfClosedRemote)
		rw, req, err := sc.newWriterAndRequestNoBody(promised, requestParam{
			method:    msg.method,
			scheme:    msg.url.Scheme,
			authority: msg.url.Host,
			path:      msg.url.RequestURI(),
			header:    cloneHeader(msg.header), 
		})
		if err != nil {
			
			panic(fmt.Sprintf("newWriterAndRequestNoBody(%+v): %v", msg.url, err))
		}
		go sc.runHandler(rw, req, sc.handler.ServeHTTP)
		return promisedID, nil
	}
	sc.writeFrame(FrameWriteRequest{
		write: &writePushPromise{
			streamID:           msg.parent.id,
			method:             msg.method,
			url:                msg.url,
			h:                  msg.header,
			allocatePromisedID: allocatePromisedID,
		},
		stream: msg.parent,
		done:   msg.done,
	})
}
func foreachHeaderElement(v string, fn func(string)) {
	v = textproto.TrimString(v)
	if v == "" {
		return
	}
	if !strings.Contains(v, ",") {
		fn(v)
		return
	}
	for _, f := range strings.Split(v, ",") {
		if f = textproto.TrimString(f); f != "" {
			fn(f)
		}
	}
}
var connHeaders = []string{
	"Connection",
	"Keep-Alive",
	"Proxy-Connection",
	"Transfer-Encoding",
	"Upgrade",
}
func checkValidHTTP2RequestHeaders(h http.Header) error {
	for _, k := range connHeaders {
		if _, ok := h[k]; ok {
			return fmt.Errorf("request header %q is not valid in HTTP
		}
	}
	te := h["Te"]
	if len(te) > 0 && (len(te) > 1 || (te[0] != "trailers" && te[0] != "")) {
		return errors.New(`request header "TE" may only be "trailers" in HTTP
	}
	return nil
}
func new400Handler(err error) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		http.Error(w, err.Error(), http.StatusBadRequest)
	}
}
func ValidTrailerHeader(name string) bool {
	name = http.CanonicalHeaderKey(name)
	if strings.HasPrefix(name, "If-") || badTrailer[name] {
		return false
	}
	return true
}
var badTrailer = map[string]bool{
	"Authorization":       true,
	"Cache-Control":       true,
	"Connection":          true,
	"Content-Encoding":    true,
	"Content-Length":      true,
	"Content-Range":       true,
	"Content-Type":        true,
	"Expect":              true,
	"Host":                true,
	"Keep-Alive":          true,
	"Max-Forwards":        true,
	"Pragma":              true,
	"Proxy-Authenticate":  true,
	"Proxy-Authorization": true,
	"Proxy-Connection":    true,
	"Range":               true,
	"Realm":               true,
	"Te":                  true,
	"Trailer":             true,
	"Transfer-Encoding":   true,
	"Www-Authenticate":    true,
}
func h1ServerKeepAlivesDisabled(hs *http.Server) bool {
	var x interface{} = hs
	type I interface {
		doKeepAlives() bool
	}
	if hs, ok := x.(I); ok {
		return !hs.doKeepAlives()
	}
	return false
}
package http2
import (
	"crypto
	"io"
	"net
)
func cloneTLSConfig(c *tls.Config) *tls.Config {
	c2 := c.Clone()
	c2.GetClientCertificate = c.GetClientCertificate 
	return c2
}
var _ http.Pusher = (*responseWriter)(nil)
func (w *responseWriter) Push(target string, opts *http.PushOptions) error {
	internalOpts := pushOptions{}
	if opts != nil {
		internalOpts.Method = opts.Method
		internalOpts.Header = opts.Header
	}
	return w.push(target, internalOpts)
}
func configureServer18(h1 *http.Server, h2 *Server) error {
	if h2.IdleTimeout == 0 {
		if h1.IdleTimeout != 0 {
			h2.IdleTimeout = h1.IdleTimeout
		} else {
			h2.IdleTimeout = h1.ReadTimeout
		}
	}
	return nil
}
func shouldLogPanic(panicValue interface{}) bool {
	return panicValue != nil && panicValue != http.ErrAbortHandler
}
func reqGetBody(req *http.Request) func() (io.ReadCloser, error) {
	return req.GetBody
}
func reqBodyIsNoBody(body io.ReadCloser) bool {
	return body == http.NoBody
}
func go18httpNoBody() io.ReadCloser { return http.NoBody } 
package http2
import (
	"crypto
	"net
	"testing"
	"time"
)
func TestConfigureServerIdleTimeout_Go18(t *testing.T) {
	const timeout = 5 * time.Second
	const notThisOne = 1 * time.Second
	
	{
		s1 := &http.Server{
			IdleTimeout: timeout,
			ReadTimeout: notThisOne,
		}
		s2 := &Server{}
		if err := ConfigureServer(s1, s2); err != nil {
			t.Fatal(err)
		}
		if s2.IdleTimeout != timeout {
			t.Errorf("s2.IdleTimeout = %v; want %v", s2.IdleTimeout, timeout)
		}
	}
	
	{
		s1 := &http.Server{
			ReadTimeout: timeout,
		}
		s2 := &Server{}
		if err := ConfigureServer(s1, s2); err != nil {
			t.Fatal(err)
		}
		if s2.IdleTimeout != timeout {
			t.Errorf("s2.IdleTimeout = %v; want %v", s2.IdleTimeout, timeout)
		}
	}
	
	{
		s1 := &http.Server{
			IdleTimeout: notThisOne,
		}
		s2 := &Server{
			IdleTimeout: timeout,
		}
		if err := ConfigureServer(s1, s2); err != nil {
			t.Fatal(err)
		}
		if s2.IdleTimeout != timeout {
			t.Errorf("s2.IdleTimeout = %v; want %v", s2.IdleTimeout, timeout)
		}
	}
}
func TestCertClone(t *testing.T) {
	c := &tls.Config{
		GetClientCertificate: func(*tls.CertificateRequestInfo) (*tls.Certificate, error) {
			panic("shouldn't be called")
		},
	}
	c2 := cloneTLSConfig(c)
	if c2.GetClientCertificate == nil {
		t.Error("GetClientCertificate is nil")
	}
}
package http2
import (
	"bufio"
	"bytes"
	"compress
	"crypto
	"crypto
	"errors"
	"fmt"
	"io"
	"io
	"log"
	"math"
	mathrand "math
	"net"
	"net
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"
	"golang.org
	"golang.org
	"golang.org
)
const (
	
	
	transportDefaultConnFlow = 1 << 30
	
	
	
	transportDefaultStreamFlow = 4 << 20
	
	
	transportDefaultStreamMinRefresh = 4 << 10
	defaultUserAgent = "Go-http-client
)
type Transport struct {
	
	
	
	
	
	
	
	DialTLS func(network, addr string, cfg *tls.Config) (net.Conn, error)
	
	
	TLSClientConfig *tls.Config
	
	
	ConnPool ClientConnPool
	
	
	
	
	
	
	
	
	DisableCompression bool
	
	
	AllowHTTP bool
	
	
	
	
	
	
	
	MaxHeaderListSize uint32
	
	
	
	t1 *http.Transport
	connPoolOnce  sync.Once
	connPoolOrDef ClientConnPool 
}
func (t *Transport) maxHeaderListSize() uint32 {
	if t.MaxHeaderListSize == 0 {
		return 10 << 20
	}
	if t.MaxHeaderListSize == 0xffffffff {
		return 0
	}
	return t.MaxHeaderListSize
}
func (t *Transport) disableCompression() bool {
	return t.DisableCompression || (t.t1 != nil && t.t1.DisableCompression)
}
var errTransportVersion = errors.New("http2: ConfigureTransport is only supported starting at Go 1.6")
func ConfigureTransport(t1 *http.Transport) error {
	_, err := configureTransport(t1) 
	return err
}
func (t *Transport) connPool() ClientConnPool {
	t.connPoolOnce.Do(t.initConnPool)
	return t.connPoolOrDef
}
func (t *Transport) initConnPool() {
	if t.ConnPool != nil {
		t.connPoolOrDef = t.ConnPool
	} else {
		t.connPoolOrDef = &clientConnPool{t: t}
	}
}
type ClientConn struct {
	t         *Transport
	tconn     net.Conn             
	tlsState  *tls.ConnectionState 
	singleUse bool                 
	
	readerDone chan struct{} 
	readerErr  error         
	idleTimeout time.Duration 
	idleTimer   *time.Timer
	mu              sync.Mutex 
	cond            *sync.Cond 
	flow            flow       
	inflow          flow       
	closed          bool
	wantSettingsAck bool                     
	goAway          *GoAwayFrame             
	goAwayDebug     string                   
	streams         map[uint32]*clientStream 
	nextStreamID    uint32
	pendingRequests int                       
	pings           map[[8]byte]chan struct{} 
	bw              *bufio.Writer
	br              *bufio.Reader
	fr              *Framer
	lastActive      time.Time
	
	maxFrameSize         uint32
	maxConcurrentStreams uint32
	initialWindowSize    uint32
	hbuf    bytes.Buffer 
	henc    *hpack.Encoder
	freeBuf [][]byte
	wmu  sync.Mutex 
	werr error      
}
type clientStream struct {
	cc            *ClientConn
	req           *http.Request
	trace         *clientTrace 
	ID            uint32
	resc          chan resAndError
	bufPipe       pipe 
	startedWrite  bool 
	requestedGzip bool
	on100         func() 
	flow        flow  
	inflow      flow  
	bytesRemain int64 
	readErr     error 
	stopReqBody error 
	didReset    bool  
	peerReset chan struct{} 
	resetErr  error         
	done chan struct{} 
	
	firstByte    bool 
	pastHeaders  bool 
	pastTrailers bool 
	trailer    http.Header  
	resTrailer *http.Header 
}
func awaitRequestCancel(req *http.Request, done <-chan struct{}) error {
	ctx := reqContext(req)
	if req.Cancel == nil && ctx.Done() == nil {
		return nil
	}
	select {
	case <-req.Cancel:
		return errRequestCanceled
	case <-ctx.Done():
		return ctx.Err()
	case <-done:
		return nil
	}
}
func (cs *clientStream) awaitRequestCancel(req *http.Request) {
	if err := awaitRequestCancel(req, cs.done); err != nil {
		cs.cancelStream()
		cs.bufPipe.CloseWithError(err)
	}
}
func (cs *clientStream) cancelStream() {
	cc := cs.cc
	cc.mu.Lock()
	didReset := cs.didReset
	cs.didReset = true
	cc.mu.Unlock()
	if !didReset {
		cc.writeStreamReset(cs.ID, ErrCodeCancel, nil)
		cc.forgetStreamID(cs.ID)
	}
}
func (cs *clientStream) checkResetOrDone() error {
	select {
	case <-cs.peerReset:
		return cs.resetErr
	case <-cs.done:
		return errStreamClosed
	default:
		return nil
	}
}
func (cs *clientStream) abortRequestBodyWrite(err error) {
	if err == nil {
		panic("nil error")
	}
	cc := cs.cc
	cc.mu.Lock()
	cs.stopReqBody = err
	cc.cond.Broadcast()
	cc.mu.Unlock()
}
type stickyErrWriter struct {
	w   io.Writer
	err *error
}
func (sew stickyErrWriter) Write(p []byte) (n int, err error) {
	if *sew.err != nil {
		return 0, *sew.err
	}
	n, err = sew.w.Write(p)
	*sew.err = err
	return
}
var ErrNoCachedConn = errors.New("http2: no cached connection was available")
type RoundTripOpt struct {
	
	
	
	
	OnlyCachedConn bool
}
func (t *Transport) RoundTrip(req *http.Request) (*http.Response, error) {
	return t.RoundTripOpt(req, RoundTripOpt{})
}
func authorityAddr(scheme string, authority string) (addr string) {
	host, port, err := net.SplitHostPort(authority)
	if err != nil { 
		port = "443"
		if scheme == "http" {
			port = "80"
		}
		host = authority
	}
	if a, err := idna.ToASCII(host); err == nil {
		host = a
	}
	
	if strings.HasPrefix(host, "[") && strings.HasSuffix(host, "]") {
		return host + ":" + port
	}
	return net.JoinHostPort(host, port)
}
func (t *Transport) RoundTripOpt(req *http.Request, opt RoundTripOpt) (*http.Response, error) {
	if !(req.URL.Scheme == "https" || (req.URL.Scheme == "http" && t.AllowHTTP)) {
		return nil, errors.New("http2: unsupported scheme")
	}
	addr := authorityAddr(req.URL.Scheme, req.URL.Host)
	for retry := 0; ; retry++ {
		cc, err := t.connPool().GetClientConn(req, addr)
		if err != nil {
			t.vlogf("http2: Transport failed to get client conn for %s: %v", addr, err)
			return nil, err
		}
		traceGotConn(req, cc)
		res, err := cc.RoundTrip(req)
		if err != nil && retry <= 6 {
			afterBodyWrite := false
			if e, ok := err.(afterReqBodyWriteError); ok {
				err = e
				afterBodyWrite = true
			}
			if req, err = shouldRetryRequest(req, err, afterBodyWrite); err == nil {
				
				if retry == 0 {
					continue
				}
				backoff := float64(uint(1) << (uint(retry) - 1))
				backoff += backoff * (0.1 * mathrand.Float64())
				select {
				case <-time.After(time.Second * time.Duration(backoff)):
					continue
				case <-reqContext(req).Done():
					return nil, reqContext(req).Err()
				}
			}
		}
		if err != nil {
			t.vlogf("RoundTrip failure: %v", err)
			return nil, err
		}
		return res, nil
	}
}
func (t *Transport) CloseIdleConnections() {
	if cp, ok := t.connPool().(clientConnPoolIdleCloser); ok {
		cp.closeIdleConnections()
	}
}
var (
	errClientConnClosed    = errors.New("http2: client conn is closed")
	errClientConnUnusable  = errors.New("http2: client conn not usable")
	errClientConnGotGoAway = errors.New("http2: Transport received Server's graceful shutdown GOAWAY")
)
type afterReqBodyWriteError struct {
	err error
}
func (e afterReqBodyWriteError) Error() string {
	return e.err.Error() + "; some request body already written"
}
func shouldRetryRequest(req *http.Request, err error, afterBodyWrite bool) (*http.Request, error) {
	if !canRetryError(err) {
		return nil, err
	}
	if !afterBodyWrite {
		return req, nil
	}
	
	
	if req.Body == nil || reqBodyIsNoBody(req.Body) {
		return req, nil
	}
	
	
	getBody := reqGetBody(req) 
	if getBody == nil {
		return nil, fmt.Errorf("http2: Transport: cannot retry err [%v] after Request.Body was written; define Request.GetBody to avoid this error", err)
	}
	body, err := getBody()
	if err != nil {
		return nil, err
	}
	newReq := *req
	newReq.Body = body
	return &newReq, nil
}
func canRetryError(err error) bool {
	if err == errClientConnUnusable || err == errClientConnGotGoAway {
		return true
	}
	if se, ok := err.(StreamError); ok {
		return se.Code == ErrCodeRefusedStream
	}
	return false
}
func (t *Transport) dialClientConn(addr string, singleUse bool) (*ClientConn, error) {
	host, _, err := net.SplitHostPort(addr)
	if err != nil {
		return nil, err
	}
	tconn, err := t.dialTLS()("tcp", addr, t.newTLSConfig(host))
	if err != nil {
		return nil, err
	}
	return t.newClientConn(tconn, singleUse)
}
func (t *Transport) newTLSConfig(host string) *tls.Config {
	cfg := new(tls.Config)
	if t.TLSClientConfig != nil {
		*cfg = *cloneTLSConfig(t.TLSClientConfig)
	}
	if !strSliceContains(cfg.NextProtos, NextProtoTLS) {
		cfg.NextProtos = append([]string{NextProtoTLS}, cfg.NextProtos...)
	}
	if cfg.ServerName == "" {
		cfg.ServerName = host
	}
	return cfg
}
func (t *Transport) dialTLS() func(string, string, *tls.Config) (net.Conn, error) {
	if t.DialTLS != nil {
		return t.DialTLS
	}
	return t.dialTLSDefault
}
func (t *Transport) dialTLSDefault(network, addr string, cfg *tls.Config) (net.Conn, error) {
	cn, err := tls.Dial(network, addr, cfg)
	if err != nil {
		return nil, err
	}
	if err := cn.Handshake(); err != nil {
		return nil, err
	}
	if !cfg.InsecureSkipVerify {
		if err := cn.VerifyHostname(cfg.ServerName); err != nil {
			return nil, err
		}
	}
	state := cn.ConnectionState()
	if p := state.NegotiatedProtocol; p != NextProtoTLS {
		return nil, fmt.Errorf("http2: unexpected ALPN protocol %q; want %q", p, NextProtoTLS)
	}
	if !state.NegotiatedProtocolIsMutual {
		return nil, errors.New("http2: could not negotiate protocol mutually")
	}
	return cn, nil
}
func (t *Transport) disableKeepAlives() bool {
	return t.t1 != nil && t.t1.DisableKeepAlives
}
func (t *Transport) expectContinueTimeout() time.Duration {
	if t.t1 == nil {
		return 0
	}
	return transportExpectContinueTimeout(t.t1)
}
func (t *Transport) NewClientConn(c net.Conn) (*ClientConn, error) {
	return t.newClientConn(c, false)
}
func (t *Transport) newClientConn(c net.Conn, singleUse bool) (*ClientConn, error) {
	cc := &ClientConn{
		t:                    t,
		tconn:                c,
		readerDone:           make(chan struct{}),
		nextStreamID:         1,
		maxFrameSize:         16 << 10, 
		initialWindowSize:    65535,    
		maxConcurrentStreams: 1000,     
		streams:              make(map[uint32]*clientStream),
		singleUse:            singleUse,
		wantSettingsAck:      true,
		pings:                make(map[[8]byte]chan struct{}),
	}
	if d := t.idleConnTimeout(); d != 0 {
		cc.idleTimeout = d
		cc.idleTimer = time.AfterFunc(d, cc.onIdleTimeout)
	}
	if VerboseLogs {
		t.vlogf("http2: Transport creating client conn %p to %v", cc, c.RemoteAddr())
	}
	cc.cond = sync.NewCond(&cc.mu)
	cc.flow.add(int32(initialWindowSize))
	
	
	cc.bw = bufio.NewWriter(stickyErrWriter{c, &cc.werr})
	cc.br = bufio.NewReader(c)
	cc.fr = NewFramer(cc.bw, cc.br)
	cc.fr.ReadMetaHeaders = hpack.NewDecoder(initialHeaderTableSize, nil)
	cc.fr.MaxHeaderListSize = t.maxHeaderListSize()
	
	
	cc.henc = hpack.NewEncoder(&cc.hbuf)
	if cs, ok := c.(connectionStater); ok {
		state := cs.ConnectionState()
		cc.tlsState = &state
	}
	initialSettings := []Setting{
		{ID: SettingEnablePush, Val: 0},
		{ID: SettingInitialWindowSize, Val: transportDefaultStreamFlow},
	}
	if max := t.maxHeaderListSize(); max != 0 {
		initialSettings = append(initialSettings, Setting{ID: SettingMaxHeaderListSize, Val: max})
	}
	cc.bw.Write(clientPreface)
	cc.fr.WriteSettings(initialSettings...)
	cc.fr.WriteWindowUpdate(0, transportDefaultConnFlow)
	cc.inflow.add(transportDefaultConnFlow + initialWindowSize)
	cc.bw.Flush()
	if cc.werr != nil {
		return nil, cc.werr
	}
	go cc.readLoop()
	return cc, nil
}
func (cc *ClientConn) setGoAway(f *GoAwayFrame) {
	cc.mu.Lock()
	defer cc.mu.Unlock()
	old := cc.goAway
	cc.goAway = f
	
	if cc.goAwayDebug == "" {
		cc.goAwayDebug = string(f.DebugData())
	}
	if old != nil && old.ErrCode != ErrCodeNo {
		cc.goAway.ErrCode = old.ErrCode
	}
	last := f.LastStreamID
	for streamID, cs := range cc.streams {
		if streamID > last {
			select {
			case cs.resc <- resAndError{err: errClientConnGotGoAway}:
			default:
			}
		}
	}
}
func (cc *ClientConn) CanTakeNewRequest() bool {
	cc.mu.Lock()
	defer cc.mu.Unlock()
	return cc.canTakeNewRequestLocked()
}
func (cc *ClientConn) canTakeNewRequestLocked() bool {
	if cc.singleUse && cc.nextStreamID > 1 {
		return false
	}
	return cc.goAway == nil && !cc.closed &&
		int64(cc.nextStreamID)+int64(cc.pendingRequests) < math.MaxInt32
}
func (cc *ClientConn) onIdleTimeout() {
	cc.closeIfIdle()
}
func (cc *ClientConn) closeIfIdle() {
	cc.mu.Lock()
	if len(cc.streams) > 0 {
		cc.mu.Unlock()
		return
	}
	cc.closed = true
	nextID := cc.nextStreamID
	
	cc.mu.Unlock()
	if VerboseLogs {
		cc.vlogf("http2: Transport closing idle conn %p (forSingleUse=%v, maxStream=%v)", cc, cc.singleUse, nextID-2)
	}
	cc.tconn.Close()
}
const maxAllocFrameSize = 512 << 10
func (cc *ClientConn) frameScratchBuffer() []byte {
	cc.mu.Lock()
	size := cc.maxFrameSize
	if size > maxAllocFrameSize {
		size = maxAllocFrameSize
	}
	for i, buf := range cc.freeBuf {
		if len(buf) >= int(size) {
			cc.freeBuf[i] = nil
			cc.mu.Unlock()
			return buf[:size]
		}
	}
	cc.mu.Unlock()
	return make([]byte, size)
}
func (cc *ClientConn) putFrameScratchBuffer(buf []byte) {
	cc.mu.Lock()
	defer cc.mu.Unlock()
	const maxBufs = 4 
	if len(cc.freeBuf) < maxBufs {
		cc.freeBuf = append(cc.freeBuf, buf)
		return
	}
	for i, old := range cc.freeBuf {
		if old == nil {
			cc.freeBuf[i] = buf
			return
		}
	}
	
}
var errRequestCanceled = errors.New("net
func commaSeparatedTrailers(req *http.Request) (string, error) {
	keys := make([]string, 0, len(req.Trailer))
	for k := range req.Trailer {
		k = http.CanonicalHeaderKey(k)
		switch k {
		case "Transfer-Encoding", "Trailer", "Content-Length":
			return "", &badStringError{"invalid Trailer key", k}
		}
		keys = append(keys, k)
	}
	if len(keys) > 0 {
		sort.Strings(keys)
		return strings.Join(keys, ","), nil
	}
	return "", nil
}
func (cc *ClientConn) responseHeaderTimeout() time.Duration {
	if cc.t.t1 != nil {
		return cc.t.t1.ResponseHeaderTimeout
	}
	
	
	
	
	return 0
}
func checkConnHeaders(req *http.Request) error {
	if v := req.Header.Get("Upgrade"); v != "" {
		return fmt.Errorf("http2: invalid Upgrade request header: %q", req.Header["Upgrade"])
	}
	if vv := req.Header["Transfer-Encoding"]; len(vv) > 0 && (len(vv) > 1 || vv[0] != "" && vv[0] != "chunked") {
		return fmt.Errorf("http2: invalid Transfer-Encoding request header: %q", vv)
	}
	if vv := req.Header["Connection"]; len(vv) > 0 && (len(vv) > 1 || vv[0] != "" && vv[0] != "close" && vv[0] != "keep-alive") {
		return fmt.Errorf("http2: invalid Connection request header: %q", vv)
	}
	return nil
}
func actualContentLength(req *http.Request) int64 {
	if req.Body == nil || reqBodyIsNoBody(req.Body) {
		return 0
	}
	if req.ContentLength != 0 {
		return req.ContentLength
	}
	return -1
}
func (cc *ClientConn) RoundTrip(req *http.Request) (*http.Response, error) {
	if err := checkConnHeaders(req); err != nil {
		return nil, err
	}
	if cc.idleTimer != nil {
		cc.idleTimer.Stop()
	}
	trailers, err := commaSeparatedTrailers(req)
	if err != nil {
		return nil, err
	}
	hasTrailers := trailers != ""
	cc.mu.Lock()
	if err := cc.awaitOpenSlotForRequest(req); err != nil {
		cc.mu.Unlock()
		return nil, err
	}
	body := req.Body
	contentLen := actualContentLength(req)
	hasBody := contentLen != 0
	
	var requestedGzip bool
	if !cc.t.disableCompression() &&
		req.Header.Get("Accept-Encoding") == "" &&
		req.Header.Get("Range") == "" &&
		req.Method != "HEAD" {
		
		
		
		
		
		
		
		
		
		
		
		
		requestedGzip = true
	}
	
	
	
	hdrs, err := cc.encodeHeaders(req, requestedGzip, trailers, contentLen)
	if err != nil {
		cc.mu.Unlock()
		return nil, err
	}
	cs := cc.newStream()
	cs.req = req
	cs.trace = requestTrace(req)
	cs.requestedGzip = requestedGzip
	bodyWriter := cc.t.getBodyWriterState(cs, body)
	cs.on100 = bodyWriter.on100
	cc.wmu.Lock()
	endStream := !hasBody && !hasTrailers
	werr := cc.writeHeaders(cs.ID, endStream, hdrs)
	cc.wmu.Unlock()
	traceWroteHeaders(cs.trace)
	cc.mu.Unlock()
	if werr != nil {
		if hasBody {
			req.Body.Close() 
			bodyWriter.cancel()
		}
		cc.forgetStreamID(cs.ID)
		
		
		traceWroteRequest(cs.trace, werr)
		return nil, werr
	}
	var respHeaderTimer <-chan time.Time
	if hasBody {
		bodyWriter.scheduleBodyWrite()
	} else {
		traceWroteRequest(cs.trace, nil)
		if d := cc.responseHeaderTimeout(); d != 0 {
			timer := time.NewTimer(d)
			defer timer.Stop()
			respHeaderTimer = timer.C
		}
	}
	readLoopResCh := cs.resc
	bodyWritten := false
	ctx := reqContext(req)
	handleReadLoopResponse := func(re resAndError) (*http.Response, error) {
		res := re.res
		if re.err != nil || res.StatusCode > 299 {
			
			
			
			
			
			
			
			
			
			bodyWriter.cancel()
			cs.abortRequestBodyWrite(errStopReqBodyWrite)
		}
		if re.err != nil {
			cc.mu.Lock()
			afterBodyWrite := cs.startedWrite
			cc.mu.Unlock()
			cc.forgetStreamID(cs.ID)
			if afterBodyWrite {
				return nil, afterReqBodyWriteError{re.err}
			}
			return nil, re.err
		}
		res.Request = req
		res.TLS = cc.tlsState
		return res, nil
	}
	for {
		select {
		case re := <-readLoopResCh:
			return handleReadLoopResponse(re)
		case <-respHeaderTimer:
			if !hasBody || bodyWritten {
				cc.writeStreamReset(cs.ID, ErrCodeCancel, nil)
			} else {
				bodyWriter.cancel()
				cs.abortRequestBodyWrite(errStopReqBodyWriteAndCancel)
			}
			cc.forgetStreamID(cs.ID)
			return nil, errTimeout
		case <-ctx.Done():
			if !hasBody || bodyWritten {
				cc.writeStreamReset(cs.ID, ErrCodeCancel, nil)
			} else {
				bodyWriter.cancel()
				cs.abortRequestBodyWrite(errStopReqBodyWriteAndCancel)
			}
			cc.forgetStreamID(cs.ID)
			return nil, ctx.Err()
		case <-req.Cancel:
			if !hasBody || bodyWritten {
				cc.writeStreamReset(cs.ID, ErrCodeCancel, nil)
			} else {
				bodyWriter.cancel()
				cs.abortRequestBodyWrite(errStopReqBodyWriteAndCancel)
			}
			cc.forgetStreamID(cs.ID)
			return nil, errRequestCanceled
		case <-cs.peerReset:
			
			
			
			return nil, cs.resetErr
		case err := <-bodyWriter.resc:
			
			select {
			case re := <-readLoopResCh:
				return handleReadLoopResponse(re)
			default:
			}
			if err != nil {
				return nil, err
			}
			bodyWritten = true
			if d := cc.responseHeaderTimeout(); d != 0 {
				timer := time.NewTimer(d)
				defer timer.Stop()
				respHeaderTimer = timer.C
			}
		}
	}
}
func (cc *ClientConn) awaitOpenSlotForRequest(req *http.Request) error {
	var waitingForConn chan struct{}
	var waitingForConnErr error 
	for {
		cc.lastActive = time.Now()
		if cc.closed || !cc.canTakeNewRequestLocked() {
			return errClientConnUnusable
		}
		if int64(len(cc.streams))+1 <= int64(cc.maxConcurrentStreams) {
			if waitingForConn != nil {
				close(waitingForConn)
			}
			return nil
		}
		
		
		
		if waitingForConn == nil {
			waitingForConn = make(chan struct{})
			go func() {
				if err := awaitRequestCancel(req, waitingForConn); err != nil {
					cc.mu.Lock()
					waitingForConnErr = err
					cc.cond.Broadcast()
					cc.mu.Unlock()
				}
			}()
		}
		cc.pendingRequests++
		cc.cond.Wait()
		cc.pendingRequests--
		if waitingForConnErr != nil {
			return waitingForConnErr
		}
	}
}
func (cc *ClientConn) writeHeaders(streamID uint32, endStream bool, hdrs []byte) error {
	first := true 
	frameSize := int(cc.maxFrameSize)
	for len(hdrs) > 0 && cc.werr == nil {
		chunk := hdrs
		if len(chunk) > frameSize {
			chunk = chunk[:frameSize]
		}
		hdrs = hdrs[len(chunk):]
		endHeaders := len(hdrs) == 0
		if first {
			cc.fr.WriteHeaders(HeadersFrameParam{
				StreamID:      streamID,
				BlockFragment: chunk,
				EndStream:     endStream,
				EndHeaders:    endHeaders,
			})
			first = false
		} else {
			cc.fr.WriteContinuation(streamID, endHeaders, chunk)
		}
	}
	
	
	
	
	cc.bw.Flush()
	return cc.werr
}
var (
	
	errStopReqBodyWrite = errors.New("http2: aborting request body write")
	
	errStopReqBodyWriteAndCancel = errors.New("http2: canceling request")
)
func (cs *clientStream) writeRequestBody(body io.Reader, bodyCloser io.Closer) (err error) {
	cc := cs.cc
	sentEnd := false 
	buf := cc.frameScratchBuffer()
	defer cc.putFrameScratchBuffer(buf)
	defer func() {
		traceWroteRequest(cs.trace, err)
		
		
		
		
		cerr := bodyCloser.Close()
		if err == nil {
			err = cerr
		}
	}()
	req := cs.req
	hasTrailers := req.Trailer != nil
	var sawEOF bool
	for !sawEOF {
		n, err := body.Read(buf)
		if err == io.EOF {
			sawEOF = true
			err = nil
		} else if err != nil {
			return err
		}
		remain := buf[:n]
		for len(remain) > 0 && err == nil {
			var allowed int32
			allowed, err = cs.awaitFlowControl(len(remain))
			switch {
			case err == errStopReqBodyWrite:
				return err
			case err == errStopReqBodyWriteAndCancel:
				cc.writeStreamReset(cs.ID, ErrCodeCancel, nil)
				return err
			case err != nil:
				return err
			}
			cc.wmu.Lock()
			data := remain[:allowed]
			remain = remain[allowed:]
			sentEnd = sawEOF && len(remain) == 0 && !hasTrailers
			err = cc.fr.WriteData(cs.ID, sentEnd, data)
			if err == nil {
				
				
				
				
				
				
				err = cc.bw.Flush()
			}
			cc.wmu.Unlock()
		}
		if err != nil {
			return err
		}
	}
	if sentEnd {
		
		
		
		return nil
	}
	var trls []byte
	if hasTrailers {
		cc.mu.Lock()
		defer cc.mu.Unlock()
		trls = cc.encodeTrailers(req)
	}
	cc.wmu.Lock()
	defer cc.wmu.Unlock()
	
	
	if len(trls) > 0 {
		err = cc.writeHeaders(cs.ID, true, trls)
	} else {
		err = cc.fr.WriteData(cs.ID, true, nil)
	}
	if ferr := cc.bw.Flush(); ferr != nil && err == nil {
		err = ferr
	}
	return err
}
func (cs *clientStream) awaitFlowControl(maxBytes int) (taken int32, err error) {
	cc := cs.cc
	cc.mu.Lock()
	defer cc.mu.Unlock()
	for {
		if cc.closed {
			return 0, errClientConnClosed
		}
		if cs.stopReqBody != nil {
			return 0, cs.stopReqBody
		}
		if err := cs.checkResetOrDone(); err != nil {
			return 0, err
		}
		if a := cs.flow.available(); a > 0 {
			take := a
			if int(take) > maxBytes {
				take = int32(maxBytes) 
			}
			if take > int32(cc.maxFrameSize) {
				take = int32(cc.maxFrameSize)
			}
			cs.flow.take(take)
			return take, nil
		}
		cc.cond.Wait()
	}
}
type badStringError struct {
	what string
	str  string
}
func (e *badStringError) Error() string { return fmt.Sprintf("%s %q", e.what, e.str) }
func (cc *ClientConn) encodeHeaders(req *http.Request, addGzipHeader bool, trailers string, contentLength int64) ([]byte, error) {
	cc.hbuf.Reset()
	host := req.Host
	if host == "" {
		host = req.URL.Host
	}
	host, err := httplex.PunycodeHostPort(host)
	if err != nil {
		return nil, err
	}
	var path string
	if req.Method != "CONNECT" {
		path = req.URL.RequestURI()
		if !validPseudoPath(path) {
			orig := path
			path = strings.TrimPrefix(path, req.URL.Scheme+":
			if !validPseudoPath(path) {
				if req.URL.Opaque != "" {
					return nil, fmt.Errorf("invalid request :path %q from URL.Opaque = %q", orig, req.URL.Opaque)
				} else {
					return nil, fmt.Errorf("invalid request :path %q", orig)
				}
			}
		}
	}
	
	
	
	for k, vv := range req.Header {
		if !httplex.ValidHeaderFieldName(k) {
			return nil, fmt.Errorf("invalid HTTP header name %q", k)
		}
		for _, v := range vv {
			if !httplex.ValidHeaderFieldValue(v) {
				return nil, fmt.Errorf("invalid HTTP header value %q for header %q", v, k)
			}
		}
	}
	
	
	
	
	
	cc.writeHeader(":authority", host)
	cc.writeHeader(":method", req.Method)
	if req.Method != "CONNECT" {
		cc.writeHeader(":path", path)
		cc.writeHeader(":scheme", req.URL.Scheme)
	}
	if trailers != "" {
		cc.writeHeader("trailer", trailers)
	}
	var didUA bool
	for k, vv := range req.Header {
		lowKey := strings.ToLower(k)
		switch lowKey {
		case "host", "content-length":
			
			
			continue
		case "connection", "proxy-connection", "transfer-encoding", "upgrade", "keep-alive":
			
			
			
			
			continue
		case "user-agent":
			
			
			
			
			didUA = true
			if len(vv) < 1 {
				continue
			}
			vv = vv[:1]
			if vv[0] == "" {
				continue
			}
		}
		for _, v := range vv {
			cc.writeHeader(lowKey, v)
		}
	}
	if shouldSendReqContentLength(req.Method, contentLength) {
		cc.writeHeader("content-length", strconv.FormatInt(contentLength, 10))
	}
	if addGzipHeader {
		cc.writeHeader("accept-encoding", "gzip")
	}
	if !didUA {
		cc.writeHeader("user-agent", defaultUserAgent)
	}
	return cc.hbuf.Bytes(), nil
}
func shouldSendReqContentLength(method string, contentLength int64) bool {
	if contentLength > 0 {
		return true
	}
	if contentLength < 0 {
		return false
	}
	
	
	switch method {
	case "POST", "PUT", "PATCH":
		return true
	default:
		return false
	}
}
func (cc *ClientConn) encodeTrailers(req *http.Request) []byte {
	cc.hbuf.Reset()
	for k, vv := range req.Trailer {
		
		
		lowKey := strings.ToLower(k)
		for _, v := range vv {
			cc.writeHeader(lowKey, v)
		}
	}
	return cc.hbuf.Bytes()
}
func (cc *ClientConn) writeHeader(name, value string) {
	if VerboseLogs {
		log.Printf("http2: Transport encoding header %q = %q", name, value)
	}
	cc.henc.WriteField(hpack.HeaderField{Name: name, Value: value})
}
type resAndError struct {
	res *http.Response
	err error
}
func (cc *ClientConn) newStream() *clientStream {
	cs := &clientStream{
		cc:        cc,
		ID:        cc.nextStreamID,
		resc:      make(chan resAndError, 1),
		peerReset: make(chan struct{}),
		done:      make(chan struct{}),
	}
	cs.flow.add(int32(cc.initialWindowSize))
	cs.flow.setConnFlow(&cc.flow)
	cs.inflow.add(transportDefaultStreamFlow)
	cs.inflow.setConnFlow(&cc.inflow)
	cc.nextStreamID += 2
	cc.streams[cs.ID] = cs
	return cs
}
func (cc *ClientConn) forgetStreamID(id uint32) {
	cc.streamByID(id, true)
}
func (cc *ClientConn) streamByID(id uint32, andRemove bool) *clientStream {
	cc.mu.Lock()
	defer cc.mu.Unlock()
	cs := cc.streams[id]
	if andRemove && cs != nil && !cc.closed {
		cc.lastActive = time.Now()
		delete(cc.streams, id)
		if len(cc.streams) == 0 && cc.idleTimer != nil {
			cc.idleTimer.Reset(cc.idleTimeout)
		}
		close(cs.done)
		
		
		cc.cond.Broadcast()
	}
	return cs
}
type clientConnReadLoop struct {
	cc            *ClientConn
	activeRes     map[uint32]*clientStream 
	closeWhenIdle bool
}
func (cc *ClientConn) readLoop() {
	rl := &clientConnReadLoop{
		cc:        cc,
		activeRes: make(map[uint32]*clientStream),
	}
	defer rl.cleanup()
	cc.readerErr = rl.run()
	if ce, ok := cc.readerErr.(ConnectionError); ok {
		cc.wmu.Lock()
		cc.fr.WriteGoAway(0, ErrCode(ce), nil)
		cc.wmu.Unlock()
	}
}
type GoAwayError struct {
	LastStreamID uint32
	ErrCode      ErrCode
	DebugData    string
}
func (e GoAwayError) Error() string {
	return fmt.Sprintf("http2: server sent GOAWAY and closed the connection; LastStreamID=%v, ErrCode=%v, debug=%q",
		e.LastStreamID, e.ErrCode, e.DebugData)
}
func isEOFOrNetReadError(err error) bool {
	if err == io.EOF {
		return true
	}
	ne, ok := err.(*net.OpError)
	return ok && ne.Op == "read"
}
func (rl *clientConnReadLoop) cleanup() {
	cc := rl.cc
	defer cc.tconn.Close()
	defer cc.t.connPool().MarkDead(cc)
	defer close(cc.readerDone)
	if cc.idleTimer != nil {
		cc.idleTimer.Stop()
	}
	
	
	
	err := cc.readerErr
	cc.mu.Lock()
	if cc.goAway != nil && isEOFOrNetReadError(err) {
		err = GoAwayError{
			LastStreamID: cc.goAway.LastStreamID,
			ErrCode:      cc.goAway.ErrCode,
			DebugData:    cc.goAwayDebug,
		}
	} else if err == io.EOF {
		err = io.ErrUnexpectedEOF
	}
	for _, cs := range rl.activeRes {
		cs.bufPipe.CloseWithError(err)
	}
	for _, cs := range cc.streams {
		select {
		case cs.resc <- resAndError{err: err}:
		default:
		}
		close(cs.done)
	}
	cc.closed = true
	cc.cond.Broadcast()
	cc.mu.Unlock()
}
func (rl *clientConnReadLoop) run() error {
	cc := rl.cc
	rl.closeWhenIdle = cc.t.disableKeepAlives() || cc.singleUse
	gotReply := false 
	gotSettings := false
	for {
		f, err := cc.fr.ReadFrame()
		if err != nil {
			cc.vlogf("http2: Transport readFrame error on conn %p: (%T) %v", cc, err, err)
		}
		if se, ok := err.(StreamError); ok {
			if cs := cc.streamByID(se.StreamID, false); cs != nil {
				cs.cc.writeStreamReset(cs.ID, se.Code, err)
				cs.cc.forgetStreamID(cs.ID)
				if se.Cause == nil {
					se.Cause = cc.fr.errDetail
				}
				rl.endStreamError(cs, se)
			}
			continue
		} else if err != nil {
			return err
		}
		if VerboseLogs {
			cc.vlogf("http2: Transport received %s", summarizeFrame(f))
		}
		if !gotSettings {
			if _, ok := f.(*SettingsFrame); !ok {
				cc.logf("protocol error: received %T before a SETTINGS frame", f)
				return ConnectionError(ErrCodeProtocol)
			}
			gotSettings = true
		}
		maybeIdle := false 
		switch f := f.(type) {
		case *MetaHeadersFrame:
			err = rl.processHeaders(f)
			maybeIdle = true
			gotReply = true
		case *DataFrame:
			err = rl.processData(f)
			maybeIdle = true
		case *GoAwayFrame:
			err = rl.processGoAway(f)
			maybeIdle = true
		case *RSTStreamFrame:
			err = rl.processResetStream(f)
			maybeIdle = true
		case *SettingsFrame:
			err = rl.processSettings(f)
		case *PushPromiseFrame:
			err = rl.processPushPromise(f)
		case *WindowUpdateFrame:
			err = rl.processWindowUpdate(f)
		case *PingFrame:
			err = rl.processPing(f)
		default:
			cc.logf("Transport: unhandled response frame type %T", f)
		}
		if err != nil {
			if VerboseLogs {
				cc.vlogf("http2: Transport conn %p received error from processing frame %v: %v", cc, summarizeFrame(f), err)
			}
			return err
		}
		if rl.closeWhenIdle && gotReply && maybeIdle && len(rl.activeRes) == 0 {
			cc.closeIfIdle()
		}
	}
}
func (rl *clientConnReadLoop) processHeaders(f *MetaHeadersFrame) error {
	cc := rl.cc
	cs := cc.streamByID(f.StreamID, f.StreamEnded())
	if cs == nil {
		
		
		
		return nil
	}
	if !cs.firstByte {
		if cs.trace != nil {
			
			
			
			
			traceFirstResponseByte(cs.trace)
		}
		cs.firstByte = true
	}
	if !cs.pastHeaders {
		cs.pastHeaders = true
	} else {
		return rl.processTrailers(cs, f)
	}
	res, err := rl.handleResponse(cs, f)
	if err != nil {
		if _, ok := err.(ConnectionError); ok {
			return err
		}
		
		cs.cc.writeStreamReset(f.StreamID, ErrCodeProtocol, err)
		cs.resc <- resAndError{err: err}
		return nil 
	}
	if res == nil {
		
		return nil
	}
	if res.Body != noBody {
		rl.activeRes[cs.ID] = cs
	}
	cs.resTrailer = &res.Trailer
	cs.resc <- resAndError{res: res}
	return nil
}
func (rl *clientConnReadLoop) handleResponse(cs *clientStream, f *MetaHeadersFrame) (*http.Response, error) {
	if f.Truncated {
		return nil, errResponseHeaderListSize
	}
	status := f.PseudoValue("status")
	if status == "" {
		return nil, errors.New("missing status pseudo header")
	}
	statusCode, err := strconv.Atoi(status)
	if err != nil {
		return nil, errors.New("malformed non-numeric status pseudo header")
	}
	if statusCode == 100 {
		traceGot100Continue(cs.trace)
		if cs.on100 != nil {
			cs.on100() 
		}
		cs.pastHeaders = false 
		return nil, nil
	}
	header := make(http.Header)
	res := &http.Response{
		Proto:      "HTTP
		ProtoMajor: 2,
		Header:     header,
		StatusCode: statusCode,
		Status:     status + " " + http.StatusText(statusCode),
	}
	for _, hf := range f.RegularFields() {
		key := http.CanonicalHeaderKey(hf.Name)
		if key == "Trailer" {
			t := res.Trailer
			if t == nil {
				t = make(http.Header)
				res.Trailer = t
			}
			foreachHeaderElement(hf.Value, func(v string) {
				t[http.CanonicalHeaderKey(v)] = nil
			})
		} else {
			header[key] = append(header[key], hf.Value)
		}
	}
	streamEnded := f.StreamEnded()
	isHead := cs.req.Method == "HEAD"
	if !streamEnded || isHead {
		res.ContentLength = -1
		if clens := res.Header["Content-Length"]; len(clens) == 1 {
			if clen64, err := strconv.ParseInt(clens[0], 10, 64); err == nil {
				res.ContentLength = clen64
			} else {
				
				
			}
		} else if len(clens) > 1 {
			
			
		}
	}
	if streamEnded || isHead {
		res.Body = noBody
		return res, nil
	}
	cs.bufPipe = pipe{b: &dataBuffer{expected: res.ContentLength}}
	cs.bytesRemain = res.ContentLength
	res.Body = transportResponseBody{cs}
	go cs.awaitRequestCancel(cs.req)
	if cs.requestedGzip && res.Header.Get("Content-Encoding") == "gzip" {
		res.Header.Del("Content-Encoding")
		res.Header.Del("Content-Length")
		res.ContentLength = -1
		res.Body = &gzipReader{body: res.Body}
		setResponseUncompressed(res)
	}
	return res, nil
}
func (rl *clientConnReadLoop) processTrailers(cs *clientStream, f *MetaHeadersFrame) error {
	if cs.pastTrailers {
		
		return ConnectionError(ErrCodeProtocol)
	}
	cs.pastTrailers = true
	if !f.StreamEnded() {
		
		
		return ConnectionError(ErrCodeProtocol)
	}
	if len(f.PseudoFields()) > 0 {
		
		
		return ConnectionError(ErrCodeProtocol)
	}
	trailer := make(http.Header)
	for _, hf := range f.RegularFields() {
		key := http.CanonicalHeaderKey(hf.Name)
		trailer[key] = append(trailer[key], hf.Value)
	}
	cs.trailer = trailer
	rl.endStream(cs)
	return nil
}
type transportResponseBody struct {
	cs *clientStream
}
func (b transportResponseBody) Read(p []byte) (n int, err error) {
	cs := b.cs
	cc := cs.cc
	if cs.readErr != nil {
		return 0, cs.readErr
	}
	n, err = b.cs.bufPipe.Read(p)
	if cs.bytesRemain != -1 {
		if int64(n) > cs.bytesRemain {
			n = int(cs.bytesRemain)
			if err == nil {
				err = errors.New("net
				cc.writeStreamReset(cs.ID, ErrCodeProtocol, err)
			}
			cs.readErr = err
			return int(cs.bytesRemain), err
		}
		cs.bytesRemain -= int64(n)
		if err == io.EOF && cs.bytesRemain > 0 {
			err = io.ErrUnexpectedEOF
			cs.readErr = err
			return n, err
		}
	}
	if n == 0 {
		
		return
	}
	cc.mu.Lock()
	defer cc.mu.Unlock()
	var connAdd, streamAdd int32
	
	if v := cc.inflow.available(); v < transportDefaultConnFlow
		connAdd = transportDefaultConnFlow - v
		cc.inflow.add(connAdd)
	}
	if err == nil { 
		
		
		
		v := int(cs.inflow.available()) + cs.bufPipe.Len()
		if v < transportDefaultStreamFlow-transportDefaultStreamMinRefresh {
			streamAdd = int32(transportDefaultStreamFlow - v)
			cs.inflow.add(streamAdd)
		}
	}
	if connAdd != 0 || streamAdd != 0 {
		cc.wmu.Lock()
		defer cc.wmu.Unlock()
		if connAdd != 0 {
			cc.fr.WriteWindowUpdate(0, mustUint31(connAdd))
		}
		if streamAdd != 0 {
			cc.fr.WriteWindowUpdate(cs.ID, mustUint31(streamAdd))
		}
		cc.bw.Flush()
	}
	return
}
var errClosedResponseBody = errors.New("http2: response body closed")
func (b transportResponseBody) Close() error {
	cs := b.cs
	cc := cs.cc
	serverSentStreamEnd := cs.bufPipe.Err() == io.EOF
	unread := cs.bufPipe.Len()
	if unread > 0 || !serverSentStreamEnd {
		cc.mu.Lock()
		cc.wmu.Lock()
		if !serverSentStreamEnd {
			cc.fr.WriteRSTStream(cs.ID, ErrCodeCancel)
			cs.didReset = true
		}
		
		if unread > 0 {
			cc.inflow.add(int32(unread))
			cc.fr.WriteWindowUpdate(0, uint32(unread))
		}
		cc.bw.Flush()
		cc.wmu.Unlock()
		cc.mu.Unlock()
	}
	cs.bufPipe.BreakWithError(errClosedResponseBody)
	cc.forgetStreamID(cs.ID)
	return nil
}
func (rl *clientConnReadLoop) processData(f *DataFrame) error {
	cc := rl.cc
	cs := cc.streamByID(f.StreamID, f.StreamEnded())
	data := f.Data()
	if cs == nil {
		cc.mu.Lock()
		neverSent := cc.nextStreamID
		cc.mu.Unlock()
		if f.StreamID >= neverSent {
			
			cc.logf("http2: Transport received unsolicited DATA frame; closing connection")
			return ConnectionError(ErrCodeProtocol)
		}
		
		
		
		
		
		if f.Length > 0 {
			cc.mu.Lock()
			cc.inflow.add(int32(f.Length))
			cc.mu.Unlock()
			cc.wmu.Lock()
			cc.fr.WriteWindowUpdate(0, uint32(f.Length))
			cc.bw.Flush()
			cc.wmu.Unlock()
		}
		return nil
	}
	if f.Length > 0 {
		
		cc.mu.Lock()
		if cs.inflow.available() >= int32(f.Length) {
			cs.inflow.take(int32(f.Length))
		} else {
			cc.mu.Unlock()
			return ConnectionError(ErrCodeFlowControl)
		}
		
		
		var refund int
		if pad := int(f.Length) - len(data); pad > 0 {
			refund += pad
		}
		
		
		didReset := cs.didReset
		if didReset {
			refund += len(data)
		}
		if refund > 0 {
			cc.inflow.add(int32(refund))
			cc.wmu.Lock()
			cc.fr.WriteWindowUpdate(0, uint32(refund))
			if !didReset {
				cs.inflow.add(int32(refund))
				cc.fr.WriteWindowUpdate(cs.ID, uint32(refund))
			}
			cc.bw.Flush()
			cc.wmu.Unlock()
		}
		cc.mu.Unlock()
		if len(data) > 0 && !didReset {
			if _, err := cs.bufPipe.Write(data); err != nil {
				rl.endStreamError(cs, err)
				return err
			}
		}
	}
	if f.StreamEnded() {
		rl.endStream(cs)
	}
	return nil
}
var errInvalidTrailers = errors.New("http2: invalid trailers")
func (rl *clientConnReadLoop) endStream(cs *clientStream) {
	
	
	rl.endStreamError(cs, nil)
}
func (rl *clientConnReadLoop) endStreamError(cs *clientStream, err error) {
	var code func()
	if err == nil {
		err = io.EOF
		code = cs.copyTrailers
	}
	cs.bufPipe.closeWithErrorAndCode(err, code)
	delete(rl.activeRes, cs.ID)
	if isConnectionCloseRequest(cs.req) {
		rl.closeWhenIdle = true
	}
	select {
	case cs.resc <- resAndError{err: err}:
	default:
	}
}
func (cs *clientStream) copyTrailers() {
	for k, vv := range cs.trailer {
		t := cs.resTrailer
		if *t == nil {
			*t = make(http.Header)
		}
		(*t)[k] = vv
	}
}
func (rl *clientConnReadLoop) processGoAway(f *GoAwayFrame) error {
	cc := rl.cc
	cc.t.connPool().MarkDead(cc)
	if f.ErrCode != 0 {
		
		cc.vlogf("transport got GOAWAY with error code = %v", f.ErrCode)
	}
	cc.setGoAway(f)
	return nil
}
func (rl *clientConnReadLoop) processSettings(f *SettingsFrame) error {
	cc := rl.cc
	cc.mu.Lock()
	defer cc.mu.Unlock()
	if f.IsAck() {
		if cc.wantSettingsAck {
			cc.wantSettingsAck = false
			return nil
		}
		return ConnectionError(ErrCodeProtocol)
	}
	err := f.ForeachSetting(func(s Setting) error {
		switch s.ID {
		case SettingMaxFrameSize:
			cc.maxFrameSize = s.Val
		case SettingMaxConcurrentStreams:
			cc.maxConcurrentStreams = s.Val
		case SettingInitialWindowSize:
			
			
			
			
			if s.Val > math.MaxInt32 {
				return ConnectionError(ErrCodeFlowControl)
			}
			
			
			
			delta := int32(s.Val) - int32(cc.initialWindowSize)
			for _, cs := range cc.streams {
				cs.flow.add(delta)
			}
			cc.cond.Broadcast()
			cc.initialWindowSize = s.Val
		default:
			
			cc.vlogf("Unhandled Setting: %v", s)
		}
		return nil
	})
	if err != nil {
		return err
	}
	cc.wmu.Lock()
	defer cc.wmu.Unlock()
	cc.fr.WriteSettingsAck()
	cc.bw.Flush()
	return cc.werr
}
func (rl *clientConnReadLoop) processWindowUpdate(f *WindowUpdateFrame) error {
	cc := rl.cc
	cs := cc.streamByID(f.StreamID, false)
	if f.StreamID != 0 && cs == nil {
		return nil
	}
	cc.mu.Lock()
	defer cc.mu.Unlock()
	fl := &cc.flow
	if cs != nil {
		fl = &cs.flow
	}
	if !fl.add(int32(f.Increment)) {
		return ConnectionError(ErrCodeFlowControl)
	}
	cc.cond.Broadcast()
	return nil
}
func (rl *clientConnReadLoop) processResetStream(f *RSTStreamFrame) error {
	cs := rl.cc.streamByID(f.StreamID, true)
	if cs == nil {
		
		return nil
	}
	select {
	case <-cs.peerReset:
		
		
		
		
	default:
		err := streamError(cs.ID, f.ErrCode)
		cs.resetErr = err
		close(cs.peerReset)
		cs.bufPipe.CloseWithError(err)
		cs.cc.cond.Broadcast() 
	}
	delete(rl.activeRes, cs.ID)
	return nil
}
func (cc *ClientConn) ping(ctx contextContext) error {
	c := make(chan struct{})
	
	var p [8]byte
	for {
		if _, err := rand.Read(p[:]); err != nil {
			return err
		}
		cc.mu.Lock()
		
		if _, found := cc.pings[p]; !found {
			cc.pings[p] = c
			cc.mu.Unlock()
			break
		}
		cc.mu.Unlock()
	}
	cc.wmu.Lock()
	if err := cc.fr.WritePing(false, p); err != nil {
		cc.wmu.Unlock()
		return err
	}
	if err := cc.bw.Flush(); err != nil {
		cc.wmu.Unlock()
		return err
	}
	cc.wmu.Unlock()
	select {
	case <-c:
		return nil
	case <-ctx.Done():
		return ctx.Err()
	case <-cc.readerDone:
		
		return cc.readerErr
	}
}
func (rl *clientConnReadLoop) processPing(f *PingFrame) error {
	if f.IsAck() {
		cc := rl.cc
		cc.mu.Lock()
		defer cc.mu.Unlock()
		
		if c, ok := cc.pings[f.Data]; ok {
			close(c)
			delete(cc.pings, f.Data)
		}
		return nil
	}
	cc := rl.cc
	cc.wmu.Lock()
	defer cc.wmu.Unlock()
	if err := cc.fr.WritePing(true, f.Data); err != nil {
		return err
	}
	return cc.bw.Flush()
}
func (rl *clientConnReadLoop) processPushPromise(f *PushPromiseFrame) error {
	
	
	
	
	
	
	
	return ConnectionError(ErrCodeProtocol)
}
func (cc *ClientConn) writeStreamReset(streamID uint32, code ErrCode, err error) {
	
	
	
	
	cc.wmu.Lock()
	cc.fr.WriteRSTStream(streamID, code)
	cc.bw.Flush()
	cc.wmu.Unlock()
}
var (
	errResponseHeaderListSize = errors.New("http2: response header list larger than advertised limit")
	errPseudoTrailers         = errors.New("http2: invalid pseudo header in trailers")
)
func (cc *ClientConn) logf(format string, args ...interface{}) {
	cc.t.logf(format, args...)
}
func (cc *ClientConn) vlogf(format string, args ...interface{}) {
	cc.t.vlogf(format, args...)
}
func (t *Transport) vlogf(format string, args ...interface{}) {
	if VerboseLogs {
		t.logf(format, args...)
	}
}
func (t *Transport) logf(format string, args ...interface{}) {
	log.Printf(format, args...)
}
var noBody io.ReadCloser = ioutil.NopCloser(bytes.NewReader(nil))
func strSliceContains(ss []string, s string) bool {
	for _, v := range ss {
		if v == s {
			return true
		}
	}
	return false
}
type erringRoundTripper struct{ err error }
func (rt erringRoundTripper) RoundTrip(*http.Request) (*http.Response, error) { return nil, rt.err }
type gzipReader struct {
	body io.ReadCloser 
	zr   *gzip.Reader  
	zerr error         
}
func (gz *gzipReader) Read(p []byte) (n int, err error) {
	if gz.zerr != nil {
		return 0, gz.zerr
	}
	if gz.zr == nil {
		gz.zr, err = gzip.NewReader(gz.body)
		if err != nil {
			gz.zerr = err
			return 0, err
		}
	}
	return gz.zr.Read(p)
}
func (gz *gzipReader) Close() error {
	return gz.body.Close()
}
type errorReader struct{ err error }
func (r errorReader) Read(p []byte) (int, error) { return 0, r.err }
type bodyWriterState struct {
	cs     *clientStream
	timer  *time.Timer   
	fnonce *sync.Once    
	fn     func()        
	resc   chan error    
	delay  time.Duration 
}
func (t *Transport) getBodyWriterState(cs *clientStream, body io.Reader) (s bodyWriterState) {
	s.cs = cs
	if body == nil {
		return
	}
	resc := make(chan error, 1)
	s.resc = resc
	s.fn = func() {
		cs.cc.mu.Lock()
		cs.startedWrite = true
		cs.cc.mu.Unlock()
		resc <- cs.writeRequestBody(body, cs.req.Body)
	}
	s.delay = t.expectContinueTimeout()
	if s.delay == 0 ||
		!httplex.HeaderValuesContainsToken(
			cs.req.Header["Expect"],
			"100-continue") {
		return
	}
	s.fnonce = new(sync.Once)
	
	
	
	
	
	const hugeDuration = 365 * 24 * time.Hour
	s.timer = time.AfterFunc(hugeDuration, func() {
		s.fnonce.Do(s.fn)
	})
	return
}
func (s bodyWriterState) cancel() {
	if s.timer != nil {
		s.timer.Stop()
	}
}
func (s bodyWriterState) on100() {
	if s.timer == nil {
		
		
		return
	}
	s.timer.Stop()
	go func() { s.fnonce.Do(s.fn) }()
}
func (s bodyWriterState) scheduleBodyWrite() {
	if s.timer == nil {
		
		
		
		go s.fn()
		return
	}
	traceWait100Continue(s.cs.trace)
	if s.timer.Stop() {
		s.timer.Reset(s.delay)
	}
}
func isConnectionCloseRequest(req *http.Request) bool {
	return req.Close || httplex.HeaderValuesContainsToken(req.Header["Connection"], "close")
}
package http2
import (
	"net
)
func configureServer19(s *http.Server, conf *Server) error {
	
	return nil
}
package http2
import (
	"crypto
	"net"
	"net
	"time"
)
type contextContext interface {
	Done() <-chan struct{}
	Err() error
}
type fakeContext struct{}
func (fakeContext) Done() <-chan struct{} { return nil }
func (fakeContext) Err() error            { panic("should not be called") }
func reqContext(r *http.Request) fakeContext {
	return fakeContext{}
}
func setResponseUncompressed(res *http.Response) {
	
}
type clientTrace struct{}
func requestTrace(*http.Request) *clientTrace { return nil }
func traceGotConn(*http.Request, *ClientConn) {}
func traceFirstResponseByte(*clientTrace)     {}
func traceWroteHeaders(*clientTrace)          {}
func traceWroteRequest(*clientTrace, error)   {}
func traceGot100Continue(trace *clientTrace)  {}
func traceWait100Continue(trace *clientTrace) {}
func nop() {}
func serverConnBaseContext(c net.Conn, opts *ServeConnOpts) (ctx contextContext, cancel func()) {
	return nil, nop
}
func contextWithCancel(ctx contextContext) (_ contextContext, cancel func()) {
	return ctx, nop
}
func requestWithContext(req *http.Request, ctx contextContext) *http.Request {
	return req
}
func cloneTLSConfig(c *tls.Config) *tls.Config {
	return &tls.Config{
		Rand:                     c.Rand,
		Time:                     c.Time,
		Certificates:             c.Certificates,
		NameToCertificate:        c.NameToCertificate,
		GetCertificate:           c.GetCertificate,
		RootCAs:                  c.RootCAs,
		NextProtos:               c.NextProtos,
		ServerName:               c.ServerName,
		ClientAuth:               c.ClientAuth,
		ClientCAs:                c.ClientCAs,
		InsecureSkipVerify:       c.InsecureSkipVerify,
		CipherSuites:             c.CipherSuites,
		PreferServerCipherSuites: c.PreferServerCipherSuites,
		SessionTicketsDisabled:   c.SessionTicketsDisabled,
		SessionTicketKey:         c.SessionTicketKey,
		ClientSessionCache:       c.ClientSessionCache,
		MinVersion:               c.MinVersion,
		MaxVersion:               c.MaxVersion,
		CurvePreferences:         c.CurvePreferences,
	}
}
func (cc *ClientConn) Ping(ctx contextContext) error {
	return cc.ping(ctx)
}
func (t *Transport) idleConnTimeout() time.Duration { return 0 }
package http2
import (
	"bufio"
	"bytes"
	"crypto
	"errors"
	"flag"
	"fmt"
	"io"
	"io
	"math
	"net"
	"net
	"net
	"os"
	"reflect"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"sync"
	"sync
	"testing"
	"time"
	"golang.org
)
var (
	extNet        = flag.Bool("extnet", false, "do external network tests")
	transportHost = flag.String("transporthost", "http2.golang.org", "hostname to use for TestTransport")
	insecure      = flag.Bool("insecure", false, "insecure TLS dials") 
)
var tlsConfigInsecure = &tls.Config{InsecureSkipVerify: true}
type testContext struct{}
func (testContext) Done() <-chan struct{}                   { return make(chan struct{}) }
func (testContext) Err() error                              { panic("should not be called") }
func (testContext) Deadline() (deadline time.Time, ok bool) { return time.Time{}, false }
func (testContext) Value(key interface{}) interface{}       { return nil }
func TestTransportExternal(t *testing.T) {
	if !*extNet {
		t.Skip("skipping external network test")
	}
	req, _ := http.NewRequest("GET", "https:
	rt := &Transport{TLSClientConfig: tlsConfigInsecure}
	res, err := rt.RoundTrip(req)
	if err != nil {
		t.Fatalf("%v", err)
	}
	res.Write(os.Stdout)
}
type fakeTLSConn struct {
	net.Conn
}
func (c *fakeTLSConn) ConnectionState() tls.ConnectionState {
	return tls.ConnectionState{
		Version:     tls.VersionTLS12,
		CipherSuite: cipher_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
	}
}
func startH2cServer(t *testing.T) net.Listener {
	h2Server := &Server{}
	l := newLocalListener(t)
	go func() {
		conn, err := l.Accept()
		if err != nil {
			t.Error(err)
			return
		}
		h2Server.ServeConn(&fakeTLSConn{conn}, &ServeConnOpts{Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			fmt.Fprintf(w, "Hello, %v, http: %v", r.URL.Path, r.TLS == nil)
		})})
	}()
	return l
}
func TestTransportH2c(t *testing.T) {
	l := startH2cServer(t)
	defer l.Close()
	req, err := http.NewRequest("GET", "http:
	if err != nil {
		t.Fatal(err)
	}
	tr := &Transport{
		AllowHTTP: true,
		DialTLS: func(network, addr string, cfg *tls.Config) (net.Conn, error) {
			return net.Dial(network, addr)
		},
	}
	res, err := tr.RoundTrip(req)
	if err != nil {
		t.Fatal(err)
	}
	if res.ProtoMajor != 2 {
		t.Fatal("proto not h2c")
	}
	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		t.Fatal(err)
	}
	if got, want := string(body), "Hello, 
		t.Fatalf("response got %v, want %v", got, want)
	}
}
func TestTransport(t *testing.T) {
	const body = "sup"
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		io.WriteString(w, body)
	}, optOnlyServer)
	defer st.Close()
	tr := &Transport{TLSClientConfig: tlsConfigInsecure}
	defer tr.CloseIdleConnections()
	req, err := http.NewRequest("GET", st.ts.URL, nil)
	if err != nil {
		t.Fatal(err)
	}
	res, err := tr.RoundTrip(req)
	if err != nil {
		t.Fatal(err)
	}
	defer res.Body.Close()
	t.Logf("Got res: %+v", res)
	if g, w := res.StatusCode, 200; g != w {
		t.Errorf("StatusCode = %v; want %v", g, w)
	}
	if g, w := res.Status, "200 OK"; g != w {
		t.Errorf("Status = %q; want %q", g, w)
	}
	wantHeader := http.Header{
		"Content-Length": []string{"3"},
		"Content-Type":   []string{"text
		"Date":           []string{"XXX"}, 
	}
	cleanDate(res)
	if !reflect.DeepEqual(res.Header, wantHeader) {
		t.Errorf("res Header = %v; want %v", res.Header, wantHeader)
	}
	if res.Request != req {
		t.Errorf("Response.Request = %p; want %p", res.Request, req)
	}
	if res.TLS == nil {
		t.Error("Response.TLS = nil; want non-nil")
	}
	slurp, err := ioutil.ReadAll(res.Body)
	if err != nil {
		t.Errorf("Body read: %v", err)
	} else if string(slurp) != body {
		t.Errorf("Body = %q; want %q", slurp, body)
	}
}
func onSameConn(t *testing.T, modReq func(*http.Request)) bool {
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		io.WriteString(w, r.RemoteAddr)
	}, optOnlyServer, func(c net.Conn, st http.ConnState) {
		t.Logf("conn %v is now state %v", c.RemoteAddr(), st)
	})
	defer st.Close()
	tr := &Transport{TLSClientConfig: tlsConfigInsecure}
	defer tr.CloseIdleConnections()
	get := func() string {
		req, err := http.NewRequest("GET", st.ts.URL, nil)
		if err != nil {
			t.Fatal(err)
		}
		modReq(req)
		res, err := tr.RoundTrip(req)
		if err != nil {
			t.Fatal(err)
		}
		defer res.Body.Close()
		slurp, err := ioutil.ReadAll(res.Body)
		if err != nil {
			t.Fatalf("Body read: %v", err)
		}
		addr := strings.TrimSpace(string(slurp))
		if addr == "" {
			t.Fatalf("didn't get an addr in response")
		}
		return addr
	}
	first := get()
	second := get()
	return first == second
}
func TestTransportReusesConns(t *testing.T) {
	if !onSameConn(t, func(*http.Request) {}) {
		t.Errorf("first and second responses were on different connections")
	}
}
func TestTransportReusesConn_RequestClose(t *testing.T) {
	if onSameConn(t, func(r *http.Request) { r.Close = true }) {
		t.Errorf("first and second responses were not on different connections")
	}
}
func TestTransportReusesConn_ConnClose(t *testing.T) {
	if onSameConn(t, func(r *http.Request) { r.Header.Set("Connection", "close") }) {
		t.Errorf("first and second responses were not on different connections")
	}
}
func TestTransportGroupsPendingDials(t *testing.T) {
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		io.WriteString(w, r.RemoteAddr)
	}, optOnlyServer)
	defer st.Close()
	tr := &Transport{
		TLSClientConfig: tlsConfigInsecure,
	}
	defer tr.CloseIdleConnections()
	var (
		mu    sync.Mutex
		dials = map[string]int{}
	)
	var wg sync.WaitGroup
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			req, err := http.NewRequest("GET", st.ts.URL, nil)
			if err != nil {
				t.Error(err)
				return
			}
			res, err := tr.RoundTrip(req)
			if err != nil {
				t.Error(err)
				return
			}
			defer res.Body.Close()
			slurp, err := ioutil.ReadAll(res.Body)
			if err != nil {
				t.Errorf("Body read: %v", err)
			}
			addr := strings.TrimSpace(string(slurp))
			if addr == "" {
				t.Errorf("didn't get an addr in response")
			}
			mu.Lock()
			dials[addr]++
			mu.Unlock()
		}()
	}
	wg.Wait()
	if len(dials) != 1 {
		t.Errorf("saw %d dials; want 1: %v", len(dials), dials)
	}
	tr.CloseIdleConnections()
	if err := retry(50, 10*time.Millisecond, func() error {
		cp, ok := tr.connPool().(*clientConnPool)
		if !ok {
			return fmt.Errorf("Conn pool is %T; want *clientConnPool", tr.connPool())
		}
		cp.mu.Lock()
		defer cp.mu.Unlock()
		if len(cp.dialing) != 0 {
			return fmt.Errorf("dialing map = %v; want empty", cp.dialing)
		}
		if len(cp.conns) != 0 {
			return fmt.Errorf("conns = %v; want empty", cp.conns)
		}
		if len(cp.keys) != 0 {
			return fmt.Errorf("keys = %v; want empty", cp.keys)
		}
		return nil
	}); err != nil {
		t.Errorf("State of pool after CloseIdleConnections: %v", err)
	}
}
func retry(tries int, delay time.Duration, fn func() error) error {
	var err error
	for i := 0; i < tries; i++ {
		err = fn()
		if err == nil {
			return nil
		}
		time.Sleep(delay)
	}
	return err
}
func TestTransportAbortClosesPipes(t *testing.T) {
	shutdown := make(chan struct{})
	st := newServerTester(t,
		func(w http.ResponseWriter, r *http.Request) {
			w.(http.Flusher).Flush()
			<-shutdown
		},
		optOnlyServer,
	)
	defer st.Close()
	defer close(shutdown) 
	done := make(chan struct{})
	requestMade := make(chan struct{})
	go func() {
		defer close(done)
		tr := &Transport{TLSClientConfig: tlsConfigInsecure}
		req, err := http.NewRequest("GET", st.ts.URL, nil)
		if err != nil {
			t.Fatal(err)
		}
		res, err := tr.RoundTrip(req)
		if err != nil {
			t.Fatal(err)
		}
		defer res.Body.Close()
		close(requestMade)
		_, err = ioutil.ReadAll(res.Body)
		if err == nil {
			t.Error("expected error from res.Body.Read")
		}
	}()
	<-requestMade
	
	st.closeConn()
	
	select {
	case <-done:
	case <-time.After(3 * time.Second):
		t.Fatal("timeout")
	}
}
func TestTransportPath(t *testing.T) {
	gotc := make(chan *url.URL, 1)
	st := newServerTester(t,
		func(w http.ResponseWriter, r *http.Request) {
			gotc <- r.URL
		},
		optOnlyServer,
	)
	defer st.Close()
	tr := &Transport{TLSClientConfig: tlsConfigInsecure}
	defer tr.CloseIdleConnections()
	const (
		path  = "
		query = "q=1"
	)
	surl := st.ts.URL + path + "?" + query
	req, err := http.NewRequest("POST", surl, nil)
	if err != nil {
		t.Fatal(err)
	}
	c := &http.Client{Transport: tr}
	res, err := c.Do(req)
	if err != nil {
		t.Fatal(err)
	}
	defer res.Body.Close()
	got := <-gotc
	if got.Path != path {
		t.Errorf("Read Path = %q; want %q", got.Path, path)
	}
	if got.RawQuery != query {
		t.Errorf("Read RawQuery = %q; want %q", got.RawQuery, query)
	}
}
func randString(n int) string {
	rnd := rand.New(rand.NewSource(int64(n)))
	b := make([]byte, n)
	for i := range b {
		b[i] = byte(rnd.Intn(256))
	}
	return string(b)
}
type panicReader struct{}
func (panicReader) Read([]byte) (int, error) { panic("unexpected Read") }
func (panicReader) Close() error             { panic("unexpected Close") }
func TestActualContentLength(t *testing.T) {
	tests := []struct {
		req  *http.Request
		want int64
	}{
		
		0: {
			req:  &http.Request{Body: panicReader{}},
			want: -1,
		},
		
		1: {
			req:  &http.Request{Body: nil, ContentLength: 5},
			want: 0,
		},
		
		2: {
			req:  &http.Request{Body: panicReader{}, ContentLength: 5},
			want: 5,
		},
		
		3: {
			req:  &http.Request{Body: go18httpNoBody()},
			want: 0,
		},
	}
	for i, tt := range tests {
		got := actualContentLength(tt.req)
		if got != tt.want {
			t.Errorf("test[%d]: got %d; want %d", i, got, tt.want)
		}
	}
}
func TestTransportBody(t *testing.T) {
	bodyTests := []struct {
		body         string
		noContentLen bool
	}{
		{body: "some message"},
		{body: "some message", noContentLen: true},
		{body: strings.Repeat("a", 1<<20), noContentLen: true},
		{body: strings.Repeat("a", 1<<20)},
		{body: randString(16<<10 - 1)},
		{body: randString(16 << 10)},
		{body: randString(16<<10 + 1)},
		{body: randString(512<<10 - 1)},
		{body: randString(512 << 10)},
		{body: randString(512<<10 + 1)},
		{body: randString(1<<20 - 1)},
		{body: randString(1 << 20)},
		{body: randString(1<<20 + 2)},
	}
	type reqInfo struct {
		req   *http.Request
		slurp []byte
		err   error
	}
	gotc := make(chan reqInfo, 1)
	st := newServerTester(t,
		func(w http.ResponseWriter, r *http.Request) {
			slurp, err := ioutil.ReadAll(r.Body)
			if err != nil {
				gotc <- reqInfo{err: err}
			} else {
				gotc <- reqInfo{req: r, slurp: slurp}
			}
		},
		optOnlyServer,
	)
	defer st.Close()
	for i, tt := range bodyTests {
		tr := &Transport{TLSClientConfig: tlsConfigInsecure}
		defer tr.CloseIdleConnections()
		var body io.Reader = strings.NewReader(tt.body)
		if tt.noContentLen {
			body = struct{ io.Reader }{body} 
		}
		req, err := http.NewRequest("POST", st.ts.URL, body)
		if err != nil {
			t.Fatalf("#%d: %v", i, err)
		}
		c := &http.Client{Transport: tr}
		res, err := c.Do(req)
		if err != nil {
			t.Fatalf("#%d: %v", i, err)
		}
		defer res.Body.Close()
		ri := <-gotc
		if ri.err != nil {
			t.Errorf("#%d: read error: %v", i, ri.err)
			continue
		}
		if got := string(ri.slurp); got != tt.body {
			t.Errorf("#%d: Read body mismatch.\n got: %q (len %d)\nwant: %q (len %d)", i, shortString(got), len(got), shortString(tt.body), len(tt.body))
		}
		wantLen := int64(len(tt.body))
		if tt.noContentLen && tt.body != "" {
			wantLen = -1
		}
		if ri.req.ContentLength != wantLen {
			t.Errorf("#%d. handler got ContentLength = %v; want %v", i, ri.req.ContentLength, wantLen)
		}
	}
}
func shortString(v string) string {
	const maxLen = 100
	if len(v) <= maxLen {
		return v
	}
	return fmt.Sprintf("%v[...%d bytes omitted...]%v", v[:maxLen
}
func TestTransportDialTLS(t *testing.T) {
	var mu sync.Mutex 
	var gotReq, didDial bool
	ts := newServerTester(t,
		func(w http.ResponseWriter, r *http.Request) {
			mu.Lock()
			gotReq = true
			mu.Unlock()
		},
		optOnlyServer,
	)
	defer ts.Close()
	tr := &Transport{
		DialTLS: func(netw, addr string, cfg *tls.Config) (net.Conn, error) {
			mu.Lock()
			didDial = true
			mu.Unlock()
			cfg.InsecureSkipVerify = true
			c, err := tls.Dial(netw, addr, cfg)
			if err != nil {
				return nil, err
			}
			return c, c.Handshake()
		},
	}
	defer tr.CloseIdleConnections()
	client := &http.Client{Transport: tr}
	res, err := client.Get(ts.ts.URL)
	if err != nil {
		t.Fatal(err)
	}
	res.Body.Close()
	mu.Lock()
	if !gotReq {
		t.Error("didn't get request")
	}
	if !didDial {
		t.Error("didn't use dial hook")
	}
}
func TestConfigureTransport(t *testing.T) {
	t1 := &http.Transport{}
	err := ConfigureTransport(t1)
	if err == errTransportVersion {
		t.Skip(err)
	}
	if err != nil {
		t.Fatal(err)
	}
	if got := fmt.Sprintf("%#v", t1); !strings.Contains(got, `"h2"`) {
		
		t.Errorf("stringification of HTTP
	}
	wantNextProtos := []string{"h2", "http
	if t1.TLSClientConfig == nil {
		t.Errorf("nil t1.TLSClientConfig")
	} else if !reflect.DeepEqual(t1.TLSClientConfig.NextProtos, wantNextProtos) {
		t.Errorf("TLSClientConfig.NextProtos = %q; want %q", t1.TLSClientConfig.NextProtos, wantNextProtos)
	}
	if err := ConfigureTransport(t1); err == nil {
		t.Error("unexpected success on second call to ConfigureTransport")
	}
	
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		io.WriteString(w, r.Proto)
	}, optOnlyServer)
	defer st.Close()
	t1.TLSClientConfig.InsecureSkipVerify = true
	c := &http.Client{Transport: t1}
	res, err := c.Get(st.ts.URL)
	if err != nil {
		t.Fatal(err)
	}
	slurp, err := ioutil.ReadAll(res.Body)
	if err != nil {
		t.Fatal(err)
	}
	if got, want := string(slurp), "HTTP
		t.Errorf("body = %q; want %q", got, want)
	}
}
type capitalizeReader struct {
	r io.Reader
}
func (cr capitalizeReader) Read(p []byte) (n int, err error) {
	n, err = cr.r.Read(p)
	for i, b := range p[:n] {
		if b >= 'a' && b <= 'z' {
			p[i] = b - ('a' - 'A')
		}
	}
	return
}
type flushWriter struct {
	w io.Writer
}
func (fw flushWriter) Write(p []byte) (n int, err error) {
	n, err = fw.w.Write(p)
	if f, ok := fw.w.(http.Flusher); ok {
		f.Flush()
	}
	return
}
type clientTester struct {
	t      *testing.T
	tr     *Transport
	sc, cc net.Conn 
	fr     *Framer  
	client func() error
	server func() error
}
func newClientTester(t *testing.T) *clientTester {
	var dialOnce struct {
		sync.Mutex
		dialed bool
	}
	ct := &clientTester{
		t: t,
	}
	ct.tr = &Transport{
		TLSClientConfig: tlsConfigInsecure,
		DialTLS: func(network, addr string, cfg *tls.Config) (net.Conn, error) {
			dialOnce.Lock()
			defer dialOnce.Unlock()
			if dialOnce.dialed {
				return nil, errors.New("only one dial allowed in test mode")
			}
			dialOnce.dialed = true
			return ct.cc, nil
		},
	}
	ln := newLocalListener(t)
	cc, err := net.Dial("tcp", ln.Addr().String())
	if err != nil {
		t.Fatal(err)
	}
	sc, err := ln.Accept()
	if err != nil {
		t.Fatal(err)
	}
	ln.Close()
	ct.cc = cc
	ct.sc = sc
	ct.fr = NewFramer(sc, sc)
	return ct
}
func newLocalListener(t *testing.T) net.Listener {
	ln, err := net.Listen("tcp4", "127.0.0.1:0")
	if err == nil {
		return ln
	}
	ln, err = net.Listen("tcp6", "[::1]:0")
	if err != nil {
		t.Fatal(err)
	}
	return ln
}
func (ct *clientTester) greet(settings ...Setting) {
	buf := make([]byte, len(ClientPreface))
	_, err := io.ReadFull(ct.sc, buf)
	if err != nil {
		ct.t.Fatalf("reading client preface: %v", err)
	}
	f, err := ct.fr.ReadFrame()
	if err != nil {
		ct.t.Fatalf("Reading client settings frame: %v", err)
	}
	if sf, ok := f.(*SettingsFrame); !ok {
		ct.t.Fatalf("Wanted client settings frame; got %v", f)
		_ = sf 
	}
	if err := ct.fr.WriteSettings(settings...); err != nil {
		ct.t.Fatal(err)
	}
	if err := ct.fr.WriteSettingsAck(); err != nil {
		ct.t.Fatal(err)
	}
}
func (ct *clientTester) readNonSettingsFrame() (Frame, error) {
	for {
		f, err := ct.fr.ReadFrame()
		if err != nil {
			return nil, err
		}
		if _, ok := f.(*SettingsFrame); ok {
			continue
		}
		return f, nil
	}
}
func (ct *clientTester) cleanup() {
	ct.tr.CloseIdleConnections()
}
func (ct *clientTester) run() {
	errc := make(chan error, 2)
	ct.start("client", errc, ct.client)
	ct.start("server", errc, ct.server)
	defer ct.cleanup()
	for i := 0; i < 2; i++ {
		if err := <-errc; err != nil {
			ct.t.Error(err)
			return
		}
	}
}
func (ct *clientTester) start(which string, errc chan<- error, fn func() error) {
	go func() {
		finished := false
		var err error
		defer func() {
			if !finished {
				err = fmt.Errorf("%s goroutine didn't finish.", which)
			} else if err != nil {
				err = fmt.Errorf("%s: %v", which, err)
			}
			errc <- err
		}()
		err = fn()
		finished = true
	}()
}
func (ct *clientTester) readFrame() (Frame, error) {
	return readFrameTimeout(ct.fr, 2*time.Second)
}
func (ct *clientTester) firstHeaders() (*HeadersFrame, error) {
	for {
		f, err := ct.readFrame()
		if err != nil {
			return nil, fmt.Errorf("ReadFrame while waiting for Headers: %v", err)
		}
		switch f.(type) {
		case *WindowUpdateFrame, *SettingsFrame:
			continue
		}
		hf, ok := f.(*HeadersFrame)
		if !ok {
			return nil, fmt.Errorf("Got %T; want HeadersFrame", f)
		}
		return hf, nil
	}
}
type countingReader struct {
	n *int64
}
func (r countingReader) Read(p []byte) (n int, err error) {
	for i := range p {
		p[i] = byte(i)
	}
	atomic.AddInt64(r.n, int64(len(p)))
	return len(p), err
}
func TestTransportReqBodyAfterResponse_200(t *testing.T) { testTransportReqBodyAfterResponse(t, 200) }
func TestTransportReqBodyAfterResponse_403(t *testing.T) { testTransportReqBodyAfterResponse(t, 403) }
func testTransportReqBodyAfterResponse(t *testing.T, status int) {
	const bodySize = 10 << 20
	clientDone := make(chan struct{})
	ct := newClientTester(t)
	ct.client = func() error {
		defer ct.cc.(*net.TCPConn).CloseWrite()
		defer close(clientDone)
		var n int64 
		req, err := http.NewRequest("PUT", "https:
		if err != nil {
			return err
		}
		res, err := ct.tr.RoundTrip(req)
		if err != nil {
			return fmt.Errorf("RoundTrip: %v", err)
		}
		defer res.Body.Close()
		if res.StatusCode != status {
			return fmt.Errorf("status code = %v; want %v", res.StatusCode, status)
		}
		slurp, err := ioutil.ReadAll(res.Body)
		if err != nil {
			return fmt.Errorf("Slurp: %v", err)
		}
		if len(slurp) > 0 {
			return fmt.Errorf("unexpected body: %q", slurp)
		}
		if status == 200 {
			if got := atomic.LoadInt64(&n); got != bodySize {
				return fmt.Errorf("For 200 response, Transport wrote %d bytes; want %d", got, bodySize)
			}
		} else {
			if got := atomic.LoadInt64(&n); got == 0 || got >= bodySize {
				return fmt.Errorf("For %d response, Transport wrote %d bytes; want (0,%d) exclusive", status, got, bodySize)
			}
		}
		return nil
	}
	ct.server = func() error {
		ct.greet()
		var buf bytes.Buffer
		enc := hpack.NewEncoder(&buf)
		var dataRecv int64
		var closed bool
		for {
			f, err := ct.fr.ReadFrame()
			if err != nil {
				select {
				case <-clientDone:
					
					
					
					return nil
				default:
					return err
				}
			}
			
			switch f := f.(type) {
			case *WindowUpdateFrame, *SettingsFrame:
			case *HeadersFrame:
				if !f.HeadersEnded() {
					return fmt.Errorf("headers should have END_HEADERS be ended: %v", f)
				}
				if f.StreamEnded() {
					return fmt.Errorf("headers contains END_STREAM unexpectedly: %v", f)
				}
			case *DataFrame:
				dataLen := len(f.Data())
				if dataLen > 0 {
					if dataRecv == 0 {
						enc.WriteField(hpack.HeaderField{Name: ":status", Value: strconv.Itoa(status)})
						ct.fr.WriteHeaders(HeadersFrameParam{
							StreamID:      f.StreamID,
							EndHeaders:    true,
							EndStream:     false,
							BlockFragment: buf.Bytes(),
						})
					}
					if err := ct.fr.WriteWindowUpdate(0, uint32(dataLen)); err != nil {
						return err
					}
					if err := ct.fr.WriteWindowUpdate(f.StreamID, uint32(dataLen)); err != nil {
						return err
					}
				}
				dataRecv += int64(dataLen)
				if !closed && ((status != 200 && dataRecv > 0) ||
					(status == 200 && dataRecv == bodySize)) {
					closed = true
					if err := ct.fr.WriteData(f.StreamID, true, nil); err != nil {
						return err
					}
				}
			default:
				return fmt.Errorf("Unexpected client frame %v", f)
			}
		}
	}
	ct.run()
}
func TestTransportFullDuplex(t *testing.T) {
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(200) 
		w.(http.Flusher).Flush()
		io.Copy(flushWriter{w}, capitalizeReader{r.Body})
		fmt.Fprintf(w, "bye.\n")
	}, optOnlyServer)
	defer st.Close()
	tr := &Transport{TLSClientConfig: tlsConfigInsecure}
	defer tr.CloseIdleConnections()
	c := &http.Client{Transport: tr}
	pr, pw := io.Pipe()
	req, err := http.NewRequest("PUT", st.ts.URL, ioutil.NopCloser(pr))
	if err != nil {
		t.Fatal(err)
	}
	req.ContentLength = -1
	res, err := c.Do(req)
	if err != nil {
		t.Fatal(err)
	}
	defer res.Body.Close()
	if res.StatusCode != 200 {
		t.Fatalf("StatusCode = %v; want %v", res.StatusCode, 200)
	}
	bs := bufio.NewScanner(res.Body)
	want := func(v string) {
		if !bs.Scan() {
			t.Fatalf("wanted to read %q but Scan() = false, err = %v", v, bs.Err())
		}
	}
	write := func(v string) {
		_, err := io.WriteString(pw, v)
		if err != nil {
			t.Fatalf("pipe write: %v", err)
		}
	}
	write("foo\n")
	want("FOO")
	write("bar\n")
	want("BAR")
	pw.Close()
	want("bye.")
	if err := bs.Err(); err != nil {
		t.Fatal(err)
	}
}
func TestTransportConnectRequest(t *testing.T) {
	gotc := make(chan *http.Request, 1)
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		gotc <- r
	}, optOnlyServer)
	defer st.Close()
	u, err := url.Parse(st.ts.URL)
	if err != nil {
		t.Fatal(err)
	}
	tr := &Transport{TLSClientConfig: tlsConfigInsecure}
	defer tr.CloseIdleConnections()
	c := &http.Client{Transport: tr}
	tests := []struct {
		req  *http.Request
		want string
	}{
		{
			req: &http.Request{
				Method: "CONNECT",
				Header: http.Header{},
				URL:    u,
			},
			want: u.Host,
		},
		{
			req: &http.Request{
				Method: "CONNECT",
				Header: http.Header{},
				URL:    u,
				Host:   "example.com:123",
			},
			want: "example.com:123",
		},
	}
	for i, tt := range tests {
		res, err := c.Do(tt.req)
		if err != nil {
			t.Errorf("%d. RoundTrip = %v", i, err)
			continue
		}
		res.Body.Close()
		req := <-gotc
		if req.Method != "CONNECT" {
			t.Errorf("method = %q; want CONNECT", req.Method)
		}
		if req.Host != tt.want {
			t.Errorf("Host = %q; want %q", req.Host, tt.want)
		}
		if req.URL.Host != tt.want {
			t.Errorf("URL.Host = %q; want %q", req.URL.Host, tt.want)
		}
	}
}
type headerType int
const (
	noHeader headerType = iota 
	oneHeader
	splitHeader 
)
const (
	f0 = noHeader
	f1 = oneHeader
	f2 = splitHeader
	d0 = false
	d1 = true
)
func TestTransportResPattern_c0h1d0t0(t *testing.T) { testTransportResPattern(t, f0, f1, d0, f0) }
func TestTransportResPattern_c0h1d0t1(t *testing.T) { testTransportResPattern(t, f0, f1, d0, f1) }
func TestTransportResPattern_c0h1d0t2(t *testing.T) { testTransportResPattern(t, f0, f1, d0, f2) }
func TestTransportResPattern_c0h1d1t0(t *testing.T) { testTransportResPattern(t, f0, f1, d1, f0) }
func TestTransportResPattern_c0h1d1t1(t *testing.T) { testTransportResPattern(t, f0, f1, d1, f1) }
func TestTransportResPattern_c0h1d1t2(t *testing.T) { testTransportResPattern(t, f0, f1, d1, f2) }
func TestTransportResPattern_c0h2d0t0(t *testing.T) { testTransportResPattern(t, f0, f2, d0, f0) }
func TestTransportResPattern_c0h2d0t1(t *testing.T) { testTransportResPattern(t, f0, f2, d0, f1) }
func TestTransportResPattern_c0h2d0t2(t *testing.T) { testTransportResPattern(t, f0, f2, d0, f2) }
func TestTransportResPattern_c0h2d1t0(t *testing.T) { testTransportResPattern(t, f0, f2, d1, f0) }
func TestTransportResPattern_c0h2d1t1(t *testing.T) { testTransportResPattern(t, f0, f2, d1, f1) }
func TestTransportResPattern_c0h2d1t2(t *testing.T) { testTransportResPattern(t, f0, f2, d1, f2) }
func TestTransportResPattern_c1h1d0t0(t *testing.T) { testTransportResPattern(t, f1, f1, d0, f0) }
func TestTransportResPattern_c1h1d0t1(t *testing.T) { testTransportResPattern(t, f1, f1, d0, f1) }
func TestTransportResPattern_c1h1d0t2(t *testing.T) { testTransportResPattern(t, f1, f1, d0, f2) }
func TestTransportResPattern_c1h1d1t0(t *testing.T) { testTransportResPattern(t, f1, f1, d1, f0) }
func TestTransportResPattern_c1h1d1t1(t *testing.T) { testTransportResPattern(t, f1, f1, d1, f1) }
func TestTransportResPattern_c1h1d1t2(t *testing.T) { testTransportResPattern(t, f1, f1, d1, f2) }
func TestTransportResPattern_c1h2d0t0(t *testing.T) { testTransportResPattern(t, f1, f2, d0, f0) }
func TestTransportResPattern_c1h2d0t1(t *testing.T) { testTransportResPattern(t, f1, f2, d0, f1) }
func TestTransportResPattern_c1h2d0t2(t *testing.T) { testTransportResPattern(t, f1, f2, d0, f2) }
func TestTransportResPattern_c1h2d1t0(t *testing.T) { testTransportResPattern(t, f1, f2, d1, f0) }
func TestTransportResPattern_c1h2d1t1(t *testing.T) { testTransportResPattern(t, f1, f2, d1, f1) }
func TestTransportResPattern_c1h2d1t2(t *testing.T) { testTransportResPattern(t, f1, f2, d1, f2) }
func TestTransportResPattern_c2h1d0t0(t *testing.T) { testTransportResPattern(t, f2, f1, d0, f0) }
func TestTransportResPattern_c2h1d0t1(t *testing.T) { testTransportResPattern(t, f2, f1, d0, f1) }
func TestTransportResPattern_c2h1d0t2(t *testing.T) { testTransportResPattern(t, f2, f1, d0, f2) }
func TestTransportResPattern_c2h1d1t0(t *testing.T) { testTransportResPattern(t, f2, f1, d1, f0) }
func TestTransportResPattern_c2h1d1t1(t *testing.T) { testTransportResPattern(t, f2, f1, d1, f1) }
func TestTransportResPattern_c2h1d1t2(t *testing.T) { testTransportResPattern(t, f2, f1, d1, f2) }
func TestTransportResPattern_c2h2d0t0(t *testing.T) { testTransportResPattern(t, f2, f2, d0, f0) }
func TestTransportResPattern_c2h2d0t1(t *testing.T) { testTransportResPattern(t, f2, f2, d0, f1) }
func TestTransportResPattern_c2h2d0t2(t *testing.T) { testTransportResPattern(t, f2, f2, d0, f2) }
func TestTransportResPattern_c2h2d1t0(t *testing.T) { testTransportResPattern(t, f2, f2, d1, f0) }
func TestTransportResPattern_c2h2d1t1(t *testing.T) { testTransportResPattern(t, f2, f2, d1, f1) }
func TestTransportResPattern_c2h2d1t2(t *testing.T) { testTransportResPattern(t, f2, f2, d1, f2) }
func testTransportResPattern(t *testing.T, expect100Continue, resHeader headerType, withData bool, trailers headerType) {
	const reqBody = "some request body"
	const resBody = "some response body"
	if resHeader == noHeader {
		
		
		panic("invalid combination")
	}
	ct := newClientTester(t)
	ct.client = func() error {
		req, _ := http.NewRequest("POST", "https:
		if expect100Continue != noHeader {
			req.Header.Set("Expect", "100-continue")
		}
		res, err := ct.tr.RoundTrip(req)
		if err != nil {
			return fmt.Errorf("RoundTrip: %v", err)
		}
		defer res.Body.Close()
		if res.StatusCode != 200 {
			return fmt.Errorf("status code = %v; want 200", res.StatusCode)
		}
		slurp, err := ioutil.ReadAll(res.Body)
		if err != nil {
			return fmt.Errorf("Slurp: %v", err)
		}
		wantBody := resBody
		if !withData {
			wantBody = ""
		}
		if string(slurp) != wantBody {
			return fmt.Errorf("body = %q; want %q", slurp, wantBody)
		}
		if trailers == noHeader {
			if len(res.Trailer) > 0 {
				t.Errorf("Trailer = %v; want none", res.Trailer)
			}
		} else {
			want := http.Header{"Some-Trailer": {"some-value"}}
			if !reflect.DeepEqual(res.Trailer, want) {
				t.Errorf("Trailer = %v; want %v", res.Trailer, want)
			}
		}
		return nil
	}
	ct.server = func() error {
		ct.greet()
		var buf bytes.Buffer
		enc := hpack.NewEncoder(&buf)
		for {
			f, err := ct.fr.ReadFrame()
			if err != nil {
				return err
			}
			endStream := false
			send := func(mode headerType) {
				hbf := buf.Bytes()
				switch mode {
				case oneHeader:
					ct.fr.WriteHeaders(HeadersFrameParam{
						StreamID:      f.Header().StreamID,
						EndHeaders:    true,
						EndStream:     endStream,
						BlockFragment: hbf,
					})
				case splitHeader:
					if len(hbf) < 2 {
						panic("too small")
					}
					ct.fr.WriteHeaders(HeadersFrameParam{
						StreamID:      f.Header().StreamID,
						EndHeaders:    false,
						EndStream:     endStream,
						BlockFragment: hbf[:1],
					})
					ct.fr.WriteContinuation(f.Header().StreamID, true, hbf[1:])
				default:
					panic("bogus mode")
				}
			}
			switch f := f.(type) {
			case *WindowUpdateFrame, *SettingsFrame:
			case *DataFrame:
				if !f.StreamEnded() {
					
					continue
				}
				
				{
					buf.Reset()
					enc.WriteField(hpack.HeaderField{Name: ":status", Value: "200"})
					enc.WriteField(hpack.HeaderField{Name: "x-foo", Value: "blah"})
					enc.WriteField(hpack.HeaderField{Name: "x-bar", Value: "more"})
					if trailers != noHeader {
						enc.WriteField(hpack.HeaderField{Name: "trailer", Value: "some-trailer"})
					}
					endStream = withData == false && trailers == noHeader
					send(resHeader)
				}
				if withData {
					endStream = trailers == noHeader
					ct.fr.WriteData(f.StreamID, endStream, []byte(resBody))
				}
				if trailers != noHeader {
					endStream = true
					buf.Reset()
					enc.WriteField(hpack.HeaderField{Name: "some-trailer", Value: "some-value"})
					send(trailers)
				}
				if endStream {
					return nil
				}
			case *HeadersFrame:
				if expect100Continue != noHeader {
					buf.Reset()
					enc.WriteField(hpack.HeaderField{Name: ":status", Value: "100"})
					send(expect100Continue)
				}
			}
		}
	}
	ct.run()
}
func TestTransportReceiveUndeclaredTrailer(t *testing.T) {
	ct := newClientTester(t)
	ct.client = func() error {
		req, _ := http.NewRequest("GET", "https:
		res, err := ct.tr.RoundTrip(req)
		if err != nil {
			return fmt.Errorf("RoundTrip: %v", err)
		}
		defer res.Body.Close()
		if res.StatusCode != 200 {
			return fmt.Errorf("status code = %v; want 200", res.StatusCode)
		}
		slurp, err := ioutil.ReadAll(res.Body)
		if err != nil {
			return fmt.Errorf("res.Body ReadAll error = %q, %v; want %v", slurp, err, nil)
		}
		if len(slurp) > 0 {
			return fmt.Errorf("body = %q; want nothing", slurp)
		}
		if _, ok := res.Trailer["Some-Trailer"]; !ok {
			return fmt.Errorf("expected Some-Trailer")
		}
		return nil
	}
	ct.server = func() error {
		ct.greet()
		var n int
		var hf *HeadersFrame
		for hf == nil && n < 10 {
			f, err := ct.fr.ReadFrame()
			if err != nil {
				return err
			}
			hf, _ = f.(*HeadersFrame)
			n++
		}
		var buf bytes.Buffer
		enc := hpack.NewEncoder(&buf)
		
		enc.WriteField(hpack.HeaderField{Name: ":status", Value: "200"})
		ct.fr.WriteHeaders(HeadersFrameParam{
			StreamID:      hf.StreamID,
			EndHeaders:    true,
			EndStream:     false,
			BlockFragment: buf.Bytes(),
		})
		
		buf.Reset()
		enc.WriteField(hpack.HeaderField{Name: "some-trailer", Value: "I'm an undeclared Trailer!"})
		ct.fr.WriteHeaders(HeadersFrameParam{
			StreamID:      hf.StreamID,
			EndHeaders:    true,
			EndStream:     true,
			BlockFragment: buf.Bytes(),
		})
		return nil
	}
	ct.run()
}
func TestTransportInvalidTrailer_Pseudo1(t *testing.T) {
	testTransportInvalidTrailer_Pseudo(t, oneHeader)
}
func TestTransportInvalidTrailer_Pseudo2(t *testing.T) {
	testTransportInvalidTrailer_Pseudo(t, splitHeader)
}
func testTransportInvalidTrailer_Pseudo(t *testing.T, trailers headerType) {
	testInvalidTrailer(t, trailers, pseudoHeaderError(":colon"), func(enc *hpack.Encoder) {
		enc.WriteField(hpack.HeaderField{Name: ":colon", Value: "foo"})
		enc.WriteField(hpack.HeaderField{Name: "foo", Value: "bar"})
	})
}
func TestTransportInvalidTrailer_Capital1(t *testing.T) {
	testTransportInvalidTrailer_Capital(t, oneHeader)
}
func TestTransportInvalidTrailer_Capital2(t *testing.T) {
	testTransportInvalidTrailer_Capital(t, splitHeader)
}
func testTransportInvalidTrailer_Capital(t *testing.T, trailers headerType) {
	testInvalidTrailer(t, trailers, headerFieldNameError("Capital"), func(enc *hpack.Encoder) {
		enc.WriteField(hpack.HeaderField{Name: "foo", Value: "bar"})
		enc.WriteField(hpack.HeaderField{Name: "Capital", Value: "bad"})
	})
}
func TestTransportInvalidTrailer_EmptyFieldName(t *testing.T) {
	testInvalidTrailer(t, oneHeader, headerFieldNameError(""), func(enc *hpack.Encoder) {
		enc.WriteField(hpack.HeaderField{Name: "", Value: "bad"})
	})
}
func TestTransportInvalidTrailer_BinaryFieldValue(t *testing.T) {
	testInvalidTrailer(t, oneHeader, headerFieldValueError("has\nnewline"), func(enc *hpack.Encoder) {
		enc.WriteField(hpack.HeaderField{Name: "x", Value: "has\nnewline"})
	})
}
func testInvalidTrailer(t *testing.T, trailers headerType, wantErr error, writeTrailer func(*hpack.Encoder)) {
	ct := newClientTester(t)
	ct.client = func() error {
		req, _ := http.NewRequest("GET", "https:
		res, err := ct.tr.RoundTrip(req)
		if err != nil {
			return fmt.Errorf("RoundTrip: %v", err)
		}
		defer res.Body.Close()
		if res.StatusCode != 200 {
			return fmt.Errorf("status code = %v; want 200", res.StatusCode)
		}
		slurp, err := ioutil.ReadAll(res.Body)
		se, ok := err.(StreamError)
		if !ok || se.Cause != wantErr {
			return fmt.Errorf("res.Body ReadAll error = %q, %#v; want StreamError with cause %T, %#v", slurp, err, wantErr, wantErr)
		}
		if len(slurp) > 0 {
			return fmt.Errorf("body = %q; want nothing", slurp)
		}
		return nil
	}
	ct.server = func() error {
		ct.greet()
		var buf bytes.Buffer
		enc := hpack.NewEncoder(&buf)
		for {
			f, err := ct.fr.ReadFrame()
			if err != nil {
				return err
			}
			switch f := f.(type) {
			case *HeadersFrame:
				var endStream bool
				send := func(mode headerType) {
					hbf := buf.Bytes()
					switch mode {
					case oneHeader:
						ct.fr.WriteHeaders(HeadersFrameParam{
							StreamID:      f.StreamID,
							EndHeaders:    true,
							EndStream:     endStream,
							BlockFragment: hbf,
						})
					case splitHeader:
						if len(hbf) < 2 {
							panic("too small")
						}
						ct.fr.WriteHeaders(HeadersFrameParam{
							StreamID:      f.StreamID,
							EndHeaders:    false,
							EndStream:     endStream,
							BlockFragment: hbf[:1],
						})
						ct.fr.WriteContinuation(f.StreamID, true, hbf[1:])
					default:
						panic("bogus mode")
					}
				}
				
				{
					buf.Reset()
					enc.WriteField(hpack.HeaderField{Name: ":status", Value: "200"})
					enc.WriteField(hpack.HeaderField{Name: "trailer", Value: "declared"})
					endStream = false
					send(oneHeader)
				}
				
				{
					endStream = true
					buf.Reset()
					writeTrailer(enc)
					send(trailers)
				}
				return nil
			}
		}
	}
	ct.run()
}
func TestTransportChecksResponseHeaderListSize(t *testing.T) {
	ct := newClientTester(t)
	ct.client = func() error {
		req, _ := http.NewRequest("GET", "https:
		res, err := ct.tr.RoundTrip(req)
		if err != errResponseHeaderListSize {
			if res != nil {
				res.Body.Close()
			}
			size := int64(0)
			for k, vv := range res.Header {
				for _, v := range vv {
					size += int64(len(k)) + int64(len(v)) + 32
				}
			}
			return fmt.Errorf("RoundTrip Error = %v (and %d bytes of response headers); want errResponseHeaderListSize", err, size)
		}
		return nil
	}
	ct.server = func() error {
		ct.greet()
		var buf bytes.Buffer
		enc := hpack.NewEncoder(&buf)
		for {
			f, err := ct.fr.ReadFrame()
			if err != nil {
				return err
			}
			switch f := f.(type) {
			case *HeadersFrame:
				enc.WriteField(hpack.HeaderField{Name: ":status", Value: "200"})
				large := strings.Repeat("a", 1<<10)
				for i := 0; i < 5042; i++ {
					enc.WriteField(hpack.HeaderField{Name: large, Value: large})
				}
				if size, want := buf.Len(), 6329; size != want {
					
					
					
					
					
					
					return fmt.Errorf("encoding over 10MB of duplicate keypairs took %d bytes; expected %d", size, want)
				}
				ct.fr.WriteHeaders(HeadersFrameParam{
					StreamID:      f.StreamID,
					EndHeaders:    true,
					EndStream:     true,
					BlockFragment: buf.Bytes(),
				})
				return nil
			}
		}
	}
	ct.run()
}
func TestTransportBodyReadErrorType(t *testing.T) {
	doPanic := make(chan bool, 1)
	st := newServerTester(t,
		func(w http.ResponseWriter, r *http.Request) {
			w.(http.Flusher).Flush() 
			<-doPanic
			panic("boom")
		},
		optOnlyServer,
		optQuiet,
	)
	defer st.Close()
	tr := &Transport{TLSClientConfig: tlsConfigInsecure}
	defer tr.CloseIdleConnections()
	c := &http.Client{Transport: tr}
	res, err := c.Get(st.ts.URL)
	if err != nil {
		t.Fatal(err)
	}
	defer res.Body.Close()
	doPanic <- true
	buf := make([]byte, 100)
	n, err := res.Body.Read(buf)
	want := StreamError{StreamID: 0x1, Code: 0x2}
	if !reflect.DeepEqual(want, err) {
		t.Errorf("Read = %v, %#v; want error %#v", n, err, want)
	}
}
func TestTransportDoubleCloseOnWriteError(t *testing.T) {
	var (
		mu   sync.Mutex
		conn net.Conn 
	)
	st := newServerTester(t,
		func(w http.ResponseWriter, r *http.Request) {
			mu.Lock()
			defer mu.Unlock()
			if conn != nil {
				conn.Close()
			}
		},
		optOnlyServer,
	)
	defer st.Close()
	tr := &Transport{
		TLSClientConfig: tlsConfigInsecure,
		DialTLS: func(network, addr string, cfg *tls.Config) (net.Conn, error) {
			tc, err := tls.Dial(network, addr, cfg)
			if err != nil {
				return nil, err
			}
			mu.Lock()
			defer mu.Unlock()
			conn = tc
			return tc, nil
		},
	}
	defer tr.CloseIdleConnections()
	c := &http.Client{Transport: tr}
	c.Get(st.ts.URL)
}
func TestTransportDisableKeepAlives(t *testing.T) {
	st := newServerTester(t,
		func(w http.ResponseWriter, r *http.Request) {
			io.WriteString(w, "hi")
		},
		optOnlyServer,
	)
	defer st.Close()
	connClosed := make(chan struct{}) 
	tr := &Transport{
		t1: &http.Transport{
			DisableKeepAlives: true,
		},
		TLSClientConfig: tlsConfigInsecure,
		DialTLS: func(network, addr string, cfg *tls.Config) (net.Conn, error) {
			tc, err := tls.Dial(network, addr, cfg)
			if err != nil {
				return nil, err
			}
			return &noteCloseConn{Conn: tc, closefn: func() { close(connClosed) }}, nil
		},
	}
	c := &http.Client{Transport: tr}
	res, err := c.Get(st.ts.URL)
	if err != nil {
		t.Fatal(err)
	}
	if _, err := ioutil.ReadAll(res.Body); err != nil {
		t.Fatal(err)
	}
	defer res.Body.Close()
	select {
	case <-connClosed:
	case <-time.After(1 * time.Second):
		t.Errorf("timeout")
	}
}
func TestTransportDisableKeepAlives_Concurrency(t *testing.T) {
	const D = 25 * time.Millisecond
	st := newServerTester(t,
		func(w http.ResponseWriter, r *http.Request) {
			time.Sleep(D)
			io.WriteString(w, "hi")
		},
		optOnlyServer,
	)
	defer st.Close()
	var dials int32
	var conns sync.WaitGroup
	tr := &Transport{
		t1: &http.Transport{
			DisableKeepAlives: true,
		},
		TLSClientConfig: tlsConfigInsecure,
		DialTLS: func(network, addr string, cfg *tls.Config) (net.Conn, error) {
			tc, err := tls.Dial(network, addr, cfg)
			if err != nil {
				return nil, err
			}
			atomic.AddInt32(&dials, 1)
			conns.Add(1)
			return &noteCloseConn{Conn: tc, closefn: func() { conns.Done() }}, nil
		},
	}
	c := &http.Client{Transport: tr}
	var reqs sync.WaitGroup
	const N = 20
	for i := 0; i < N; i++ {
		reqs.Add(1)
		if i == N-1 {
			
			
			
			
			
			
			time.Sleep(D * 2)
		}
		go func() {
			defer reqs.Done()
			res, err := c.Get(st.ts.URL)
			if err != nil {
				t.Error(err)
				return
			}
			if _, err := ioutil.ReadAll(res.Body); err != nil {
				t.Error(err)
				return
			}
			res.Body.Close()
		}()
	}
	reqs.Wait()
	conns.Wait()
	t.Logf("did %d dials, %d requests", atomic.LoadInt32(&dials), N)
}
type noteCloseConn struct {
	net.Conn
	onceClose sync.Once
	closefn   func()
}
func (c *noteCloseConn) Close() error {
	c.onceClose.Do(c.closefn)
	return c.Conn.Close()
}
func isTimeout(err error) bool {
	switch err := err.(type) {
	case nil:
		return false
	case *url.Error:
		return isTimeout(err.Err)
	case net.Error:
		return err.Timeout()
	}
	return false
}
func TestTransportResponseHeaderTimeout_NoBody(t *testing.T) {
	testTransportResponseHeaderTimeout(t, false)
}
func TestTransportResponseHeaderTimeout_Body(t *testing.T) {
	testTransportResponseHeaderTimeout(t, true)
}
func testTransportResponseHeaderTimeout(t *testing.T, body bool) {
	ct := newClientTester(t)
	ct.tr.t1 = &http.Transport{
		ResponseHeaderTimeout: 5 * time.Millisecond,
	}
	ct.client = func() error {
		c := &http.Client{Transport: ct.tr}
		var err error
		var n int64
		const bodySize = 4 << 20
		if body {
			_, err = c.Post("https:
		} else {
			_, err = c.Get("https:
		}
		if !isTimeout(err) {
			t.Errorf("client expected timeout error; got %#v", err)
		}
		if body && n != bodySize {
			t.Errorf("only read %d bytes of body; want %d", n, bodySize)
		}
		return nil
	}
	ct.server = func() error {
		ct.greet()
		for {
			f, err := ct.fr.ReadFrame()
			if err != nil {
				t.Logf("ReadFrame: %v", err)
				return nil
			}
			switch f := f.(type) {
			case *DataFrame:
				dataLen := len(f.Data())
				if dataLen > 0 {
					if err := ct.fr.WriteWindowUpdate(0, uint32(dataLen)); err != nil {
						return err
					}
					if err := ct.fr.WriteWindowUpdate(f.StreamID, uint32(dataLen)); err != nil {
						return err
					}
				}
			case *RSTStreamFrame:
				if f.StreamID == 1 && f.ErrCode == ErrCodeCancel {
					return nil
				}
			}
		}
	}
	ct.run()
}
func TestTransportDisableCompression(t *testing.T) {
	const body = "sup"
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		want := http.Header{
			"User-Agent": []string{"Go-http-client
		}
		if !reflect.DeepEqual(r.Header, want) {
			t.Errorf("request headers = %v; want %v", r.Header, want)
		}
	}, optOnlyServer)
	defer st.Close()
	tr := &Transport{
		TLSClientConfig: tlsConfigInsecure,
		t1: &http.Transport{
			DisableCompression: true,
		},
	}
	defer tr.CloseIdleConnections()
	req, err := http.NewRequest("GET", st.ts.URL, nil)
	if err != nil {
		t.Fatal(err)
	}
	res, err := tr.RoundTrip(req)
	if err != nil {
		t.Fatal(err)
	}
	defer res.Body.Close()
}
func TestTransportRejectsConnHeaders(t *testing.T) {
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		var got []string
		for k := range r.Header {
			got = append(got, k)
		}
		sort.Strings(got)
		w.Header().Set("Got-Header", strings.Join(got, ","))
	}, optOnlyServer)
	defer st.Close()
	tr := &Transport{TLSClientConfig: tlsConfigInsecure}
	defer tr.CloseIdleConnections()
	tests := []struct {
		key   string
		value []string
		want  string
	}{
		{
			key:   "Upgrade",
			value: []string{"anything"},
			want:  "ERROR: http2: invalid Upgrade request header: [\"anything\"]",
		},
		{
			key:   "Connection",
			value: []string{"foo"},
			want:  "ERROR: http2: invalid Connection request header: [\"foo\"]",
		},
		{
			key:   "Connection",
			value: []string{"close"},
			want:  "Accept-Encoding,User-Agent",
		},
		{
			key:   "Connection",
			value: []string{"close", "something-else"},
			want:  "ERROR: http2: invalid Connection request header: [\"close\" \"something-else\"]",
		},
		{
			key:   "Connection",
			value: []string{"keep-alive"},
			want:  "Accept-Encoding,User-Agent",
		},
		{
			key:   "Proxy-Connection", 
			value: []string{"keep-alive"},
			want:  "Accept-Encoding,User-Agent",
		},
		{
			key:   "Transfer-Encoding",
			value: []string{""},
			want:  "Accept-Encoding,User-Agent",
		},
		{
			key:   "Transfer-Encoding",
			value: []string{"foo"},
			want:  "ERROR: http2: invalid Transfer-Encoding request header: [\"foo\"]",
		},
		{
			key:   "Transfer-Encoding",
			value: []string{"chunked"},
			want:  "Accept-Encoding,User-Agent",
		},
		{
			key:   "Transfer-Encoding",
			value: []string{"chunked", "other"},
			want:  "ERROR: http2: invalid Transfer-Encoding request header: [\"chunked\" \"other\"]",
		},
		{
			key:   "Content-Length",
			value: []string{"123"},
			want:  "Accept-Encoding,User-Agent",
		},
		{
			key:   "Keep-Alive",
			value: []string{"doop"},
			want:  "Accept-Encoding,User-Agent",
		},
	}
	for _, tt := range tests {
		req, _ := http.NewRequest("GET", st.ts.URL, nil)
		req.Header[tt.key] = tt.value
		res, err := tr.RoundTrip(req)
		var got string
		if err != nil {
			got = fmt.Sprintf("ERROR: %v", err)
		} else {
			got = res.Header.Get("Got-Header")
			res.Body.Close()
		}
		if got != tt.want {
			t.Errorf("For key %q, value %q, got = %q; want %q", tt.key, tt.value, got, tt.want)
		}
	}
}
func TestTransportFailsOnInvalidHeaders(t *testing.T) {
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		var got []string
		for k := range r.Header {
			got = append(got, k)
		}
		sort.Strings(got)
		w.Header().Set("Got-Header", strings.Join(got, ","))
	}, optOnlyServer)
	defer st.Close()
	tests := [...]struct {
		h       http.Header
		wantErr string
	}{
		0: {
			h:       http.Header{"with space": {"foo"}},
			wantErr: `invalid HTTP header name "with space"`,
		},
		1: {
			h:       http.Header{"name": {"Брэд"}},
			wantErr: "", 
		},
		2: {
			h:       http.Header{"имя": {"Brad"}},
			wantErr: `invalid HTTP header name "имя"`,
		},
		3: {
			h:       http.Header{"foo": {"foo\x01bar"}},
			wantErr: `invalid HTTP header value "foo\x01bar" for header "foo"`,
		},
	}
	tr := &Transport{TLSClientConfig: tlsConfigInsecure}
	defer tr.CloseIdleConnections()
	for i, tt := range tests {
		req, _ := http.NewRequest("GET", st.ts.URL, nil)
		req.Header = tt.h
		res, err := tr.RoundTrip(req)
		var bad bool
		if tt.wantErr == "" {
			if err != nil {
				bad = true
				t.Errorf("case %d: error = %v; want no error", i, err)
			}
		} else {
			if !strings.Contains(fmt.Sprint(err), tt.wantErr) {
				bad = true
				t.Errorf("case %d: error = %v; want error %q", i, err, tt.wantErr)
			}
		}
		if err == nil {
			if bad {
				t.Logf("case %d: server got headers %q", i, res.Header.Get("Got-Header"))
			}
			res.Body.Close()
		}
	}
}
func TestGzipReader_DoubleReadCrash(t *testing.T) {
	gz := &gzipReader{
		body: ioutil.NopCloser(strings.NewReader("0123456789")),
	}
	var buf [1]byte
	n, err1 := gz.Read(buf[:])
	if n != 0 || !strings.Contains(fmt.Sprint(err1), "invalid header") {
		t.Fatalf("Read = %v, %v; want 0, invalid header", n, err1)
	}
	n, err2 := gz.Read(buf[:])
	if n != 0 || err2 != err1 {
		t.Fatalf("second Read = %v, %v; want 0, %v", n, err2, err1)
	}
}
func TestTransportNewTLSConfig(t *testing.T) {
	tests := [...]struct {
		conf *tls.Config
		host string
		want *tls.Config
	}{
		
		0: {
			conf: nil,
			host: "foo.com",
			want: &tls.Config{
				ServerName: "foo.com",
				NextProtos: []string{NextProtoTLS},
			},
		},
		
		1: {
			conf: &tls.Config{
				ServerName: "bar.com",
			},
			host: "foo.com",
			want: &tls.Config{
				ServerName: "bar.com",
				NextProtos: []string{NextProtoTLS},
			},
		},
		
		2: {
			conf: &tls.Config{
				NextProtos: []string{"foo", "bar"},
			},
			host: "example.com",
			want: &tls.Config{
				ServerName: "example.com",
				NextProtos: []string{NextProtoTLS, "foo", "bar"},
			},
		},
		
		3: {
			conf: &tls.Config{
				NextProtos: []string{"foo", "bar", NextProtoTLS},
			},
			host: "example.com",
			want: &tls.Config{
				ServerName: "example.com",
				NextProtos: []string{"foo", "bar", NextProtoTLS},
			},
		},
	}
	for i, tt := range tests {
		
		
		if tt.conf != nil {
			tt.conf.SessionTicketsDisabled = true
		}
		tr := &Transport{TLSClientConfig: tt.conf}
		got := tr.newTLSConfig(tt.host)
		got.SessionTicketsDisabled = false
		if !reflect.DeepEqual(got, tt.want) {
			t.Errorf("%d. got %#v; want %#v", i, got, tt.want)
		}
	}
}
func TestTransportReadHeadResponse(t *testing.T) {
	ct := newClientTester(t)
	clientDone := make(chan struct{})
	ct.client = func() error {
		defer close(clientDone)
		req, _ := http.NewRequest("HEAD", "https:
		res, err := ct.tr.RoundTrip(req)
		if err != nil {
			return err
		}
		if res.ContentLength != 123 {
			return fmt.Errorf("Content-Length = %d; want 123", res.ContentLength)
		}
		slurp, err := ioutil.ReadAll(res.Body)
		if err != nil {
			return fmt.Errorf("ReadAll: %v", err)
		}
		if len(slurp) > 0 {
			return fmt.Errorf("Unexpected non-empty ReadAll body: %q", slurp)
		}
		return nil
	}
	ct.server = func() error {
		ct.greet()
		for {
			f, err := ct.fr.ReadFrame()
			if err != nil {
				t.Logf("ReadFrame: %v", err)
				return nil
			}
			hf, ok := f.(*HeadersFrame)
			if !ok {
				continue
			}
			var buf bytes.Buffer
			enc := hpack.NewEncoder(&buf)
			enc.WriteField(hpack.HeaderField{Name: ":status", Value: "200"})
			enc.WriteField(hpack.HeaderField{Name: "content-length", Value: "123"})
			ct.fr.WriteHeaders(HeadersFrameParam{
				StreamID:      hf.StreamID,
				EndHeaders:    true,
				EndStream:     false, 
				BlockFragment: buf.Bytes(),
			})
			ct.fr.WriteData(hf.StreamID, true, nil)
			<-clientDone
			return nil
		}
	}
	ct.run()
}
type neverEnding byte
func (b neverEnding) Read(p []byte) (int, error) {
	for i := range p {
		p[i] = byte(b)
	}
	return len(p), nil
}
func TestTransportHandlerBodyClose(t *testing.T) {
	const bodySize = 10 << 20
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		r.Body.Close()
		io.Copy(w, io.LimitReader(neverEnding('A'), bodySize))
	}, optOnlyServer)
	defer st.Close()
	tr := &Transport{TLSClientConfig: tlsConfigInsecure}
	defer tr.CloseIdleConnections()
	g0 := runtime.NumGoroutine()
	const numReq = 10
	for i := 0; i < numReq; i++ {
		req, err := http.NewRequest("POST", st.ts.URL, struct{ io.Reader }{io.LimitReader(neverEnding('A'), bodySize)})
		if err != nil {
			t.Fatal(err)
		}
		res, err := tr.RoundTrip(req)
		if err != nil {
			t.Fatal(err)
		}
		n, err := io.Copy(ioutil.Discard, res.Body)
		res.Body.Close()
		if n != bodySize || err != nil {
			t.Fatalf("req#%d: Copy = %d, %v; want %d, nil", i, n, err, bodySize)
		}
	}
	tr.CloseIdleConnections()
	gd := runtime.NumGoroutine() - g0
	if gd > numReq
		t.Errorf("appeared to leak goroutines")
	}
}
func TestTransportFlowControl(t *testing.T) {
	const bufLen = 64 << 10
	var total int64 = 100 << 20 
	if testing.Short() {
		total = 10 << 20
	}
	var wrote int64 
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		b := make([]byte, bufLen)
		for wrote < total {
			n, err := w.Write(b)
			atomic.AddInt64(&wrote, int64(n))
			if err != nil {
				t.Errorf("ResponseWriter.Write error: %v", err)
				break
			}
			w.(http.Flusher).Flush()
		}
	}, optOnlyServer)
	tr := &Transport{TLSClientConfig: tlsConfigInsecure}
	defer tr.CloseIdleConnections()
	req, err := http.NewRequest("GET", st.ts.URL, nil)
	if err != nil {
		t.Fatal("NewRequest error:", err)
	}
	resp, err := tr.RoundTrip(req)
	if err != nil {
		t.Fatal("RoundTrip error:", err)
	}
	defer resp.Body.Close()
	var read int64
	b := make([]byte, bufLen)
	for {
		n, err := resp.Body.Read(b)
		if err == io.EOF {
			break
		}
		if err != nil {
			t.Fatal("Read error:", err)
		}
		read += int64(n)
		const max = transportDefaultStreamFlow
		if w := atomic.LoadInt64(&wrote); -max > read-w || read-w > max {
			t.Fatalf("Too much data inflight: server wrote %v bytes but client only received %v", w, read)
		}
		
		time.Sleep(1 * time.Millisecond)
	}
}
func TestTransportUsesGoAwayDebugError_RoundTrip(t *testing.T) {
	testTransportUsesGoAwayDebugError(t, false)
}
func TestTransportUsesGoAwayDebugError_Body(t *testing.T) {
	testTransportUsesGoAwayDebugError(t, true)
}
func testTransportUsesGoAwayDebugError(t *testing.T, failMidBody bool) {
	ct := newClientTester(t)
	clientDone := make(chan struct{})
	const goAwayErrCode = ErrCodeHTTP11Required 
	const goAwayDebugData = "some debug data"
	ct.client = func() error {
		defer close(clientDone)
		req, _ := http.NewRequest("GET", "https:
		res, err := ct.tr.RoundTrip(req)
		if failMidBody {
			if err != nil {
				return fmt.Errorf("unexpected client RoundTrip error: %v", err)
			}
			_, err = io.Copy(ioutil.Discard, res.Body)
			res.Body.Close()
		}
		want := GoAwayError{
			LastStreamID: 5,
			ErrCode:      goAwayErrCode,
			DebugData:    goAwayDebugData,
		}
		if !reflect.DeepEqual(err, want) {
			t.Errorf("RoundTrip error = %T: %#v, want %T (%#v)", err, err, want, want)
		}
		return nil
	}
	ct.server = func() error {
		ct.greet()
		for {
			f, err := ct.fr.ReadFrame()
			if err != nil {
				t.Logf("ReadFrame: %v", err)
				return nil
			}
			hf, ok := f.(*HeadersFrame)
			if !ok {
				continue
			}
			if failMidBody {
				var buf bytes.Buffer
				enc := hpack.NewEncoder(&buf)
				enc.WriteField(hpack.HeaderField{Name: ":status", Value: "200"})
				enc.WriteField(hpack.HeaderField{Name: "content-length", Value: "123"})
				ct.fr.WriteHeaders(HeadersFrameParam{
					StreamID:      hf.StreamID,
					EndHeaders:    true,
					EndStream:     false,
					BlockFragment: buf.Bytes(),
				})
			}
			
			
			ct.fr.WriteGoAway(5, ErrCodeNo, []byte(goAwayDebugData))
			ct.fr.WriteGoAway(5, goAwayErrCode, nil)
			ct.sc.(*net.TCPConn).CloseWrite()
			<-clientDone
			return nil
		}
	}
	ct.run()
}
func testTransportReturnsUnusedFlowControl(t *testing.T, oneDataFrame bool) {
	ct := newClientTester(t)
	clientClosed := make(chan struct{})
	serverWroteFirstByte := make(chan struct{})
	ct.client = func() error {
		req, _ := http.NewRequest("GET", "https:
		res, err := ct.tr.RoundTrip(req)
		if err != nil {
			return err
		}
		<-serverWroteFirstByte
		if n, err := res.Body.Read(make([]byte, 1)); err != nil || n != 1 {
			return fmt.Errorf("body read = %v, %v; want 1, nil", n, err)
		}
		res.Body.Close() 
		close(clientClosed)
		return nil
	}
	ct.server = func() error {
		ct.greet()
		var hf *HeadersFrame
		for {
			f, err := ct.fr.ReadFrame()
			if err != nil {
				return fmt.Errorf("ReadFrame while waiting for Headers: %v", err)
			}
			switch f.(type) {
			case *WindowUpdateFrame, *SettingsFrame:
				continue
			}
			var ok bool
			hf, ok = f.(*HeadersFrame)
			if !ok {
				return fmt.Errorf("Got %T; want HeadersFrame", f)
			}
			break
		}
		var buf bytes.Buffer
		enc := hpack.NewEncoder(&buf)
		enc.WriteField(hpack.HeaderField{Name: ":status", Value: "200"})
		enc.WriteField(hpack.HeaderField{Name: "content-length", Value: "5000"})
		ct.fr.WriteHeaders(HeadersFrameParam{
			StreamID:      hf.StreamID,
			EndHeaders:    true,
			EndStream:     false,
			BlockFragment: buf.Bytes(),
		})
		
		
		
		
		
		
		
		
		
		
		if oneDataFrame {
			ct.fr.WriteData(hf.StreamID, false 
			close(serverWroteFirstByte)
			<-clientClosed
		} else {
			ct.fr.WriteData(hf.StreamID, false 
			close(serverWroteFirstByte)
			<-clientClosed
			ct.fr.WriteData(hf.StreamID, false 
		}
		waitingFor := "RSTStreamFrame"
		for {
			f, err := ct.fr.ReadFrame()
			if err != nil {
				return fmt.Errorf("ReadFrame while waiting for %s: %v", waitingFor, err)
			}
			if _, ok := f.(*SettingsFrame); ok {
				continue
			}
			switch waitingFor {
			case "RSTStreamFrame":
				if rf, ok := f.(*RSTStreamFrame); !ok || rf.ErrCode != ErrCodeCancel {
					return fmt.Errorf("Expected a RSTStreamFrame with code cancel; got %v", summarizeFrame(f))
				}
				waitingFor = "WindowUpdateFrame"
			case "WindowUpdateFrame":
				if wuf, ok := f.(*WindowUpdateFrame); !ok || wuf.Increment != 4999 {
					return fmt.Errorf("Expected WindowUpdateFrame for 4999 bytes; got %v", summarizeFrame(f))
				}
				return nil
			}
		}
	}
	ct.run()
}
func TestTransportReturnsUnusedFlowControlSingleWrite(t *testing.T) {
	testTransportReturnsUnusedFlowControl(t, true)
}
func TestTransportReturnsUnusedFlowControlMultipleWrites(t *testing.T) {
	testTransportReturnsUnusedFlowControl(t, false)
}
func TestTransportAdjustsFlowControl(t *testing.T) {
	ct := newClientTester(t)
	clientDone := make(chan struct{})
	const bodySize = 1 << 20
	ct.client = func() error {
		defer ct.cc.(*net.TCPConn).CloseWrite()
		defer close(clientDone)
		req, _ := http.NewRequest("POST", "https:
		res, err := ct.tr.RoundTrip(req)
		if err != nil {
			return err
		}
		res.Body.Close()
		return nil
	}
	ct.server = func() error {
		_, err := io.ReadFull(ct.sc, make([]byte, len(ClientPreface)))
		if err != nil {
			return fmt.Errorf("reading client preface: %v", err)
		}
		var gotBytes int64
		var sentSettings bool
		for {
			f, err := ct.fr.ReadFrame()
			if err != nil {
				select {
				case <-clientDone:
					return nil
				default:
					return fmt.Errorf("ReadFrame while waiting for Headers: %v", err)
				}
			}
			switch f := f.(type) {
			case *DataFrame:
				gotBytes += int64(len(f.Data()))
				
				
				
				
				if gotBytes >= initialWindowSize
					sentSettings = true
					ct.fr.WriteSettings(Setting{ID: SettingInitialWindowSize, Val: bodySize})
					ct.fr.WriteWindowUpdate(0, bodySize)
					ct.fr.WriteSettingsAck()
				}
				if f.StreamEnded() {
					var buf bytes.Buffer
					enc := hpack.NewEncoder(&buf)
					enc.WriteField(hpack.HeaderField{Name: ":status", Value: "200"})
					ct.fr.WriteHeaders(HeadersFrameParam{
						StreamID:      f.StreamID,
						EndHeaders:    true,
						EndStream:     true,
						BlockFragment: buf.Bytes(),
					})
				}
			}
		}
	}
	ct.run()
}
func TestTransportReturnsDataPaddingFlowControl(t *testing.T) {
	ct := newClientTester(t)
	unblockClient := make(chan bool, 1)
	ct.client = func() error {
		req, _ := http.NewRequest("GET", "https:
		res, err := ct.tr.RoundTrip(req)
		if err != nil {
			return err
		}
		defer res.Body.Close()
		<-unblockClient
		return nil
	}
	ct.server = func() error {
		ct.greet()
		var hf *HeadersFrame
		for {
			f, err := ct.fr.ReadFrame()
			if err != nil {
				return fmt.Errorf("ReadFrame while waiting for Headers: %v", err)
			}
			switch f.(type) {
			case *WindowUpdateFrame, *SettingsFrame:
				continue
			}
			var ok bool
			hf, ok = f.(*HeadersFrame)
			if !ok {
				return fmt.Errorf("Got %T; want HeadersFrame", f)
			}
			break
		}
		var buf bytes.Buffer
		enc := hpack.NewEncoder(&buf)
		enc.WriteField(hpack.HeaderField{Name: ":status", Value: "200"})
		enc.WriteField(hpack.HeaderField{Name: "content-length", Value: "5000"})
		ct.fr.WriteHeaders(HeadersFrameParam{
			StreamID:      hf.StreamID,
			EndHeaders:    true,
			EndStream:     false,
			BlockFragment: buf.Bytes(),
		})
		pad := make([]byte, 5)
		ct.fr.WriteDataPadded(hf.StreamID, false, make([]byte, 5000), pad) 
		f, err := ct.readNonSettingsFrame()
		if err != nil {
			return fmt.Errorf("ReadFrame while waiting for first WindowUpdateFrame: %v", err)
		}
		wantBack := uint32(len(pad)) + 1 
		if wuf, ok := f.(*WindowUpdateFrame); !ok || wuf.Increment != wantBack || wuf.StreamID != 0 {
			return fmt.Errorf("Expected conn WindowUpdateFrame for %d bytes; got %v", wantBack, summarizeFrame(f))
		}
		f, err = ct.readNonSettingsFrame()
		if err != nil {
			return fmt.Errorf("ReadFrame while waiting for second WindowUpdateFrame: %v", err)
		}
		if wuf, ok := f.(*WindowUpdateFrame); !ok || wuf.Increment != wantBack || wuf.StreamID == 0 {
			return fmt.Errorf("Expected stream WindowUpdateFrame for %d bytes; got %v", wantBack, summarizeFrame(f))
		}
		unblockClient <- true
		return nil
	}
	ct.run()
}
func TestTransportReturnsErrorOnBadResponseHeaders(t *testing.T) {
	ct := newClientTester(t)
	ct.client = func() error {
		req, _ := http.NewRequest("GET", "https:
		res, err := ct.tr.RoundTrip(req)
		if err == nil {
			res.Body.Close()
			return errors.New("unexpected successful GET")
		}
		want := StreamError{1, ErrCodeProtocol, headerFieldNameError("  content-type")}
		if !reflect.DeepEqual(want, err) {
			t.Errorf("RoundTrip error = %#v; want %#v", err, want)
		}
		return nil
	}
	ct.server = func() error {
		ct.greet()
		hf, err := ct.firstHeaders()
		if err != nil {
			return err
		}
		var buf bytes.Buffer
		enc := hpack.NewEncoder(&buf)
		enc.WriteField(hpack.HeaderField{Name: ":status", Value: "200"})
		enc.WriteField(hpack.HeaderField{Name: "  content-type", Value: "bogus"}) 
		ct.fr.WriteHeaders(HeadersFrameParam{
			StreamID:      hf.StreamID,
			EndHeaders:    true,
			EndStream:     false,
			BlockFragment: buf.Bytes(),
		})
		for {
			fr, err := ct.readFrame()
			if err != nil {
				return fmt.Errorf("error waiting for RST_STREAM from client: %v", err)
			}
			if _, ok := fr.(*SettingsFrame); ok {
				continue
			}
			if rst, ok := fr.(*RSTStreamFrame); !ok || rst.StreamID != 1 || rst.ErrCode != ErrCodeProtocol {
				t.Errorf("Frame = %v; want RST_STREAM for stream 1 with ErrCodeProtocol", summarizeFrame(fr))
			}
			break
		}
		return nil
	}
	ct.run()
}
type byteAndEOFReader byte
func (b byteAndEOFReader) Read(p []byte) (n int, err error) {
	if len(p) == 0 {
		panic("unexpected useless call")
	}
	p[0] = byte(b)
	return 1, io.EOF
}
func TestTransportBodyDoubleEndStream(t *testing.T) {
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		
	}, optOnlyServer)
	defer st.Close()
	tr := &Transport{TLSClientConfig: tlsConfigInsecure}
	defer tr.CloseIdleConnections()
	for i := 0; i < 2; i++ {
		req, _ := http.NewRequest("POST", st.ts.URL, byteAndEOFReader('a'))
		req.ContentLength = 1
		res, err := tr.RoundTrip(req)
		if err != nil {
			t.Fatalf("failure on req %d: %v", i+1, err)
		}
		defer res.Body.Close()
	}
}
func TestTransportRequestPathPseudo(t *testing.T) {
	type result struct {
		path string
		err  string
	}
	tests := []struct {
		req  *http.Request
		want result
	}{
		0: {
			req: &http.Request{
				Method: "GET",
				URL: &url.URL{
					Host: "foo.com",
					Path: "
				},
			},
			want: result{path: "
		},
		
		
		
		1: {
			req: &http.Request{
				Method: "GET",
				URL: &url.URL{
					Host: "foo.com",
					Path: "
				},
			},
			want: result{path: "
		},
		
		2: {
			req: &http.Request{
				Method: "GET",
				URL: &url.URL{
					Scheme: "https",
					Opaque: "
					Host:   "foo.com",
					Path:   "
				},
			},
			want: result{path: "
		},
		
		3: {
			req: &http.Request{
				Method: "GET",
				Host:   "bar.com",
				URL: &url.URL{
					Scheme: "https",
					Opaque: "
					Host:   "foo.com",
					Path:   "
				},
			},
			want: result{path: "
		},
		
		4: {
			req: &http.Request{
				Method: "GET",
				URL: &url.URL{
					Opaque: "
					Host:   "foo.com",
					Path:   "
				},
			},
			want: result{path: "
		},
		
		5: {
			req: &http.Request{
				Method: "GET",
				URL: &url.URL{
					Scheme: "https",
					Opaque: "
					Host:   "foo.com",
					Path:   "
				},
			},
			want: result{err: `invalid request :path "https:
		},
		
		6: {
			req: &http.Request{
				Method: "CONNECT",
				URL: &url.URL{
					Host: "foo.com",
				},
			},
			want: result{},
		},
	}
	for i, tt := range tests {
		cc := &ClientConn{}
		cc.henc = hpack.NewEncoder(&cc.hbuf)
		cc.mu.Lock()
		hdrs, err := cc.encodeHeaders(tt.req, false, "", -1)
		cc.mu.Unlock()
		var got result
		hpackDec := hpack.NewDecoder(initialHeaderTableSize, func(f hpack.HeaderField) {
			if f.Name == ":path" {
				got.path = f.Value
			}
		})
		if err != nil {
			got.err = err.Error()
		} else if len(hdrs) > 0 {
			if _, err := hpackDec.Write(hdrs); err != nil {
				t.Errorf("%d. bogus hpack: %v", i, err)
				continue
			}
		}
		if got != tt.want {
			t.Errorf("%d. got %+v; want %+v", i, got, tt.want)
		}
	}
}
func TestRoundTripDoesntConsumeRequestBodyEarly(t *testing.T) {
	const body = "foo"
	req, _ := http.NewRequest("POST", "http:
	cc := &ClientConn{
		closed: true,
	}
	_, err := cc.RoundTrip(req)
	if err != errClientConnUnusable {
		t.Fatalf("RoundTrip = %v; want errClientConnUnusable", err)
	}
	slurp, err := ioutil.ReadAll(req.Body)
	if err != nil {
		t.Errorf("ReadAll = %v", err)
	}
	if string(slurp) != body {
		t.Errorf("Body = %q; want %q", slurp, body)
	}
}
func TestClientConnPing(t *testing.T) {
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {}, optOnlyServer)
	defer st.Close()
	tr := &Transport{TLSClientConfig: tlsConfigInsecure}
	defer tr.CloseIdleConnections()
	cc, err := tr.dialClientConn(st.ts.Listener.Addr().String(), false)
	if err != nil {
		t.Fatal(err)
	}
	if err = cc.Ping(testContext{}); err != nil {
		t.Fatal(err)
	}
}
func TestTransportCancelDataResponseRace(t *testing.T) {
	cancel := make(chan struct{})
	clientGotError := make(chan bool, 1)
	const msg = "Hello."
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		if strings.Contains(r.URL.Path, "
			time.Sleep(50 * time.Millisecond)
			io.WriteString(w, msg)
			return
		}
		for i := 0; i < 50; i++ {
			io.WriteString(w, "Some data.")
			w.(http.Flusher).Flush()
			if i == 2 {
				close(cancel)
				<-clientGotError
			}
			time.Sleep(10 * time.Millisecond)
		}
	}, optOnlyServer)
	defer st.Close()
	tr := &Transport{TLSClientConfig: tlsConfigInsecure}
	defer tr.CloseIdleConnections()
	c := &http.Client{Transport: tr}
	req, _ := http.NewRequest("GET", st.ts.URL, nil)
	req.Cancel = cancel
	res, err := c.Do(req)
	if err != nil {
		t.Fatal(err)
	}
	if _, err = io.Copy(ioutil.Discard, res.Body); err == nil {
		t.Fatal("unexpected success")
	}
	clientGotError <- true
	res, err = c.Get(st.ts.URL + "
	if err != nil {
		t.Fatal(err)
	}
	slurp, err := ioutil.ReadAll(res.Body)
	if err != nil {
		t.Fatal(err)
	}
	if string(slurp) != msg {
		t.Errorf("Got = %q; want %q", slurp, msg)
	}
}
func TestTransportRetryAfterGOAWAY(t *testing.T) {
	var dialer struct {
		sync.Mutex
		count int
	}
	ct1 := make(chan *clientTester)
	ct2 := make(chan *clientTester)
	ln := newLocalListener(t)
	defer ln.Close()
	tr := &Transport{
		TLSClientConfig: tlsConfigInsecure,
	}
	tr.DialTLS = func(network, addr string, cfg *tls.Config) (net.Conn, error) {
		dialer.Lock()
		defer dialer.Unlock()
		dialer.count++
		if dialer.count == 3 {
			return nil, errors.New("unexpected number of dials")
		}
		cc, err := net.Dial("tcp", ln.Addr().String())
		if err != nil {
			return nil, fmt.Errorf("dial error: %v", err)
		}
		sc, err := ln.Accept()
		if err != nil {
			return nil, fmt.Errorf("accept error: %v", err)
		}
		ct := &clientTester{
			t:  t,
			tr: tr,
			cc: cc,
			sc: sc,
			fr: NewFramer(sc, sc),
		}
		switch dialer.count {
		case 1:
			ct1 <- ct
		case 2:
			ct2 <- ct
		}
		return cc, nil
	}
	errs := make(chan error, 3)
	done := make(chan struct{})
	defer close(done)
	
	go func() {
		req, _ := http.NewRequest("GET", "https:
		res, err := tr.RoundTrip(req)
		if res != nil {
			res.Body.Close()
			if got := res.Header.Get("Foo"); got != "bar" {
				err = fmt.Errorf("foo header = %q; want bar", got)
			}
		}
		if err != nil {
			err = fmt.Errorf("RoundTrip: %v", err)
		}
		errs <- err
	}()
	connToClose := make(chan io.Closer, 2)
	
	go func() {
		var ct *clientTester
		select {
		case ct = <-ct1:
		case <-done:
			return
		}
		connToClose <- ct.cc
		ct.greet()
		hf, err := ct.firstHeaders()
		if err != nil {
			errs <- fmt.Errorf("server1 failed reading HEADERS: %v", err)
			return
		}
		t.Logf("server1 got %v", hf)
		if err := ct.fr.WriteGoAway(0 
			errs <- fmt.Errorf("server1 failed writing GOAWAY: %v", err)
			return
		}
		errs <- nil
	}()
	
	go func() {
		var ct *clientTester
		select {
		case ct = <-ct2:
		case <-done:
			return
		}
		connToClose <- ct.cc
		ct.greet()
		hf, err := ct.firstHeaders()
		if err != nil {
			errs <- fmt.Errorf("server2 failed reading HEADERS: %v", err)
			return
		}
		t.Logf("server2 got %v", hf)
		var buf bytes.Buffer
		enc := hpack.NewEncoder(&buf)
		enc.WriteField(hpack.HeaderField{Name: ":status", Value: "200"})
		enc.WriteField(hpack.HeaderField{Name: "foo", Value: "bar"})
		err = ct.fr.WriteHeaders(HeadersFrameParam{
			StreamID:      hf.StreamID,
			EndHeaders:    true,
			EndStream:     false,
			BlockFragment: buf.Bytes(),
		})
		if err != nil {
			errs <- fmt.Errorf("server2 failed writing response HEADERS: %v", err)
		} else {
			errs <- nil
		}
	}()
	for k := 0; k < 3; k++ {
		select {
		case err := <-errs:
			if err != nil {
				t.Error(err)
			}
		case <-time.After(1 * time.Second):
			t.Errorf("timed out")
		}
	}
	for {
		select {
		case c := <-connToClose:
			c.Close()
		default:
			return
		}
	}
}
func TestTransportRetryAfterRefusedStream(t *testing.T) {
	clientDone := make(chan struct{})
	ct := newClientTester(t)
	ct.client = func() error {
		defer ct.cc.(*net.TCPConn).CloseWrite()
		defer close(clientDone)
		req, _ := http.NewRequest("GET", "https:
		resp, err := ct.tr.RoundTrip(req)
		if err != nil {
			return fmt.Errorf("RoundTrip: %v", err)
		}
		resp.Body.Close()
		if resp.StatusCode != 204 {
			return fmt.Errorf("Status = %v; want 204", resp.StatusCode)
		}
		return nil
	}
	ct.server = func() error {
		ct.greet()
		var buf bytes.Buffer
		enc := hpack.NewEncoder(&buf)
		nreq := 0
		for {
			f, err := ct.fr.ReadFrame()
			if err != nil {
				select {
				case <-clientDone:
					
					
					
					return nil
				default:
					return err
				}
			}
			switch f := f.(type) {
			case *WindowUpdateFrame, *SettingsFrame:
			case *HeadersFrame:
				if !f.HeadersEnded() {
					return fmt.Errorf("headers should have END_HEADERS be ended: %v", f)
				}
				nreq++
				if nreq == 1 {
					ct.fr.WriteRSTStream(f.StreamID, ErrCodeRefusedStream)
				} else {
					enc.WriteField(hpack.HeaderField{Name: ":status", Value: "204"})
					ct.fr.WriteHeaders(HeadersFrameParam{
						StreamID:      f.StreamID,
						EndHeaders:    true,
						EndStream:     true,
						BlockFragment: buf.Bytes(),
					})
				}
			default:
				return fmt.Errorf("Unexpected client frame %v", f)
			}
		}
	}
	ct.run()
}
func TestTransportRetryHasLimit(t *testing.T) {
	
	if testing.Short() {
		t.Skip("skipping long test in short mode")
	}
	clientDone := make(chan struct{})
	ct := newClientTester(t)
	ct.client = func() error {
		defer ct.cc.(*net.TCPConn).CloseWrite()
		defer close(clientDone)
		req, _ := http.NewRequest("GET", "https:
		resp, err := ct.tr.RoundTrip(req)
		if err == nil {
			return fmt.Errorf("RoundTrip expected error, got response: %+v", resp)
		}
		t.Logf("expected error, got: %v", err)
		return nil
	}
	ct.server = func() error {
		ct.greet()
		for {
			f, err := ct.fr.ReadFrame()
			if err != nil {
				select {
				case <-clientDone:
					
					
					
					return nil
				default:
					return err
				}
			}
			switch f := f.(type) {
			case *WindowUpdateFrame, *SettingsFrame:
			case *HeadersFrame:
				if !f.HeadersEnded() {
					return fmt.Errorf("headers should have END_HEADERS be ended: %v", f)
				}
				ct.fr.WriteRSTStream(f.StreamID, ErrCodeRefusedStream)
			default:
				return fmt.Errorf("Unexpected client frame %v", f)
			}
		}
	}
	ct.run()
}
func TestTransportRequestsStallAtServerLimit(t *testing.T) {
	const maxConcurrent = 2
	greet := make(chan struct{})      
	gotRequest := make(chan struct{}) 
	clientDone := make(chan struct{})
	
	var wg sync.WaitGroup
	errs := make(chan error, 100)
	defer func() {
		wg.Wait()
		close(errs)
		for err := range errs {
			t.Error(err)
		}
	}()
	
	
	
	
	
	
	wg.Add(1)
	unblockClient := make(chan struct{})
	clientRequestCancelled := make(chan struct{})
	unblockServer := make(chan struct{})
	go func() {
		defer wg.Done()
		
		for k := 0; k < maxConcurrent; k++ {
			<-gotRequest
		}
		
		close(unblockClient)
		<-clientRequestCancelled
		
		
		time.Sleep(50 * time.Millisecond)
		select {
		case <-gotRequest:
			errs <- errors.New("last request did not stall")
			close(unblockServer)
			return
		default:
		}
		close(unblockServer)
		
		<-gotRequest
	}()
	ct := newClientTester(t)
	ct.client = func() error {
		var wg sync.WaitGroup
		defer func() {
			wg.Wait()
			close(clientDone)
			ct.cc.(*net.TCPConn).CloseWrite()
		}()
		for k := 0; k < maxConcurrent+2; k++ {
			wg.Add(1)
			go func(k int) {
				defer wg.Done()
				
				
				
				
				if k > 0 {
					<-greet
				}
				
				if k >= maxConcurrent {
					<-unblockClient
				}
				req, _ := http.NewRequest("GET", fmt.Sprintf("https:
				if k == maxConcurrent {
					
					cancel := make(chan struct{})
					req.Cancel = cancel
					close(cancel)
					_, err := ct.tr.RoundTrip(req)
					close(clientRequestCancelled)
					if err == nil {
						errs <- fmt.Errorf("RoundTrip(%d) should have failed due to cancel", k)
						return
					}
				} else {
					resp, err := ct.tr.RoundTrip(req)
					if err != nil {
						errs <- fmt.Errorf("RoundTrip(%d): %v", k, err)
						return
					}
					ioutil.ReadAll(resp.Body)
					resp.Body.Close()
					if resp.StatusCode != 204 {
						errs <- fmt.Errorf("Status = %v; want 204", resp.StatusCode)
						return
					}
				}
			}(k)
		}
		return nil
	}
	ct.server = func() error {
		var wg sync.WaitGroup
		defer wg.Wait()
		ct.greet(Setting{SettingMaxConcurrentStreams, maxConcurrent})
		
		var buf bytes.Buffer
		enc := hpack.NewEncoder(&buf)
		writeResp := make(chan uint32, maxConcurrent+1)
		wg.Add(1)
		go func() {
			defer wg.Done()
			<-unblockServer
			for id := range writeResp {
				buf.Reset()
				enc.WriteField(hpack.HeaderField{Name: ":status", Value: "204"})
				ct.fr.WriteHeaders(HeadersFrameParam{
					StreamID:      id,
					EndHeaders:    true,
					EndStream:     true,
					BlockFragment: buf.Bytes(),
				})
			}
		}()
		
		var nreq int
		for {
			f, err := ct.fr.ReadFrame()
			if err != nil {
				select {
				case <-clientDone:
					
					return nil
				default:
					return err
				}
			}
			switch f := f.(type) {
			case *WindowUpdateFrame:
			case *SettingsFrame:
				
				close(greet)
			case *HeadersFrame:
				if !f.HeadersEnded() {
					return fmt.Errorf("headers should have END_HEADERS be ended: %v", f)
				}
				gotRequest <- struct{}{}
				nreq++
				writeResp <- f.StreamID
				if nreq == maxConcurrent+1 {
					close(writeResp)
				}
			default:
				return fmt.Errorf("Unexpected client frame %v", f)
			}
		}
	}
	ct.run()
}
func TestAuthorityAddr(t *testing.T) {
	tests := []struct {
		scheme, authority string
		want              string
	}{
		{"http", "foo.com", "foo.com:80"},
		{"https", "foo.com", "foo.com:443"},
		{"https", "foo.com:1234", "foo.com:1234"},
		{"https", "1.2.3.4:1234", "1.2.3.4:1234"},
		{"https", "1.2.3.4", "1.2.3.4:443"},
		{"https", "[::1]:1234", "[::1]:1234"},
		{"https", "[::1]", "[::1]:443"},
	}
	for _, tt := range tests {
		got := authorityAddr(tt.scheme, tt.authority)
		if got != tt.want {
			t.Errorf("authorityAddr(%q, %q) = %q; want %q", tt.scheme, tt.authority, got, tt.want)
		}
	}
}
func TestTransportAllocationsAfterResponseBodyClose(t *testing.T) {
	megabyteZero := make([]byte, 1<<20)
	writeErr := make(chan error, 1)
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		w.(http.Flusher).Flush()
		var sum int64
		for i := 0; i < 100; i++ {
			n, err := w.Write(megabyteZero)
			sum += int64(n)
			if err != nil {
				writeErr <- err
				return
			}
		}
		t.Logf("wrote all %d bytes", sum)
		writeErr <- nil
	}, optOnlyServer)
	defer st.Close()
	tr := &Transport{TLSClientConfig: tlsConfigInsecure}
	defer tr.CloseIdleConnections()
	c := &http.Client{Transport: tr}
	res, err := c.Get(st.ts.URL)
	if err != nil {
		t.Fatal(err)
	}
	var buf [1]byte
	if _, err := res.Body.Read(buf[:]); err != nil {
		t.Error(err)
	}
	if err := res.Body.Close(); err != nil {
		t.Error(err)
	}
	trb, ok := res.Body.(transportResponseBody)
	if !ok {
		t.Fatalf("res.Body = %T; want transportResponseBody", res.Body)
	}
	if trb.cs.bufPipe.b != nil {
		t.Errorf("response body pipe is still open")
	}
	gotErr := <-writeErr
	if gotErr == nil {
		t.Errorf("Handler unexpectedly managed to write its entire response without getting an error")
	} else if gotErr != errStreamClosed {
		t.Errorf("Handler Write err = %v; want errStreamClosed", gotErr)
	}
}
func TestTransportNoBodyMeansNoDATA(t *testing.T) {
	ct := newClientTester(t)
	unblockClient := make(chan bool)
	ct.client = func() error {
		req, _ := http.NewRequest("GET", "https:
		ct.tr.RoundTrip(req)
		<-unblockClient
		return nil
	}
	ct.server = func() error {
		defer close(unblockClient)
		defer ct.cc.(*net.TCPConn).Close()
		ct.greet()
		for {
			f, err := ct.fr.ReadFrame()
			if err != nil {
				return fmt.Errorf("ReadFrame while waiting for Headers: %v", err)
			}
			switch f := f.(type) {
			default:
				return fmt.Errorf("Got %T; want HeadersFrame", f)
			case *WindowUpdateFrame, *SettingsFrame:
				continue
			case *HeadersFrame:
				if !f.StreamEnded() {
					return fmt.Errorf("got headers frame without END_STREAM")
				}
				return nil
			}
		}
	}
	ct.run()
}
package http2
import (
	"errors"
	"fmt"
)
type ErrCode uint32
const (
	ErrCodeNo                 ErrCode = 0x0
	ErrCodeProtocol           ErrCode = 0x1
	ErrCodeInternal           ErrCode = 0x2
	ErrCodeFlowControl        ErrCode = 0x3
	ErrCodeSettingsTimeout    ErrCode = 0x4
	ErrCodeStreamClosed       ErrCode = 0x5
	ErrCodeFrameSize          ErrCode = 0x6
	ErrCodeRefusedStream      ErrCode = 0x7
	ErrCodeCancel             ErrCode = 0x8
	ErrCodeCompression        ErrCode = 0x9
	ErrCodeConnect            ErrCode = 0xa
	ErrCodeEnhanceYourCalm    ErrCode = 0xb
	ErrCodeInadequateSecurity ErrCode = 0xc
	ErrCodeHTTP11Required     ErrCode = 0xd
)
var errCodeName = map[ErrCode]string{
	ErrCodeNo:                 "NO_ERROR",
	ErrCodeProtocol:           "PROTOCOL_ERROR",
	ErrCodeInternal:           "INTERNAL_ERROR",
	ErrCodeFlowControl:        "FLOW_CONTROL_ERROR",
	ErrCodeSettingsTimeout:    "SETTINGS_TIMEOUT",
	ErrCodeStreamClosed:       "STREAM_CLOSED",
	ErrCodeFrameSize:          "FRAME_SIZE_ERROR",
	ErrCodeRefusedStream:      "REFUSED_STREAM",
	ErrCodeCancel:             "CANCEL",
	ErrCodeCompression:        "COMPRESSION_ERROR",
	ErrCodeConnect:            "CONNECT_ERROR",
	ErrCodeEnhanceYourCalm:    "ENHANCE_YOUR_CALM",
	ErrCodeInadequateSecurity: "INADEQUATE_SECURITY",
	ErrCodeHTTP11Required:     "HTTP_1_1_REQUIRED",
}
func (e ErrCode) String() string {
	if s, ok := errCodeName[e]; ok {
		return s
	}
	return fmt.Sprintf("unknown error code 0x%x", uint32(e))
}
type ConnectionError ErrCode
func (e ConnectionError) Error() string { return fmt.Sprintf("connection error: %s", ErrCode(e)) }
type StreamError struct {
	StreamID uint32
	Code     ErrCode
	Cause    error 
}
func streamError(id uint32, code ErrCode) StreamError {
	return StreamError{StreamID: id, Code: code}
}
func (e StreamError) Error() string {
	if e.Cause != nil {
		return fmt.Sprintf("stream error: stream ID %d; %v; %v", e.StreamID, e.Code, e.Cause)
	}
	return fmt.Sprintf("stream error: stream ID %d; %v", e.StreamID, e.Code)
}
type goAwayFlowError struct{}
func (goAwayFlowError) Error() string { return "connection exceeded flow control window size" }
type connError struct {
	Code   ErrCode 
	Reason string  
}
func (e connError) Error() string {
	return fmt.Sprintf("http2: connection error: %v: %v", e.Code, e.Reason)
}
type pseudoHeaderError string
func (e pseudoHeaderError) Error() string {
	return fmt.Sprintf("invalid pseudo-header %q", string(e))
}
type duplicatePseudoHeaderError string
func (e duplicatePseudoHeaderError) Error() string {
	return fmt.Sprintf("duplicate pseudo-header %q", string(e))
}
type headerFieldNameError string
func (e headerFieldNameError) Error() string {
	return fmt.Sprintf("invalid header field name %q", string(e))
}
type headerFieldValueError string
func (e headerFieldValueError) Error() string {
	return fmt.Sprintf("invalid header field value %q", string(e))
}
var (
	errMixPseudoHeaderTypes = errors.New("mix of request and response pseudo headers")
	errPseudoAfterRegular   = errors.New("pseudo header field after regular")
)
package http2
import "testing"
func TestRandomScheduler(t *testing.T) {
	ws := NewRandomWriteScheduler()
	ws.Push(makeWriteHeadersRequest(3))
	ws.Push(makeWriteHeadersRequest(4))
	ws.Push(makeWriteHeadersRequest(1))
	ws.Push(makeWriteHeadersRequest(2))
	ws.Push(makeWriteNonStreamRequest())
	ws.Push(makeWriteNonStreamRequest())
	
	
	var order []FrameWriteRequest
	for {
		wr, ok := ws.Pop()
		if !ok {
			break
		}
		order = append(order, wr)
	}
	t.Logf("got frames: %v", order)
	if len(order) != 6 {
		t.Fatalf("got %d frames, expected 6", len(order))
	}
	if order[0].StreamID() != 0 || order[1].StreamID() != 0 {
		t.Fatal("expected non-stream frames first", order[0], order[1])
	}
	got := make(map[uint32]bool)
	for _, wr := range order[2:] {
		got[wr.StreamID()] = true
	}
	for id := uint32(1); id <= 4; id++ {
		if !got[id] {
			t.Errorf("frame not found for stream %d", id)
		}
	}
}
package http2
import (
	"crypto
	"net
	"sync"
)
type ClientConnPool interface {
	GetClientConn(req *http.Request, addr string) (*ClientConn, error)
	MarkDead(*ClientConn)
}
type clientConnPoolIdleCloser interface {
	ClientConnPool
	closeIdleConnections()
}
var (
	_ clientConnPoolIdleCloser = (*clientConnPool)(nil)
	_ clientConnPoolIdleCloser = noDialClientConnPool{}
)
type clientConnPool struct {
	t *Transport
	mu sync.Mutex 
	
	
	conns        map[string][]*ClientConn 
	dialing      map[string]*dialCall     
	keys         map[*ClientConn][]string
	addConnCalls map[string]*addConnCall 
}
func (p *clientConnPool) GetClientConn(req *http.Request, addr string) (*ClientConn, error) {
	return p.getClientConn(req, addr, dialOnMiss)
}
const (
	dialOnMiss   = true
	noDialOnMiss = false
)
func (p *clientConnPool) getClientConn(req *http.Request, addr string, dialOnMiss bool) (*ClientConn, error) {
	if isConnectionCloseRequest(req) && dialOnMiss {
		
		const singleUse = true
		cc, err := p.t.dialClientConn(addr, singleUse)
		if err != nil {
			return nil, err
		}
		return cc, nil
	}
	p.mu.Lock()
	for _, cc := range p.conns[addr] {
		if cc.CanTakeNewRequest() {
			p.mu.Unlock()
			return cc, nil
		}
	}
	if !dialOnMiss {
		p.mu.Unlock()
		return nil, ErrNoCachedConn
	}
	call := p.getStartDialLocked(addr)
	p.mu.Unlock()
	<-call.done
	return call.res, call.err
}
type dialCall struct {
	p    *clientConnPool
	done chan struct{} 
	res  *ClientConn   
	err  error         
}
func (p *clientConnPool) getStartDialLocked(addr string) *dialCall {
	if call, ok := p.dialing[addr]; ok {
		
		return call
	}
	call := &dialCall{p: p, done: make(chan struct{})}
	if p.dialing == nil {
		p.dialing = make(map[string]*dialCall)
	}
	p.dialing[addr] = call
	go call.dial(addr)
	return call
}
func (c *dialCall) dial(addr string) {
	const singleUse = false 
	c.res, c.err = c.p.t.dialClientConn(addr, singleUse)
	close(c.done)
	c.p.mu.Lock()
	delete(c.p.dialing, addr)
	if c.err == nil {
		c.p.addConnLocked(addr, c.res)
	}
	c.p.mu.Unlock()
}
func (p *clientConnPool) addConnIfNeeded(key string, t *Transport, c *tls.Conn) (used bool, err error) {
	p.mu.Lock()
	for _, cc := range p.conns[key] {
		if cc.CanTakeNewRequest() {
			p.mu.Unlock()
			return false, nil
		}
	}
	call, dup := p.addConnCalls[key]
	if !dup {
		if p.addConnCalls == nil {
			p.addConnCalls = make(map[string]*addConnCall)
		}
		call = &addConnCall{
			p:    p,
			done: make(chan struct{}),
		}
		p.addConnCalls[key] = call
		go call.run(t, key, c)
	}
	p.mu.Unlock()
	<-call.done
	if call.err != nil {
		return false, call.err
	}
	return !dup, nil
}
type addConnCall struct {
	p    *clientConnPool
	done chan struct{} 
	err  error
}
func (c *addConnCall) run(t *Transport, key string, tc *tls.Conn) {
	cc, err := t.NewClientConn(tc)
	p := c.p
	p.mu.Lock()
	if err != nil {
		c.err = err
	} else {
		p.addConnLocked(key, cc)
	}
	delete(p.addConnCalls, key)
	p.mu.Unlock()
	close(c.done)
}
func (p *clientConnPool) addConn(key string, cc *ClientConn) {
	p.mu.Lock()
	p.addConnLocked(key, cc)
	p.mu.Unlock()
}
func (p *clientConnPool) addConnLocked(key string, cc *ClientConn) {
	for _, v := range p.conns[key] {
		if v == cc {
			return
		}
	}
	if p.conns == nil {
		p.conns = make(map[string][]*ClientConn)
	}
	if p.keys == nil {
		p.keys = make(map[*ClientConn][]string)
	}
	p.conns[key] = append(p.conns[key], cc)
	p.keys[cc] = append(p.keys[cc], key)
}
func (p *clientConnPool) MarkDead(cc *ClientConn) {
	p.mu.Lock()
	defer p.mu.Unlock()
	for _, key := range p.keys[cc] {
		vv, ok := p.conns[key]
		if !ok {
			continue
		}
		newList := filterOutClientConn(vv, cc)
		if len(newList) > 0 {
			p.conns[key] = newList
		} else {
			delete(p.conns, key)
		}
	}
	delete(p.keys, cc)
}
func (p *clientConnPool) closeIdleConnections() {
	p.mu.Lock()
	defer p.mu.Unlock()
	
	
	
	
	
	
	for _, vv := range p.conns {
		for _, cc := range vv {
			cc.closeIfIdle()
		}
	}
}
func filterOutClientConn(in []*ClientConn, exclude *ClientConn) []*ClientConn {
	out := in[:0]
	for _, v := range in {
		if v != exclude {
			out = append(out, v)
		}
	}
	
	
	if len(in) != len(out) {
		in[len(in)-1] = nil
	}
	return out
}
type noDialClientConnPool struct{ *clientConnPool }
func (p noDialClientConnPool) GetClientConn(req *http.Request, addr string) (*ClientConn, error) {
	return p.getClientConn(req, addr, noDialOnMiss)
}
package http2
import (
	"bytes"
	"errors"
	"io"
	"io
	"testing"
)
func TestPipeClose(t *testing.T) {
	var p pipe
	p.b = new(bytes.Buffer)
	a := errors.New("a")
	b := errors.New("b")
	p.CloseWithError(a)
	p.CloseWithError(b)
	_, err := p.Read(make([]byte, 1))
	if err != a {
		t.Errorf("err = %v want %v", err, a)
	}
}
func TestPipeDoneChan(t *testing.T) {
	var p pipe
	done := p.Done()
	select {
	case <-done:
		t.Fatal("done too soon")
	default:
	}
	p.CloseWithError(io.EOF)
	select {
	case <-done:
	default:
		t.Fatal("should be done")
	}
}
func TestPipeDoneChan_ErrFirst(t *testing.T) {
	var p pipe
	p.CloseWithError(io.EOF)
	done := p.Done()
	select {
	case <-done:
	default:
		t.Fatal("should be done")
	}
}
func TestPipeDoneChan_Break(t *testing.T) {
	var p pipe
	done := p.Done()
	select {
	case <-done:
		t.Fatal("done too soon")
	default:
	}
	p.BreakWithError(io.EOF)
	select {
	case <-done:
	default:
		t.Fatal("should be done")
	}
}
func TestPipeDoneChan_Break_ErrFirst(t *testing.T) {
	var p pipe
	p.BreakWithError(io.EOF)
	done := p.Done()
	select {
	case <-done:
	default:
		t.Fatal("should be done")
	}
}
func TestPipeCloseWithError(t *testing.T) {
	p := &pipe{b: new(bytes.Buffer)}
	const body = "foo"
	io.WriteString(p, body)
	a := errors.New("test error")
	p.CloseWithError(a)
	all, err := ioutil.ReadAll(p)
	if string(all) != body {
		t.Errorf("read bytes = %q; want %q", all, body)
	}
	if err != a {
		t.Logf("read error = %v, %v", err, a)
	}
	
	if n, err := p.Write([]byte("abc")); err != errClosedPipeWrite || n != 0 {
		t.Errorf("Write(abc) after close\ngot %v, %v\nwant 0, %v", n, err, errClosedPipeWrite)
	}
	if n, err := p.Read(make([]byte, 1)); err == nil || n != 0 {
		t.Errorf("Read() after close\ngot %v, nil\nwant 0, %v", n, errClosedPipeWrite)
	}
}
func TestPipeBreakWithError(t *testing.T) {
	p := &pipe{b: new(bytes.Buffer)}
	io.WriteString(p, "foo")
	a := errors.New("test err")
	p.BreakWithError(a)
	all, err := ioutil.ReadAll(p)
	if string(all) != "" {
		t.Errorf("read bytes = %q; want empty string", all)
	}
	if err != a {
		t.Logf("read error = %v, %v", err, a)
	}
	if p.b != nil {
		t.Errorf("buffer should be nil after BreakWithError")
	}
	
	if n, err := p.Write([]byte("abc")); err != nil || n != 3 {
		t.Errorf("Write(abc) after break\ngot %v, %v\nwant 0, nil", n, err)
	}
	if p.b != nil {
		t.Errorf("buffer should be nil after Write")
	}
	
	if n, err := p.Read(make([]byte, 1)); err == nil || n != 0 {
		t.Errorf("Read() after close\ngot %v, nil\nwant 0, not nil", n)
	}
}
package http2
import (
	"bytes"
	"fmt"
	"log"
	"net
	"net
	"time"
	"golang.org
	"golang.org
)
type writeFramer interface {
	writeFrame(writeContext) error
	
	
	
	staysWithinBuffer(size int) bool
}
type writeContext interface {
	Framer() *Framer
	Flush() error
	CloseConn() error
	
	
	HeaderEncoder() (*hpack.Encoder, *bytes.Buffer)
}
func writeEndsStream(w writeFramer) bool {
	switch v := w.(type) {
	case *writeData:
		return v.endStream
	case *writeResHeaders:
		return v.endStream
	case nil:
		
		
		
		panic("writeEndsStream called on nil writeFramer")
	}
	return false
}
type flushFrameWriter struct{}
func (flushFrameWriter) writeFrame(ctx writeContext) error {
	return ctx.Flush()
}
func (flushFrameWriter) staysWithinBuffer(max int) bool { return false }
type writeSettings []Setting
func (s writeSettings) staysWithinBuffer(max int) bool {
	const settingSize = 6 
	return frameHeaderLen+settingSize*len(s) <= max
}
func (s writeSettings) writeFrame(ctx writeContext) error {
	return ctx.Framer().WriteSettings([]Setting(s)...)
}
type writeGoAway struct {
	maxStreamID uint32
	code        ErrCode
}
func (p *writeGoAway) writeFrame(ctx writeContext) error {
	err := ctx.Framer().WriteGoAway(p.maxStreamID, p.code, nil)
	if p.code != 0 {
		ctx.Flush() 
		time.Sleep(50 * time.Millisecond)
		ctx.CloseConn()
	}
	return err
}
func (*writeGoAway) staysWithinBuffer(max int) bool { return false } 
type writeData struct {
	streamID  uint32
	p         []byte
	endStream bool
}
func (w *writeData) String() string {
	return fmt.Sprintf("writeData(stream=%d, p=%d, endStream=%v)", w.streamID, len(w.p), w.endStream)
}
func (w *writeData) writeFrame(ctx writeContext) error {
	return ctx.Framer().WriteData(w.streamID, w.endStream, w.p)
}
func (w *writeData) staysWithinBuffer(max int) bool {
	return frameHeaderLen+len(w.p) <= max
}
type handlerPanicRST struct {
	StreamID uint32
}
func (hp handlerPanicRST) writeFrame(ctx writeContext) error {
	return ctx.Framer().WriteRSTStream(hp.StreamID, ErrCodeInternal)
}
func (hp handlerPanicRST) staysWithinBuffer(max int) bool { return frameHeaderLen+4 <= max }
func (se StreamError) writeFrame(ctx writeContext) error {
	return ctx.Framer().WriteRSTStream(se.StreamID, se.Code)
}
func (se StreamError) staysWithinBuffer(max int) bool { return frameHeaderLen+4 <= max }
type writePingAck struct{ pf *PingFrame }
func (w writePingAck) writeFrame(ctx writeContext) error {
	return ctx.Framer().WritePing(true, w.pf.Data)
}
func (w writePingAck) staysWithinBuffer(max int) bool { return frameHeaderLen+len(w.pf.Data) <= max }
type writeSettingsAck struct{}
func (writeSettingsAck) writeFrame(ctx writeContext) error {
	return ctx.Framer().WriteSettingsAck()
}
func (writeSettingsAck) staysWithinBuffer(max int) bool { return frameHeaderLen <= max }
func splitHeaderBlock(ctx writeContext, headerBlock []byte, fn func(ctx writeContext, frag []byte, firstFrag, lastFrag bool) error) error {
	
	
	
	
	
	
	const maxFrameSize = 16384
	first := true
	for len(headerBlock) > 0 {
		frag := headerBlock
		if len(frag) > maxFrameSize {
			frag = frag[:maxFrameSize]
		}
		headerBlock = headerBlock[len(frag):]
		if err := fn(ctx, frag, first, len(headerBlock) == 0); err != nil {
			return err
		}
		first = false
	}
	return nil
}
type writeResHeaders struct {
	streamID    uint32
	httpResCode int         
	h           http.Header 
	trailers    []string    
	endStream   bool
	date          string
	contentType   string
	contentLength string
}
func encKV(enc *hpack.Encoder, k, v string) {
	if VerboseLogs {
		log.Printf("http2: server encoding header %q = %q", k, v)
	}
	enc.WriteField(hpack.HeaderField{Name: k, Value: v})
}
func (w *writeResHeaders) staysWithinBuffer(max int) bool {
	
	
	
	
	
	
	
	return false
}
func (w *writeResHeaders) writeFrame(ctx writeContext) error {
	enc, buf := ctx.HeaderEncoder()
	buf.Reset()
	if w.httpResCode != 0 {
		encKV(enc, ":status", httpCodeString(w.httpResCode))
	}
	encodeHeaders(enc, w.h, w.trailers)
	if w.contentType != "" {
		encKV(enc, "content-type", w.contentType)
	}
	if w.contentLength != "" {
		encKV(enc, "content-length", w.contentLength)
	}
	if w.date != "" {
		encKV(enc, "date", w.date)
	}
	headerBlock := buf.Bytes()
	if len(headerBlock) == 0 && w.trailers == nil {
		panic("unexpected empty hpack")
	}
	return splitHeaderBlock(ctx, headerBlock, w.writeHeaderBlock)
}
func (w *writeResHeaders) writeHeaderBlock(ctx writeContext, frag []byte, firstFrag, lastFrag bool) error {
	if firstFrag {
		return ctx.Framer().WriteHeaders(HeadersFrameParam{
			StreamID:      w.streamID,
			BlockFragment: frag,
			EndStream:     w.endStream,
			EndHeaders:    lastFrag,
		})
	} else {
		return ctx.Framer().WriteContinuation(w.streamID, lastFrag, frag)
	}
}
type writePushPromise struct {
	streamID uint32   
	method   string   
	url      *url.URL 
	h        http.Header
	
	
	allocatePromisedID func() (uint32, error)
	promisedID         uint32
}
func (w *writePushPromise) staysWithinBuffer(max int) bool {
	
	return false
}
func (w *writePushPromise) writeFrame(ctx writeContext) error {
	enc, buf := ctx.HeaderEncoder()
	buf.Reset()
	encKV(enc, ":method", w.method)
	encKV(enc, ":scheme", w.url.Scheme)
	encKV(enc, ":authority", w.url.Host)
	encKV(enc, ":path", w.url.RequestURI())
	encodeHeaders(enc, w.h, nil)
	headerBlock := buf.Bytes()
	if len(headerBlock) == 0 {
		panic("unexpected empty hpack")
	}
	return splitHeaderBlock(ctx, headerBlock, w.writeHeaderBlock)
}
func (w *writePushPromise) writeHeaderBlock(ctx writeContext, frag []byte, firstFrag, lastFrag bool) error {
	if firstFrag {
		return ctx.Framer().WritePushPromise(PushPromiseParam{
			StreamID:      w.streamID,
			PromiseID:     w.promisedID,
			BlockFragment: frag,
			EndHeaders:    lastFrag,
		})
	} else {
		return ctx.Framer().WriteContinuation(w.streamID, lastFrag, frag)
	}
}
type write100ContinueHeadersFrame struct {
	streamID uint32
}
func (w write100ContinueHeadersFrame) writeFrame(ctx writeContext) error {
	enc, buf := ctx.HeaderEncoder()
	buf.Reset()
	encKV(enc, ":status", "100")
	return ctx.Framer().WriteHeaders(HeadersFrameParam{
		StreamID:      w.streamID,
		BlockFragment: buf.Bytes(),
		EndStream:     false,
		EndHeaders:    true,
	})
}
func (w write100ContinueHeadersFrame) staysWithinBuffer(max int) bool {
	
	return 9+2*(len(":status")+len("100")) <= max
}
type writeWindowUpdate struct {
	streamID uint32 
	n        uint32
}
func (wu writeWindowUpdate) staysWithinBuffer(max int) bool { return frameHeaderLen+4 <= max }
func (wu writeWindowUpdate) writeFrame(ctx writeContext) error {
	return ctx.Framer().WriteWindowUpdate(wu.streamID, wu.n)
}
func encodeHeaders(enc *hpack.Encoder, h http.Header, keys []string) {
	if keys == nil {
		sorter := sorterPool.Get().(*sorter)
		
		
		
		defer sorterPool.Put(sorter)
		keys = sorter.Keys(h)
	}
	for _, k := range keys {
		vv := h[k]
		k = lowerHeader(k)
		if !validWireHeaderFieldName(k) {
			
			
			
			continue
		}
		isTE := k == "transfer-encoding"
		for _, v := range vv {
			if !httplex.ValidHeaderFieldValue(v) {
				
				
				continue
			}
			
			if isTE && v != "trailers" {
				continue
			}
			encKV(enc, k, v)
		}
	}
}
package http2
const (
	cipher_TLS_NULL_WITH_NULL_NULL               uint16 = 0x0000
	cipher_TLS_RSA_WITH_NULL_MD5                 uint16 = 0x0001
	cipher_TLS_RSA_WITH_NULL_SHA                 uint16 = 0x0002
	cipher_TLS_RSA_EXPORT_WITH_RC4_40_MD5        uint16 = 0x0003
	cipher_TLS_RSA_WITH_RC4_128_MD5              uint16 = 0x0004
	cipher_TLS_RSA_WITH_RC4_128_SHA              uint16 = 0x0005
	cipher_TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5    uint16 = 0x0006
	cipher_TLS_RSA_WITH_IDEA_CBC_SHA             uint16 = 0x0007
	cipher_TLS_RSA_EXPORT_WITH_DES40_CBC_SHA     uint16 = 0x0008
	cipher_TLS_RSA_WITH_DES_CBC_SHA              uint16 = 0x0009
	cipher_TLS_RSA_WITH_3DES_EDE_CBC_SHA         uint16 = 0x000A
	cipher_TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA  uint16 = 0x000B
	cipher_TLS_DH_DSS_WITH_DES_CBC_SHA           uint16 = 0x000C
	cipher_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA      uint16 = 0x000D
	cipher_TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA  uint16 = 0x000E
	cipher_TLS_DH_RSA_WITH_DES_CBC_SHA           uint16 = 0x000F
	cipher_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA      uint16 = 0x0010
	cipher_TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA uint16 = 0x0011
	cipher_TLS_DHE_DSS_WITH_DES_CBC_SHA          uint16 = 0x0012
	cipher_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA     uint16 = 0x0013
	cipher_TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA uint16 = 0x0014
	cipher_TLS_DHE_RSA_WITH_DES_CBC_SHA          uint16 = 0x0015
	cipher_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA     uint16 = 0x0016
	cipher_TLS_DH_anon_EXPORT_WITH_RC4_40_MD5    uint16 = 0x0017
	cipher_TLS_DH_anon_WITH_RC4_128_MD5          uint16 = 0x0018
	cipher_TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA uint16 = 0x0019
	cipher_TLS_DH_anon_WITH_DES_CBC_SHA          uint16 = 0x001A
	cipher_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA     uint16 = 0x001B
	
	cipher_TLS_KRB5_WITH_DES_CBC_SHA             uint16 = 0x001E
	cipher_TLS_KRB5_WITH_3DES_EDE_CBC_SHA        uint16 = 0x001F
	cipher_TLS_KRB5_WITH_RC4_128_SHA             uint16 = 0x0020
	cipher_TLS_KRB5_WITH_IDEA_CBC_SHA            uint16 = 0x0021
	cipher_TLS_KRB5_WITH_DES_CBC_MD5             uint16 = 0x0022
	cipher_TLS_KRB5_WITH_3DES_EDE_CBC_MD5        uint16 = 0x0023
	cipher_TLS_KRB5_WITH_RC4_128_MD5             uint16 = 0x0024
	cipher_TLS_KRB5_WITH_IDEA_CBC_MD5            uint16 = 0x0025
	cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA   uint16 = 0x0026
	cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA   uint16 = 0x0027
	cipher_TLS_KRB5_EXPORT_WITH_RC4_40_SHA       uint16 = 0x0028
	cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5   uint16 = 0x0029
	cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5   uint16 = 0x002A
	cipher_TLS_KRB5_EXPORT_WITH_RC4_40_MD5       uint16 = 0x002B
	cipher_TLS_PSK_WITH_NULL_SHA                 uint16 = 0x002C
	cipher_TLS_DHE_PSK_WITH_NULL_SHA             uint16 = 0x002D
	cipher_TLS_RSA_PSK_WITH_NULL_SHA             uint16 = 0x002E
	cipher_TLS_RSA_WITH_AES_128_CBC_SHA          uint16 = 0x002F
	cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA       uint16 = 0x0030
	cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA       uint16 = 0x0031
	cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA      uint16 = 0x0032
	cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA      uint16 = 0x0033
	cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA      uint16 = 0x0034
	cipher_TLS_RSA_WITH_AES_256_CBC_SHA          uint16 = 0x0035
	cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA       uint16 = 0x0036
	cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA       uint16 = 0x0037
	cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA      uint16 = 0x0038
	cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA      uint16 = 0x0039
	cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA      uint16 = 0x003A
	cipher_TLS_RSA_WITH_NULL_SHA256              uint16 = 0x003B
	cipher_TLS_RSA_WITH_AES_128_CBC_SHA256       uint16 = 0x003C
	cipher_TLS_RSA_WITH_AES_256_CBC_SHA256       uint16 = 0x003D
	cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA256    uint16 = 0x003E
	cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA256    uint16 = 0x003F
	cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256   uint16 = 0x0040
	cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA     uint16 = 0x0041
	cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA  uint16 = 0x0042
	cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA  uint16 = 0x0043
	cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA uint16 = 0x0044
	cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA uint16 = 0x0045
	cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA uint16 = 0x0046
	
	
	
	
	
	cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 uint16 = 0x0067
	cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA256  uint16 = 0x0068
	cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA256  uint16 = 0x0069
	cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 uint16 = 0x006A
	cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 uint16 = 0x006B
	cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA256 uint16 = 0x006C
	cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA256 uint16 = 0x006D
	
	cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA        uint16 = 0x0084
	cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA     uint16 = 0x0085
	cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA     uint16 = 0x0086
	cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA    uint16 = 0x0087
	cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA    uint16 = 0x0088
	cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA    uint16 = 0x0089
	cipher_TLS_PSK_WITH_RC4_128_SHA                 uint16 = 0x008A
	cipher_TLS_PSK_WITH_3DES_EDE_CBC_SHA            uint16 = 0x008B
	cipher_TLS_PSK_WITH_AES_128_CBC_SHA             uint16 = 0x008C
	cipher_TLS_PSK_WITH_AES_256_CBC_SHA             uint16 = 0x008D
	cipher_TLS_DHE_PSK_WITH_RC4_128_SHA             uint16 = 0x008E
	cipher_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA        uint16 = 0x008F
	cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA         uint16 = 0x0090
	cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA         uint16 = 0x0091
	cipher_TLS_RSA_PSK_WITH_RC4_128_SHA             uint16 = 0x0092
	cipher_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA        uint16 = 0x0093
	cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA         uint16 = 0x0094
	cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA         uint16 = 0x0095
	cipher_TLS_RSA_WITH_SEED_CBC_SHA                uint16 = 0x0096
	cipher_TLS_DH_DSS_WITH_SEED_CBC_SHA             uint16 = 0x0097
	cipher_TLS_DH_RSA_WITH_SEED_CBC_SHA             uint16 = 0x0098
	cipher_TLS_DHE_DSS_WITH_SEED_CBC_SHA            uint16 = 0x0099
	cipher_TLS_DHE_RSA_WITH_SEED_CBC_SHA            uint16 = 0x009A
	cipher_TLS_DH_anon_WITH_SEED_CBC_SHA            uint16 = 0x009B
	cipher_TLS_RSA_WITH_AES_128_GCM_SHA256          uint16 = 0x009C
	cipher_TLS_RSA_WITH_AES_256_GCM_SHA384          uint16 = 0x009D
	cipher_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256      uint16 = 0x009E
	cipher_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384      uint16 = 0x009F
	cipher_TLS_DH_RSA_WITH_AES_128_GCM_SHA256       uint16 = 0x00A0
	cipher_TLS_DH_RSA_WITH_AES_256_GCM_SHA384       uint16 = 0x00A1
	cipher_TLS_DHE_DSS_WITH_AES_128_GCM_SHA256      uint16 = 0x00A2
	cipher_TLS_DHE_DSS_WITH_AES_256_GCM_SHA384      uint16 = 0x00A3
	cipher_TLS_DH_DSS_WITH_AES_128_GCM_SHA256       uint16 = 0x00A4
	cipher_TLS_DH_DSS_WITH_AES_256_GCM_SHA384       uint16 = 0x00A5
	cipher_TLS_DH_anon_WITH_AES_128_GCM_SHA256      uint16 = 0x00A6
	cipher_TLS_DH_anon_WITH_AES_256_GCM_SHA384      uint16 = 0x00A7
	cipher_TLS_PSK_WITH_AES_128_GCM_SHA256          uint16 = 0x00A8
	cipher_TLS_PSK_WITH_AES_256_GCM_SHA384          uint16 = 0x00A9
	cipher_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256      uint16 = 0x00AA
	cipher_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384      uint16 = 0x00AB
	cipher_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256      uint16 = 0x00AC
	cipher_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384      uint16 = 0x00AD
	cipher_TLS_PSK_WITH_AES_128_CBC_SHA256          uint16 = 0x00AE
	cipher_TLS_PSK_WITH_AES_256_CBC_SHA384          uint16 = 0x00AF
	cipher_TLS_PSK_WITH_NULL_SHA256                 uint16 = 0x00B0
	cipher_TLS_PSK_WITH_NULL_SHA384                 uint16 = 0x00B1
	cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256      uint16 = 0x00B2
	cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384      uint16 = 0x00B3
	cipher_TLS_DHE_PSK_WITH_NULL_SHA256             uint16 = 0x00B4
	cipher_TLS_DHE_PSK_WITH_NULL_SHA384             uint16 = 0x00B5
	cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256      uint16 = 0x00B6
	cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384      uint16 = 0x00B7
	cipher_TLS_RSA_PSK_WITH_NULL_SHA256             uint16 = 0x00B8
	cipher_TLS_RSA_PSK_WITH_NULL_SHA384             uint16 = 0x00B9
	cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256     uint16 = 0x00BA
	cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256  uint16 = 0x00BB
	cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256  uint16 = 0x00BC
	cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0x00BD
	cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0x00BE
	cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0x00BF
	cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256     uint16 = 0x00C0
	cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256  uint16 = 0x00C1
	cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256  uint16 = 0x00C2
	cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 uint16 = 0x00C3
	cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 uint16 = 0x00C4
	cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 uint16 = 0x00C5
	
	cipher_TLS_EMPTY_RENEGOTIATION_INFO_SCSV uint16 = 0x00FF
	
	cipher_TLS_FALLBACK_SCSV uint16 = 0x5600
	
	cipher_TLS_ECDH_ECDSA_WITH_NULL_SHA                 uint16 = 0xC001
	cipher_TLS_ECDH_ECDSA_WITH_RC4_128_SHA              uint16 = 0xC002
	cipher_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA         uint16 = 0xC003
	cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA          uint16 = 0xC004
	cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA          uint16 = 0xC005
	cipher_TLS_ECDHE_ECDSA_WITH_NULL_SHA                uint16 = 0xC006
	cipher_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA             uint16 = 0xC007
	cipher_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA        uint16 = 0xC008
	cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA         uint16 = 0xC009
	cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA         uint16 = 0xC00A
	cipher_TLS_ECDH_RSA_WITH_NULL_SHA                   uint16 = 0xC00B
	cipher_TLS_ECDH_RSA_WITH_RC4_128_SHA                uint16 = 0xC00C
	cipher_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA           uint16 = 0xC00D
	cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA            uint16 = 0xC00E
	cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA            uint16 = 0xC00F
	cipher_TLS_ECDHE_RSA_WITH_NULL_SHA                  uint16 = 0xC010
	cipher_TLS_ECDHE_RSA_WITH_RC4_128_SHA               uint16 = 0xC011
	cipher_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA          uint16 = 0xC012
	cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA           uint16 = 0xC013
	cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA           uint16 = 0xC014
	cipher_TLS_ECDH_anon_WITH_NULL_SHA                  uint16 = 0xC015
	cipher_TLS_ECDH_anon_WITH_RC4_128_SHA               uint16 = 0xC016
	cipher_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA          uint16 = 0xC017
	cipher_TLS_ECDH_anon_WITH_AES_128_CBC_SHA           uint16 = 0xC018
	cipher_TLS_ECDH_anon_WITH_AES_256_CBC_SHA           uint16 = 0xC019
	cipher_TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA            uint16 = 0xC01A
	cipher_TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA        uint16 = 0xC01B
	cipher_TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA        uint16 = 0xC01C
	cipher_TLS_SRP_SHA_WITH_AES_128_CBC_SHA             uint16 = 0xC01D
	cipher_TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA         uint16 = 0xC01E
	cipher_TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA         uint16 = 0xC01F
	cipher_TLS_SRP_SHA_WITH_AES_256_CBC_SHA             uint16 = 0xC020
	cipher_TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA         uint16 = 0xC021
	cipher_TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA         uint16 = 0xC022
	cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256      uint16 = 0xC023
	cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384      uint16 = 0xC024
	cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256       uint16 = 0xC025
	cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384       uint16 = 0xC026
	cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256        uint16 = 0xC027
	cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384        uint16 = 0xC028
	cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256         uint16 = 0xC029
	cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384         uint16 = 0xC02A
	cipher_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256      uint16 = 0xC02B
	cipher_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384      uint16 = 0xC02C
	cipher_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256       uint16 = 0xC02D
	cipher_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384       uint16 = 0xC02E
	cipher_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256        uint16 = 0xC02F
	cipher_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384        uint16 = 0xC030
	cipher_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256         uint16 = 0xC031
	cipher_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384         uint16 = 0xC032
	cipher_TLS_ECDHE_PSK_WITH_RC4_128_SHA               uint16 = 0xC033
	cipher_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA          uint16 = 0xC034
	cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA           uint16 = 0xC035
	cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA           uint16 = 0xC036
	cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256        uint16 = 0xC037
	cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384        uint16 = 0xC038
	cipher_TLS_ECDHE_PSK_WITH_NULL_SHA                  uint16 = 0xC039
	cipher_TLS_ECDHE_PSK_WITH_NULL_SHA256               uint16 = 0xC03A
	cipher_TLS_ECDHE_PSK_WITH_NULL_SHA384               uint16 = 0xC03B
	cipher_TLS_RSA_WITH_ARIA_128_CBC_SHA256             uint16 = 0xC03C
	cipher_TLS_RSA_WITH_ARIA_256_CBC_SHA384             uint16 = 0xC03D
	cipher_TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256          uint16 = 0xC03E
	cipher_TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384          uint16 = 0xC03F
	cipher_TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256          uint16 = 0xC040
	cipher_TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384          uint16 = 0xC041
	cipher_TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256         uint16 = 0xC042
	cipher_TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384         uint16 = 0xC043
	cipher_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256         uint16 = 0xC044
	cipher_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384         uint16 = 0xC045
	cipher_TLS_DH_anon_WITH_ARIA_128_CBC_SHA256         uint16 = 0xC046
	cipher_TLS_DH_anon_WITH_ARIA_256_CBC_SHA384         uint16 = 0xC047
	cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256     uint16 = 0xC048
	cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384     uint16 = 0xC049
	cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256      uint16 = 0xC04A
	cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384      uint16 = 0xC04B
	cipher_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256       uint16 = 0xC04C
	cipher_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384       uint16 = 0xC04D
	cipher_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256        uint16 = 0xC04E
	cipher_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384        uint16 = 0xC04F
	cipher_TLS_RSA_WITH_ARIA_128_GCM_SHA256             uint16 = 0xC050
	cipher_TLS_RSA_WITH_ARIA_256_GCM_SHA384             uint16 = 0xC051
	cipher_TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256         uint16 = 0xC052
	cipher_TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384         uint16 = 0xC053
	cipher_TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256          uint16 = 0xC054
	cipher_TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384          uint16 = 0xC055
	cipher_TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256         uint16 = 0xC056
	cipher_TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384         uint16 = 0xC057
	cipher_TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256          uint16 = 0xC058
	cipher_TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384          uint16 = 0xC059
	cipher_TLS_DH_anon_WITH_ARIA_128_GCM_SHA256         uint16 = 0xC05A
	cipher_TLS_DH_anon_WITH_ARIA_256_GCM_SHA384         uint16 = 0xC05B
	cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256     uint16 = 0xC05C
	cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384     uint16 = 0xC05D
	cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256      uint16 = 0xC05E
	cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384      uint16 = 0xC05F
	cipher_TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256       uint16 = 0xC060
	cipher_TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384       uint16 = 0xC061
	cipher_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256        uint16 = 0xC062
	cipher_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384        uint16 = 0xC063
	cipher_TLS_PSK_WITH_ARIA_128_CBC_SHA256             uint16 = 0xC064
	cipher_TLS_PSK_WITH_ARIA_256_CBC_SHA384             uint16 = 0xC065
	cipher_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256         uint16 = 0xC066
	cipher_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384         uint16 = 0xC067
	cipher_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256         uint16 = 0xC068
	cipher_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384         uint16 = 0xC069
	cipher_TLS_PSK_WITH_ARIA_128_GCM_SHA256             uint16 = 0xC06A
	cipher_TLS_PSK_WITH_ARIA_256_GCM_SHA384             uint16 = 0xC06B
	cipher_TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256         uint16 = 0xC06C
	cipher_TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384         uint16 = 0xC06D
	cipher_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256         uint16 = 0xC06E
	cipher_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384         uint16 = 0xC06F
	cipher_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256       uint16 = 0xC070
	cipher_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384       uint16 = 0xC071
	cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0xC072
	cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 uint16 = 0xC073
	cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256  uint16 = 0xC074
	cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384  uint16 = 0xC075
	cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256   uint16 = 0xC076
	cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384   uint16 = 0xC077
	cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256    uint16 = 0xC078
	cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384    uint16 = 0xC079
	cipher_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256         uint16 = 0xC07A
	cipher_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384         uint16 = 0xC07B
	cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256     uint16 = 0xC07C
	cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384     uint16 = 0xC07D
	cipher_TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256      uint16 = 0xC07E
	cipher_TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384      uint16 = 0xC07F
	cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256     uint16 = 0xC080
	cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384     uint16 = 0xC081
	cipher_TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256      uint16 = 0xC082
	cipher_TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384      uint16 = 0xC083
	cipher_TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256     uint16 = 0xC084
	cipher_TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384     uint16 = 0xC085
	cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC086
	cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC087
	cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256  uint16 = 0xC088
	cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384  uint16 = 0xC089
	cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256   uint16 = 0xC08A
	cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384   uint16 = 0xC08B
	cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256    uint16 = 0xC08C
	cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384    uint16 = 0xC08D
	cipher_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256         uint16 = 0xC08E
	cipher_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384         uint16 = 0xC08F
	cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256     uint16 = 0xC090
	cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384     uint16 = 0xC091
	cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256     uint16 = 0xC092
	cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384     uint16 = 0xC093
	cipher_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256         uint16 = 0xC094
	cipher_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384         uint16 = 0xC095
	cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256     uint16 = 0xC096
	cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384     uint16 = 0xC097
	cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256     uint16 = 0xC098
	cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384     uint16 = 0xC099
	cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256   uint16 = 0xC09A
	cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384   uint16 = 0xC09B
	cipher_TLS_RSA_WITH_AES_128_CCM                     uint16 = 0xC09C
	cipher_TLS_RSA_WITH_AES_256_CCM                     uint16 = 0xC09D
	cipher_TLS_DHE_RSA_WITH_AES_128_CCM                 uint16 = 0xC09E
	cipher_TLS_DHE_RSA_WITH_AES_256_CCM                 uint16 = 0xC09F
	cipher_TLS_RSA_WITH_AES_128_CCM_8                   uint16 = 0xC0A0
	cipher_TLS_RSA_WITH_AES_256_CCM_8                   uint16 = 0xC0A1
	cipher_TLS_DHE_RSA_WITH_AES_128_CCM_8               uint16 = 0xC0A2
	cipher_TLS_DHE_RSA_WITH_AES_256_CCM_8               uint16 = 0xC0A3
	cipher_TLS_PSK_WITH_AES_128_CCM                     uint16 = 0xC0A4
	cipher_TLS_PSK_WITH_AES_256_CCM                     uint16 = 0xC0A5
	cipher_TLS_DHE_PSK_WITH_AES_128_CCM                 uint16 = 0xC0A6
	cipher_TLS_DHE_PSK_WITH_AES_256_CCM                 uint16 = 0xC0A7
	cipher_TLS_PSK_WITH_AES_128_CCM_8                   uint16 = 0xC0A8
	cipher_TLS_PSK_WITH_AES_256_CCM_8                   uint16 = 0xC0A9
	cipher_TLS_PSK_DHE_WITH_AES_128_CCM_8               uint16 = 0xC0AA
	cipher_TLS_PSK_DHE_WITH_AES_256_CCM_8               uint16 = 0xC0AB
	cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM             uint16 = 0xC0AC
	cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM             uint16 = 0xC0AD
	cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8           uint16 = 0xC0AE
	cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8           uint16 = 0xC0AF
	
	
	
	cipher_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256   uint16 = 0xCCA8
	cipher_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 uint16 = 0xCCA9
	cipher_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256     uint16 = 0xCCAA
	cipher_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256         uint16 = 0xCCAB
	cipher_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256   uint16 = 0xCCAC
	cipher_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256     uint16 = 0xCCAD
	cipher_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256     uint16 = 0xCCAE
)
func isBadCipher(cipher uint16) bool {
	switch cipher {
	case cipher_TLS_NULL_WITH_NULL_NULL,
		cipher_TLS_RSA_WITH_NULL_MD5,
		cipher_TLS_RSA_WITH_NULL_SHA,
		cipher_TLS_RSA_EXPORT_WITH_RC4_40_MD5,
		cipher_TLS_RSA_WITH_RC4_128_MD5,
		cipher_TLS_RSA_WITH_RC4_128_SHA,
		cipher_TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5,
		cipher_TLS_RSA_WITH_IDEA_CBC_SHA,
		cipher_TLS_RSA_EXPORT_WITH_DES40_CBC_SHA,
		cipher_TLS_RSA_WITH_DES_CBC_SHA,
		cipher_TLS_RSA_WITH_3DES_EDE_CBC_SHA,
		cipher_TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA,
		cipher_TLS_DH_DSS_WITH_DES_CBC_SHA,
		cipher_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA,
		cipher_TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA,
		cipher_TLS_DH_RSA_WITH_DES_CBC_SHA,
		cipher_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA,
		cipher_TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA,
		cipher_TLS_DHE_DSS_WITH_DES_CBC_SHA,
		cipher_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA,
		cipher_TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA,
		cipher_TLS_DHE_RSA_WITH_DES_CBC_SHA,
		cipher_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA,
		cipher_TLS_DH_anon_EXPORT_WITH_RC4_40_MD5,
		cipher_TLS_DH_anon_WITH_RC4_128_MD5,
		cipher_TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA,
		cipher_TLS_DH_anon_WITH_DES_CBC_SHA,
		cipher_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA,
		cipher_TLS_KRB5_WITH_DES_CBC_SHA,
		cipher_TLS_KRB5_WITH_3DES_EDE_CBC_SHA,
		cipher_TLS_KRB5_WITH_RC4_128_SHA,
		cipher_TLS_KRB5_WITH_IDEA_CBC_SHA,
		cipher_TLS_KRB5_WITH_DES_CBC_MD5,
		cipher_TLS_KRB5_WITH_3DES_EDE_CBC_MD5,
		cipher_TLS_KRB5_WITH_RC4_128_MD5,
		cipher_TLS_KRB5_WITH_IDEA_CBC_MD5,
		cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA,
		cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA,
		cipher_TLS_KRB5_EXPORT_WITH_RC4_40_SHA,
		cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5,
		cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5,
		cipher_TLS_KRB5_EXPORT_WITH_RC4_40_MD5,
		cipher_TLS_PSK_WITH_NULL_SHA,
		cipher_TLS_DHE_PSK_WITH_NULL_SHA,
		cipher_TLS_RSA_PSK_WITH_NULL_SHA,
		cipher_TLS_RSA_WITH_AES_128_CBC_SHA,
		cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA,
		cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA,
		cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA,
		cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
		cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA,
		cipher_TLS_RSA_WITH_AES_256_CBC_SHA,
		cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA,
		cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA,
		cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA,
		cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
		cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA,
		cipher_TLS_RSA_WITH_NULL_SHA256,
		cipher_TLS_RSA_WITH_AES_128_CBC_SHA256,
		cipher_TLS_RSA_WITH_AES_256_CBC_SHA256,
		cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA256,
		cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA256,
		cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256,
		cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA,
		cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA,
		cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA,
		cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA,
		cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA,
		cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA,
		cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,
		cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA256,
		cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA256,
		cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256,
		cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256,
		cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA256,
		cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA256,
		cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA,
		cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA,
		cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA,
		cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA,
		cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA,
		cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA,
		cipher_TLS_PSK_WITH_RC4_128_SHA,
		cipher_TLS_PSK_WITH_3DES_EDE_CBC_SHA,
		cipher_TLS_PSK_WITH_AES_128_CBC_SHA,
		cipher_TLS_PSK_WITH_AES_256_CBC_SHA,
		cipher_TLS_DHE_PSK_WITH_RC4_128_SHA,
		cipher_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA,
		cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA,
		cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA,
		cipher_TLS_RSA_PSK_WITH_RC4_128_SHA,
		cipher_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA,
		cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA,
		cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA,
		cipher_TLS_RSA_WITH_SEED_CBC_SHA,
		cipher_TLS_DH_DSS_WITH_SEED_CBC_SHA,
		cipher_TLS_DH_RSA_WITH_SEED_CBC_SHA,
		cipher_TLS_DHE_DSS_WITH_SEED_CBC_SHA,
		cipher_TLS_DHE_RSA_WITH_SEED_CBC_SHA,
		cipher_TLS_DH_anon_WITH_SEED_CBC_SHA,
		cipher_TLS_RSA_WITH_AES_128_GCM_SHA256,
		cipher_TLS_RSA_WITH_AES_256_GCM_SHA384,
		cipher_TLS_DH_RSA_WITH_AES_128_GCM_SHA256,
		cipher_TLS_DH_RSA_WITH_AES_256_GCM_SHA384,
		cipher_TLS_DH_DSS_WITH_AES_128_GCM_SHA256,
		cipher_TLS_DH_DSS_WITH_AES_256_GCM_SHA384,
		cipher_TLS_DH_anon_WITH_AES_128_GCM_SHA256,
		cipher_TLS_DH_anon_WITH_AES_256_GCM_SHA384,
		cipher_TLS_PSK_WITH_AES_128_GCM_SHA256,
		cipher_TLS_PSK_WITH_AES_256_GCM_SHA384,
		cipher_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256,
		cipher_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384,
		cipher_TLS_PSK_WITH_AES_128_CBC_SHA256,
		cipher_TLS_PSK_WITH_AES_256_CBC_SHA384,
		cipher_TLS_PSK_WITH_NULL_SHA256,
		cipher_TLS_PSK_WITH_NULL_SHA384,
		cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256,
		cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384,
		cipher_TLS_DHE_PSK_WITH_NULL_SHA256,
		cipher_TLS_DHE_PSK_WITH_NULL_SHA384,
		cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256,
		cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384,
		cipher_TLS_RSA_PSK_WITH_NULL_SHA256,
		cipher_TLS_RSA_PSK_WITH_NULL_SHA384,
		cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256,
		cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256,
		cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256,
		cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256,
		cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256,
		cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256,
		cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256,
		cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256,
		cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256,
		cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256,
		cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256,
		cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256,
		cipher_TLS_EMPTY_RENEGOTIATION_INFO_SCSV,
		cipher_TLS_ECDH_ECDSA_WITH_NULL_SHA,
		cipher_TLS_ECDH_ECDSA_WITH_RC4_128_SHA,
		cipher_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA,
		cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA,
		cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA,
		cipher_TLS_ECDHE_ECDSA_WITH_NULL_SHA,
		cipher_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,
		cipher_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA,
		cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
		cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
		cipher_TLS_ECDH_RSA_WITH_NULL_SHA,
		cipher_TLS_ECDH_RSA_WITH_RC4_128_SHA,
		cipher_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA,
		cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA,
		cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA,
		cipher_TLS_ECDHE_RSA_WITH_NULL_SHA,
		cipher_TLS_ECDHE_RSA_WITH_RC4_128_SHA,
		cipher_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,
		cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
		cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
		cipher_TLS_ECDH_anon_WITH_NULL_SHA,
		cipher_TLS_ECDH_anon_WITH_RC4_128_SHA,
		cipher_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA,
		cipher_TLS_ECDH_anon_WITH_AES_128_CBC_SHA,
		cipher_TLS_ECDH_anon_WITH_AES_256_CBC_SHA,
		cipher_TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA,
		cipher_TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA,
		cipher_TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA,
		cipher_TLS_SRP_SHA_WITH_AES_128_CBC_SHA,
		cipher_TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA,
		cipher_TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA,
		cipher_TLS_SRP_SHA_WITH_AES_256_CBC_SHA,
		cipher_TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA,
		cipher_TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA,
		cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,
		cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,
		cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256,
		cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384,
		cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,
		cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,
		cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256,
		cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384,
		cipher_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256,
		cipher_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384,
		cipher_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256,
		cipher_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384,
		cipher_TLS_ECDHE_PSK_WITH_RC4_128_SHA,
		cipher_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA,
		cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA,
		cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA,
		cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256,
		cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384,
		cipher_TLS_ECDHE_PSK_WITH_NULL_SHA,
		cipher_TLS_ECDHE_PSK_WITH_NULL_SHA256,
		cipher_TLS_ECDHE_PSK_WITH_NULL_SHA384,
		cipher_TLS_RSA_WITH_ARIA_128_CBC_SHA256,
		cipher_TLS_RSA_WITH_ARIA_256_CBC_SHA384,
		cipher_TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256,
		cipher_TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384,
		cipher_TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256,
		cipher_TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384,
		cipher_TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256,
		cipher_TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384,
		cipher_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256,
		cipher_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384,
		cipher_TLS_DH_anon_WITH_ARIA_128_CBC_SHA256,
		cipher_TLS_DH_anon_WITH_ARIA_256_CBC_SHA384,
		cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256,
		cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384,
		cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256,
		cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384,
		cipher_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256,
		cipher_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384,
		cipher_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256,
		cipher_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384,
		cipher_TLS_RSA_WITH_ARIA_128_GCM_SHA256,
		cipher_TLS_RSA_WITH_ARIA_256_GCM_SHA384,
		cipher_TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256,
		cipher_TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384,
		cipher_TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256,
		cipher_TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384,
		cipher_TLS_DH_anon_WITH_ARIA_128_GCM_SHA256,
		cipher_TLS_DH_anon_WITH_ARIA_256_GCM_SHA384,
		cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256,
		cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384,
		cipher_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256,
		cipher_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384,
		cipher_TLS_PSK_WITH_ARIA_128_CBC_SHA256,
		cipher_TLS_PSK_WITH_ARIA_256_CBC_SHA384,
		cipher_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256,
		cipher_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384,
		cipher_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256,
		cipher_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384,
		cipher_TLS_PSK_WITH_ARIA_128_GCM_SHA256,
		cipher_TLS_PSK_WITH_ARIA_256_GCM_SHA384,
		cipher_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256,
		cipher_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384,
		cipher_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256,
		cipher_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384,
		cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256,
		cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384,
		cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256,
		cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384,
		cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256,
		cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384,
		cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256,
		cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384,
		cipher_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256,
		cipher_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384,
		cipher_TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256,
		cipher_TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384,
		cipher_TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256,
		cipher_TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384,
		cipher_TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256,
		cipher_TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384,
		cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256,
		cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384,
		cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256,
		cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384,
		cipher_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256,
		cipher_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384,
		cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256,
		cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384,
		cipher_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256,
		cipher_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384,
		cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256,
		cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384,
		cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256,
		cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384,
		cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256,
		cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384,
		cipher_TLS_RSA_WITH_AES_128_CCM,
		cipher_TLS_RSA_WITH_AES_256_CCM,
		cipher_TLS_RSA_WITH_AES_128_CCM_8,
		cipher_TLS_RSA_WITH_AES_256_CCM_8,
		cipher_TLS_PSK_WITH_AES_128_CCM,
		cipher_TLS_PSK_WITH_AES_256_CCM,
		cipher_TLS_PSK_WITH_AES_128_CCM_8,
		cipher_TLS_PSK_WITH_AES_256_CCM_8:
		return true
	default:
		return false
	}
}
package http2
import "fmt"
type WriteScheduler interface {
	
	
	
	OpenStream(streamID uint32, options OpenStreamOptions)
	
	
	
	CloseStream(streamID uint32)
	
	
	
	
	AdjustStream(streamID uint32, priority PriorityParam)
	
	
	
	Push(wr FrameWriteRequest)
	
	
	
	Pop() (wr FrameWriteRequest, ok bool)
}
type OpenStreamOptions struct {
	
	
	PusherID uint32
}
type FrameWriteRequest struct {
	
	
	
	write writeFramer
	
	
	stream *stream
	
	
	
	done chan error
}
func (wr FrameWriteRequest) StreamID() uint32 {
	if wr.stream == nil {
		if se, ok := wr.write.(StreamError); ok {
			
			
			
			
			return se.StreamID
		}
		return 0
	}
	return wr.stream.id
}
func (wr FrameWriteRequest) DataSize() int {
	if wd, ok := wr.write.(*writeData); ok {
		return len(wd.p)
	}
	return 0
}
func (wr FrameWriteRequest) Consume(n int32) (FrameWriteRequest, FrameWriteRequest, int) {
	var empty FrameWriteRequest
	
	wd, ok := wr.write.(*writeData)
	if !ok || len(wd.p) == 0 {
		return wr, empty, 1
	}
	
	allowed := wr.stream.flow.available()
	if n < allowed {
		allowed = n
	}
	if wr.stream.sc.maxFrameSize < allowed {
		allowed = wr.stream.sc.maxFrameSize
	}
	if allowed <= 0 {
		return empty, empty, 0
	}
	if len(wd.p) > int(allowed) {
		wr.stream.flow.take(allowed)
		consumed := FrameWriteRequest{
			stream: wr.stream,
			write: &writeData{
				streamID: wd.streamID,
				p:        wd.p[:allowed],
				
				
				
				endStream: false,
			},
			
			
			done: nil,
		}
		rest := FrameWriteRequest{
			stream: wr.stream,
			write: &writeData{
				streamID:  wd.streamID,
				p:         wd.p[allowed:],
				endStream: wd.endStream,
			},
			done: wr.done,
		}
		return consumed, rest, 2
	}
	
	
	wr.stream.flow.take(int32(len(wd.p)))
	return wr, empty, 1
}
func (wr FrameWriteRequest) String() string {
	var des string
	if s, ok := wr.write.(fmt.Stringer); ok {
		des = s.String()
	} else {
		des = fmt.Sprintf("%T", wr.write)
	}
	return fmt.Sprintf("[FrameWriteRequest stream=%d, ch=%v, writer=%v]", wr.StreamID(), wr.done != nil, des)
}
func (wr *FrameWriteRequest) replyToWriter(err error) {
	if wr.done == nil {
		return
	}
	select {
	case wr.done <- err:
	default:
		panic(fmt.Sprintf("unbuffered done channel passed in for type %T", wr.write))
	}
	wr.write = nil 
}
type writeQueue struct {
	s []FrameWriteRequest
}
func (q *writeQueue) empty() bool { return len(q.s) == 0 }
func (q *writeQueue) push(wr FrameWriteRequest) {
	q.s = append(q.s, wr)
}
func (q *writeQueue) shift() FrameWriteRequest {
	if len(q.s) == 0 {
		panic("invalid use of queue")
	}
	wr := q.s[0]
	
	copy(q.s, q.s[1:])
	q.s[len(q.s)-1] = FrameWriteRequest{}
	q.s = q.s[:len(q.s)-1]
	return wr
}
func (q *writeQueue) consume(n int32) (FrameWriteRequest, bool) {
	if len(q.s) == 0 {
		return FrameWriteRequest{}, false
	}
	consumed, rest, numresult := q.s[0].Consume(n)
	switch numresult {
	case 0:
		return FrameWriteRequest{}, false
	case 1:
		q.shift()
	case 2:
		q.s[0] = rest
	}
	return consumed, true
}
type writeQueuePool []*writeQueue
func (p *writeQueuePool) put(q *writeQueue) {
	for i := range q.s {
		q.s[i] = FrameWriteRequest{}
	}
	q.s = q.s[:0]
	*p = append(*p, q)
}
func (p *writeQueuePool) get() *writeQueue {
	ln := len(*p)
	if ln == 0 {
		return new(writeQueue)
	}
	x := ln - 1
	q := (*p)[x]
	(*p)[x] = nil
	*p = (*p)[:x]
	return q
}
The h2i command is an interactive HTTP
Usage:
  $ h2i [flags] <hostname>
Interactive commands in the console: (all parts case-insensitive)
  ping [data]
  settings ack
  settings FOO=n BAR=z
  headers      (open a new stream by typing HTTP
*
package main
import (
	"bufio"
	"bytes"
	"crypto
	"errors"
	"flag"
	"fmt"
	"io"
	"log"
	"net"
	"net
	"os"
	"regexp"
	"strconv"
	"strings"
	"golang.org
	"golang.org
	"golang.org
)
var (
	flagNextProto = flag.String("nextproto", "h2,h2-14", "Comma-separated list of NPN
	flagInsecure  = flag.Bool("insecure", false, "Whether to skip TLS cert validation")
	flagSettings  = flag.String("settings", "empty", "comma-separated list of KEY=value settings for the initial SETTINGS frame. The magic value 'empty' sends an empty initial settings frame, and the magic value 'omit' causes no initial settings frame to be sent.")
	flagDial      = flag.String("dial", "", "optional ip:port to dial, to connect to a host:port but use a different SNI name (including a SNI name without DNS)")
)
type command struct {
	run func(*h2i, []string) error 
	
	
	complete func() []string
}
var commands = map[string]command{
	"ping": {run: (*h2i).cmdPing},
	"settings": {
		run: (*h2i).cmdSettings,
		complete: func() []string {
			return []string{
				"ACK",
				http2.SettingHeaderTableSize.String(),
				http2.SettingEnablePush.String(),
				http2.SettingMaxConcurrentStreams.String(),
				http2.SettingInitialWindowSize.String(),
				http2.SettingMaxFrameSize.String(),
				http2.SettingMaxHeaderListSize.String(),
			}
		},
	},
	"quit":    {run: (*h2i).cmdQuit},
	"headers": {run: (*h2i).cmdHeaders},
}
func usage() {
	fmt.Fprintf(os.Stderr, "Usage: h2i <hostname>\n\n")
	flag.PrintDefaults()
}
func withPort(host string) string {
	if _, _, err := net.SplitHostPort(host); err != nil {
		return net.JoinHostPort(host, "443")
	}
	return host
}
func withoutPort(addr string) string {
	if h, _, err := net.SplitHostPort(addr); err == nil {
		return h
	}
	return addr
}
type h2i struct {
	host   string
	tc     *tls.Conn
	framer *http2.Framer
	term   *terminal.Terminal
	
	streamID uint32
	hbuf     bytes.Buffer
	henc     *hpack.Encoder
	
	peerSetting map[http2.SettingID]uint32
	hdec        *hpack.Decoder
}
func main() {
	flag.Usage = usage
	flag.Parse()
	if flag.NArg() != 1 {
		usage()
		os.Exit(2)
	}
	log.SetFlags(0)
	host := flag.Arg(0)
	app := &h2i{
		host:        host,
		peerSetting: make(map[http2.SettingID]uint32),
	}
	app.henc = hpack.NewEncoder(&app.hbuf)
	if err := app.Main(); err != nil {
		if app.term != nil {
			app.logf("%v\n", err)
		} else {
			fmt.Fprintf(os.Stderr, "%v\n", err)
		}
		os.Exit(1)
	}
	fmt.Fprintf(os.Stdout, "\n")
}
func (app *h2i) Main() error {
	cfg := &tls.Config{
		ServerName:         withoutPort(app.host),
		NextProtos:         strings.Split(*flagNextProto, ","),
		InsecureSkipVerify: *flagInsecure,
	}
	hostAndPort := *flagDial
	if hostAndPort == "" {
		hostAndPort = withPort(app.host)
	}
	log.Printf("Connecting to %s ...", hostAndPort)
	tc, err := tls.Dial("tcp", hostAndPort, cfg)
	if err != nil {
		return fmt.Errorf("Error dialing %s: %v", hostAndPort, err)
	}
	log.Printf("Connected to %v", tc.RemoteAddr())
	defer tc.Close()
	if err := tc.Handshake(); err != nil {
		return fmt.Errorf("TLS handshake: %v", err)
	}
	if !*flagInsecure {
		if err := tc.VerifyHostname(app.host); err != nil {
			return fmt.Errorf("VerifyHostname: %v", err)
		}
	}
	state := tc.ConnectionState()
	log.Printf("Negotiated protocol %q", state.NegotiatedProtocol)
	if !state.NegotiatedProtocolIsMutual || state.NegotiatedProtocol == "" {
		return fmt.Errorf("Could not negotiate protocol mutually")
	}
	if _, err := io.WriteString(tc, http2.ClientPreface); err != nil {
		return err
	}
	app.framer = http2.NewFramer(tc, tc)
	oldState, err := terminal.MakeRaw(int(os.Stdin.Fd()))
	if err != nil {
		return err
	}
	defer terminal.Restore(0, oldState)
	var screen = struct {
		io.Reader
		io.Writer
	}{os.Stdin, os.Stdout}
	app.term = terminal.NewTerminal(screen, "h2i> ")
	lastWord := regexp.MustCompile(`.+\W(\w+)$`)
	app.term.AutoCompleteCallback = func(line string, pos int, key rune) (newLine string, newPos int, ok bool) {
		if key != '\t' {
			return
		}
		if pos != len(line) {
			
			return
		}
		
		if !strings.Contains(line, " ") {
			var name string
			name, _, ok = lookupCommand(line)
			if !ok {
				return
			}
			return name, len(name), true
		}
		_, c, ok := lookupCommand(line[:strings.IndexByte(line, ' ')])
		if !ok || c.complete == nil {
			return
		}
		if strings.HasSuffix(line, " ") {
			app.logf("%s", strings.Join(c.complete(), " "))
			return line, pos, true
		}
		m := lastWord.FindStringSubmatch(line)
		if m == nil {
			return line, len(line), true
		}
		soFar := m[1]
		var match []string
		for _, cand := range c.complete() {
			if len(soFar) > len(cand) || !strings.EqualFold(cand[:len(soFar)], soFar) {
				continue
			}
			match = append(match, cand)
		}
		if len(match) == 0 {
			return
		}
		if len(match) > 1 {
			
			app.logf("%s", strings.Join(match, " "))
			return line, pos, true
		}
		newLine = line[:len(line)-len(soFar)] + match[0]
		return newLine, len(newLine), true
	}
	errc := make(chan error, 2)
	go func() { errc <- app.readFrames() }()
	go func() { errc <- app.readConsole() }()
	return <-errc
}
func (app *h2i) logf(format string, args ...interface{}) {
	fmt.Fprintf(app.term, format+"\r\n", args...)
}
func (app *h2i) readConsole() error {
	if s := *flagSettings; s != "omit" {
		var args []string
		if s != "empty" {
			args = strings.Split(s, ",")
		}
		_, c, ok := lookupCommand("settings")
		if !ok {
			panic("settings command not found")
		}
		c.run(app, args)
	}
	for {
		line, err := app.term.ReadLine()
		if err == io.EOF {
			return nil
		}
		if err != nil {
			return fmt.Errorf("terminal.ReadLine: %v", err)
		}
		f := strings.Fields(line)
		if len(f) == 0 {
			continue
		}
		cmd, args := f[0], f[1:]
		if _, c, ok := lookupCommand(cmd); ok {
			err = c.run(app, args)
		} else {
			app.logf("Unknown command %q", line)
		}
		if err == errExitApp {
			return nil
		}
		if err != nil {
			return err
		}
	}
}
func lookupCommand(prefix string) (name string, c command, ok bool) {
	prefix = strings.ToLower(prefix)
	if c, ok = commands[prefix]; ok {
		return prefix, c, ok
	}
	for full, candidate := range commands {
		if strings.HasPrefix(full, prefix) {
			if c.run != nil {
				return "", command{}, false 
			}
			c = candidate
			name = full
		}
	}
	return name, c, c.run != nil
}
var errExitApp = errors.New("internal sentinel error value to quit the console reading loop")
func (a *h2i) cmdQuit(args []string) error {
	if len(args) > 0 {
		a.logf("the QUIT command takes no argument")
		return nil
	}
	return errExitApp
}
func (a *h2i) cmdSettings(args []string) error {
	if len(args) == 1 && strings.EqualFold(args[0], "ACK") {
		return a.framer.WriteSettingsAck()
	}
	var settings []http2.Setting
	for _, arg := range args {
		if strings.EqualFold(arg, "ACK") {
			a.logf("Error: ACK must be only argument with the SETTINGS command")
			return nil
		}
		eq := strings.Index(arg, "=")
		if eq == -1 {
			a.logf("Error: invalid argument %q (expected SETTING_NAME=nnnn)", arg)
			return nil
		}
		sid, ok := settingByName(arg[:eq])
		if !ok {
			a.logf("Error: unknown setting name %q", arg[:eq])
			return nil
		}
		val, err := strconv.ParseUint(arg[eq+1:], 10, 32)
		if err != nil {
			a.logf("Error: invalid argument %q (expected SETTING_NAME=nnnn)", arg)
			return nil
		}
		settings = append(settings, http2.Setting{
			ID:  sid,
			Val: uint32(val),
		})
	}
	a.logf("Sending: %v", settings)
	return a.framer.WriteSettings(settings...)
}
func settingByName(name string) (http2.SettingID, bool) {
	for _, sid := range [...]http2.SettingID{
		http2.SettingHeaderTableSize,
		http2.SettingEnablePush,
		http2.SettingMaxConcurrentStreams,
		http2.SettingInitialWindowSize,
		http2.SettingMaxFrameSize,
		http2.SettingMaxHeaderListSize,
	} {
		if strings.EqualFold(sid.String(), name) {
			return sid, true
		}
	}
	return 0, false
}
func (app *h2i) cmdPing(args []string) error {
	if len(args) > 1 {
		app.logf("invalid PING usage: only accepts 0 or 1 args")
		return nil 
	}
	var data [8]byte
	if len(args) == 1 {
		copy(data[:], args[0])
	} else {
		copy(data[:], "h2i_ping")
	}
	return app.framer.WritePing(false, data)
}
func (app *h2i) cmdHeaders(args []string) error {
	if len(args) > 0 {
		app.logf("Error: HEADERS doesn't yet take arguments.")
		
		
		return nil
	}
	var h1req bytes.Buffer
	app.term.SetPrompt("(as HTTP
	defer app.term.SetPrompt("h2i> ")
	for {
		line, err := app.term.ReadLine()
		if err != nil {
			return err
		}
		h1req.WriteString(line)
		h1req.WriteString("\r\n")
		if line == "" {
			break
		}
	}
	req, err := http.ReadRequest(bufio.NewReader(&h1req))
	if err != nil {
		app.logf("Invalid HTTP
		return nil
	}
	if app.streamID == 0 {
		app.streamID = 1
	} else {
		app.streamID += 2
	}
	app.logf("Opening Stream-ID %d:", app.streamID)
	hbf := app.encodeHeaders(req)
	if len(hbf) > 16<<10 {
		app.logf("TODO: h2i doesn't yet write CONTINUATION frames. Copy it from transport.go")
		return nil
	}
	return app.framer.WriteHeaders(http2.HeadersFrameParam{
		StreamID:      app.streamID,
		BlockFragment: hbf,
		EndStream:     req.Method == "GET" || req.Method == "HEAD", 
		EndHeaders:    true,                                        
	})
}
func (app *h2i) readFrames() error {
	for {
		f, err := app.framer.ReadFrame()
		if err != nil {
			return fmt.Errorf("ReadFrame: %v", err)
		}
		app.logf("%v", f)
		switch f := f.(type) {
		case *http2.PingFrame:
			app.logf("  Data = %q", f.Data)
		case *http2.SettingsFrame:
			f.ForeachSetting(func(s http2.Setting) error {
				app.logf("  %v", s)
				app.peerSetting[s.ID] = s.Val
				return nil
			})
		case *http2.WindowUpdateFrame:
			app.logf("  Window-Increment = %v", f.Increment)
		case *http2.GoAwayFrame:
			app.logf("  Last-Stream-ID = %d; Error-Code = %v (%d)", f.LastStreamID, f.ErrCode, f.ErrCode)
		case *http2.DataFrame:
			app.logf("  %q", f.Data())
		case *http2.HeadersFrame:
			if f.HasPriority() {
				app.logf("  PRIORITY = %v", f.Priority)
			}
			if app.hdec == nil {
				
				
				
				tableSize := uint32(4 << 10)
				app.hdec = hpack.NewDecoder(tableSize, app.onNewHeaderField)
			}
			app.hdec.Write(f.HeaderBlockFragment())
		case *http2.PushPromiseFrame:
			if app.hdec == nil {
				
				
				
				tableSize := uint32(4 << 10)
				app.hdec = hpack.NewDecoder(tableSize, app.onNewHeaderField)
			}
			app.hdec.Write(f.HeaderBlockFragment())
		}
	}
}
func (app *h2i) onNewHeaderField(f hpack.HeaderField) {
	if f.Sensitive {
		app.logf("  %s = %q (SENSITIVE)", f.Name, f.Value)
	}
	app.logf("  %s = %q", f.Name, f.Value)
}
func (app *h2i) encodeHeaders(req *http.Request) []byte {
	app.hbuf.Reset()
	
	host := req.Host
	if host == "" {
		host = req.URL.Host
	}
	path := req.RequestURI
	if path == "" {
		path = "
	}
	app.writeHeader(":authority", host) 
	app.writeHeader(":method", req.Method)
	app.writeHeader(":path", path)
	app.writeHeader(":scheme", "https")
	for k, vv := range req.Header {
		lowKey := strings.ToLower(k)
		if lowKey == "host" {
			continue
		}
		for _, v := range vv {
			app.writeHeader(lowKey, v)
		}
	}
	return app.hbuf.Bytes()
}
func (app *h2i) writeHeader(name, value string) {
	app.henc.WriteField(hpack.HeaderField{Name: name, Value: value})
	app.logf(" %s = %s", name, value)
}
package http2
import (
	"crypto
	"fmt"
	"net
)
func configureTransport(t1 *http.Transport) (*Transport, error) {
	connPool := new(clientConnPool)
	t2 := &Transport{
		ConnPool: noDialClientConnPool{connPool},
		t1:       t1,
	}
	connPool.t = t2
	if err := registerHTTPSProtocol(t1, noDialH2RoundTripper{t2}); err != nil {
		return nil, err
	}
	if t1.TLSClientConfig == nil {
		t1.TLSClientConfig = new(tls.Config)
	}
	if !strSliceContains(t1.TLSClientConfig.NextProtos, "h2") {
		t1.TLSClientConfig.NextProtos = append([]string{"h2"}, t1.TLSClientConfig.NextProtos...)
	}
	if !strSliceContains(t1.TLSClientConfig.NextProtos, "http
		t1.TLSClientConfig.NextProtos = append(t1.TLSClientConfig.NextProtos, "http
	}
	upgradeFn := func(authority string, c *tls.Conn) http.RoundTripper {
		addr := authorityAddr("https", authority)
		if used, err := connPool.addConnIfNeeded(addr, t2, c); err != nil {
			go c.Close()
			return erringRoundTripper{err}
		} else if !used {
			
			
			
			
			go c.Close()
		}
		return t2
	}
	if m := t1.TLSNextProto; len(m) == 0 {
		t1.TLSNextProto = map[string]func(string, *tls.Conn) http.RoundTripper{
			"h2": upgradeFn,
		}
	} else {
		m["h2"] = upgradeFn
	}
	return t2, nil
}
func registerHTTPSProtocol(t *http.Transport, rt http.RoundTripper) (err error) {
	defer func() {
		if e := recover(); e != nil {
			err = fmt.Errorf("%v", e)
		}
	}()
	t.RegisterProtocol("https", rt)
	return nil
}
type noDialH2RoundTripper struct{ t *Transport }
func (rt noDialH2RoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
	res, err := rt.t.RoundTrip(req)
	if err == ErrNoCachedConn {
		return nil, http.ErrSkipAltProtocol
	}
	return res, err
}
package http2
import (
	"bytes"
	"fmt"
	"io"
	"reflect"
	"strings"
	"testing"
	"unsafe"
	"golang.org
)
func testFramer() (*Framer, *bytes.Buffer) {
	buf := new(bytes.Buffer)
	return NewFramer(buf, buf), buf
}
func TestFrameSizes(t *testing.T) {
	
	if got, want := int(unsafe.Sizeof(FrameHeader{})), 12; got != want {
		t.Errorf("FrameHeader size = %d; want %d", got, want)
	}
}
func TestFrameTypeString(t *testing.T) {
	tests := []struct {
		ft   FrameType
		want string
	}{
		{FrameData, "DATA"},
		{FramePing, "PING"},
		{FrameGoAway, "GOAWAY"},
		{0xf, "UNKNOWN_FRAME_TYPE_15"},
	}
	for i, tt := range tests {
		got := tt.ft.String()
		if got != tt.want {
			t.Errorf("%d. String(FrameType %d) = %q; want %q", i, int(tt.ft), got, tt.want)
		}
	}
}
func TestWriteRST(t *testing.T) {
	fr, buf := testFramer()
	var streamID uint32 = 1<<24 + 2<<16 + 3<<8 + 4
	var errCode uint32 = 7<<24 + 6<<16 + 5<<8 + 4
	fr.WriteRSTStream(streamID, ErrCode(errCode))
	const wantEnc = "\x00\x00\x04\x03\x00\x01\x02\x03\x04\x07\x06\x05\x04"
	if buf.String() != wantEnc {
		t.Errorf("encoded as %q; want %q", buf.Bytes(), wantEnc)
	}
	f, err := fr.ReadFrame()
	if err != nil {
		t.Fatal(err)
	}
	want := &RSTStreamFrame{
		FrameHeader: FrameHeader{
			valid:    true,
			Type:     0x3,
			Flags:    0x0,
			Length:   0x4,
			StreamID: 0x1020304,
		},
		ErrCode: 0x7060504,
	}
	if !reflect.DeepEqual(f, want) {
		t.Errorf("parsed back %#v; want %#v", f, want)
	}
}
func TestWriteData(t *testing.T) {
	fr, buf := testFramer()
	var streamID uint32 = 1<<24 + 2<<16 + 3<<8 + 4
	data := []byte("ABC")
	fr.WriteData(streamID, true, data)
	const wantEnc = "\x00\x00\x03\x00\x01\x01\x02\x03\x04ABC"
	if buf.String() != wantEnc {
		t.Errorf("encoded as %q; want %q", buf.Bytes(), wantEnc)
	}
	f, err := fr.ReadFrame()
	if err != nil {
		t.Fatal(err)
	}
	df, ok := f.(*DataFrame)
	if !ok {
		t.Fatalf("got %T; want *DataFrame", f)
	}
	if !bytes.Equal(df.Data(), data) {
		t.Errorf("got %q; want %q", df.Data(), data)
	}
	if f.Header().Flags&1 == 0 {
		t.Errorf("didn't see END_STREAM flag")
	}
}
func TestWriteDataPadded(t *testing.T) {
	tests := [...]struct {
		streamID   uint32
		endStream  bool
		data       []byte
		pad        []byte
		wantHeader FrameHeader
	}{
		
		0: {
			streamID:  1,
			endStream: true,
			data:      []byte("foo"),
			pad:       nil,
			wantHeader: FrameHeader{
				Type:     FrameData,
				Flags:    FlagDataEndStream,
				Length:   3,
				StreamID: 1,
			},
		},
		
		1: {
			streamID:  1,
			endStream: true,
			data:      []byte("foo"),
			pad:       []byte{},
			wantHeader: FrameHeader{
				Type:     FrameData,
				Flags:    FlagDataEndStream | FlagDataPadded,
				Length:   4,
				StreamID: 1,
			},
		},
		
		2: {
			streamID:  1,
			endStream: false,
			data:      []byte("foo"),
			pad:       []byte{0, 0, 0},
			wantHeader: FrameHeader{
				Type:     FrameData,
				Flags:    FlagDataPadded,
				Length:   7,
				StreamID: 1,
			},
		},
	}
	for i, tt := range tests {
		fr, _ := testFramer()
		fr.WriteDataPadded(tt.streamID, tt.endStream, tt.data, tt.pad)
		f, err := fr.ReadFrame()
		if err != nil {
			t.Errorf("%d. ReadFrame: %v", i, err)
			continue
		}
		got := f.Header()
		tt.wantHeader.valid = true
		if got != tt.wantHeader {
			t.Errorf("%d. read %+v; want %+v", i, got, tt.wantHeader)
			continue
		}
		df := f.(*DataFrame)
		if !bytes.Equal(df.Data(), tt.data) {
			t.Errorf("%d. got %q; want %q", i, df.Data(), tt.data)
		}
	}
}
func TestWriteHeaders(t *testing.T) {
	tests := []struct {
		name      string
		p         HeadersFrameParam
		wantEnc   string
		wantFrame *HeadersFrame
	}{
		{
			"basic",
			HeadersFrameParam{
				StreamID:      42,
				BlockFragment: []byte("abc"),
				Priority:      PriorityParam{},
			},
			"\x00\x00\x03\x01\x00\x00\x00\x00*abc",
			&HeadersFrame{
				FrameHeader: FrameHeader{
					valid:    true,
					StreamID: 42,
					Type:     FrameHeaders,
					Length:   uint32(len("abc")),
				},
				Priority:      PriorityParam{},
				headerFragBuf: []byte("abc"),
			},
		},
		{
			"basic + end flags",
			HeadersFrameParam{
				StreamID:      42,
				BlockFragment: []byte("abc"),
				EndStream:     true,
				EndHeaders:    true,
				Priority:      PriorityParam{},
			},
			"\x00\x00\x03\x01\x05\x00\x00\x00*abc",
			&HeadersFrame{
				FrameHeader: FrameHeader{
					valid:    true,
					StreamID: 42,
					Type:     FrameHeaders,
					Flags:    FlagHeadersEndStream | FlagHeadersEndHeaders,
					Length:   uint32(len("abc")),
				},
				Priority:      PriorityParam{},
				headerFragBuf: []byte("abc"),
			},
		},
		{
			"with padding",
			HeadersFrameParam{
				StreamID:      42,
				BlockFragment: []byte("abc"),
				EndStream:     true,
				EndHeaders:    true,
				PadLength:     5,
				Priority:      PriorityParam{},
			},
			"\x00\x00\t\x01\r\x00\x00\x00*\x05abc\x00\x00\x00\x00\x00",
			&HeadersFrame{
				FrameHeader: FrameHeader{
					valid:    true,
					StreamID: 42,
					Type:     FrameHeaders,
					Flags:    FlagHeadersEndStream | FlagHeadersEndHeaders | FlagHeadersPadded,
					Length:   uint32(1 + len("abc") + 5), 
				},
				Priority:      PriorityParam{},
				headerFragBuf: []byte("abc"),
			},
		},
		{
			"with priority",
			HeadersFrameParam{
				StreamID:      42,
				BlockFragment: []byte("abc"),
				EndStream:     true,
				EndHeaders:    true,
				PadLength:     2,
				Priority: PriorityParam{
					StreamDep: 15,
					Exclusive: true,
					Weight:    127,
				},
			},
			"\x00\x00\v\x01-\x00\x00\x00*\x02\x80\x00\x00\x0f\u007fabc\x00\x00",
			&HeadersFrame{
				FrameHeader: FrameHeader{
					valid:    true,
					StreamID: 42,
					Type:     FrameHeaders,
					Flags:    FlagHeadersEndStream | FlagHeadersEndHeaders | FlagHeadersPadded | FlagHeadersPriority,
					Length:   uint32(1 + 5 + len("abc") + 2), 
				},
				Priority: PriorityParam{
					StreamDep: 15,
					Exclusive: true,
					Weight:    127,
				},
				headerFragBuf: []byte("abc"),
			},
		},
		{
			"with priority stream dep zero", 
			HeadersFrameParam{
				StreamID:      42,
				BlockFragment: []byte("abc"),
				EndStream:     true,
				EndHeaders:    true,
				PadLength:     2,
				Priority: PriorityParam{
					StreamDep: 0,
					Exclusive: true,
					Weight:    127,
				},
			},
			"\x00\x00\v\x01-\x00\x00\x00*\x02\x80\x00\x00\x00\u007fabc\x00\x00",
			&HeadersFrame{
				FrameHeader: FrameHeader{
					valid:    true,
					StreamID: 42,
					Type:     FrameHeaders,
					Flags:    FlagHeadersEndStream | FlagHeadersEndHeaders | FlagHeadersPadded | FlagHeadersPriority,
					Length:   uint32(1 + 5 + len("abc") + 2), 
				},
				Priority: PriorityParam{
					StreamDep: 0,
					Exclusive: true,
					Weight:    127,
				},
				headerFragBuf: []byte("abc"),
			},
		},
	}
	for _, tt := range tests {
		fr, buf := testFramer()
		if err := fr.WriteHeaders(tt.p); err != nil {
			t.Errorf("test %q: %v", tt.name, err)
			continue
		}
		if buf.String() != tt.wantEnc {
			t.Errorf("test %q: encoded %q; want %q", tt.name, buf.Bytes(), tt.wantEnc)
		}
		f, err := fr.ReadFrame()
		if err != nil {
			t.Errorf("test %q: failed to read the frame back: %v", tt.name, err)
			continue
		}
		if !reflect.DeepEqual(f, tt.wantFrame) {
			t.Errorf("test %q: mismatch.\n got: %#v\nwant: %#v\n", tt.name, f, tt.wantFrame)
		}
	}
}
func TestWriteInvalidStreamDep(t *testing.T) {
	fr, _ := testFramer()
	err := fr.WriteHeaders(HeadersFrameParam{
		StreamID: 42,
		Priority: PriorityParam{
			StreamDep: 1 << 31,
		},
	})
	if err != errDepStreamID {
		t.Errorf("header error = %v; want %q", err, errDepStreamID)
	}
	err = fr.WritePriority(2, PriorityParam{StreamDep: 1 << 31})
	if err != errDepStreamID {
		t.Errorf("priority error = %v; want %q", err, errDepStreamID)
	}
}
func TestWriteContinuation(t *testing.T) {
	const streamID = 42
	tests := []struct {
		name string
		end  bool
		frag []byte
		wantFrame *ContinuationFrame
	}{
		{
			"not end",
			false,
			[]byte("abc"),
			&ContinuationFrame{
				FrameHeader: FrameHeader{
					valid:    true,
					StreamID: streamID,
					Type:     FrameContinuation,
					Length:   uint32(len("abc")),
				},
				headerFragBuf: []byte("abc"),
			},
		},
		{
			"end",
			true,
			[]byte("def"),
			&ContinuationFrame{
				FrameHeader: FrameHeader{
					valid:    true,
					StreamID: streamID,
					Type:     FrameContinuation,
					Flags:    FlagContinuationEndHeaders,
					Length:   uint32(len("def")),
				},
				headerFragBuf: []byte("def"),
			},
		},
	}
	for _, tt := range tests {
		fr, _ := testFramer()
		if err := fr.WriteContinuation(streamID, tt.end, tt.frag); err != nil {
			t.Errorf("test %q: %v", tt.name, err)
			continue
		}
		fr.AllowIllegalReads = true
		f, err := fr.ReadFrame()
		if err != nil {
			t.Errorf("test %q: failed to read the frame back: %v", tt.name, err)
			continue
		}
		if !reflect.DeepEqual(f, tt.wantFrame) {
			t.Errorf("test %q: mismatch.\n got: %#v\nwant: %#v\n", tt.name, f, tt.wantFrame)
		}
	}
}
func TestWritePriority(t *testing.T) {
	const streamID = 42
	tests := []struct {
		name      string
		priority  PriorityParam
		wantFrame *PriorityFrame
	}{
		{
			"not exclusive",
			PriorityParam{
				StreamDep: 2,
				Exclusive: false,
				Weight:    127,
			},
			&PriorityFrame{
				FrameHeader{
					valid:    true,
					StreamID: streamID,
					Type:     FramePriority,
					Length:   5,
				},
				PriorityParam{
					StreamDep: 2,
					Exclusive: false,
					Weight:    127,
				},
			},
		},
		{
			"exclusive",
			PriorityParam{
				StreamDep: 3,
				Exclusive: true,
				Weight:    77,
			},
			&PriorityFrame{
				FrameHeader{
					valid:    true,
					StreamID: streamID,
					Type:     FramePriority,
					Length:   5,
				},
				PriorityParam{
					StreamDep: 3,
					Exclusive: true,
					Weight:    77,
				},
			},
		},
	}
	for _, tt := range tests {
		fr, _ := testFramer()
		if err := fr.WritePriority(streamID, tt.priority); err != nil {
			t.Errorf("test %q: %v", tt.name, err)
			continue
		}
		f, err := fr.ReadFrame()
		if err != nil {
			t.Errorf("test %q: failed to read the frame back: %v", tt.name, err)
			continue
		}
		if !reflect.DeepEqual(f, tt.wantFrame) {
			t.Errorf("test %q: mismatch.\n got: %#v\nwant: %#v\n", tt.name, f, tt.wantFrame)
		}
	}
}
func TestWriteSettings(t *testing.T) {
	fr, buf := testFramer()
	settings := []Setting{{1, 2}, {3, 4}}
	fr.WriteSettings(settings...)
	const wantEnc = "\x00\x00\f\x04\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x03\x00\x00\x00\x04"
	if buf.String() != wantEnc {
		t.Errorf("encoded as %q; want %q", buf.Bytes(), wantEnc)
	}
	f, err := fr.ReadFrame()
	if err != nil {
		t.Fatal(err)
	}
	sf, ok := f.(*SettingsFrame)
	if !ok {
		t.Fatalf("Got a %T; want a SettingsFrame", f)
	}
	var got []Setting
	sf.ForeachSetting(func(s Setting) error {
		got = append(got, s)
		valBack, ok := sf.Value(s.ID)
		if !ok || valBack != s.Val {
			t.Errorf("Value(%d) = %v, %v; want %v, true", s.ID, valBack, ok, s.Val)
		}
		return nil
	})
	if !reflect.DeepEqual(settings, got) {
		t.Errorf("Read settings %+v != written settings %+v", got, settings)
	}
}
func TestWriteSettingsAck(t *testing.T) {
	fr, buf := testFramer()
	fr.WriteSettingsAck()
	const wantEnc = "\x00\x00\x00\x04\x01\x00\x00\x00\x00"
	if buf.String() != wantEnc {
		t.Errorf("encoded as %q; want %q", buf.Bytes(), wantEnc)
	}
}
func TestWriteWindowUpdate(t *testing.T) {
	fr, buf := testFramer()
	const streamID = 1<<24 + 2<<16 + 3<<8 + 4
	const incr = 7<<24 + 6<<16 + 5<<8 + 4
	if err := fr.WriteWindowUpdate(streamID, incr); err != nil {
		t.Fatal(err)
	}
	const wantEnc = "\x00\x00\x04\x08\x00\x01\x02\x03\x04\x07\x06\x05\x04"
	if buf.String() != wantEnc {
		t.Errorf("encoded as %q; want %q", buf.Bytes(), wantEnc)
	}
	f, err := fr.ReadFrame()
	if err != nil {
		t.Fatal(err)
	}
	want := &WindowUpdateFrame{
		FrameHeader: FrameHeader{
			valid:    true,
			Type:     0x8,
			Flags:    0x0,
			Length:   0x4,
			StreamID: 0x1020304,
		},
		Increment: 0x7060504,
	}
	if !reflect.DeepEqual(f, want) {
		t.Errorf("parsed back %#v; want %#v", f, want)
	}
}
func TestWritePing(t *testing.T)    { testWritePing(t, false) }
func TestWritePingAck(t *testing.T) { testWritePing(t, true) }
func testWritePing(t *testing.T, ack bool) {
	fr, buf := testFramer()
	if err := fr.WritePing(ack, [8]byte{1, 2, 3, 4, 5, 6, 7, 8}); err != nil {
		t.Fatal(err)
	}
	var wantFlags Flags
	if ack {
		wantFlags = FlagPingAck
	}
	var wantEnc = "\x00\x00\x08\x06" + string(wantFlags) + "\x00\x00\x00\x00" + "\x01\x02\x03\x04\x05\x06\x07\x08"
	if buf.String() != wantEnc {
		t.Errorf("encoded as %q; want %q", buf.Bytes(), wantEnc)
	}
	f, err := fr.ReadFrame()
	if err != nil {
		t.Fatal(err)
	}
	want := &PingFrame{
		FrameHeader: FrameHeader{
			valid:    true,
			Type:     0x6,
			Flags:    wantFlags,
			Length:   0x8,
			StreamID: 0,
		},
		Data: [8]byte{1, 2, 3, 4, 5, 6, 7, 8},
	}
	if !reflect.DeepEqual(f, want) {
		t.Errorf("parsed back %#v; want %#v", f, want)
	}
}
func TestReadFrameHeader(t *testing.T) {
	tests := []struct {
		in   string
		want FrameHeader
	}{
		{in: "\x00\x00\x00" + "\x00" + "\x00" + "\x00\x00\x00\x00", want: FrameHeader{}},
		{in: "\x01\x02\x03" + "\x04" + "\x05" + "\x06\x07\x08\x09", want: FrameHeader{
			Length: 66051, Type: 4, Flags: 5, StreamID: 101124105,
		}},
		
		{in: "\xff\xff\xff" + "\xff" + "\xff" + "\xff\xff\xff\xff", want: FrameHeader{
			Length: 16777215, Type: 255, Flags: 255, StreamID: 2147483647}},
		{in: "\xff\xff\xff" + "\xff" + "\xff" + "\x7f\xff\xff\xff", want: FrameHeader{
			Length: 16777215, Type: 255, Flags: 255, StreamID: 2147483647}},
	}
	for i, tt := range tests {
		got, err := readFrameHeader(make([]byte, 9), strings.NewReader(tt.in))
		if err != nil {
			t.Errorf("%d. readFrameHeader(%q) = %v", i, tt.in, err)
			continue
		}
		tt.want.valid = true
		if got != tt.want {
			t.Errorf("%d. readFrameHeader(%q) = %+v; want %+v", i, tt.in, got, tt.want)
		}
	}
}
func TestReadWriteFrameHeader(t *testing.T) {
	tests := []struct {
		len      uint32
		typ      FrameType
		flags    Flags
		streamID uint32
	}{
		{len: 0, typ: 255, flags: 1, streamID: 0},
		{len: 0, typ: 255, flags: 1, streamID: 1},
		{len: 0, typ: 255, flags: 1, streamID: 255},
		{len: 0, typ: 255, flags: 1, streamID: 256},
		{len: 0, typ: 255, flags: 1, streamID: 65535},
		{len: 0, typ: 255, flags: 1, streamID: 65536},
		{len: 0, typ: 1, flags: 255, streamID: 1},
		{len: 255, typ: 1, flags: 255, streamID: 1},
		{len: 256, typ: 1, flags: 255, streamID: 1},
		{len: 65535, typ: 1, flags: 255, streamID: 1},
		{len: 65536, typ: 1, flags: 255, streamID: 1},
		{len: 16777215, typ: 1, flags: 255, streamID: 1},
	}
	for _, tt := range tests {
		fr, buf := testFramer()
		fr.startWrite(tt.typ, tt.flags, tt.streamID)
		fr.writeBytes(make([]byte, tt.len))
		fr.endWrite()
		fh, err := ReadFrameHeader(buf)
		if err != nil {
			t.Errorf("ReadFrameHeader(%+v) = %v", tt, err)
			continue
		}
		if fh.Type != tt.typ || fh.Flags != tt.flags || fh.Length != tt.len || fh.StreamID != tt.streamID {
			t.Errorf("ReadFrameHeader(%+v) = %+v; mismatch", tt, fh)
		}
	}
}
func TestWriteTooLargeFrame(t *testing.T) {
	fr, _ := testFramer()
	fr.startWrite(0, 1, 1)
	fr.writeBytes(make([]byte, 1<<24))
	err := fr.endWrite()
	if err != ErrFrameTooLarge {
		t.Errorf("endWrite = %v; want errFrameTooLarge", err)
	}
}
func TestWriteGoAway(t *testing.T) {
	const debug = "foo"
	fr, buf := testFramer()
	if err := fr.WriteGoAway(0x01020304, 0x05060708, []byte(debug)); err != nil {
		t.Fatal(err)
	}
	const wantEnc = "\x00\x00\v\a\x00\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x07\x08" + debug
	if buf.String() != wantEnc {
		t.Errorf("encoded as %q; want %q", buf.Bytes(), wantEnc)
	}
	f, err := fr.ReadFrame()
	if err != nil {
		t.Fatal(err)
	}
	want := &GoAwayFrame{
		FrameHeader: FrameHeader{
			valid:    true,
			Type:     0x7,
			Flags:    0,
			Length:   uint32(4 + 4 + len(debug)),
			StreamID: 0,
		},
		LastStreamID: 0x01020304,
		ErrCode:      0x05060708,
		debugData:    []byte(debug),
	}
	if !reflect.DeepEqual(f, want) {
		t.Fatalf("parsed back:\n%#v\nwant:\n%#v", f, want)
	}
	if got := string(f.(*GoAwayFrame).DebugData()); got != debug {
		t.Errorf("debug data = %q; want %q", got, debug)
	}
}
func TestWritePushPromise(t *testing.T) {
	pp := PushPromiseParam{
		StreamID:      42,
		PromiseID:     42,
		BlockFragment: []byte("abc"),
	}
	fr, buf := testFramer()
	if err := fr.WritePushPromise(pp); err != nil {
		t.Fatal(err)
	}
	const wantEnc = "\x00\x00\x07\x05\x00\x00\x00\x00*\x00\x00\x00*abc"
	if buf.String() != wantEnc {
		t.Errorf("encoded as %q; want %q", buf.Bytes(), wantEnc)
	}
	f, err := fr.ReadFrame()
	if err != nil {
		t.Fatal(err)
	}
	_, ok := f.(*PushPromiseFrame)
	if !ok {
		t.Fatalf("got %T; want *PushPromiseFrame", f)
	}
	want := &PushPromiseFrame{
		FrameHeader: FrameHeader{
			valid:    true,
			Type:     0x5,
			Flags:    0x0,
			Length:   0x7,
			StreamID: 42,
		},
		PromiseID:     42,
		headerFragBuf: []byte("abc"),
	}
	if !reflect.DeepEqual(f, want) {
		t.Fatalf("parsed back:\n%#v\nwant:\n%#v", f, want)
	}
}
func TestReadFrameOrder(t *testing.T) {
	head := func(f *Framer, id uint32, end bool) {
		f.WriteHeaders(HeadersFrameParam{
			StreamID:      id,
			BlockFragment: []byte("foo"), 
			EndHeaders:    end,
		})
	}
	cont := func(f *Framer, id uint32, end bool) {
		f.WriteContinuation(id, end, []byte("foo"))
	}
	tests := [...]struct {
		name    string
		w       func(*Framer)
		atLeast int
		wantErr string
	}{
		0: {
			w: func(f *Framer) {
				head(f, 1, true)
			},
		},
		1: {
			w: func(f *Framer) {
				head(f, 1, true)
				head(f, 2, true)
			},
		},
		2: {
			wantErr: "got HEADERS for stream 2; expected CONTINUATION following HEADERS for stream 1",
			w: func(f *Framer) {
				head(f, 1, false)
				head(f, 2, true)
			},
		},
		3: {
			wantErr: "got DATA for stream 1; expected CONTINUATION following HEADERS for stream 1",
			w: func(f *Framer) {
				head(f, 1, false)
			},
		},
		4: {
			w: func(f *Framer) {
				head(f, 1, false)
				cont(f, 1, true)
				head(f, 2, true)
			},
		},
		5: {
			wantErr: "got CONTINUATION for stream 2; expected stream 1",
			w: func(f *Framer) {
				head(f, 1, false)
				cont(f, 2, true)
				head(f, 2, true)
			},
		},
		6: {
			wantErr: "unexpected CONTINUATION for stream 1",
			w: func(f *Framer) {
				cont(f, 1, true)
			},
		},
		7: {
			wantErr: "unexpected CONTINUATION for stream 1",
			w: func(f *Framer) {
				cont(f, 1, false)
			},
		},
		8: {
			wantErr: "HEADERS frame with stream ID 0",
			w: func(f *Framer) {
				head(f, 0, true)
			},
		},
		9: {
			wantErr: "CONTINUATION frame with stream ID 0",
			w: func(f *Framer) {
				cont(f, 0, true)
			},
		},
		10: {
			wantErr: "unexpected CONTINUATION for stream 1",
			atLeast: 5,
			w: func(f *Framer) {
				head(f, 1, false)
				cont(f, 1, false)
				cont(f, 1, false)
				cont(f, 1, false)
				cont(f, 1, true)
				cont(f, 1, false)
			},
		},
	}
	for i, tt := range tests {
		buf := new(bytes.Buffer)
		f := NewFramer(buf, buf)
		f.AllowIllegalWrites = true
		tt.w(f)
		f.WriteData(1, true, nil) 
		var err error
		n := 0
		var log bytes.Buffer
		for {
			var got Frame
			got, err = f.ReadFrame()
			fmt.Fprintf(&log, "  read %v, %v\n", got, err)
			if err != nil {
				break
			}
			n++
		}
		if err == io.EOF {
			err = nil
		}
		ok := tt.wantErr == ""
		if ok && err != nil {
			t.Errorf("%d. after %d good frames, ReadFrame = %v; want success\n%s", i, n, err, log.Bytes())
			continue
		}
		if !ok && err != ConnectionError(ErrCodeProtocol) {
			t.Errorf("%d. after %d good frames, ReadFrame = %v; want ConnectionError(ErrCodeProtocol)\n%s", i, n, err, log.Bytes())
			continue
		}
		if !((f.errDetail == nil && tt.wantErr == "") || (fmt.Sprint(f.errDetail) == tt.wantErr)) {
			t.Errorf("%d. framer eror = %q; want %q\n%s", i, f.errDetail, tt.wantErr, log.Bytes())
		}
		if n < tt.atLeast {
			t.Errorf("%d. framer only read %d frames; want at least %d\n%s", i, n, tt.atLeast, log.Bytes())
		}
	}
}
func TestMetaFrameHeader(t *testing.T) {
	write := func(f *Framer, frags ...[]byte) {
		for i, frag := range frags {
			end := (i == len(frags)-1)
			if i == 0 {
				f.WriteHeaders(HeadersFrameParam{
					StreamID:      1,
					BlockFragment: frag,
					EndHeaders:    end,
				})
			} else {
				f.WriteContinuation(1, end, frag)
			}
		}
	}
	want := func(flags Flags, length uint32, pairs ...string) *MetaHeadersFrame {
		mh := &MetaHeadersFrame{
			HeadersFrame: &HeadersFrame{
				FrameHeader: FrameHeader{
					Type:     FrameHeaders,
					Flags:    flags,
					Length:   length,
					StreamID: 1,
				},
			},
			Fields: []hpack.HeaderField(nil),
		}
		for len(pairs) > 0 {
			mh.Fields = append(mh.Fields, hpack.HeaderField{
				Name:  pairs[0],
				Value: pairs[1],
			})
			pairs = pairs[2:]
		}
		return mh
	}
	truncated := func(mh *MetaHeadersFrame) *MetaHeadersFrame {
		mh.Truncated = true
		return mh
	}
	const noFlags Flags = 0
	oneKBString := strings.Repeat("a", 1<<10)
	tests := [...]struct {
		name              string
		w                 func(*Framer)
		want              interface{} 
		wantErrReason     string
		maxHeaderListSize uint32
	}{
		0: {
			name: "single_headers",
			w: func(f *Framer) {
				var he hpackEncoder
				all := he.encodeHeaderRaw(t, ":method", "GET", ":path", "
				write(f, all)
			},
			want: want(FlagHeadersEndHeaders, 2, ":method", "GET", ":path", "
		},
		1: {
			name: "with_continuation",
			w: func(f *Framer) {
				var he hpackEncoder
				all := he.encodeHeaderRaw(t, ":method", "GET", ":path", "
				write(f, all[:1], all[1:])
			},
			want: want(noFlags, 1, ":method", "GET", ":path", "
		},
		2: {
			name: "with_two_continuation",
			w: func(f *Framer) {
				var he hpackEncoder
				all := he.encodeHeaderRaw(t, ":method", "GET", ":path", "
				write(f, all[:2], all[2:4], all[4:])
			},
			want: want(noFlags, 2, ":method", "GET", ":path", "
		},
		3: {
			name: "big_string_okay",
			w: func(f *Framer) {
				var he hpackEncoder
				all := he.encodeHeaderRaw(t, ":method", "GET", ":path", "
				write(f, all[:2], all[2:])
			},
			want: want(noFlags, 2, ":method", "GET", ":path", "
		},
		4: {
			name: "big_string_error",
			w: func(f *Framer) {
				var he hpackEncoder
				all := he.encodeHeaderRaw(t, ":method", "GET", ":path", "
				write(f, all[:2], all[2:])
			},
			maxHeaderListSize: (1 << 10) 
			want:              ConnectionError(ErrCodeCompression),
		},
		5: {
			name: "max_header_list_truncated",
			w: func(f *Framer) {
				var he hpackEncoder
				var pairs = []string{":method", "GET", ":path", "
				for i := 0; i < 100; i++ {
					pairs = append(pairs, "foo", "bar")
				}
				all := he.encodeHeaderRaw(t, pairs...)
				write(f, all[:2], all[2:])
			},
			maxHeaderListSize: (1 << 10) 
			want: truncated(want(noFlags, 2,
				":method", "GET",
				":path", "
				"foo", "bar",
				"foo", "bar",
				"foo", "bar",
				"foo", "bar",
				"foo", "bar",
				"foo", "bar",
				"foo", "bar",
				"foo", "bar",
				"foo", "bar",
				"foo", "bar",
				"foo", "bar", 
			)),
		},
		6: {
			name: "pseudo_order",
			w: func(f *Framer) {
				write(f, encodeHeaderRaw(t,
					":method", "GET",
					"foo", "bar",
					":path", "
				))
			},
			want:          streamError(1, ErrCodeProtocol),
			wantErrReason: "pseudo header field after regular",
		},
		7: {
			name: "pseudo_unknown",
			w: func(f *Framer) {
				write(f, encodeHeaderRaw(t,
					":unknown", "foo", 
					"foo", "bar",
				))
			},
			want:          streamError(1, ErrCodeProtocol),
			wantErrReason: "invalid pseudo-header \":unknown\"",
		},
		8: {
			name: "pseudo_mix_request_response",
			w: func(f *Framer) {
				write(f, encodeHeaderRaw(t,
					":method", "GET",
					":status", "100",
				))
			},
			want:          streamError(1, ErrCodeProtocol),
			wantErrReason: "mix of request and response pseudo headers",
		},
		9: {
			name: "pseudo_dup",
			w: func(f *Framer) {
				write(f, encodeHeaderRaw(t,
					":method", "GET",
					":method", "POST",
				))
			},
			want:          streamError(1, ErrCodeProtocol),
			wantErrReason: "duplicate pseudo-header \":method\"",
		},
		10: {
			name: "trailer_okay_no_pseudo",
			w:    func(f *Framer) { write(f, encodeHeaderRaw(t, "foo", "bar")) },
			want: want(FlagHeadersEndHeaders, 8, "foo", "bar"),
		},
		11: {
			name:          "invalid_field_name",
			w:             func(f *Framer) { write(f, encodeHeaderRaw(t, "CapitalBad", "x")) },
			want:          streamError(1, ErrCodeProtocol),
			wantErrReason: "invalid header field name \"CapitalBad\"",
		},
		12: {
			name:          "invalid_field_value",
			w:             func(f *Framer) { write(f, encodeHeaderRaw(t, "key", "bad_null\x00")) },
			want:          streamError(1, ErrCodeProtocol),
			wantErrReason: "invalid header field value \"bad_null\\x00\"",
		},
	}
	for i, tt := range tests {
		buf := new(bytes.Buffer)
		f := NewFramer(buf, buf)
		f.ReadMetaHeaders = hpack.NewDecoder(initialHeaderTableSize, nil)
		f.MaxHeaderListSize = tt.maxHeaderListSize
		tt.w(f)
		name := tt.name
		if name == "" {
			name = fmt.Sprintf("test index %d", i)
		}
		var got interface{}
		var err error
		got, err = f.ReadFrame()
		if err != nil {
			got = err
			
			
			if se, ok := err.(StreamError); ok && se.Cause != nil && se.Cause.Error() == tt.wantErrReason {
				se.Cause = nil
				got = se
			}
		}
		if !reflect.DeepEqual(got, tt.want) {
			if mhg, ok := got.(*MetaHeadersFrame); ok {
				if mhw, ok := tt.want.(*MetaHeadersFrame); ok {
					hg := mhg.HeadersFrame
					hw := mhw.HeadersFrame
					if hg != nil && hw != nil && !reflect.DeepEqual(*hg, *hw) {
						t.Errorf("%s: headers differ:\n got: %+v\nwant: %+v\n", name, *hg, *hw)
					}
				}
			}
			str := func(v interface{}) string {
				if _, ok := v.(error); ok {
					return fmt.Sprintf("error %v", v)
				} else {
					return fmt.Sprintf("value %#v", v)
				}
			}
			t.Errorf("%s:\n got: %v\nwant: %s", name, str(got), str(tt.want))
		}
		if tt.wantErrReason != "" && tt.wantErrReason != fmt.Sprint(f.errDetail) {
			t.Errorf("%s: got error reason %q; want %q", name, f.errDetail, tt.wantErrReason)
		}
	}
}
func TestSetReuseFrames(t *testing.T) {
	fr, buf := testFramer()
	fr.SetReuseFrames()
	
	
	firstDf := readAndVerifyDataFrame("ABC", 3, fr, buf, t)
	for i := 0; i < 10; i++ {
		df := readAndVerifyDataFrame("XYZ", 3, fr, buf, t)
		if df != firstDf {
			t.Errorf("Expected Framer to return references to the same DataFrame. Have %v and %v", &df, &firstDf)
		}
	}
	for i := 0; i < 10; i++ {
		df := readAndVerifyDataFrame("", 0, fr, buf, t)
		if df != firstDf {
			t.Errorf("Expected Framer to return references to the same DataFrame. Have %v and %v", &df, &firstDf)
		}
	}
	for i := 0; i < 10; i++ {
		df := readAndVerifyDataFrame("HHH", 3, fr, buf, t)
		if df != firstDf {
			t.Errorf("Expected Framer to return references to the same DataFrame. Have %v and %v", &df, &firstDf)
		}
	}
}
func TestSetReuseFramesMoreThanOnce(t *testing.T) {
	fr, buf := testFramer()
	fr.SetReuseFrames()
	firstDf := readAndVerifyDataFrame("ABC", 3, fr, buf, t)
	fr.SetReuseFrames()
	for i := 0; i < 10; i++ {
		df := readAndVerifyDataFrame("XYZ", 3, fr, buf, t)
		
		fr.SetReuseFrames()
		if df != firstDf {
			t.Errorf("Expected Framer to return references to the same DataFrame. Have %v and %v", &df, &firstDf)
		}
	}
}
func TestNoSetReuseFrames(t *testing.T) {
	fr, buf := testFramer()
	const numNewDataFrames = 10
	dfSoFar := make([]interface{}, numNewDataFrames)
	
	
	for i := 0; i < numNewDataFrames; i++ {
		df := readAndVerifyDataFrame("XYZ", 3, fr, buf, t)
		for _, item := range dfSoFar {
			if df == item {
				t.Errorf("Expected Framer to return new DataFrames since SetNoReuseFrames not set.")
			}
		}
		dfSoFar[i] = df
	}
}
func readAndVerifyDataFrame(data string, length byte, fr *Framer, buf *bytes.Buffer, t *testing.T) *DataFrame {
	var streamID uint32 = 1<<24 + 2<<16 + 3<<8 + 4
	fr.WriteData(streamID, true, []byte(data))
	wantEnc := "\x00\x00" + string(length) + "\x00\x01\x01\x02\x03\x04" + data
	if buf.String() != wantEnc {
		t.Errorf("encoded as %q; want %q", buf.Bytes(), wantEnc)
	}
	f, err := fr.ReadFrame()
	if err != nil {
		t.Fatal(err)
	}
	df, ok := f.(*DataFrame)
	if !ok {
		t.Fatalf("got %T; want *DataFrame", f)
	}
	if !bytes.Equal(df.Data(), []byte(data)) {
		t.Errorf("got %q; want %q", df.Data(), []byte(data))
	}
	if f.Header().Flags&1 == 0 {
		t.Errorf("didn't see END_STREAM flag")
	}
	return df
}
func encodeHeaderRaw(t *testing.T, pairs ...string) []byte {
	var he hpackEncoder
	return he.encodeHeaderRaw(t, pairs...)
}
package http2
type flow struct {
	
	
	n int32
	
	
	
	conn *flow
}
func (f *flow) setConnFlow(cf *flow) { f.conn = cf }
func (f *flow) available() int32 {
	n := f.n
	if f.conn != nil && f.conn.n < n {
		n = f.conn.n
	}
	return n
}
func (f *flow) take(n int32) {
	if n > f.available() {
		panic("internal error: took too much")
	}
	f.n -= n
	if f.conn != nil {
		f.conn.n -= n
	}
}
func (f *flow) add(n int32) bool {
	remain := (1<<31 - 1) - f.n
	if n > remain {
		return false
	}
	f.n += n
	return true
}
package http2
import (
	"net
	"strings"
)
var (
	commonLowerHeader = map[string]string{} 
	commonCanonHeader = map[string]string{} 
)
func init() {
	for _, v := range []string{
		"accept",
		"accept-charset",
		"accept-encoding",
		"accept-language",
		"accept-ranges",
		"age",
		"access-control-allow-origin",
		"allow",
		"authorization",
		"cache-control",
		"content-disposition",
		"content-encoding",
		"content-language",
		"content-length",
		"content-location",
		"content-range",
		"content-type",
		"cookie",
		"date",
		"etag",
		"expect",
		"expires",
		"from",
		"host",
		"if-match",
		"if-modified-since",
		"if-none-match",
		"if-unmodified-since",
		"last-modified",
		"link",
		"location",
		"max-forwards",
		"proxy-authenticate",
		"proxy-authorization",
		"range",
		"referer",
		"refresh",
		"retry-after",
		"server",
		"set-cookie",
		"strict-transport-security",
		"trailer",
		"transfer-encoding",
		"user-agent",
		"vary",
		"via",
		"www-authenticate",
	} {
		chk := http.CanonicalHeaderKey(v)
		commonLowerHeader[chk] = v
		commonCanonHeader[v] = chk
	}
}
func lowerHeader(v string) string {
	if s, ok := commonLowerHeader[v]; ok {
		return s
	}
	return strings.ToLower(v)
}
package http2
import (
	"fmt"
	"strings"
	"testing"
)
func TestGoroutineLock(t *testing.T) {
	oldDebug := DebugGoroutines
	DebugGoroutines = true
	defer func() { DebugGoroutines = oldDebug }()
	g := newGoroutineLock()
	g.check()
	sawPanic := make(chan interface{})
	go func() {
		defer func() { sawPanic <- recover() }()
		g.check() 
	}()
	e := <-sawPanic
	if e == nil {
		t.Fatal("did not see panic from check in other goroutine")
	}
	if !strings.Contains(fmt.Sprint(e), "wrong goroutine") {
		t.Errorf("expected on see panic about running on the wrong goroutine; got %v", e)
	}
}
package http2
import (
	"bytes"
	"fmt"
	"reflect"
	"testing"
)
func fmtDataChunk(chunk []byte) string {
	out := ""
	var last byte
	var count int
	for _, c := range chunk {
		if c != last {
			if count > 0 {
				out += fmt.Sprintf(" x %d ", count)
				count = 0
			}
			out += string([]byte{c})
			last = c
		}
		count++
	}
	if count > 0 {
		out += fmt.Sprintf(" x %d", count)
	}
	return out
}
func fmtDataChunks(chunks [][]byte) string {
	var out string
	for _, chunk := range chunks {
		out += fmt.Sprintf("{%q}", fmtDataChunk(chunk))
	}
	return out
}
func testDataBuffer(t *testing.T, wantBytes []byte, setup func(t *testing.T) *dataBuffer) {
	
	
	
	for _, readSize := range []int{1, 2, 1 * 1024, 32 * 1024} {
		t.Run(fmt.Sprintf("ReadSize=%d", readSize), func(t *testing.T) {
			b := setup(t)
			buf := make([]byte, readSize)
			var gotRead bytes.Buffer
			for {
				n, err := b.Read(buf)
				gotRead.Write(buf[:n])
				if err == errReadEmpty {
					break
				}
				if err != nil {
					t.Fatalf("error after %v bytes: %v", gotRead.Len(), err)
				}
			}
			if got, want := gotRead.Bytes(), wantBytes; !bytes.Equal(got, want) {
				t.Errorf("FinalRead=%q, want %q", fmtDataChunk(got), fmtDataChunk(want))
			}
		})
	}
}
func TestDataBufferAllocation(t *testing.T) {
	writes := [][]byte{
		bytes.Repeat([]byte("a"), 1*1024-1),
		[]byte("a"),
		bytes.Repeat([]byte("b"), 4*1024-1),
		[]byte("b"),
		bytes.Repeat([]byte("c"), 8*1024-1),
		[]byte("c"),
		bytes.Repeat([]byte("d"), 16*1024-1),
		[]byte("d"),
		bytes.Repeat([]byte("e"), 32*1024),
	}
	var wantRead bytes.Buffer
	for _, p := range writes {
		wantRead.Write(p)
	}
	testDataBuffer(t, wantRead.Bytes(), func(t *testing.T) *dataBuffer {
		b := &dataBuffer{}
		for _, p := range writes {
			if n, err := b.Write(p); n != len(p) || err != nil {
				t.Fatalf("Write(%q x %d)=%v,%v want %v,nil", p[:1], len(p), n, err, len(p))
			}
		}
		want := [][]byte{
			bytes.Repeat([]byte("a"), 1*1024),
			bytes.Repeat([]byte("b"), 4*1024),
			bytes.Repeat([]byte("c"), 8*1024),
			bytes.Repeat([]byte("d"), 16*1024),
			bytes.Repeat([]byte("e"), 16*1024),
			bytes.Repeat([]byte("e"), 16*1024),
		}
		if !reflect.DeepEqual(b.chunks, want) {
			t.Errorf("dataBuffer.chunks\ngot:  %s\nwant: %s", fmtDataChunks(b.chunks), fmtDataChunks(want))
		}
		return b
	})
}
func TestDataBufferAllocationWithExpected(t *testing.T) {
	writes := [][]byte{
		bytes.Repeat([]byte("a"), 1*1024), 
		bytes.Repeat([]byte("b"), 14*1024),
		bytes.Repeat([]byte("c"), 15*1024), 
		bytes.Repeat([]byte("d"), 2*1024),
		bytes.Repeat([]byte("e"), 1*1024), 
	}
	var wantRead bytes.Buffer
	for _, p := range writes {
		wantRead.Write(p)
	}
	testDataBuffer(t, wantRead.Bytes(), func(t *testing.T) *dataBuffer {
		b := &dataBuffer{expected: 32 * 1024}
		for _, p := range writes {
			if n, err := b.Write(p); n != len(p) || err != nil {
				t.Fatalf("Write(%q x %d)=%v,%v want %v,nil", p[:1], len(p), n, err, len(p))
			}
		}
		want := [][]byte{
			append(bytes.Repeat([]byte("a"), 1*1024), append(bytes.Repeat([]byte("b"), 14*1024), bytes.Repeat([]byte("c"), 1*1024)...)...),
			append(bytes.Repeat([]byte("c"), 14*1024), bytes.Repeat([]byte("d"), 2*1024)...),
			bytes.Repeat([]byte("e"), 1*1024),
		}
		if !reflect.DeepEqual(b.chunks, want) {
			t.Errorf("dataBuffer.chunks\ngot:  %s\nwant: %s", fmtDataChunks(b.chunks), fmtDataChunks(want))
		}
		return b
	})
}
func TestDataBufferWriteAfterPartialRead(t *testing.T) {
	testDataBuffer(t, []byte("cdxyz"), func(t *testing.T) *dataBuffer {
		b := &dataBuffer{}
		if n, err := b.Write([]byte("abcd")); n != 4 || err != nil {
			t.Fatalf("Write(\"abcd\")=%v,%v want 4,nil", n, err)
		}
		p := make([]byte, 2)
		if n, err := b.Read(p); n != 2 || err != nil || !bytes.Equal(p, []byte("ab")) {
			t.Fatalf("Read()=%q,%v,%v want \"ab\",2,nil", p, n, err)
		}
		if n, err := b.Write([]byte("xyz")); n != 3 || err != nil {
			t.Fatalf("Write(\"xyz\")=%v,%v want 3,nil", n, err)
		}
		return b
	})
}
package http2
import (
	"bytes"
	"encoding
	"errors"
	"fmt"
	"io"
	"log"
	"strings"
	"sync"
	"golang.org
	"golang.org
)
const frameHeaderLen = 9
var padZeros = make([]byte, 255) 
type FrameType uint8
const (
	FrameData         FrameType = 0x0
	FrameHeaders      FrameType = 0x1
	FramePriority     FrameType = 0x2
	FrameRSTStream    FrameType = 0x3
	FrameSettings     FrameType = 0x4
	FramePushPromise  FrameType = 0x5
	FramePing         FrameType = 0x6
	FrameGoAway       FrameType = 0x7
	FrameWindowUpdate FrameType = 0x8
	FrameContinuation FrameType = 0x9
)
var frameName = map[FrameType]string{
	FrameData:         "DATA",
	FrameHeaders:      "HEADERS",
	FramePriority:     "PRIORITY",
	FrameRSTStream:    "RST_STREAM",
	FrameSettings:     "SETTINGS",
	FramePushPromise:  "PUSH_PROMISE",
	FramePing:         "PING",
	FrameGoAway:       "GOAWAY",
	FrameWindowUpdate: "WINDOW_UPDATE",
	FrameContinuation: "CONTINUATION",
}
func (t FrameType) String() string {
	if s, ok := frameName[t]; ok {
		return s
	}
	return fmt.Sprintf("UNKNOWN_FRAME_TYPE_%d", uint8(t))
}
type Flags uint8
func (f Flags) Has(v Flags) bool {
	return (f & v) == v
}
const (
	
	FlagDataEndStream Flags = 0x1
	FlagDataPadded    Flags = 0x8
	
	FlagHeadersEndStream  Flags = 0x1
	FlagHeadersEndHeaders Flags = 0x4
	FlagHeadersPadded     Flags = 0x8
	FlagHeadersPriority   Flags = 0x20
	
	FlagSettingsAck Flags = 0x1
	
	FlagPingAck Flags = 0x1
	
	FlagContinuationEndHeaders Flags = 0x4
	FlagPushPromiseEndHeaders Flags = 0x4
	FlagPushPromisePadded     Flags = 0x8
)
var flagName = map[FrameType]map[Flags]string{
	FrameData: {
		FlagDataEndStream: "END_STREAM",
		FlagDataPadded:    "PADDED",
	},
	FrameHeaders: {
		FlagHeadersEndStream:  "END_STREAM",
		FlagHeadersEndHeaders: "END_HEADERS",
		FlagHeadersPadded:     "PADDED",
		FlagHeadersPriority:   "PRIORITY",
	},
	FrameSettings: {
		FlagSettingsAck: "ACK",
	},
	FramePing: {
		FlagPingAck: "ACK",
	},
	FrameContinuation: {
		FlagContinuationEndHeaders: "END_HEADERS",
	},
	FramePushPromise: {
		FlagPushPromiseEndHeaders: "END_HEADERS",
		FlagPushPromisePadded:     "PADDED",
	},
}
type frameParser func(fc *frameCache, fh FrameHeader, payload []byte) (Frame, error)
var frameParsers = map[FrameType]frameParser{
	FrameData:         parseDataFrame,
	FrameHeaders:      parseHeadersFrame,
	FramePriority:     parsePriorityFrame,
	FrameRSTStream:    parseRSTStreamFrame,
	FrameSettings:     parseSettingsFrame,
	FramePushPromise:  parsePushPromise,
	FramePing:         parsePingFrame,
	FrameGoAway:       parseGoAwayFrame,
	FrameWindowUpdate: parseWindowUpdateFrame,
	FrameContinuation: parseContinuationFrame,
}
func typeFrameParser(t FrameType) frameParser {
	if f := frameParsers[t]; f != nil {
		return f
	}
	return parseUnknownFrame
}
type FrameHeader struct {
	valid bool 
	
	
	
	Type FrameType
	
	
	Flags Flags
	
	
	
	Length uint32
	
	
	StreamID uint32
}
func (h FrameHeader) Header() FrameHeader { return h }
func (h FrameHeader) String() string {
	var buf bytes.Buffer
	buf.WriteString("[FrameHeader ")
	h.writeDebug(&buf)
	buf.WriteByte(']')
	return buf.String()
}
func (h FrameHeader) writeDebug(buf *bytes.Buffer) {
	buf.WriteString(h.Type.String())
	if h.Flags != 0 {
		buf.WriteString(" flags=")
		set := 0
		for i := uint8(0); i < 8; i++ {
			if h.Flags&(1<<i) == 0 {
				continue
			}
			set++
			if set > 1 {
				buf.WriteByte('|')
			}
			name := flagName[h.Type][Flags(1<<i)]
			if name != "" {
				buf.WriteString(name)
			} else {
				fmt.Fprintf(buf, "0x%x", 1<<i)
			}
		}
	}
	if h.StreamID != 0 {
		fmt.Fprintf(buf, " stream=%d", h.StreamID)
	}
	fmt.Fprintf(buf, " len=%d", h.Length)
}
func (h *FrameHeader) checkValid() {
	if !h.valid {
		panic("Frame accessor called on non-owned Frame")
	}
}
func (h *FrameHeader) invalidate() { h.valid = false }
var fhBytes = sync.Pool{
	New: func() interface{} {
		buf := make([]byte, frameHeaderLen)
		return &buf
	},
}
func ReadFrameHeader(r io.Reader) (FrameHeader, error) {
	bufp := fhBytes.Get().(*[]byte)
	defer fhBytes.Put(bufp)
	return readFrameHeader(*bufp, r)
}
func readFrameHeader(buf []byte, r io.Reader) (FrameHeader, error) {
	_, err := io.ReadFull(r, buf[:frameHeaderLen])
	if err != nil {
		return FrameHeader{}, err
	}
	return FrameHeader{
		Length:   (uint32(buf[0])<<16 | uint32(buf[1])<<8 | uint32(buf[2])),
		Type:     FrameType(buf[3]),
		Flags:    Flags(buf[4]),
		StreamID: binary.BigEndian.Uint32(buf[5:]) & (1<<31 - 1),
		valid:    true,
	}, nil
}
type Frame interface {
	Header() FrameHeader
	
	
	
	invalidate()
}
type Framer struct {
	r         io.Reader
	lastFrame Frame
	errDetail error
	
	
	lastHeaderStream uint32
	maxReadSize uint32
	headerBuf   [frameHeaderLen]byte
	
	
	
	getReadBuf func(size uint32) []byte
	readBuf    []byte 
	maxWriteSize uint32 
	w    io.Writer
	wbuf []byte
	
	
	
	
	
	
	AllowIllegalWrites bool
	
	
	
	
	
	AllowIllegalReads bool
	
	
	
	ReadMetaHeaders *hpack.Decoder
	
	
	
	
	MaxHeaderListSize uint32
	
	
	
	
	
	logReads, logWrites bool
	debugFramer       *Framer 
	debugFramerBuf    *bytes.Buffer
	debugReadLoggerf  func(string, ...interface{})
	debugWriteLoggerf func(string, ...interface{})
	frameCache *frameCache 
}
func (fr *Framer) maxHeaderListSize() uint32 {
	if fr.MaxHeaderListSize == 0 {
		return 16 << 20 
	}
	return fr.MaxHeaderListSize
}
func (f *Framer) startWrite(ftype FrameType, flags Flags, streamID uint32) {
	
	f.wbuf = append(f.wbuf[:0],
		0, 
		0,
		0,
		byte(ftype),
		byte(flags),
		byte(streamID>>24),
		byte(streamID>>16),
		byte(streamID>>8),
		byte(streamID))
}
func (f *Framer) endWrite() error {
	
	
	length := len(f.wbuf) - frameHeaderLen
	if length >= (1 << 24) {
		return ErrFrameTooLarge
	}
	_ = append(f.wbuf[:0],
		byte(length>>16),
		byte(length>>8),
		byte(length))
	if f.logWrites {
		f.logWrite()
	}
	n, err := f.w.Write(f.wbuf)
	if err == nil && n != len(f.wbuf) {
		err = io.ErrShortWrite
	}
	return err
}
func (f *Framer) logWrite() {
	if f.debugFramer == nil {
		f.debugFramerBuf = new(bytes.Buffer)
		f.debugFramer = NewFramer(nil, f.debugFramerBuf)
		f.debugFramer.logReads = false 
		
		
		f.debugFramer.AllowIllegalReads = true
	}
	f.debugFramerBuf.Write(f.wbuf)
	fr, err := f.debugFramer.ReadFrame()
	if err != nil {
		f.debugWriteLoggerf("http2: Framer %p: failed to decode just-written frame", f)
		return
	}
	f.debugWriteLoggerf("http2: Framer %p: wrote %v", f, summarizeFrame(fr))
}
func (f *Framer) writeByte(v byte)     { f.wbuf = append(f.wbuf, v) }
func (f *Framer) writeBytes(v []byte)  { f.wbuf = append(f.wbuf, v...) }
func (f *Framer) writeUint16(v uint16) { f.wbuf = append(f.wbuf, byte(v>>8), byte(v)) }
func (f *Framer) writeUint32(v uint32) {
	f.wbuf = append(f.wbuf, byte(v>>24), byte(v>>16), byte(v>>8), byte(v))
}
const (
	minMaxFrameSize = 1 << 14
	maxFrameSize    = 1<<24 - 1
)
func (fr *Framer) SetReuseFrames() {
	if fr.frameCache != nil {
		return
	}
	fr.frameCache = &frameCache{}
}
type frameCache struct {
	dataFrame DataFrame
}
func (fc *frameCache) getDataFrame() *DataFrame {
	if fc == nil {
		return &DataFrame{}
	}
	return &fc.dataFrame
}
func NewFramer(w io.Writer, r io.Reader) *Framer {
	fr := &Framer{
		w:                 w,
		r:                 r,
		logReads:          logFrameReads,
		logWrites:         logFrameWrites,
		debugReadLoggerf:  log.Printf,
		debugWriteLoggerf: log.Printf,
	}
	fr.getReadBuf = func(size uint32) []byte {
		if cap(fr.readBuf) >= int(size) {
			return fr.readBuf[:size]
		}
		fr.readBuf = make([]byte, size)
		return fr.readBuf
	}
	fr.SetMaxReadFrameSize(maxFrameSize)
	return fr
}
func (fr *Framer) SetMaxReadFrameSize(v uint32) {
	if v > maxFrameSize {
		v = maxFrameSize
	}
	fr.maxReadSize = v
}
func (fr *Framer) ErrorDetail() error {
	return fr.errDetail
}
var ErrFrameTooLarge = errors.New("http2: frame too large")
func terminalReadFrameError(err error) bool {
	if _, ok := err.(StreamError); ok {
		return false
	}
	return err != nil
}
func (fr *Framer) ReadFrame() (Frame, error) {
	fr.errDetail = nil
	if fr.lastFrame != nil {
		fr.lastFrame.invalidate()
	}
	fh, err := readFrameHeader(fr.headerBuf[:], fr.r)
	if err != nil {
		return nil, err
	}
	if fh.Length > fr.maxReadSize {
		return nil, ErrFrameTooLarge
	}
	payload := fr.getReadBuf(fh.Length)
	if _, err := io.ReadFull(fr.r, payload); err != nil {
		return nil, err
	}
	f, err := typeFrameParser(fh.Type)(fr.frameCache, fh, payload)
	if err != nil {
		if ce, ok := err.(connError); ok {
			return nil, fr.connError(ce.Code, ce.Reason)
		}
		return nil, err
	}
	if err := fr.checkFrameOrder(f); err != nil {
		return nil, err
	}
	if fr.logReads {
		fr.debugReadLoggerf("http2: Framer %p: read %v", fr, summarizeFrame(f))
	}
	if fh.Type == FrameHeaders && fr.ReadMetaHeaders != nil {
		return fr.readMetaFrame(f.(*HeadersFrame))
	}
	return f, nil
}
func (fr *Framer) connError(code ErrCode, reason string) error {
	fr.errDetail = errors.New(reason)
	return ConnectionError(code)
}
func (fr *Framer) checkFrameOrder(f Frame) error {
	last := fr.lastFrame
	fr.lastFrame = f
	if fr.AllowIllegalReads {
		return nil
	}
	fh := f.Header()
	if fr.lastHeaderStream != 0 {
		if fh.Type != FrameContinuation {
			return fr.connError(ErrCodeProtocol,
				fmt.Sprintf("got %s for stream %d; expected CONTINUATION following %s for stream %d",
					fh.Type, fh.StreamID,
					last.Header().Type, fr.lastHeaderStream))
		}
		if fh.StreamID != fr.lastHeaderStream {
			return fr.connError(ErrCodeProtocol,
				fmt.Sprintf("got CONTINUATION for stream %d; expected stream %d",
					fh.StreamID, fr.lastHeaderStream))
		}
	} else if fh.Type == FrameContinuation {
		return fr.connError(ErrCodeProtocol, fmt.Sprintf("unexpected CONTINUATION for stream %d", fh.StreamID))
	}
	switch fh.Type {
	case FrameHeaders, FrameContinuation:
		if fh.Flags.Has(FlagHeadersEndHeaders) {
			fr.lastHeaderStream = 0
		} else {
			fr.lastHeaderStream = fh.StreamID
		}
	}
	return nil
}
type DataFrame struct {
	FrameHeader
	data []byte
}
func (f *DataFrame) StreamEnded() bool {
	return f.FrameHeader.Flags.Has(FlagDataEndStream)
}
func (f *DataFrame) Data() []byte {
	f.checkValid()
	return f.data
}
func parseDataFrame(fc *frameCache, fh FrameHeader, payload []byte) (Frame, error) {
	if fh.StreamID == 0 {
		
		
		
		
		
		return nil, connError{ErrCodeProtocol, "DATA frame with stream ID 0"}
	}
	f := fc.getDataFrame()
	f.FrameHeader = fh
	var padSize byte
	if fh.Flags.Has(FlagDataPadded) {
		var err error
		payload, padSize, err = readByte(payload)
		if err != nil {
			return nil, err
		}
	}
	if int(padSize) > len(payload) {
		
		
		
		
		return nil, connError{ErrCodeProtocol, "pad size larger than data payload"}
	}
	f.data = payload[:len(payload)-int(padSize)]
	return f, nil
}
var (
	errStreamID    = errors.New("invalid stream ID")
	errDepStreamID = errors.New("invalid dependent stream ID")
	errPadLength   = errors.New("pad length too large")
	errPadBytes    = errors.New("padding bytes must all be zeros unless AllowIllegalWrites is enabled")
)
func validStreamIDOrZero(streamID uint32) bool {
	return streamID&(1<<31) == 0
}
func validStreamID(streamID uint32) bool {
	return streamID != 0 && streamID&(1<<31) == 0
}
func (f *Framer) WriteData(streamID uint32, endStream bool, data []byte) error {
	return f.WriteDataPadded(streamID, endStream, data, nil)
}
func (f *Framer) WriteDataPadded(streamID uint32, endStream bool, data, pad []byte) error {
	if !validStreamID(streamID) && !f.AllowIllegalWrites {
		return errStreamID
	}
	if len(pad) > 0 {
		if len(pad) > 255 {
			return errPadLength
		}
		if !f.AllowIllegalWrites {
			for _, b := range pad {
				if b != 0 {
					
					return errPadBytes
				}
			}
		}
	}
	var flags Flags
	if endStream {
		flags |= FlagDataEndStream
	}
	if pad != nil {
		flags |= FlagDataPadded
	}
	f.startWrite(FrameData, flags, streamID)
	if pad != nil {
		f.wbuf = append(f.wbuf, byte(len(pad)))
	}
	f.wbuf = append(f.wbuf, data...)
	f.wbuf = append(f.wbuf, pad...)
	return f.endWrite()
}
type SettingsFrame struct {
	FrameHeader
	p []byte
}
func parseSettingsFrame(_ *frameCache, fh FrameHeader, p []byte) (Frame, error) {
	if fh.Flags.Has(FlagSettingsAck) && fh.Length > 0 {
		
		
		
		
		
		
		return nil, ConnectionError(ErrCodeFrameSize)
	}
	if fh.StreamID != 0 {
		
		
		
		
		
		
		
		return nil, ConnectionError(ErrCodeProtocol)
	}
	if len(p)%6 != 0 {
		
		return nil, ConnectionError(ErrCodeFrameSize)
	}
	f := &SettingsFrame{FrameHeader: fh, p: p}
	if v, ok := f.Value(SettingInitialWindowSize); ok && v > (1<<31)-1 {
		
		
		
		return nil, ConnectionError(ErrCodeFlowControl)
	}
	return f, nil
}
func (f *SettingsFrame) IsAck() bool {
	return f.FrameHeader.Flags.Has(FlagSettingsAck)
}
func (f *SettingsFrame) Value(s SettingID) (v uint32, ok bool) {
	f.checkValid()
	buf := f.p
	for len(buf) > 0 {
		settingID := SettingID(binary.BigEndian.Uint16(buf[:2]))
		if settingID == s {
			return binary.BigEndian.Uint32(buf[2:6]), true
		}
		buf = buf[6:]
	}
	return 0, false
}
func (f *SettingsFrame) ForeachSetting(fn func(Setting) error) error {
	f.checkValid()
	buf := f.p
	for len(buf) > 0 {
		if err := fn(Setting{
			SettingID(binary.BigEndian.Uint16(buf[:2])),
			binary.BigEndian.Uint32(buf[2:6]),
		}); err != nil {
			return err
		}
		buf = buf[6:]
	}
	return nil
}
func (f *Framer) WriteSettings(settings ...Setting) error {
	f.startWrite(FrameSettings, 0, 0)
	for _, s := range settings {
		f.writeUint16(uint16(s.ID))
		f.writeUint32(s.Val)
	}
	return f.endWrite()
}
func (f *Framer) WriteSettingsAck() error {
	f.startWrite(FrameSettings, FlagSettingsAck, 0)
	return f.endWrite()
}
type PingFrame struct {
	FrameHeader
	Data [8]byte
}
func (f *PingFrame) IsAck() bool { return f.Flags.Has(FlagPingAck) }
func parsePingFrame(_ *frameCache, fh FrameHeader, payload []byte) (Frame, error) {
	if len(payload) != 8 {
		return nil, ConnectionError(ErrCodeFrameSize)
	}
	if fh.StreamID != 0 {
		return nil, ConnectionError(ErrCodeProtocol)
	}
	f := &PingFrame{FrameHeader: fh}
	copy(f.Data[:], payload)
	return f, nil
}
func (f *Framer) WritePing(ack bool, data [8]byte) error {
	var flags Flags
	if ack {
		flags = FlagPingAck
	}
	f.startWrite(FramePing, flags, 0)
	f.writeBytes(data[:])
	return f.endWrite()
}
type GoAwayFrame struct {
	FrameHeader
	LastStreamID uint32
	ErrCode      ErrCode
	debugData    []byte
}
func (f *GoAwayFrame) DebugData() []byte {
	f.checkValid()
	return f.debugData
}
func parseGoAwayFrame(_ *frameCache, fh FrameHeader, p []byte) (Frame, error) {
	if fh.StreamID != 0 {
		return nil, ConnectionError(ErrCodeProtocol)
	}
	if len(p) < 8 {
		return nil, ConnectionError(ErrCodeFrameSize)
	}
	return &GoAwayFrame{
		FrameHeader:  fh,
		LastStreamID: binary.BigEndian.Uint32(p[:4]) & (1<<31 - 1),
		ErrCode:      ErrCode(binary.BigEndian.Uint32(p[4:8])),
		debugData:    p[8:],
	}, nil
}
func (f *Framer) WriteGoAway(maxStreamID uint32, code ErrCode, debugData []byte) error {
	f.startWrite(FrameGoAway, 0, 0)
	f.writeUint32(maxStreamID & (1<<31 - 1))
	f.writeUint32(uint32(code))
	f.writeBytes(debugData)
	return f.endWrite()
}
type UnknownFrame struct {
	FrameHeader
	p []byte
}
func (f *UnknownFrame) Payload() []byte {
	f.checkValid()
	return f.p
}
func parseUnknownFrame(_ *frameCache, fh FrameHeader, p []byte) (Frame, error) {
	return &UnknownFrame{fh, p}, nil
}
type WindowUpdateFrame struct {
	FrameHeader
	Increment uint32 
}
func parseWindowUpdateFrame(_ *frameCache, fh FrameHeader, p []byte) (Frame, error) {
	if len(p) != 4 {
		return nil, ConnectionError(ErrCodeFrameSize)
	}
	inc := binary.BigEndian.Uint32(p[:4]) & 0x7fffffff 
	if inc == 0 {
		
		
		
		
		
		
		if fh.StreamID == 0 {
			return nil, ConnectionError(ErrCodeProtocol)
		}
		return nil, streamError(fh.StreamID, ErrCodeProtocol)
	}
	return &WindowUpdateFrame{
		FrameHeader: fh,
		Increment:   inc,
	}, nil
}
func (f *Framer) WriteWindowUpdate(streamID, incr uint32) error {
	
	if (incr < 1 || incr > 2147483647) && !f.AllowIllegalWrites {
		return errors.New("illegal window increment value")
	}
	f.startWrite(FrameWindowUpdate, 0, streamID)
	f.writeUint32(incr)
	return f.endWrite()
}
type HeadersFrame struct {
	FrameHeader
	
	Priority PriorityParam
	headerFragBuf []byte 
}
func (f *HeadersFrame) HeaderBlockFragment() []byte {
	f.checkValid()
	return f.headerFragBuf
}
func (f *HeadersFrame) HeadersEnded() bool {
	return f.FrameHeader.Flags.Has(FlagHeadersEndHeaders)
}
func (f *HeadersFrame) StreamEnded() bool {
	return f.FrameHeader.Flags.Has(FlagHeadersEndStream)
}
func (f *HeadersFrame) HasPriority() bool {
	return f.FrameHeader.Flags.Has(FlagHeadersPriority)
}
func parseHeadersFrame(_ *frameCache, fh FrameHeader, p []byte) (_ Frame, err error) {
	hf := &HeadersFrame{
		FrameHeader: fh,
	}
	if fh.StreamID == 0 {
		
		
		
		
		return nil, connError{ErrCodeProtocol, "HEADERS frame with stream ID 0"}
	}
	var padLength uint8
	if fh.Flags.Has(FlagHeadersPadded) {
		if p, padLength, err = readByte(p); err != nil {
			return
		}
	}
	if fh.Flags.Has(FlagHeadersPriority) {
		var v uint32
		p, v, err = readUint32(p)
		if err != nil {
			return nil, err
		}
		hf.Priority.StreamDep = v & 0x7fffffff
		hf.Priority.Exclusive = (v != hf.Priority.StreamDep) 
		p, hf.Priority.Weight, err = readByte(p)
		if err != nil {
			return nil, err
		}
	}
	if len(p)-int(padLength) <= 0 {
		return nil, streamError(fh.StreamID, ErrCodeProtocol)
	}
	hf.headerFragBuf = p[:len(p)-int(padLength)]
	return hf, nil
}
type HeadersFrameParam struct {
	
	StreamID uint32
	
	BlockFragment []byte
	
	
	
	
	EndStream bool
	
	
	
	EndHeaders bool
	
	
	PadLength uint8
	
	
	Priority PriorityParam
}
func (f *Framer) WriteHeaders(p HeadersFrameParam) error {
	if !validStreamID(p.StreamID) && !f.AllowIllegalWrites {
		return errStreamID
	}
	var flags Flags
	if p.PadLength != 0 {
		flags |= FlagHeadersPadded
	}
	if p.EndStream {
		flags |= FlagHeadersEndStream
	}
	if p.EndHeaders {
		flags |= FlagHeadersEndHeaders
	}
	if !p.Priority.IsZero() {
		flags |= FlagHeadersPriority
	}
	f.startWrite(FrameHeaders, flags, p.StreamID)
	if p.PadLength != 0 {
		f.writeByte(p.PadLength)
	}
	if !p.Priority.IsZero() {
		v := p.Priority.StreamDep
		if !validStreamIDOrZero(v) && !f.AllowIllegalWrites {
			return errDepStreamID
		}
		if p.Priority.Exclusive {
			v |= 1 << 31
		}
		f.writeUint32(v)
		f.writeByte(p.Priority.Weight)
	}
	f.wbuf = append(f.wbuf, p.BlockFragment...)
	f.wbuf = append(f.wbuf, padZeros[:p.PadLength]...)
	return f.endWrite()
}
type PriorityFrame struct {
	FrameHeader
	PriorityParam
}
type PriorityParam struct {
	
	
	
	StreamDep uint32
	
	Exclusive bool
	
	
	
	
	Weight uint8
}
func (p PriorityParam) IsZero() bool {
	return p == PriorityParam{}
}
func parsePriorityFrame(_ *frameCache, fh FrameHeader, payload []byte) (Frame, error) {
	if fh.StreamID == 0 {
		return nil, connError{ErrCodeProtocol, "PRIORITY frame with stream ID 0"}
	}
	if len(payload) != 5 {
		return nil, connError{ErrCodeFrameSize, fmt.Sprintf("PRIORITY frame payload size was %d; want 5", len(payload))}
	}
	v := binary.BigEndian.Uint32(payload[:4])
	streamID := v & 0x7fffffff 
	return &PriorityFrame{
		FrameHeader: fh,
		PriorityParam: PriorityParam{
			Weight:    payload[4],
			StreamDep: streamID,
			Exclusive: streamID != v, 
		},
	}, nil
}
func (f *Framer) WritePriority(streamID uint32, p PriorityParam) error {
	if !validStreamID(streamID) && !f.AllowIllegalWrites {
		return errStreamID
	}
	if !validStreamIDOrZero(p.StreamDep) {
		return errDepStreamID
	}
	f.startWrite(FramePriority, 0, streamID)
	v := p.StreamDep
	if p.Exclusive {
		v |= 1 << 31
	}
	f.writeUint32(v)
	f.writeByte(p.Weight)
	return f.endWrite()
}
type RSTStreamFrame struct {
	FrameHeader
	ErrCode ErrCode
}
func parseRSTStreamFrame(_ *frameCache, fh FrameHeader, p []byte) (Frame, error) {
	if len(p) != 4 {
		return nil, ConnectionError(ErrCodeFrameSize)
	}
	if fh.StreamID == 0 {
		return nil, ConnectionError(ErrCodeProtocol)
	}
	return &RSTStreamFrame{fh, ErrCode(binary.BigEndian.Uint32(p[:4]))}, nil
}
func (f *Framer) WriteRSTStream(streamID uint32, code ErrCode) error {
	if !validStreamID(streamID) && !f.AllowIllegalWrites {
		return errStreamID
	}
	f.startWrite(FrameRSTStream, 0, streamID)
	f.writeUint32(uint32(code))
	return f.endWrite()
}
type ContinuationFrame struct {
	FrameHeader
	headerFragBuf []byte
}
func parseContinuationFrame(_ *frameCache, fh FrameHeader, p []byte) (Frame, error) {
	if fh.StreamID == 0 {
		return nil, connError{ErrCodeProtocol, "CONTINUATION frame with stream ID 0"}
	}
	return &ContinuationFrame{fh, p}, nil
}
func (f *ContinuationFrame) HeaderBlockFragment() []byte {
	f.checkValid()
	return f.headerFragBuf
}
func (f *ContinuationFrame) HeadersEnded() bool {
	return f.FrameHeader.Flags.Has(FlagContinuationEndHeaders)
}
func (f *Framer) WriteContinuation(streamID uint32, endHeaders bool, headerBlockFragment []byte) error {
	if !validStreamID(streamID) && !f.AllowIllegalWrites {
		return errStreamID
	}
	var flags Flags
	if endHeaders {
		flags |= FlagContinuationEndHeaders
	}
	f.startWrite(FrameContinuation, flags, streamID)
	f.wbuf = append(f.wbuf, headerBlockFragment...)
	return f.endWrite()
}
type PushPromiseFrame struct {
	FrameHeader
	PromiseID     uint32
	headerFragBuf []byte 
}
func (f *PushPromiseFrame) HeaderBlockFragment() []byte {
	f.checkValid()
	return f.headerFragBuf
}
func (f *PushPromiseFrame) HeadersEnded() bool {
	return f.FrameHeader.Flags.Has(FlagPushPromiseEndHeaders)
}
func parsePushPromise(_ *frameCache, fh FrameHeader, p []byte) (_ Frame, err error) {
	pp := &PushPromiseFrame{
		FrameHeader: fh,
	}
	if pp.StreamID == 0 {
		
		
		
		
		
		
		return nil, ConnectionError(ErrCodeProtocol)
	}
	
	
	var padLength uint8
	if fh.Flags.Has(FlagPushPromisePadded) {
		if p, padLength, err = readByte(p); err != nil {
			return
		}
	}
	p, pp.PromiseID, err = readUint32(p)
	if err != nil {
		return
	}
	pp.PromiseID = pp.PromiseID & (1<<31 - 1)
	if int(padLength) > len(p) {
		
		return nil, ConnectionError(ErrCodeProtocol)
	}
	pp.headerFragBuf = p[:len(p)-int(padLength)]
	return pp, nil
}
type PushPromiseParam struct {
	
	StreamID uint32
	
	
	PromiseID uint32
	
	BlockFragment []byte
	
	
	
	EndHeaders bool
	
	
	PadLength uint8
}
func (f *Framer) WritePushPromise(p PushPromiseParam) error {
	if !validStreamID(p.StreamID) && !f.AllowIllegalWrites {
		return errStreamID
	}
	var flags Flags
	if p.PadLength != 0 {
		flags |= FlagPushPromisePadded
	}
	if p.EndHeaders {
		flags |= FlagPushPromiseEndHeaders
	}
	f.startWrite(FramePushPromise, flags, p.StreamID)
	if p.PadLength != 0 {
		f.writeByte(p.PadLength)
	}
	if !validStreamID(p.PromiseID) && !f.AllowIllegalWrites {
		return errStreamID
	}
	f.writeUint32(p.PromiseID)
	f.wbuf = append(f.wbuf, p.BlockFragment...)
	f.wbuf = append(f.wbuf, padZeros[:p.PadLength]...)
	return f.endWrite()
}
func (f *Framer) WriteRawFrame(t FrameType, flags Flags, streamID uint32, payload []byte) error {
	f.startWrite(t, flags, streamID)
	f.writeBytes(payload)
	return f.endWrite()
}
func readByte(p []byte) (remain []byte, b byte, err error) {
	if len(p) == 0 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	return p[1:], p[0], nil
}
func readUint32(p []byte) (remain []byte, v uint32, err error) {
	if len(p) < 4 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	return p[4:], binary.BigEndian.Uint32(p[:4]), nil
}
type streamEnder interface {
	StreamEnded() bool
}
type headersEnder interface {
	HeadersEnded() bool
}
type headersOrContinuation interface {
	headersEnder
	HeaderBlockFragment() []byte
}
type MetaHeadersFrame struct {
	*HeadersFrame
	
	
	
	
	
	
	
	
	
	
	Fields []hpack.HeaderField
	
	
	
	Truncated bool
}
func (mh *MetaHeadersFrame) PseudoValue(pseudo string) string {
	for _, hf := range mh.Fields {
		if !hf.IsPseudo() {
			return ""
		}
		if hf.Name[1:] == pseudo {
			return hf.Value
		}
	}
	return ""
}
func (mh *MetaHeadersFrame) RegularFields() []hpack.HeaderField {
	for i, hf := range mh.Fields {
		if !hf.IsPseudo() {
			return mh.Fields[i:]
		}
	}
	return nil
}
func (mh *MetaHeadersFrame) PseudoFields() []hpack.HeaderField {
	for i, hf := range mh.Fields {
		if !hf.IsPseudo() {
			return mh.Fields[:i]
		}
	}
	return mh.Fields
}
func (mh *MetaHeadersFrame) checkPseudos() error {
	var isRequest, isResponse bool
	pf := mh.PseudoFields()
	for i, hf := range pf {
		switch hf.Name {
		case ":method", ":path", ":scheme", ":authority":
			isRequest = true
		case ":status":
			isResponse = true
		default:
			return pseudoHeaderError(hf.Name)
		}
		
		
		
		for _, hf2 := range pf[:i] {
			if hf.Name == hf2.Name {
				return duplicatePseudoHeaderError(hf.Name)
			}
		}
	}
	if isRequest && isResponse {
		return errMixPseudoHeaderTypes
	}
	return nil
}
func (fr *Framer) maxHeaderStringLen() int {
	v := fr.maxHeaderListSize()
	if uint32(int(v)) == v {
		return int(v)
	}
	
	
	return 0
}
func (fr *Framer) readMetaFrame(hf *HeadersFrame) (*MetaHeadersFrame, error) {
	if fr.AllowIllegalReads {
		return nil, errors.New("illegal use of AllowIllegalReads with ReadMetaHeaders")
	}
	mh := &MetaHeadersFrame{
		HeadersFrame: hf,
	}
	var remainSize = fr.maxHeaderListSize()
	var sawRegular bool
	var invalid error 
	hdec := fr.ReadMetaHeaders
	hdec.SetEmitEnabled(true)
	hdec.SetMaxStringLength(fr.maxHeaderStringLen())
	hdec.SetEmitFunc(func(hf hpack.HeaderField) {
		if VerboseLogs && fr.logReads {
			fr.debugReadLoggerf("http2: decoded hpack field %+v", hf)
		}
		if !httplex.ValidHeaderFieldValue(hf.Value) {
			invalid = headerFieldValueError(hf.Value)
		}
		isPseudo := strings.HasPrefix(hf.Name, ":")
		if isPseudo {
			if sawRegular {
				invalid = errPseudoAfterRegular
			}
		} else {
			sawRegular = true
			if !validWireHeaderFieldName(hf.Name) {
				invalid = headerFieldNameError(hf.Name)
			}
		}
		if invalid != nil {
			hdec.SetEmitEnabled(false)
			return
		}
		size := hf.Size()
		if size > remainSize {
			hdec.SetEmitEnabled(false)
			mh.Truncated = true
			return
		}
		remainSize -= size
		mh.Fields = append(mh.Fields, hf)
	})
	
	defer hdec.SetEmitFunc(func(hf hpack.HeaderField) {})
	var hc headersOrContinuation = hf
	for {
		frag := hc.HeaderBlockFragment()
		if _, err := hdec.Write(frag); err != nil {
			return nil, ConnectionError(ErrCodeCompression)
		}
		if hc.HeadersEnded() {
			break
		}
		if f, err := fr.ReadFrame(); err != nil {
			return nil, err
		} else {
			hc = f.(*ContinuationFrame) 
		}
	}
	mh.HeadersFrame.headerFragBuf = nil
	mh.HeadersFrame.invalidate()
	if err := hdec.Close(); err != nil {
		return nil, ConnectionError(ErrCodeCompression)
	}
	if invalid != nil {
		fr.errDetail = invalid
		if VerboseLogs {
			log.Printf("http2: invalid header: %v", invalid)
		}
		return nil, StreamError{mh.StreamID, ErrCodeProtocol, invalid}
	}
	if err := mh.checkPseudos(); err != nil {
		fr.errDetail = err
		if VerboseLogs {
			log.Printf("http2: invalid pseudo headers: %v", err)
		}
		return nil, StreamError{mh.StreamID, ErrCodeProtocol, err}
	}
	return mh, nil
}
func summarizeFrame(f Frame) string {
	var buf bytes.Buffer
	f.Header().writeDebug(&buf)
	switch f := f.(type) {
	case *SettingsFrame:
		n := 0
		f.ForeachSetting(func(s Setting) error {
			n++
			if n == 1 {
				buf.WriteString(", settings:")
			}
			fmt.Fprintf(&buf, " %v=%v,", s.ID, s.Val)
			return nil
		})
		if n > 0 {
			buf.Truncate(buf.Len() - 1) 
		}
	case *DataFrame:
		data := f.Data()
		const max = 256
		if len(data) > max {
			data = data[:max]
		}
		fmt.Fprintf(&buf, " data=%q", data)
		if len(f.Data()) > max {
			fmt.Fprintf(&buf, " (%d bytes omitted)", len(f.Data())-max)
		}
	case *WindowUpdateFrame:
		if f.StreamID == 0 {
			buf.WriteString(" (conn)")
		}
		fmt.Fprintf(&buf, " incr=%v", f.Increment)
	case *PingFrame:
		fmt.Fprintf(&buf, " ping=%q", f.Data[:])
	case *GoAwayFrame:
		fmt.Fprintf(&buf, " LastStreamID=%v ErrCode=%v Debug=%q",
			f.LastStreamID, f.ErrCode, f.debugData)
	case *RSTStreamFrame:
		fmt.Fprintf(&buf, " ErrCode=%v", f.ErrCode)
	}
	return buf.String()
}
package http2
import "testing"
func TestErrCodeString(t *testing.T) {
	tests := []struct {
		err  ErrCode
		want string
	}{
		{ErrCodeProtocol, "PROTOCOL_ERROR"},
		{0xd, "HTTP_1_1_REQUIRED"},
		{0xf, "unknown error code 0xf"},
	}
	for i, tt := range tests {
		got := tt.err.String()
		if got != tt.want {
			t.Errorf("%d. Error = %q; want %q", i, got, tt.want)
		}
	}
}
package http2
import (
	"context"
	"net"
	"net
	"net
	"time"
)
type contextContext interface {
	context.Context
}
func serverConnBaseContext(c net.Conn, opts *ServeConnOpts) (ctx contextContext, cancel func()) {
	ctx, cancel = context.WithCancel(context.Background())
	ctx = context.WithValue(ctx, http.LocalAddrContextKey, c.LocalAddr())
	if hs := opts.baseConfig(); hs != nil {
		ctx = context.WithValue(ctx, http.ServerContextKey, hs)
	}
	return
}
func contextWithCancel(ctx contextContext) (_ contextContext, cancel func()) {
	return context.WithCancel(ctx)
}
func requestWithContext(req *http.Request, ctx contextContext) *http.Request {
	return req.WithContext(ctx)
}
type clientTrace httptrace.ClientTrace
func reqContext(r *http.Request) context.Context { return r.Context() }
func (t *Transport) idleConnTimeout() time.Duration {
	if t.t1 != nil {
		return t.t1.IdleConnTimeout
	}
	return 0
}
func setResponseUncompressed(res *http.Response) { res.Uncompressed = true }
func traceGotConn(req *http.Request, cc *ClientConn) {
	trace := httptrace.ContextClientTrace(req.Context())
	if trace == nil || trace.GotConn == nil {
		return
	}
	ci := httptrace.GotConnInfo{Conn: cc.tconn}
	cc.mu.Lock()
	ci.Reused = cc.nextStreamID > 1
	ci.WasIdle = len(cc.streams) == 0 && ci.Reused
	if ci.WasIdle && !cc.lastActive.IsZero() {
		ci.IdleTime = time.Now().Sub(cc.lastActive)
	}
	cc.mu.Unlock()
	trace.GotConn(ci)
}
func traceWroteHeaders(trace *clientTrace) {
	if trace != nil && trace.WroteHeaders != nil {
		trace.WroteHeaders()
	}
}
func traceGot100Continue(trace *clientTrace) {
	if trace != nil && trace.Got100Continue != nil {
		trace.Got100Continue()
	}
}
func traceWait100Continue(trace *clientTrace) {
	if trace != nil && trace.Wait100Continue != nil {
		trace.Wait100Continue()
	}
}
func traceWroteRequest(trace *clientTrace, err error) {
	if trace != nil && trace.WroteRequest != nil {
		trace.WroteRequest(httptrace.WroteRequestInfo{Err: err})
	}
}
func traceFirstResponseByte(trace *clientTrace) {
	if trace != nil && trace.GotFirstResponseByte != nil {
		trace.GotFirstResponseByte()
	}
}
func requestTrace(req *http.Request) *clientTrace {
	trace := httptrace.ContextClientTrace(req.Context())
	return (*clientTrace)(trace)
}
func (cc *ClientConn) Ping(ctx context.Context) error {
	return cc.ping(ctx)
}
package http2
import (
	"fmt"
	"math"
	"reflect"
	"testing"
)
func makeWriteNonStreamRequest() FrameWriteRequest {
	return FrameWriteRequest{writeSettingsAck{}, nil, nil}
}
func makeWriteHeadersRequest(streamID uint32) FrameWriteRequest {
	st := &stream{id: streamID}
	return FrameWriteRequest{&writeResHeaders{streamID: streamID, httpResCode: 200}, st, nil}
}
func checkConsume(wr FrameWriteRequest, nbytes int32, want []FrameWriteRequest) error {
	consumed, rest, n := wr.Consume(nbytes)
	var wantConsumed, wantRest FrameWriteRequest
	switch len(want) {
	case 0:
	case 1:
		wantConsumed = want[0]
	case 2:
		wantConsumed = want[0]
		wantRest = want[1]
	}
	if !reflect.DeepEqual(consumed, wantConsumed) || !reflect.DeepEqual(rest, wantRest) || n != len(want) {
		return fmt.Errorf("got %v, %v, %v\nwant %v, %v, %v", consumed, rest, n, wantConsumed, wantRest, len(want))
	}
	return nil
}
func TestFrameWriteRequestNonData(t *testing.T) {
	wr := makeWriteNonStreamRequest()
	if got, want := wr.DataSize(), 0; got != want {
		t.Errorf("DataSize: got %v, want %v", got, want)
	}
	
	if err := checkConsume(wr, 0, []FrameWriteRequest{wr}); err != nil {
		t.Errorf("Consume:\n%v", err)
	}
}
func TestFrameWriteRequestData(t *testing.T) {
	st := &stream{
		id: 1,
		sc: &serverConn{maxFrameSize: 16},
	}
	const size = 32
	wr := FrameWriteRequest{&writeData{st.id, make([]byte, size), true}, st, make(chan error)}
	if got, want := wr.DataSize(), size; got != want {
		t.Errorf("DataSize: got %v, want %v", got, want)
	}
	
	if err := checkConsume(wr, math.MaxInt32, []FrameWriteRequest{}); err != nil {
		t.Errorf("Consume(limited by flow control):\n%v", err)
	}
	
	
	st.flow.add(size)
	want := []FrameWriteRequest{
		{
			write:  &writeData{st.id, make([]byte, st.sc.maxFrameSize), false},
			stream: st,
			done:   nil,
		},
		{
			write:  &writeData{st.id, make([]byte, size-st.sc.maxFrameSize), true},
			stream: st,
			done:   wr.done,
		},
	}
	if err := checkConsume(wr, math.MaxInt32, want); err != nil {
		t.Errorf("Consume(limited by maxFrameSize):\n%v", err)
	}
	rest := want[1]
	
	want = []FrameWriteRequest{
		{
			write:  &writeData{st.id, make([]byte, 8), false},
			stream: st,
			done:   nil,
		},
		{
			write:  &writeData{st.id, make([]byte, size-st.sc.maxFrameSize-8), true},
			stream: st,
			done:   wr.done,
		},
	}
	if err := checkConsume(rest, 8, want); err != nil {
		t.Errorf("Consume(8):\n%v", err)
	}
	rest = want[1]
	
	want = []FrameWriteRequest{
		{
			write:  &writeData{st.id, make([]byte, size-st.sc.maxFrameSize-8), true},
			stream: st,
			done:   wr.done,
		},
	}
	if err := checkConsume(rest, math.MaxInt32, want); err != nil {
		t.Errorf("Consume(remainder):\n%v", err)
	}
}
func TestFrameWriteRequest_StreamID(t *testing.T) {
	const streamID = 123
	wr := FrameWriteRequest{write: streamError(streamID, ErrCodeNo)}
	if got := wr.StreamID(); got != streamID {
		t.Errorf("FrameWriteRequest(StreamError) = %v; want %v", got, streamID)
	}
}
package http2
import (
	"context"
	"net
	"reflect"
	"testing"
	"time"
)
func TestServerGracefulShutdown(t *testing.T) {
	var st *serverTester
	handlerDone := make(chan struct{})
	st = newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		defer close(handlerDone)
		go st.ts.Config.Shutdown(context.Background())
		ga := st.wantGoAway()
		if ga.ErrCode != ErrCodeNo {
			t.Errorf("GOAWAY error = %v; want ErrCodeNo", ga.ErrCode)
		}
		if ga.LastStreamID != 1 {
			t.Errorf("GOAWAY LastStreamID = %v; want 1", ga.LastStreamID)
		}
		w.Header().Set("x-foo", "bar")
	})
	defer st.Close()
	st.greet()
	st.bodylessReq1()
	select {
	case <-handlerDone:
	case <-time.After(5 * time.Second):
		t.Fatalf("server did not shutdown?")
	}
	hf := st.wantHeaders()
	goth := st.decodeHeader(hf.HeaderBlockFragment())
	wanth := [][2]string{
		{":status", "200"},
		{"x-foo", "bar"},
		{"content-type", "text
		{"content-length", "0"},
	}
	if !reflect.DeepEqual(goth, wanth) {
		t.Errorf("Got headers %v; want %v", goth, wanth)
	}
	n, err := st.cc.Read([]byte{0})
	if n != 0 || err == nil {
		t.Errorf("Read = %v, %v; want 0, non-nil", n, err)
	}
}
package http2
import "math"
func NewRandomWriteScheduler() WriteScheduler {
	return &randomWriteScheduler{sq: make(map[uint32]*writeQueue)}
}
type randomWriteScheduler struct {
	
	zero writeQueue
	
	
	sq map[uint32]*writeQueue
	
	queuePool writeQueuePool
}
func (ws *randomWriteScheduler) OpenStream(streamID uint32, options OpenStreamOptions) {
	
}
func (ws *randomWriteScheduler) CloseStream(streamID uint32) {
	q, ok := ws.sq[streamID]
	if !ok {
		return
	}
	delete(ws.sq, streamID)
	ws.queuePool.put(q)
}
func (ws *randomWriteScheduler) AdjustStream(streamID uint32, priority PriorityParam) {
	
}
func (ws *randomWriteScheduler) Push(wr FrameWriteRequest) {
	id := wr.StreamID()
	if id == 0 {
		ws.zero.push(wr)
		return
	}
	q, ok := ws.sq[id]
	if !ok {
		q = ws.queuePool.get()
		ws.sq[id] = q
	}
	q.push(wr)
}
func (ws *randomWriteScheduler) Pop() (FrameWriteRequest, bool) {
	
	if !ws.zero.empty() {
		return ws.zero.shift(), true
	}
	
	for _, q := range ws.sq {
		if wr, ok := q.consume(math.MaxInt32); ok {
			return wr, true
		}
	}
	return FrameWriteRequest{}, false
}
package http2
import (
	"bytes"
	"crypto
	"errors"
	"flag"
	"fmt"
	"io"
	"io
	"log"
	"net"
	"net
	"net
	"os"
	"os
	"reflect"
	"runtime"
	"strconv"
	"strings"
	"sync"
	"sync
	"testing"
	"time"
	"golang.org
)
var stderrVerbose = flag.Bool("stderr_verbose", false, "Mirror verbosity to stderr, unbuffered")
func stderrv() io.Writer {
	if *stderrVerbose {
		return os.Stderr
	}
	return ioutil.Discard
}
type serverTester struct {
	cc             net.Conn 
	t              testing.TB
	ts             *httptest.Server
	fr             *Framer
	serverLogBuf   bytes.Buffer 
	logFilter      []string     
	scMu           sync.Mutex   
	sc             *serverConn
	hpackDec       *hpack.Decoder
	decodedHeaders [][2]string
	
	
	
	
	frameReadLogMu   sync.Mutex
	frameReadLogBuf  bytes.Buffer
	frameWriteLogMu  sync.Mutex
	frameWriteLogBuf bytes.Buffer
	
	headerBuf bytes.Buffer
	hpackEnc  *hpack.Encoder
}
func init() {
	testHookOnPanicMu = new(sync.Mutex)
}
func resetHooks() {
	testHookOnPanicMu.Lock()
	testHookOnPanic = nil
	testHookOnPanicMu.Unlock()
}
type serverTesterOpt string
var optOnlyServer = serverTesterOpt("only_server")
var optQuiet = serverTesterOpt("quiet_logging")
var optFramerReuseFrames = serverTesterOpt("frame_reuse_frames")
func newServerTester(t testing.TB, handler http.HandlerFunc, opts ...interface{}) *serverTester {
	resetHooks()
	ts := httptest.NewUnstartedServer(handler)
	tlsConfig := &tls.Config{
		InsecureSkipVerify: true,
		NextProtos:         []string{NextProtoTLS},
	}
	var onlyServer, quiet, framerReuseFrames bool
	h2server := new(Server)
	for _, opt := range opts {
		switch v := opt.(type) {
		case func(*tls.Config):
			v(tlsConfig)
		case func(*httptest.Server):
			v(ts)
		case func(*Server):
			v(h2server)
		case serverTesterOpt:
			switch v {
			case optOnlyServer:
				onlyServer = true
			case optQuiet:
				quiet = true
			case optFramerReuseFrames:
				framerReuseFrames = true
			}
		case func(net.Conn, http.ConnState):
			ts.Config.ConnState = v
		default:
			t.Fatalf("unknown newServerTester option type %T", v)
		}
	}
	ConfigureServer(ts.Config, h2server)
	st := &serverTester{
		t:  t,
		ts: ts,
	}
	st.hpackEnc = hpack.NewEncoder(&st.headerBuf)
	st.hpackDec = hpack.NewDecoder(initialHeaderTableSize, st.onHeaderField)
	ts.TLS = ts.Config.TLSConfig 
	if quiet {
		ts.Config.ErrorLog = log.New(ioutil.Discard, "", 0)
	} else {
		ts.Config.ErrorLog = log.New(io.MultiWriter(stderrv(), twriter{t: t, st: st}, &st.serverLogBuf), "", log.LstdFlags)
	}
	ts.StartTLS()
	if VerboseLogs {
		t.Logf("Running test server at: %s", ts.URL)
	}
	testHookGetServerConn = func(v *serverConn) {
		st.scMu.Lock()
		defer st.scMu.Unlock()
		st.sc = v
	}
	log.SetOutput(io.MultiWriter(stderrv(), twriter{t: t, st: st}))
	if !onlyServer {
		cc, err := tls.Dial("tcp", ts.Listener.Addr().String(), tlsConfig)
		if err != nil {
			t.Fatal(err)
		}
		st.cc = cc
		st.fr = NewFramer(cc, cc)
		if framerReuseFrames {
			st.fr.SetReuseFrames()
		}
		if !logFrameReads && !logFrameWrites {
			st.fr.debugReadLoggerf = func(m string, v ...interface{}) {
				m = time.Now().Format("2006-01-02 15:04:05.999999999 ") + strings.TrimPrefix(m, "http2: ") + "\n"
				st.frameReadLogMu.Lock()
				fmt.Fprintf(&st.frameReadLogBuf, m, v...)
				st.frameReadLogMu.Unlock()
			}
			st.fr.debugWriteLoggerf = func(m string, v ...interface{}) {
				m = time.Now().Format("2006-01-02 15:04:05.999999999 ") + strings.TrimPrefix(m, "http2: ") + "\n"
				st.frameWriteLogMu.Lock()
				fmt.Fprintf(&st.frameWriteLogBuf, m, v...)
				st.frameWriteLogMu.Unlock()
			}
			st.fr.logReads = true
			st.fr.logWrites = true
		}
	}
	return st
}
func (st *serverTester) closeConn() {
	st.scMu.Lock()
	defer st.scMu.Unlock()
	st.sc.conn.Close()
}
func (st *serverTester) addLogFilter(phrase string) {
	st.logFilter = append(st.logFilter, phrase)
}
func (st *serverTester) stream(id uint32) *stream {
	ch := make(chan *stream, 1)
	st.sc.serveMsgCh <- func(int) {
		ch <- st.sc.streams[id]
	}
	return <-ch
}
func (st *serverTester) streamState(id uint32) streamState {
	ch := make(chan streamState, 1)
	st.sc.serveMsgCh <- func(int) {
		state, _ := st.sc.state(id)
		ch <- state
	}
	return <-ch
}
func (st *serverTester) loopNum() int {
	lastc := make(chan int, 1)
	st.sc.serveMsgCh <- func(loopNum int) {
		lastc <- loopNum
	}
	return <-lastc
}
func (st *serverTester) awaitIdle() {
	remain := 50
	last := st.loopNum()
	for remain > 0 {
		n := st.loopNum()
		if n == last+1 {
			remain--
		} else {
			remain = 50
		}
		last = n
	}
}
func (st *serverTester) Close() {
	if st.t.Failed() {
		st.frameReadLogMu.Lock()
		if st.frameReadLogBuf.Len() > 0 {
			st.t.Logf("Framer read log:\n%s", st.frameReadLogBuf.String())
		}
		st.frameReadLogMu.Unlock()
		st.frameWriteLogMu.Lock()
		if st.frameWriteLogBuf.Len() > 0 {
			st.t.Logf("Framer write log:\n%s", st.frameWriteLogBuf.String())
		}
		st.frameWriteLogMu.Unlock()
		
		
		
		
		if st.cc != nil {
			st.cc.Close()
		}
	}
	st.ts.Close()
	if st.cc != nil {
		st.cc.Close()
	}
	log.SetOutput(os.Stderr)
}
func (st *serverTester) greet() {
	st.greetAndCheckSettings(func(Setting) error { return nil })
}
func (st *serverTester) greetAndCheckSettings(checkSetting func(s Setting) error) {
	st.writePreface()
	st.writeInitialSettings()
	st.wantSettings().ForeachSetting(checkSetting)
	st.writeSettingsAck()
	
	var gotSettingsAck bool
	var gotWindowUpdate bool
	for i := 0; i < 2; i++ {
		f, err := st.readFrame()
		if err != nil {
			st.t.Fatal(err)
		}
		switch f := f.(type) {
		case *SettingsFrame:
			if !f.Header().Flags.Has(FlagSettingsAck) {
				st.t.Fatal("Settings Frame didn't have ACK set")
			}
			gotSettingsAck = true
		case *WindowUpdateFrame:
			if f.FrameHeader.StreamID != 0 {
				st.t.Fatalf("WindowUpdate StreamID = %d; want 0", f.FrameHeader.StreamID)
			}
			incr := uint32((&Server{}).initialConnRecvWindowSize() - initialWindowSize)
			if f.Increment != incr {
				st.t.Fatalf("WindowUpdate increment = %d; want %d", f.Increment, incr)
			}
			gotWindowUpdate = true
		default:
			st.t.Fatalf("Wanting a settings ACK or window update, received a %T", f)
		}
	}
	if !gotSettingsAck {
		st.t.Fatalf("Didn't get a settings ACK")
	}
	if !gotWindowUpdate {
		st.t.Fatalf("Didn't get a window update")
	}
}
func (st *serverTester) writePreface() {
	n, err := st.cc.Write(clientPreface)
	if err != nil {
		st.t.Fatalf("Error writing client preface: %v", err)
	}
	if n != len(clientPreface) {
		st.t.Fatalf("Writing client preface, wrote %d bytes; want %d", n, len(clientPreface))
	}
}
func (st *serverTester) writeInitialSettings() {
	if err := st.fr.WriteSettings(); err != nil {
		st.t.Fatalf("Error writing initial SETTINGS frame from client to server: %v", err)
	}
}
func (st *serverTester) writeSettingsAck() {
	if err := st.fr.WriteSettingsAck(); err != nil {
		st.t.Fatalf("Error writing ACK of server's SETTINGS: %v", err)
	}
}
func (st *serverTester) writeHeaders(p HeadersFrameParam) {
	if err := st.fr.WriteHeaders(p); err != nil {
		st.t.Fatalf("Error writing HEADERS: %v", err)
	}
}
func (st *serverTester) writePriority(id uint32, p PriorityParam) {
	if err := st.fr.WritePriority(id, p); err != nil {
		st.t.Fatalf("Error writing PRIORITY: %v", err)
	}
}
func (st *serverTester) encodeHeaderField(k, v string) {
	err := st.hpackEnc.WriteField(hpack.HeaderField{Name: k, Value: v})
	if err != nil {
		st.t.Fatalf("HPACK encoding error for %q
	}
}
func (st *serverTester) encodeHeaderRaw(headers ...string) []byte {
	if len(headers)%2 == 1 {
		panic("odd number of kv args")
	}
	st.headerBuf.Reset()
	for len(headers) > 0 {
		k, v := headers[0], headers[1]
		st.encodeHeaderField(k, v)
		headers = headers[2:]
	}
	return st.headerBuf.Bytes()
}
func (st *serverTester) encodeHeader(headers ...string) []byte {
	if len(headers)%2 == 1 {
		panic("odd number of kv args")
	}
	st.headerBuf.Reset()
	defaultAuthority := st.ts.Listener.Addr().String()
	if len(headers) == 0 {
		
		
		st.encodeHeaderField(":method", "GET")
		st.encodeHeaderField(":scheme", "https")
		st.encodeHeaderField(":authority", defaultAuthority)
		st.encodeHeaderField(":path", "
		return st.headerBuf.Bytes()
	}
	if len(headers) == 2 && headers[0] == ":method" {
		
		st.encodeHeaderField(":method", headers[1])
		st.encodeHeaderField(":scheme", "https")
		st.encodeHeaderField(":authority", defaultAuthority)
		st.encodeHeaderField(":path", "
		return st.headerBuf.Bytes()
	}
	pseudoCount := map[string]int{}
	keys := []string{":method", ":scheme", ":authority", ":path"}
	vals := map[string][]string{
		":method":    {"GET"},
		":scheme":    {"https"},
		":authority": {defaultAuthority},
		":path":      {"
	}
	for len(headers) > 0 {
		k, v := headers[0], headers[1]
		headers = headers[2:]
		if _, ok := vals[k]; !ok {
			keys = append(keys, k)
		}
		if strings.HasPrefix(k, ":") {
			pseudoCount[k]++
			if pseudoCount[k] == 1 {
				vals[k] = []string{v}
			} else {
				
				vals[k] = append(vals[k], v)
			}
		} else {
			vals[k] = append(vals[k], v)
		}
	}
	for _, k := range keys {
		for _, v := range vals[k] {
			st.encodeHeaderField(k, v)
		}
	}
	return st.headerBuf.Bytes()
}
func (st *serverTester) bodylessReq1(headers ...string) {
	st.writeHeaders(HeadersFrameParam{
		StreamID:      1, 
		BlockFragment: st.encodeHeader(headers...),
		EndStream:     true,
		EndHeaders:    true,
	})
}
func (st *serverTester) writeData(streamID uint32, endStream bool, data []byte) {
	if err := st.fr.WriteData(streamID, endStream, data); err != nil {
		st.t.Fatalf("Error writing DATA: %v", err)
	}
}
func (st *serverTester) writeDataPadded(streamID uint32, endStream bool, data, pad []byte) {
	if err := st.fr.WriteDataPadded(streamID, endStream, data, pad); err != nil {
		st.t.Fatalf("Error writing DATA: %v", err)
	}
}
func readFrameTimeout(fr *Framer, wait time.Duration) (Frame, error) {
	ch := make(chan interface{}, 1)
	go func() {
		fr, err := fr.ReadFrame()
		if err != nil {
			ch <- err
		} else {
			ch <- fr
		}
	}()
	t := time.NewTimer(wait)
	select {
	case v := <-ch:
		t.Stop()
		if fr, ok := v.(Frame); ok {
			return fr, nil
		}
		return nil, v.(error)
	case <-t.C:
		return nil, errors.New("timeout waiting for frame")
	}
}
func (st *serverTester) readFrame() (Frame, error) {
	return readFrameTimeout(st.fr, 2*time.Second)
}
func (st *serverTester) wantHeaders() *HeadersFrame {
	f, err := st.readFrame()
	if err != nil {
		st.t.Fatalf("Error while expecting a HEADERS frame: %v", err)
	}
	hf, ok := f.(*HeadersFrame)
	if !ok {
		st.t.Fatalf("got a %T; want *HeadersFrame", f)
	}
	return hf
}
func (st *serverTester) wantContinuation() *ContinuationFrame {
	f, err := st.readFrame()
	if err != nil {
		st.t.Fatalf("Error while expecting a CONTINUATION frame: %v", err)
	}
	cf, ok := f.(*ContinuationFrame)
	if !ok {
		st.t.Fatalf("got a %T; want *ContinuationFrame", f)
	}
	return cf
}
func (st *serverTester) wantData() *DataFrame {
	f, err := st.readFrame()
	if err != nil {
		st.t.Fatalf("Error while expecting a DATA frame: %v", err)
	}
	df, ok := f.(*DataFrame)
	if !ok {
		st.t.Fatalf("got a %T; want *DataFrame", f)
	}
	return df
}
func (st *serverTester) wantSettings() *SettingsFrame {
	f, err := st.readFrame()
	if err != nil {
		st.t.Fatalf("Error while expecting a SETTINGS frame: %v", err)
	}
	sf, ok := f.(*SettingsFrame)
	if !ok {
		st.t.Fatalf("got a %T; want *SettingsFrame", f)
	}
	return sf
}
func (st *serverTester) wantPing() *PingFrame {
	f, err := st.readFrame()
	if err != nil {
		st.t.Fatalf("Error while expecting a PING frame: %v", err)
	}
	pf, ok := f.(*PingFrame)
	if !ok {
		st.t.Fatalf("got a %T; want *PingFrame", f)
	}
	return pf
}
func (st *serverTester) wantGoAway() *GoAwayFrame {
	f, err := st.readFrame()
	if err != nil {
		st.t.Fatalf("Error while expecting a GOAWAY frame: %v", err)
	}
	gf, ok := f.(*GoAwayFrame)
	if !ok {
		st.t.Fatalf("got a %T; want *GoAwayFrame", f)
	}
	return gf
}
func (st *serverTester) wantRSTStream(streamID uint32, errCode ErrCode) {
	f, err := st.readFrame()
	if err != nil {
		st.t.Fatalf("Error while expecting an RSTStream frame: %v", err)
	}
	rs, ok := f.(*RSTStreamFrame)
	if !ok {
		st.t.Fatalf("got a %T; want *RSTStreamFrame", f)
	}
	if rs.FrameHeader.StreamID != streamID {
		st.t.Fatalf("RSTStream StreamID = %d; want %d", rs.FrameHeader.StreamID, streamID)
	}
	if rs.ErrCode != errCode {
		st.t.Fatalf("RSTStream ErrCode = %d (%s); want %d (%s)", rs.ErrCode, rs.ErrCode, errCode, errCode)
	}
}
func (st *serverTester) wantWindowUpdate(streamID, incr uint32) {
	f, err := st.readFrame()
	if err != nil {
		st.t.Fatalf("Error while expecting a WINDOW_UPDATE frame: %v", err)
	}
	wu, ok := f.(*WindowUpdateFrame)
	if !ok {
		st.t.Fatalf("got a %T; want *WindowUpdateFrame", f)
	}
	if wu.FrameHeader.StreamID != streamID {
		st.t.Fatalf("WindowUpdate StreamID = %d; want %d", wu.FrameHeader.StreamID, streamID)
	}
	if wu.Increment != incr {
		st.t.Fatalf("WindowUpdate increment = %d; want %d", wu.Increment, incr)
	}
}
func (st *serverTester) wantSettingsAck() {
	f, err := st.readFrame()
	if err != nil {
		st.t.Fatal(err)
	}
	sf, ok := f.(*SettingsFrame)
	if !ok {
		st.t.Fatalf("Wanting a settings ACK, received a %T", f)
	}
	if !sf.Header().Flags.Has(FlagSettingsAck) {
		st.t.Fatal("Settings Frame didn't have ACK set")
	}
}
func (st *serverTester) wantPushPromise() *PushPromiseFrame {
	f, err := st.readFrame()
	if err != nil {
		st.t.Fatal(err)
	}
	ppf, ok := f.(*PushPromiseFrame)
	if !ok {
		st.t.Fatalf("Wanted PushPromise, received %T", ppf)
	}
	return ppf
}
func TestServer(t *testing.T) {
	gotReq := make(chan bool, 1)
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Foo", "Bar")
		gotReq <- true
	})
	defer st.Close()
	covers("3.5", `
		The server connection preface consists of a potentially empty
		SETTINGS frame ([SETTINGS]) that MUST be the first frame the
		server sends in the HTTP
	`)
	st.greet()
	st.writeHeaders(HeadersFrameParam{
		StreamID:      1, 
		BlockFragment: st.encodeHeader(),
		EndStream:     true, 
		EndHeaders:    true,
	})
	select {
	case <-gotReq:
	case <-time.After(2 * time.Second):
		t.Error("timeout waiting for request")
	}
}
func TestServer_Request_Get(t *testing.T) {
	testServerRequest(t, func(st *serverTester) {
		st.writeHeaders(HeadersFrameParam{
			StreamID:      1, 
			BlockFragment: st.encodeHeader("foo-bar", "some-value"),
			EndStream:     true, 
			EndHeaders:    true,
		})
	}, func(r *http.Request) {
		if r.Method != "GET" {
			t.Errorf("Method = %q; want GET", r.Method)
		}
		if r.URL.Path != "
			t.Errorf("URL.Path = %q; want 
		}
		if r.ContentLength != 0 {
			t.Errorf("ContentLength = %v; want 0", r.ContentLength)
		}
		if r.Close {
			t.Error("Close = true; want false")
		}
		if !strings.Contains(r.RemoteAddr, ":") {
			t.Errorf("RemoteAddr = %q; want something with a colon", r.RemoteAddr)
		}
		if r.Proto != "HTTP
			t.Errorf("Proto = %q Major=%v,Minor=%v; want HTTP
		}
		wantHeader := http.Header{
			"Foo-Bar": []string{"some-value"},
		}
		if !reflect.DeepEqual(r.Header, wantHeader) {
			t.Errorf("Header = %#v; want %#v", r.Header, wantHeader)
		}
		if n, err := r.Body.Read([]byte(" ")); err != io.EOF || n != 0 {
			t.Errorf("Read = %d, %v; want 0, EOF", n, err)
		}
	})
}
func TestServer_Request_Get_PathSlashes(t *testing.T) {
	testServerRequest(t, func(st *serverTester) {
		st.writeHeaders(HeadersFrameParam{
			StreamID:      1, 
			BlockFragment: st.encodeHeader(":path", "
			EndStream:     true, 
			EndHeaders:    true,
		})
	}, func(r *http.Request) {
		if r.RequestURI != "
			t.Errorf("RequestURI = %q; want 
		}
		if r.URL.Path != "
			t.Errorf("URL.Path = %q; want 
		}
	})
}
func TestServer_Request_Post_NoContentLength_EndStream(t *testing.T) {
	testServerRequest(t, func(st *serverTester) {
		st.writeHeaders(HeadersFrameParam{
			StreamID:      1, 
			BlockFragment: st.encodeHeader(":method", "POST"),
			EndStream:     true,
			EndHeaders:    true,
		})
	}, func(r *http.Request) {
		if r.Method != "POST" {
			t.Errorf("Method = %q; want POST", r.Method)
		}
		if r.ContentLength != 0 {
			t.Errorf("ContentLength = %v; want 0", r.ContentLength)
		}
		if n, err := r.Body.Read([]byte(" ")); err != io.EOF || n != 0 {
			t.Errorf("Read = %d, %v; want 0, EOF", n, err)
		}
	})
}
func TestServer_Request_Post_Body_ImmediateEOF(t *testing.T) {
	testBodyContents(t, -1, "", func(st *serverTester) {
		st.writeHeaders(HeadersFrameParam{
			StreamID:      1, 
			BlockFragment: st.encodeHeader(":method", "POST"),
			EndStream:     false, 
			EndHeaders:    true,
		})
		st.writeData(1, true, nil) 
	})
}
func TestServer_Request_Post_Body_OneData(t *testing.T) {
	const content = "Some content"
	testBodyContents(t, -1, content, func(st *serverTester) {
		st.writeHeaders(HeadersFrameParam{
			StreamID:      1, 
			BlockFragment: st.encodeHeader(":method", "POST"),
			EndStream:     false, 
			EndHeaders:    true,
		})
		st.writeData(1, true, []byte(content))
	})
}
func TestServer_Request_Post_Body_TwoData(t *testing.T) {
	const content = "Some content"
	testBodyContents(t, -1, content, func(st *serverTester) {
		st.writeHeaders(HeadersFrameParam{
			StreamID:      1, 
			BlockFragment: st.encodeHeader(":method", "POST"),
			EndStream:     false, 
			EndHeaders:    true,
		})
		st.writeData(1, false, []byte(content[:5]))
		st.writeData(1, true, []byte(content[5:]))
	})
}
func TestServer_Request_Post_Body_ContentLength_Correct(t *testing.T) {
	const content = "Some content"
	testBodyContents(t, int64(len(content)), content, func(st *serverTester) {
		st.writeHeaders(HeadersFrameParam{
			StreamID: 1, 
			BlockFragment: st.encodeHeader(
				":method", "POST",
				"content-length", strconv.Itoa(len(content)),
			),
			EndStream:  false, 
			EndHeaders: true,
		})
		st.writeData(1, true, []byte(content))
	})
}
func TestServer_Request_Post_Body_ContentLength_TooLarge(t *testing.T) {
	testBodyContentsFail(t, 3, "request declared a Content-Length of 3 but only wrote 2 bytes",
		func(st *serverTester) {
			st.writeHeaders(HeadersFrameParam{
				StreamID: 1, 
				BlockFragment: st.encodeHeader(
					":method", "POST",
					"content-length", "3",
				),
				EndStream:  false, 
				EndHeaders: true,
			})
			st.writeData(1, true, []byte("12"))
		})
}
func TestServer_Request_Post_Body_ContentLength_TooSmall(t *testing.T) {
	testBodyContentsFail(t, 4, "sender tried to send more than declared Content-Length of 4 bytes",
		func(st *serverTester) {
			st.writeHeaders(HeadersFrameParam{
				StreamID: 1, 
				BlockFragment: st.encodeHeader(
					":method", "POST",
					"content-length", "4",
				),
				EndStream:  false, 
				EndHeaders: true,
			})
			st.writeData(1, true, []byte("12345"))
		})
}
func testBodyContents(t *testing.T, wantContentLength int64, wantBody string, write func(st *serverTester)) {
	testServerRequest(t, write, func(r *http.Request) {
		if r.Method != "POST" {
			t.Errorf("Method = %q; want POST", r.Method)
		}
		if r.ContentLength != wantContentLength {
			t.Errorf("ContentLength = %v; want %d", r.ContentLength, wantContentLength)
		}
		all, err := ioutil.ReadAll(r.Body)
		if err != nil {
			t.Fatal(err)
		}
		if string(all) != wantBody {
			t.Errorf("Read = %q; want %q", all, wantBody)
		}
		if err := r.Body.Close(); err != nil {
			t.Fatalf("Close: %v", err)
		}
	})
}
func testBodyContentsFail(t *testing.T, wantContentLength int64, wantReadError string, write func(st *serverTester)) {
	testServerRequest(t, write, func(r *http.Request) {
		if r.Method != "POST" {
			t.Errorf("Method = %q; want POST", r.Method)
		}
		if r.ContentLength != wantContentLength {
			t.Errorf("ContentLength = %v; want %d", r.ContentLength, wantContentLength)
		}
		all, err := ioutil.ReadAll(r.Body)
		if err == nil {
			t.Fatalf("expected an error (%q) reading from the body. Successfully read %q instead.",
				wantReadError, all)
		}
		if !strings.Contains(err.Error(), wantReadError) {
			t.Fatalf("Body.Read = %v; want substring %q", err, wantReadError)
		}
		if err := r.Body.Close(); err != nil {
			t.Fatalf("Close: %v", err)
		}
	})
}
func TestServer_Request_Get_Host(t *testing.T) {
	const host = "example.com"
	testServerRequest(t, func(st *serverTester) {
		st.writeHeaders(HeadersFrameParam{
			StreamID:      1, 
			BlockFragment: st.encodeHeader(":authority", "", "host", host),
			EndStream:     true,
			EndHeaders:    true,
		})
	}, func(r *http.Request) {
		if r.Host != host {
			t.Errorf("Host = %q; want %q", r.Host, host)
		}
	})
}
func TestServer_Request_Get_Authority(t *testing.T) {
	const host = "example.com"
	testServerRequest(t, func(st *serverTester) {
		st.writeHeaders(HeadersFrameParam{
			StreamID:      1, 
			BlockFragment: st.encodeHeader(":authority", host),
			EndStream:     true,
			EndHeaders:    true,
		})
	}, func(r *http.Request) {
		if r.Host != host {
			t.Errorf("Host = %q; want %q", r.Host, host)
		}
	})
}
func TestServer_Request_WithContinuation(t *testing.T) {
	wantHeader := http.Header{
		"Foo-One":   []string{"value-one"},
		"Foo-Two":   []string{"value-two"},
		"Foo-Three": []string{"value-three"},
	}
	testServerRequest(t, func(st *serverTester) {
		fullHeaders := st.encodeHeader(
			"foo-one", "value-one",
			"foo-two", "value-two",
			"foo-three", "value-three",
		)
		remain := fullHeaders
		chunks := 0
		for len(remain) > 0 {
			const maxChunkSize = 5
			chunk := remain
			if len(chunk) > maxChunkSize {
				chunk = chunk[:maxChunkSize]
			}
			remain = remain[len(chunk):]
			if chunks == 0 {
				st.writeHeaders(HeadersFrameParam{
					StreamID:      1, 
					BlockFragment: chunk,
					EndStream:     true,  
					EndHeaders:    false, 
				})
			} else {
				err := st.fr.WriteContinuation(1, len(remain) == 0, chunk)
				if err != nil {
					t.Fatal(err)
				}
			}
			chunks++
		}
		if chunks < 2 {
			t.Fatal("too few chunks")
		}
	}, func(r *http.Request) {
		if !reflect.DeepEqual(r.Header, wantHeader) {
			t.Errorf("Header = %#v; want %#v", r.Header, wantHeader)
		}
	})
}
func TestServer_Request_CookieConcat(t *testing.T) {
	const host = "example.com"
	testServerRequest(t, func(st *serverTester) {
		st.bodylessReq1(
			":authority", host,
			"cookie", "a=b",
			"cookie", "c=d",
			"cookie", "e=f",
		)
	}, func(r *http.Request) {
		const want = "a=b; c=d; e=f"
		if got := r.Header.Get("Cookie"); got != want {
			t.Errorf("Cookie = %q; want %q", got, want)
		}
	})
}
func TestServer_Request_Reject_CapitalHeader(t *testing.T) {
	testRejectRequest(t, func(st *serverTester) { st.bodylessReq1("UPPER", "v") })
}
func TestServer_Request_Reject_HeaderFieldNameColon(t *testing.T) {
	testRejectRequest(t, func(st *serverTester) { st.bodylessReq1("has:colon", "v") })
}
func TestServer_Request_Reject_HeaderFieldNameNULL(t *testing.T) {
	testRejectRequest(t, func(st *serverTester) { st.bodylessReq1("has\x00null", "v") })
}
func TestServer_Request_Reject_HeaderFieldNameEmpty(t *testing.T) {
	testRejectRequest(t, func(st *serverTester) { st.bodylessReq1("", "v") })
}
func TestServer_Request_Reject_HeaderFieldValueNewline(t *testing.T) {
	testRejectRequest(t, func(st *serverTester) { st.bodylessReq1("foo", "has\nnewline") })
}
func TestServer_Request_Reject_HeaderFieldValueCR(t *testing.T) {
	testRejectRequest(t, func(st *serverTester) { st.bodylessReq1("foo", "has\rcarriage") })
}
func TestServer_Request_Reject_HeaderFieldValueDEL(t *testing.T) {
	testRejectRequest(t, func(st *serverTester) { st.bodylessReq1("foo", "has\x7fdel") })
}
func TestServer_Request_Reject_Pseudo_Missing_method(t *testing.T) {
	testRejectRequest(t, func(st *serverTester) { st.bodylessReq1(":method", "") })
}
func TestServer_Request_Reject_Pseudo_ExactlyOne(t *testing.T) {
	
	
	testRejectRequest(t, func(st *serverTester) {
		st.addLogFilter("duplicate pseudo-header")
		st.bodylessReq1(":method", "GET", ":method", "POST")
	})
}
func TestServer_Request_Reject_Pseudo_AfterRegular(t *testing.T) {
	
	
	
	
	
	
	testRejectRequest(t, func(st *serverTester) {
		st.addLogFilter("pseudo-header after regular header")
		var buf bytes.Buffer
		enc := hpack.NewEncoder(&buf)
		enc.WriteField(hpack.HeaderField{Name: ":method", Value: "GET"})
		enc.WriteField(hpack.HeaderField{Name: "regular", Value: "foobar"})
		enc.WriteField(hpack.HeaderField{Name: ":path", Value: "
		enc.WriteField(hpack.HeaderField{Name: ":scheme", Value: "https"})
		st.writeHeaders(HeadersFrameParam{
			StreamID:      1, 
			BlockFragment: buf.Bytes(),
			EndStream:     true,
			EndHeaders:    true,
		})
	})
}
func TestServer_Request_Reject_Pseudo_Missing_path(t *testing.T) {
	testRejectRequest(t, func(st *serverTester) { st.bodylessReq1(":path", "") })
}
func TestServer_Request_Reject_Pseudo_Missing_scheme(t *testing.T) {
	testRejectRequest(t, func(st *serverTester) { st.bodylessReq1(":scheme", "") })
}
func TestServer_Request_Reject_Pseudo_scheme_invalid(t *testing.T) {
	testRejectRequest(t, func(st *serverTester) { st.bodylessReq1(":scheme", "bogus") })
}
func TestServer_Request_Reject_Pseudo_Unknown(t *testing.T) {
	testRejectRequest(t, func(st *serverTester) {
		st.addLogFilter(`invalid pseudo-header ":unknown_thing"`)
		st.bodylessReq1(":unknown_thing", "")
	})
}
func testRejectRequest(t *testing.T, send func(*serverTester)) {
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		t.Error("server request made it to handler; should've been rejected")
	})
	defer st.Close()
	st.greet()
	send(st)
	st.wantRSTStream(1, ErrCodeProtocol)
}
func testRejectRequestWithProtocolError(t *testing.T, send func(*serverTester)) {
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		t.Error("server request made it to handler; should've been rejected")
	}, optQuiet)
	defer st.Close()
	st.greet()
	send(st)
	gf := st.wantGoAway()
	if gf.ErrCode != ErrCodeProtocol {
		t.Errorf("err code = %v; want %v", gf.ErrCode, ErrCodeProtocol)
	}
}
func TestRejectFrameOnIdle_WindowUpdate(t *testing.T) {
	testRejectRequestWithProtocolError(t, func(st *serverTester) {
		st.fr.WriteWindowUpdate(123, 456)
	})
}
func TestRejectFrameOnIdle_Data(t *testing.T) {
	testRejectRequestWithProtocolError(t, func(st *serverTester) {
		st.fr.WriteData(123, true, nil)
	})
}
func TestRejectFrameOnIdle_RSTStream(t *testing.T) {
	testRejectRequestWithProtocolError(t, func(st *serverTester) {
		st.fr.WriteRSTStream(123, ErrCodeCancel)
	})
}
func TestServer_Request_Connect(t *testing.T) {
	testServerRequest(t, func(st *serverTester) {
		st.writeHeaders(HeadersFrameParam{
			StreamID: 1,
			BlockFragment: st.encodeHeaderRaw(
				":method", "CONNECT",
				":authority", "example.com:123",
			),
			EndStream:  true,
			EndHeaders: true,
		})
	}, func(r *http.Request) {
		if g, w := r.Method, "CONNECT"; g != w {
			t.Errorf("Method = %q; want %q", g, w)
		}
		if g, w := r.RequestURI, "example.com:123"; g != w {
			t.Errorf("RequestURI = %q; want %q", g, w)
		}
		if g, w := r.URL.Host, "example.com:123"; g != w {
			t.Errorf("URL.Host = %q; want %q", g, w)
		}
	})
}
func TestServer_Request_Connect_InvalidPath(t *testing.T) {
	testServerRejectsStream(t, ErrCodeProtocol, func(st *serverTester) {
		st.writeHeaders(HeadersFrameParam{
			StreamID: 1,
			BlockFragment: st.encodeHeaderRaw(
				":method", "CONNECT",
				":authority", "example.com:123",
				":path", "
			),
			EndStream:  true,
			EndHeaders: true,
		})
	})
}
func TestServer_Request_Connect_InvalidScheme(t *testing.T) {
	testServerRejectsStream(t, ErrCodeProtocol, func(st *serverTester) {
		st.writeHeaders(HeadersFrameParam{
			StreamID: 1,
			BlockFragment: st.encodeHeaderRaw(
				":method", "CONNECT",
				":authority", "example.com:123",
				":scheme", "https",
			),
			EndStream:  true,
			EndHeaders: true,
		})
	})
}
func TestServer_Ping(t *testing.T) {
	st := newServerTester(t, nil)
	defer st.Close()
	st.greet()
	
	ackPingData := [8]byte{1, 2, 4, 8, 16, 32, 64, 128}
	if err := st.fr.WritePing(true, ackPingData); err != nil {
		t.Fatal(err)
	}
	
	pingData := [8]byte{1, 2, 3, 4, 5, 6, 7, 8}
	if err := st.fr.WritePing(false, pingData); err != nil {
		t.Fatal(err)
	}
	pf := st.wantPing()
	if !pf.Flags.Has(FlagPingAck) {
		t.Error("response ping doesn't have ACK set")
	}
	if pf.Data != pingData {
		t.Errorf("response ping has data %q; want %q", pf.Data, pingData)
	}
}
func TestServer_RejectsLargeFrames(t *testing.T) {
	if runtime.GOOS == "windows" {
		t.Skip("see golang.org
	}
	st := newServerTester(t, nil)
	defer st.Close()
	st.greet()
	
	
	
	st.fr.WriteRawFrame(0xff, 0, 0, make([]byte, defaultMaxReadFrameSize+1))
	gf := st.wantGoAway()
	if gf.ErrCode != ErrCodeFrameSize {
		t.Errorf("GOAWAY err = %v; want %v", gf.ErrCode, ErrCodeFrameSize)
	}
	if st.serverLogBuf.Len() != 0 {
		
		
		t.Errorf("unexpected server output: %.500s\n", st.serverLogBuf.Bytes())
	}
}
func TestServer_Handler_Sends_WindowUpdate(t *testing.T) {
	puppet := newHandlerPuppet()
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		puppet.act(w, r)
	})
	defer st.Close()
	defer puppet.done()
	st.greet()
	st.writeHeaders(HeadersFrameParam{
		StreamID:      1, 
		BlockFragment: st.encodeHeader(":method", "POST"),
		EndStream:     false, 
		EndHeaders:    true,
	})
	st.writeData(1, false, []byte("abcdef"))
	puppet.do(readBodyHandler(t, "abc"))
	st.wantWindowUpdate(0, 3)
	st.wantWindowUpdate(1, 3)
	puppet.do(readBodyHandler(t, "def"))
	st.wantWindowUpdate(0, 3)
	st.wantWindowUpdate(1, 3)
	st.writeData(1, true, []byte("ghijkl")) 
	puppet.do(readBodyHandler(t, "ghi"))
	puppet.do(readBodyHandler(t, "jkl"))
	st.wantWindowUpdate(0, 3)
	st.wantWindowUpdate(0, 3) 
}
func TestServer_Handler_Sends_WindowUpdate_Padding(t *testing.T) {
	puppet := newHandlerPuppet()
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		puppet.act(w, r)
	})
	defer st.Close()
	defer puppet.done()
	st.greet()
	st.writeHeaders(HeadersFrameParam{
		StreamID:      1,
		BlockFragment: st.encodeHeader(":method", "POST"),
		EndStream:     false,
		EndHeaders:    true,
	})
	st.writeDataPadded(1, false, []byte("abcdef"), []byte{0, 0, 0, 0})
	
	
	st.wantWindowUpdate(0, 5)
	st.wantWindowUpdate(1, 5)
	puppet.do(readBodyHandler(t, "abc"))
	st.wantWindowUpdate(0, 3)
	st.wantWindowUpdate(1, 3)
	puppet.do(readBodyHandler(t, "def"))
	st.wantWindowUpdate(0, 3)
	st.wantWindowUpdate(1, 3)
}
func TestServer_Send_GoAway_After_Bogus_WindowUpdate(t *testing.T) {
	st := newServerTester(t, nil)
	defer st.Close()
	st.greet()
	if err := st.fr.WriteWindowUpdate(0, 1<<31-1); err != nil {
		t.Fatal(err)
	}
	gf := st.wantGoAway()
	if gf.ErrCode != ErrCodeFlowControl {
		t.Errorf("GOAWAY err = %v; want %v", gf.ErrCode, ErrCodeFlowControl)
	}
	if gf.LastStreamID != 0 {
		t.Errorf("GOAWAY last stream ID = %v; want %v", gf.LastStreamID, 0)
	}
}
func TestServer_Send_RstStream_After_Bogus_WindowUpdate(t *testing.T) {
	inHandler := make(chan bool)
	blockHandler := make(chan bool)
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		inHandler <- true
		<-blockHandler
	})
	defer st.Close()
	defer close(blockHandler)
	st.greet()
	st.writeHeaders(HeadersFrameParam{
		StreamID:      1,
		BlockFragment: st.encodeHeader(":method", "POST"),
		EndStream:     false, 
		EndHeaders:    true,
	})
	<-inHandler
	
	if err := st.fr.WriteWindowUpdate(1, 1<<31-1); err != nil {
		t.Fatal(err)
	}
	st.wantRSTStream(1, ErrCodeFlowControl)
}
func testServerPostUnblock(t *testing.T,
	handler func(http.ResponseWriter, *http.Request) error,
	fn func(*serverTester),
	checkErr func(error),
	otherHeaders ...string) {
	inHandler := make(chan bool)
	errc := make(chan error, 1)
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		inHandler <- true
		errc <- handler(w, r)
	})
	defer st.Close()
	st.greet()
	st.writeHeaders(HeadersFrameParam{
		StreamID:      1,
		BlockFragment: st.encodeHeader(append([]string{":method", "POST"}, otherHeaders...)...),
		EndStream:     false, 
		EndHeaders:    true,
	})
	<-inHandler
	fn(st)
	select {
	case err := <-errc:
		if checkErr != nil {
			checkErr(err)
		}
	case <-time.After(5 * time.Second):
		t.Fatal("timeout waiting for Handler to return")
	}
}
func TestServer_RSTStream_Unblocks_Read(t *testing.T) {
	testServerPostUnblock(t,
		func(w http.ResponseWriter, r *http.Request) (err error) {
			_, err = r.Body.Read(make([]byte, 1))
			return
		},
		func(st *serverTester) {
			if err := st.fr.WriteRSTStream(1, ErrCodeCancel); err != nil {
				t.Fatal(err)
			}
		},
		func(err error) {
			want := StreamError{StreamID: 0x1, Code: 0x8}
			if !reflect.DeepEqual(err, want) {
				t.Errorf("Read error = %v; want %v", err, want)
			}
		},
	)
}
func TestServer_RSTStream_Unblocks_Header_Write(t *testing.T) {
	
	
	n := 50
	if testing.Short() {
		n = 5
	}
	for i := 0; i < n; i++ {
		testServer_RSTStream_Unblocks_Header_Write(t)
	}
}
func testServer_RSTStream_Unblocks_Header_Write(t *testing.T) {
	inHandler := make(chan bool, 1)
	unblockHandler := make(chan bool, 1)
	headerWritten := make(chan bool, 1)
	wroteRST := make(chan bool, 1)
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		inHandler <- true
		<-wroteRST
		w.Header().Set("foo", "bar")
		w.WriteHeader(200)
		w.(http.Flusher).Flush()
		headerWritten <- true
		<-unblockHandler
	})
	defer st.Close()
	st.greet()
	st.writeHeaders(HeadersFrameParam{
		StreamID:      1,
		BlockFragment: st.encodeHeader(":method", "POST"),
		EndStream:     false, 
		EndHeaders:    true,
	})
	<-inHandler
	if err := st.fr.WriteRSTStream(1, ErrCodeCancel); err != nil {
		t.Fatal(err)
	}
	wroteRST <- true
	st.awaitIdle()
	select {
	case <-headerWritten:
	case <-time.After(2 * time.Second):
		t.Error("timeout waiting for header write")
	}
	unblockHandler <- true
}
func TestServer_DeadConn_Unblocks_Read(t *testing.T) {
	testServerPostUnblock(t,
		func(w http.ResponseWriter, r *http.Request) (err error) {
			_, err = r.Body.Read(make([]byte, 1))
			return
		},
		func(st *serverTester) { st.cc.Close() },
		func(err error) {
			if err == nil {
				t.Error("unexpected nil error from Request.Body.Read")
			}
		},
	)
}
var blockUntilClosed = func(w http.ResponseWriter, r *http.Request) error {
	<-w.(http.CloseNotifier).CloseNotify()
	return nil
}
func TestServer_CloseNotify_After_RSTStream(t *testing.T) {
	testServerPostUnblock(t, blockUntilClosed, func(st *serverTester) {
		if err := st.fr.WriteRSTStream(1, ErrCodeCancel); err != nil {
			t.Fatal(err)
		}
	}, nil)
}
func TestServer_CloseNotify_After_ConnClose(t *testing.T) {
	testServerPostUnblock(t, blockUntilClosed, func(st *serverTester) { st.cc.Close() }, nil)
}
func TestServer_CloseNotify_After_StreamError(t *testing.T) {
	testServerPostUnblock(t, blockUntilClosed, func(st *serverTester) {
		
		st.writeData(1, true, []byte("1234"))
	}, nil, "content-length", "3")
}
func TestServer_StateTransitions(t *testing.T) {
	var st *serverTester
	inHandler := make(chan bool)
	writeData := make(chan bool)
	leaveHandler := make(chan bool)
	st = newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		inHandler <- true
		if st.stream(1) == nil {
			t.Errorf("nil stream 1 in handler")
		}
		if got, want := st.streamState(1), stateOpen; got != want {
			t.Errorf("in handler, state is %v; want %v", got, want)
		}
		writeData <- true
		if n, err := r.Body.Read(make([]byte, 1)); n != 0 || err != io.EOF {
			t.Errorf("body read = %d, %v; want 0, EOF", n, err)
		}
		if got, want := st.streamState(1), stateHalfClosedRemote; got != want {
			t.Errorf("in handler, state is %v; want %v", got, want)
		}
		<-leaveHandler
	})
	st.greet()
	if st.stream(1) != nil {
		t.Fatal("stream 1 should be empty")
	}
	if got := st.streamState(1); got != stateIdle {
		t.Fatalf("stream 1 should be idle; got %v", got)
	}
	st.writeHeaders(HeadersFrameParam{
		StreamID:      1,
		BlockFragment: st.encodeHeader(":method", "POST"),
		EndStream:     false, 
		EndHeaders:    true,
	})
	<-inHandler
	<-writeData
	st.writeData(1, true, nil)
	leaveHandler <- true
	hf := st.wantHeaders()
	if !hf.StreamEnded() {
		t.Fatal("expected END_STREAM flag")
	}
	if got, want := st.streamState(1), stateClosed; got != want {
		t.Errorf("at end, state is %v; want %v", got, want)
	}
	if st.stream(1) != nil {
		t.Fatal("at end, stream 1 should be gone")
	}
}
func TestServer_Rejects_HeadersNoEnd_Then_Headers(t *testing.T) {
	testServerRejectsConn(t, func(st *serverTester) {
		st.writeHeaders(HeadersFrameParam{
			StreamID:      1,
			BlockFragment: st.encodeHeader(),
			EndStream:     true,
			EndHeaders:    false,
		})
		st.writeHeaders(HeadersFrameParam{ 
			StreamID:      3, 
			BlockFragment: st.encodeHeader(),
			EndStream:     true,
			EndHeaders:    true,
		})
	})
}
func TestServer_Rejects_HeadersNoEnd_Then_Ping(t *testing.T) {
	testServerRejectsConn(t, func(st *serverTester) {
		st.writeHeaders(HeadersFrameParam{
			StreamID:      1,
			BlockFragment: st.encodeHeader(),
			EndStream:     true,
			EndHeaders:    false,
		})
		if err := st.fr.WritePing(false, [8]byte{}); err != nil {
			t.Fatal(err)
		}
	})
}
func TestServer_Rejects_HeadersEnd_Then_Continuation(t *testing.T) {
	testServerRejectsConn(t, func(st *serverTester) {
		st.writeHeaders(HeadersFrameParam{
			StreamID:      1,
			BlockFragment: st.encodeHeader(),
			EndStream:     true,
			EndHeaders:    true,
		})
		st.wantHeaders()
		if err := st.fr.WriteContinuation(1, true, encodeHeaderNoImplicit(t, "foo", "bar")); err != nil {
			t.Fatal(err)
		}
	})
}
func TestServer_Rejects_HeadersNoEnd_Then_ContinuationWrongStream(t *testing.T) {
	testServerRejectsConn(t, func(st *serverTester) {
		st.writeHeaders(HeadersFrameParam{
			StreamID:      1,
			BlockFragment: st.encodeHeader(),
			EndStream:     true,
			EndHeaders:    false,
		})
		if err := st.fr.WriteContinuation(3, true, encodeHeaderNoImplicit(t, "foo", "bar")); err != nil {
			t.Fatal(err)
		}
	})
}
func TestServer_Rejects_Headers0(t *testing.T) {
	testServerRejectsConn(t, func(st *serverTester) {
		st.fr.AllowIllegalWrites = true
		st.writeHeaders(HeadersFrameParam{
			StreamID:      0,
			BlockFragment: st.encodeHeader(),
			EndStream:     true,
			EndHeaders:    true,
		})
	})
}
func TestServer_Rejects_Continuation0(t *testing.T) {
	testServerRejectsConn(t, func(st *serverTester) {
		st.fr.AllowIllegalWrites = true
		if err := st.fr.WriteContinuation(0, true, st.encodeHeader()); err != nil {
			t.Fatal(err)
		}
	})
}
func TestServer_Rejects_Priority0(t *testing.T) {
	testServerRejectsConn(t, func(st *serverTester) {
		st.fr.AllowIllegalWrites = true
		st.writePriority(0, PriorityParam{StreamDep: 1})
	})
}
func TestServer_Rejects_HeadersSelfDependence(t *testing.T) {
	testServerRejectsStream(t, ErrCodeProtocol, func(st *serverTester) {
		st.fr.AllowIllegalWrites = true
		st.writeHeaders(HeadersFrameParam{
			StreamID:      1,
			BlockFragment: st.encodeHeader(),
			EndStream:     true,
			EndHeaders:    true,
			Priority:      PriorityParam{StreamDep: 1},
		})
	})
}
func TestServer_Rejects_PrioritySelfDependence(t *testing.T) {
	testServerRejectsStream(t, ErrCodeProtocol, func(st *serverTester) {
		st.fr.AllowIllegalWrites = true
		st.writePriority(1, PriorityParam{StreamDep: 1})
	})
}
func TestServer_Rejects_PushPromise(t *testing.T) {
	testServerRejectsConn(t, func(st *serverTester) {
		pp := PushPromiseParam{
			StreamID:  1,
			PromiseID: 3,
		}
		if err := st.fr.WritePushPromise(pp); err != nil {
			t.Fatal(err)
		}
	})
}
func testServerRejectsConn(t *testing.T, writeReq func(*serverTester)) {
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {})
	st.addLogFilter("connection error: PROTOCOL_ERROR")
	defer st.Close()
	st.greet()
	writeReq(st)
	st.wantGoAway()
	errc := make(chan error, 1)
	go func() {
		fr, err := st.fr.ReadFrame()
		if err == nil {
			err = fmt.Errorf("got frame of type %T", fr)
		}
		errc <- err
	}()
	select {
	case err := <-errc:
		if err != io.EOF {
			t.Errorf("ReadFrame = %v; want io.EOF", err)
		}
	case <-time.After(2 * time.Second):
		t.Error("timeout waiting for disconnect")
	}
}
func testServerRejectsStream(t *testing.T, code ErrCode, writeReq func(*serverTester)) {
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {})
	defer st.Close()
	st.greet()
	writeReq(st)
	st.wantRSTStream(1, code)
}
func testServerRequest(t *testing.T, writeReq func(*serverTester), checkReq func(*http.Request)) {
	gotReq := make(chan bool, 1)
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		if r.Body == nil {
			t.Fatal("nil Body")
		}
		checkReq(r)
		gotReq <- true
	})
	defer st.Close()
	st.greet()
	writeReq(st)
	select {
	case <-gotReq:
	case <-time.After(2 * time.Second):
		t.Error("timeout waiting for request")
	}
}
func getSlash(st *serverTester) { st.bodylessReq1() }
func TestServer_Response_NoData(t *testing.T) {
	testServerResponse(t, func(w http.ResponseWriter, r *http.Request) error {
		
		return nil
	}, func(st *serverTester) {
		getSlash(st)
		hf := st.wantHeaders()
		if !hf.StreamEnded() {
			t.Fatal("want END_STREAM flag")
		}
		if !hf.HeadersEnded() {
			t.Fatal("want END_HEADERS flag")
		}
	})
}
func TestServer_Response_NoData_Header_FooBar(t *testing.T) {
	testServerResponse(t, func(w http.ResponseWriter, r *http.Request) error {
		w.Header().Set("Foo-Bar", "some-value")
		return nil
	}, func(st *serverTester) {
		getSlash(st)
		hf := st.wantHeaders()
		if !hf.StreamEnded() {
			t.Fatal("want END_STREAM flag")
		}
		if !hf.HeadersEnded() {
			t.Fatal("want END_HEADERS flag")
		}
		goth := st.decodeHeader(hf.HeaderBlockFragment())
		wanth := [][2]string{
			{":status", "200"},
			{"foo-bar", "some-value"},
			{"content-type", "text
			{"content-length", "0"},
		}
		if !reflect.DeepEqual(goth, wanth) {
			t.Errorf("Got headers %v; want %v", goth, wanth)
		}
	})
}
func TestServer_Response_Data_Sniff_DoesntOverride(t *testing.T) {
	const msg = "<html>this is HTML."
	testServerResponse(t, func(w http.ResponseWriter, r *http.Request) error {
		w.Header().Set("Content-Type", "foo
		io.WriteString(w, msg)
		return nil
	}, func(st *serverTester) {
		getSlash(st)
		hf := st.wantHeaders()
		if hf.StreamEnded() {
			t.Fatal("don't want END_STREAM, expecting data")
		}
		if !hf.HeadersEnded() {
			t.Fatal("want END_HEADERS flag")
		}
		goth := st.decodeHeader(hf.HeaderBlockFragment())
		wanth := [][2]string{
			{":status", "200"},
			{"content-type", "foo
			{"content-length", strconv.Itoa(len(msg))},
		}
		if !reflect.DeepEqual(goth, wanth) {
			t.Errorf("Got headers %v; want %v", goth, wanth)
		}
		df := st.wantData()
		if !df.StreamEnded() {
			t.Error("expected DATA to have END_STREAM flag")
		}
		if got := string(df.Data()); got != msg {
			t.Errorf("got DATA %q; want %q", got, msg)
		}
	})
}
func TestServer_Response_TransferEncoding_chunked(t *testing.T) {
	const msg = "hi"
	testServerResponse(t, func(w http.ResponseWriter, r *http.Request) error {
		w.Header().Set("Transfer-Encoding", "chunked") 
		io.WriteString(w, msg)
		return nil
	}, func(st *serverTester) {
		getSlash(st)
		hf := st.wantHeaders()
		goth := st.decodeHeader(hf.HeaderBlockFragment())
		wanth := [][2]string{
			{":status", "200"},
			{"content-type", "text
			{"content-length", strconv.Itoa(len(msg))},
		}
		if !reflect.DeepEqual(goth, wanth) {
			t.Errorf("Got headers %v; want %v", goth, wanth)
		}
	})
}
func TestServer_Response_Data_IgnoreHeaderAfterWrite_After(t *testing.T) {
	const msg = "<html>this is HTML."
	testServerResponse(t, func(w http.ResponseWriter, r *http.Request) error {
		io.WriteString(w, msg)
		w.Header().Set("foo", "should be ignored")
		return nil
	}, func(st *serverTester) {
		getSlash(st)
		hf := st.wantHeaders()
		if hf.StreamEnded() {
			t.Fatal("unexpected END_STREAM")
		}
		if !hf.HeadersEnded() {
			t.Fatal("want END_HEADERS flag")
		}
		goth := st.decodeHeader(hf.HeaderBlockFragment())
		wanth := [][2]string{
			{":status", "200"},
			{"content-type", "text
			{"content-length", strconv.Itoa(len(msg))},
		}
		if !reflect.DeepEqual(goth, wanth) {
			t.Errorf("Got headers %v; want %v", goth, wanth)
		}
	})
}
func TestServer_Response_Data_IgnoreHeaderAfterWrite_Overwrite(t *testing.T) {
	const msg = "<html>this is HTML."
	testServerResponse(t, func(w http.ResponseWriter, r *http.Request) error {
		w.Header().Set("foo", "proper value")
		io.WriteString(w, msg)
		w.Header().Set("foo", "should be ignored")
		return nil
	}, func(st *serverTester) {
		getSlash(st)
		hf := st.wantHeaders()
		if hf.StreamEnded() {
			t.Fatal("unexpected END_STREAM")
		}
		if !hf.HeadersEnded() {
			t.Fatal("want END_HEADERS flag")
		}
		goth := st.decodeHeader(hf.HeaderBlockFragment())
		wanth := [][2]string{
			{":status", "200"},
			{"foo", "proper value"},
			{"content-type", "text
			{"content-length", strconv.Itoa(len(msg))},
		}
		if !reflect.DeepEqual(goth, wanth) {
			t.Errorf("Got headers %v; want %v", goth, wanth)
		}
	})
}
func TestServer_Response_Data_SniffLenType(t *testing.T) {
	const msg = "<html>this is HTML."
	testServerResponse(t, func(w http.ResponseWriter, r *http.Request) error {
		io.WriteString(w, msg)
		return nil
	}, func(st *serverTester) {
		getSlash(st)
		hf := st.wantHeaders()
		if hf.StreamEnded() {
			t.Fatal("don't want END_STREAM, expecting data")
		}
		if !hf.HeadersEnded() {
			t.Fatal("want END_HEADERS flag")
		}
		goth := st.decodeHeader(hf.HeaderBlockFragment())
		wanth := [][2]string{
			{":status", "200"},
			{"content-type", "text
			{"content-length", strconv.Itoa(len(msg))},
		}
		if !reflect.DeepEqual(goth, wanth) {
			t.Errorf("Got headers %v; want %v", goth, wanth)
		}
		df := st.wantData()
		if !df.StreamEnded() {
			t.Error("expected DATA to have END_STREAM flag")
		}
		if got := string(df.Data()); got != msg {
			t.Errorf("got DATA %q; want %q", got, msg)
		}
	})
}
func TestServer_Response_Header_Flush_MidWrite(t *testing.T) {
	const msg = "<html>this is HTML"
	const msg2 = ", and this is the next chunk"
	testServerResponse(t, func(w http.ResponseWriter, r *http.Request) error {
		io.WriteString(w, msg)
		w.(http.Flusher).Flush()
		io.WriteString(w, msg2)
		return nil
	}, func(st *serverTester) {
		getSlash(st)
		hf := st.wantHeaders()
		if hf.StreamEnded() {
			t.Fatal("unexpected END_STREAM flag")
		}
		if !hf.HeadersEnded() {
			t.Fatal("want END_HEADERS flag")
		}
		goth := st.decodeHeader(hf.HeaderBlockFragment())
		wanth := [][2]string{
			{":status", "200"},
			{"content-type", "text
			
		}
		if !reflect.DeepEqual(goth, wanth) {
			t.Errorf("Got headers %v; want %v", goth, wanth)
		}
		{
			df := st.wantData()
			if df.StreamEnded() {
				t.Error("unexpected END_STREAM flag")
			}
			if got := string(df.Data()); got != msg {
				t.Errorf("got DATA %q; want %q", got, msg)
			}
		}
		{
			df := st.wantData()
			if !df.StreamEnded() {
				t.Error("wanted END_STREAM flag on last data chunk")
			}
			if got := string(df.Data()); got != msg2 {
				t.Errorf("got DATA %q; want %q", got, msg2)
			}
		}
	})
}
func TestServer_Response_LargeWrite(t *testing.T) {
	const size = 1 << 20
	const maxFrameSize = 16 << 10
	testServerResponse(t, func(w http.ResponseWriter, r *http.Request) error {
		n, err := w.Write(bytes.Repeat([]byte("a"), size))
		if err != nil {
			return fmt.Errorf("Write error: %v", err)
		}
		if n != size {
			return fmt.Errorf("wrong size %d from Write", n)
		}
		return nil
	}, func(st *serverTester) {
		if err := st.fr.WriteSettings(
			Setting{SettingInitialWindowSize, 0},
			Setting{SettingMaxFrameSize, maxFrameSize},
		); err != nil {
			t.Fatal(err)
		}
		st.wantSettingsAck()
		getSlash(st) 
		
		if err := st.fr.WriteWindowUpdate(1, size); err != nil {
			t.Fatal(err)
		}
		
		
		if err := st.fr.WriteWindowUpdate(0, size); err != nil {
			t.Fatal(err)
		}
		hf := st.wantHeaders()
		if hf.StreamEnded() {
			t.Fatal("unexpected END_STREAM flag")
		}
		if !hf.HeadersEnded() {
			t.Fatal("want END_HEADERS flag")
		}
		goth := st.decodeHeader(hf.HeaderBlockFragment())
		wanth := [][2]string{
			{":status", "200"},
			{"content-type", "text
			
		}
		if !reflect.DeepEqual(goth, wanth) {
			t.Errorf("Got headers %v; want %v", goth, wanth)
		}
		var bytes, frames int
		for {
			df := st.wantData()
			bytes += len(df.Data())
			frames++
			for _, b := range df.Data() {
				if b != 'a' {
					t.Fatal("non-'a' byte seen in DATA")
				}
			}
			if df.StreamEnded() {
				break
			}
		}
		if bytes != size {
			t.Errorf("Got %d bytes; want %d", bytes, size)
		}
		if want := int(size 
			t.Errorf("Got %d frames; want %d", frames, size)
		}
	})
}
func TestServer_Response_LargeWrite_FlowControlled(t *testing.T) {
	
	
	reads := []int{123, 1, 13, 127}
	size := 0
	for _, n := range reads {
		size += n
	}
	testServerResponse(t, func(w http.ResponseWriter, r *http.Request) error {
		w.(http.Flusher).Flush()
		n, err := w.Write(bytes.Repeat([]byte("a"), size))
		if err != nil {
			return fmt.Errorf("Write error: %v", err)
		}
		if n != size {
			return fmt.Errorf("wrong size %d from Write", n)
		}
		return nil
	}, func(st *serverTester) {
		
		
		if err := st.fr.WriteSettings(Setting{SettingInitialWindowSize, uint32(reads[0])}); err != nil {
			t.Fatal(err)
		}
		st.wantSettingsAck()
		getSlash(st) 
		hf := st.wantHeaders()
		if hf.StreamEnded() {
			t.Fatal("unexpected END_STREAM flag")
		}
		if !hf.HeadersEnded() {
			t.Fatal("want END_HEADERS flag")
		}
		df := st.wantData()
		if got := len(df.Data()); got != reads[0] {
			t.Fatalf("Initial window size = %d but got DATA with %d bytes", reads[0], got)
		}
		for _, quota := range reads[1:] {
			if err := st.fr.WriteWindowUpdate(1, uint32(quota)); err != nil {
				t.Fatal(err)
			}
			df := st.wantData()
			if int(quota) != len(df.Data()) {
				t.Fatalf("read %d bytes after giving %d quota", len(df.Data()), quota)
			}
		}
	})
}
func TestServer_Response_RST_Unblocks_LargeWrite(t *testing.T) {
	const size = 1 << 20
	const maxFrameSize = 16 << 10
	testServerResponse(t, func(w http.ResponseWriter, r *http.Request) error {
		w.(http.Flusher).Flush()
		errc := make(chan error, 1)
		go func() {
			_, err := w.Write(bytes.Repeat([]byte("a"), size))
			errc <- err
		}()
		select {
		case err := <-errc:
			if err == nil {
				return errors.New("unexpected nil error from Write in handler")
			}
			return nil
		case <-time.After(2 * time.Second):
			return errors.New("timeout waiting for Write in handler")
		}
	}, func(st *serverTester) {
		if err := st.fr.WriteSettings(
			Setting{SettingInitialWindowSize, 0},
			Setting{SettingMaxFrameSize, maxFrameSize},
		); err != nil {
			t.Fatal(err)
		}
		st.wantSettingsAck()
		getSlash(st) 
		hf := st.wantHeaders()
		if hf.StreamEnded() {
			t.Fatal("unexpected END_STREAM flag")
		}
		if !hf.HeadersEnded() {
			t.Fatal("want END_HEADERS flag")
		}
		if err := st.fr.WriteRSTStream(1, ErrCodeCancel); err != nil {
			t.Fatal(err)
		}
	})
}
func TestServer_Response_Empty_Data_Not_FlowControlled(t *testing.T) {
	testServerResponse(t, func(w http.ResponseWriter, r *http.Request) error {
		w.(http.Flusher).Flush()
		
		return nil
	}, func(st *serverTester) {
		
		if err := st.fr.WriteSettings(Setting{SettingInitialWindowSize, 0}); err != nil {
			t.Fatal(err)
		}
		st.wantSettingsAck()
		getSlash(st) 
		hf := st.wantHeaders()
		if hf.StreamEnded() {
			t.Fatal("unexpected END_STREAM flag")
		}
		if !hf.HeadersEnded() {
			t.Fatal("want END_HEADERS flag")
		}
		df := st.wantData()
		if got := len(df.Data()); got != 0 {
			t.Fatalf("unexpected %d DATA bytes; want 0", got)
		}
		if !df.StreamEnded() {
			t.Fatal("DATA didn't have END_STREAM")
		}
	})
}
func TestServer_Response_Automatic100Continue(t *testing.T) {
	const msg = "foo"
	const reply = "bar"
	testServerResponse(t, func(w http.ResponseWriter, r *http.Request) error {
		if v := r.Header.Get("Expect"); v != "" {
			t.Errorf("Expect header = %q; want empty", v)
		}
		buf := make([]byte, len(msg))
		
		if n, err := io.ReadFull(r.Body, buf); err != nil || n != len(msg) || string(buf) != msg {
			return fmt.Errorf("ReadFull = %q, %v; want %q, nil", buf[:n], err, msg)
		}
		_, err := io.WriteString(w, reply)
		return err
	}, func(st *serverTester) {
		st.writeHeaders(HeadersFrameParam{
			StreamID:      1, 
			BlockFragment: st.encodeHeader(":method", "POST", "expect", "100-continue"),
			EndStream:     false,
			EndHeaders:    true,
		})
		hf := st.wantHeaders()
		if hf.StreamEnded() {
			t.Fatal("unexpected END_STREAM flag")
		}
		if !hf.HeadersEnded() {
			t.Fatal("want END_HEADERS flag")
		}
		goth := st.decodeHeader(hf.HeaderBlockFragment())
		wanth := [][2]string{
			{":status", "100"},
		}
		if !reflect.DeepEqual(goth, wanth) {
			t.Fatalf("Got headers %v; want %v", goth, wanth)
		}
		
		
		st.writeData(1, true, []byte(msg))
		st.wantWindowUpdate(0, uint32(len(msg)))
		hf = st.wantHeaders()
		if hf.StreamEnded() {
			t.Fatal("expected data to follow")
		}
		if !hf.HeadersEnded() {
			t.Fatal("want END_HEADERS flag")
		}
		goth = st.decodeHeader(hf.HeaderBlockFragment())
		wanth = [][2]string{
			{":status", "200"},
			{"content-type", "text
			{"content-length", strconv.Itoa(len(reply))},
		}
		if !reflect.DeepEqual(goth, wanth) {
			t.Errorf("Got headers %v; want %v", goth, wanth)
		}
		df := st.wantData()
		if string(df.Data()) != reply {
			t.Errorf("Client read %q; want %q", df.Data(), reply)
		}
		if !df.StreamEnded() {
			t.Errorf("expect data stream end")
		}
	})
}
func TestServer_HandlerWriteErrorOnDisconnect(t *testing.T) {
	errc := make(chan error, 1)
	testServerResponse(t, func(w http.ResponseWriter, r *http.Request) error {
		p := []byte("some data.\n")
		for {
			_, err := w.Write(p)
			if err != nil {
				errc <- err
				return nil
			}
		}
	}, func(st *serverTester) {
		st.writeHeaders(HeadersFrameParam{
			StreamID:      1,
			BlockFragment: st.encodeHeader(),
			EndStream:     false,
			EndHeaders:    true,
		})
		hf := st.wantHeaders()
		if hf.StreamEnded() {
			t.Fatal("unexpected END_STREAM flag")
		}
		if !hf.HeadersEnded() {
			t.Fatal("want END_HEADERS flag")
		}
		
		st.cc.Close()
		select {
		case <-errc:
		case <-time.After(5 * time.Second):
			t.Error("timeout")
		}
	})
}
func TestServer_Rejects_Too_Many_Streams(t *testing.T) {
	const testPath = "
	inHandler := make(chan uint32)
	leaveHandler := make(chan bool)
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		id := w.(*responseWriter).rws.stream.id
		inHandler <- id
		if id == 1+(defaultMaxStreams+1)*2 && r.URL.Path != testPath {
			t.Errorf("decoded final path as %q; want %q", r.URL.Path, testPath)
		}
		<-leaveHandler
	})
	defer st.Close()
	st.greet()
	nextStreamID := uint32(1)
	streamID := func() uint32 {
		defer func() { nextStreamID += 2 }()
		return nextStreamID
	}
	sendReq := func(id uint32, headers ...string) {
		st.writeHeaders(HeadersFrameParam{
			StreamID:      id,
			BlockFragment: st.encodeHeader(headers...),
			EndStream:     true,
			EndHeaders:    true,
		})
	}
	for i := 0; i < defaultMaxStreams; i++ {
		sendReq(streamID())
		<-inHandler
	}
	defer func() {
		for i := 0; i < defaultMaxStreams; i++ {
			leaveHandler <- true
		}
	}()
	
	
	
	rejectID := streamID()
	headerBlock := st.encodeHeader(":path", testPath)
	frag1, frag2 := headerBlock[:3], headerBlock[3:]
	st.writeHeaders(HeadersFrameParam{
		StreamID:      rejectID,
		BlockFragment: frag1,
		EndStream:     true,
		EndHeaders:    false, 
	})
	if err := st.fr.WriteContinuation(rejectID, true, frag2); err != nil {
		t.Fatal(err)
	}
	st.wantRSTStream(rejectID, ErrCodeProtocol)
	
	leaveHandler <- true
	st.wantHeaders()
	
	goodID := streamID()
	sendReq(goodID, ":path", testPath)
	select {
	case got := <-inHandler:
		if got != goodID {
			t.Errorf("Got stream %d; want %d", got, goodID)
		}
	case <-time.After(3 * time.Second):
		t.Error("timeout waiting for handler")
	}
}
func TestServer_Response_ManyHeaders_With_Continuation(t *testing.T) {
	testServerResponse(t, func(w http.ResponseWriter, r *http.Request) error {
		h := w.Header()
		for i := 0; i < 5000; i++ {
			h.Set(fmt.Sprintf("x-header-%d", i), fmt.Sprintf("x-value-%d", i))
		}
		return nil
	}, func(st *serverTester) {
		getSlash(st)
		hf := st.wantHeaders()
		if hf.HeadersEnded() {
			t.Fatal("got unwanted END_HEADERS flag")
		}
		n := 0
		for {
			n++
			cf := st.wantContinuation()
			if cf.HeadersEnded() {
				break
			}
		}
		if n < 5 {
			t.Errorf("Only got %d CONTINUATION frames; expected 5+ (currently 6)", n)
		}
	})
}
func TestServer_NoCrash_HandlerClose_Then_ClientClose(t *testing.T) {
	testServerResponse(t, func(w http.ResponseWriter, r *http.Request) error {
		
		return nil
	}, func(st *serverTester) {
		st.writeHeaders(HeadersFrameParam{
			StreamID:      1,
			BlockFragment: st.encodeHeader(),
			EndStream:     false, 
			EndHeaders:    true,
		})
		hf := st.wantHeaders()
		if !hf.HeadersEnded() || !hf.StreamEnded() {
			t.Fatalf("want END_HEADERS+END_STREAM, got %v", hf)
		}
		
		
		st.wantRSTStream(1, ErrCodeNo)
		
		
		
		
		
		st.writeData(1, true, []byte("foo"))
		
		st.wantWindowUpdate(0, uint32(len("foo")))
		
		
		
		
		st.wantRSTStream(1, ErrCodeStreamClosed)
		
		
		var (
			panMu    sync.Mutex
			panicVal interface{}
		)
		testHookOnPanicMu.Lock()
		testHookOnPanic = func(sc *serverConn, pv interface{}) bool {
			panMu.Lock()
			panicVal = pv
			panMu.Unlock()
			return true
		}
		testHookOnPanicMu.Unlock()
		
		st.cc.Close()
		select {
		case <-st.sc.doneServing:
			
			panMu.Lock()
			got := panicVal
			panMu.Unlock()
			if got != nil {
				t.Errorf("Got panic: %v", got)
			}
		case <-time.After(5 * time.Second):
			t.Error("timeout")
		}
	})
}
func TestServer_Rejects_TLS10(t *testing.T) { testRejectTLS(t, tls.VersionTLS10) }
func TestServer_Rejects_TLS11(t *testing.T) { testRejectTLS(t, tls.VersionTLS11) }
func testRejectTLS(t *testing.T, max uint16) {
	st := newServerTester(t, nil, func(c *tls.Config) {
		c.MaxVersion = max
	})
	defer st.Close()
	gf := st.wantGoAway()
	if got, want := gf.ErrCode, ErrCodeInadequateSecurity; got != want {
		t.Errorf("Got error code %v; want %v", got, want)
	}
}
func TestServer_Rejects_TLSBadCipher(t *testing.T) {
	st := newServerTester(t, nil, func(c *tls.Config) {
		
		c.CipherSuites = []uint16{
			tls.TLS_RSA_WITH_RC4_128_SHA,
			tls.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
			tls.TLS_RSA_WITH_AES_128_CBC_SHA,
			tls.TLS_RSA_WITH_AES_256_CBC_SHA,
			tls.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,
			tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
			tls.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
			tls.TLS_ECDHE_RSA_WITH_RC4_128_SHA,
			tls.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,
			tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
			tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
			cipher_TLS_RSA_WITH_AES_128_CBC_SHA256,
		}
	})
	defer st.Close()
	gf := st.wantGoAway()
	if got, want := gf.ErrCode, ErrCodeInadequateSecurity; got != want {
		t.Errorf("Got error code %v; want %v", got, want)
	}
}
func TestServer_Advertises_Common_Cipher(t *testing.T) {
	const requiredSuite = tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
	st := newServerTester(t, nil, func(c *tls.Config) {
		
		c.CipherSuites = []uint16{requiredSuite}
	}, func(ts *httptest.Server) {
		var srv *http.Server = ts.Config
		
		
		srv.TLSConfig = nil
	})
	defer st.Close()
	st.greet()
}
func (st *serverTester) onHeaderField(f hpack.HeaderField) {
	if f.Name == "date" {
		return
	}
	st.decodedHeaders = append(st.decodedHeaders, [2]string{f.Name, f.Value})
}
func (st *serverTester) decodeHeader(headerBlock []byte) (pairs [][2]string) {
	st.decodedHeaders = nil
	if _, err := st.hpackDec.Write(headerBlock); err != nil {
		st.t.Fatalf("hpack decoding error: %v", err)
	}
	if err := st.hpackDec.Close(); err != nil {
		st.t.Fatalf("hpack decoding error: %v", err)
	}
	return st.decodedHeaders
}
func testServerResponse(t testing.TB,
	handler func(http.ResponseWriter, *http.Request) error,
	client func(*serverTester),
) {
	errc := make(chan error, 1)
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		if r.Body == nil {
			t.Fatal("nil Body")
		}
		errc <- handler(w, r)
	})
	defer st.Close()
	donec := make(chan bool)
	go func() {
		defer close(donec)
		st.greet()
		client(st)
	}()
	select {
	case <-donec:
	case <-time.After(5 * time.Second):
		t.Fatal("timeout in client")
	}
	select {
	case err := <-errc:
		if err != nil {
			t.Fatalf("Error in handler: %v", err)
		}
	case <-time.After(2 * time.Second):
		t.Fatal("timeout in handler")
	}
}
func readBodyHandler(t *testing.T, want string) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		buf := make([]byte, len(want))
		_, err := io.ReadFull(r.Body, buf)
		if err != nil {
			t.Error(err)
			return
		}
		if string(buf) != want {
			t.Errorf("read %q; want %q", buf, want)
		}
	}
}
func TestServerWithCurl(t *testing.T)                     { testServerWithCurl(t, false) }
func TestServerWithCurl_LenientCipherSuites(t *testing.T) { testServerWithCurl(t, true) }
func testServerWithCurl(t *testing.T, permitProhibitedCipherSuites bool) {
	if runtime.GOOS != "linux" {
		t.Skip("skipping Docker test when not on Linux; requires --net which won't work with boot2docker anyway")
	}
	if testing.Short() {
		t.Skip("skipping curl test in short mode")
	}
	requireCurl(t)
	var gotConn int32
	testHookOnConn = func() { atomic.StoreInt32(&gotConn, 1) }
	const msg = "Hello from curl!\n"
	ts := httptest.NewUnstartedServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Foo", "Bar")
		w.Header().Set("Client-Proto", r.Proto)
		io.WriteString(w, msg)
	}))
	ConfigureServer(ts.Config, &Server{
		PermitProhibitedCipherSuites: permitProhibitedCipherSuites,
	})
	ts.TLS = ts.Config.TLSConfig 
	ts.StartTLS()
	defer ts.Close()
	t.Logf("Running test server for curl to hit at: %s", ts.URL)
	container := curl(t, "--silent", "--http2", "--insecure", "-v", ts.URL)
	defer kill(container)
	resc := make(chan interface{}, 1)
	go func() {
		res, err := dockerLogs(container)
		if err != nil {
			resc <- err
		} else {
			resc <- res
		}
	}()
	select {
	case res := <-resc:
		if err, ok := res.(error); ok {
			t.Fatal(err)
		}
		body := string(res.([]byte))
		
		
		
		if !strings.Contains(body, "foo: Bar") && !strings.Contains(body, "foo:Bar") {
			t.Errorf("didn't see foo: Bar header")
			t.Logf("Got: %s", body)
		}
		if !strings.Contains(body, "client-proto: HTTP
			t.Errorf("didn't see client-proto: HTTP
			t.Logf("Got: %s", res)
		}
		if !strings.Contains(string(res.([]byte)), msg) {
			t.Errorf("didn't see %q content", msg)
			t.Logf("Got: %s", res)
		}
	case <-time.After(3 * time.Second):
		t.Errorf("timeout waiting for curl")
	}
	if atomic.LoadInt32(&gotConn) == 0 {
		t.Error("never saw an http2 connection")
	}
}
var doh2load = flag.Bool("h2load", false, "Run h2load test")
func TestServerWithH2Load(t *testing.T) {
	if !*doh2load {
		t.Skip("Skipping without --h2load flag.")
	}
	if runtime.GOOS != "linux" {
		t.Skip("skipping Docker test when not on Linux; requires --net which won't work with boot2docker anyway")
	}
	requireH2load(t)
	msg := strings.Repeat("Hello, h2load!\n", 5000)
	ts := httptest.NewUnstartedServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		io.WriteString(w, msg)
		w.(http.Flusher).Flush()
		io.WriteString(w, msg)
	}))
	ts.StartTLS()
	defer ts.Close()
	cmd := exec.Command("docker", "run", "--net=host", "--entrypoint=
		"-n100000", "-c100", "-m100", ts.URL)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		t.Fatal(err)
	}
}
func TestServerDoS_MaxHeaderListSize(t *testing.T) {
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {})
	defer st.Close()
	
	frameSize := defaultMaxReadFrameSize
	var advHeaderListSize *uint32
	st.greetAndCheckSettings(func(s Setting) error {
		switch s.ID {
		case SettingMaxFrameSize:
			if s.Val < minMaxFrameSize {
				frameSize = minMaxFrameSize
			} else if s.Val > maxFrameSize {
				frameSize = maxFrameSize
			} else {
				frameSize = int(s.Val)
			}
		case SettingMaxHeaderListSize:
			advHeaderListSize = &s.Val
		}
		return nil
	})
	if advHeaderListSize == nil {
		t.Errorf("server didn't advertise a max header list size")
	} else if *advHeaderListSize == 0 {
		t.Errorf("server advertised a max header list size of 0")
	}
	st.encodeHeaderField(":method", "GET")
	st.encodeHeaderField(":path", "
	st.encodeHeaderField(":scheme", "https")
	cookie := strings.Repeat("*", 4058)
	st.encodeHeaderField("cookie", cookie)
	st.writeHeaders(HeadersFrameParam{
		StreamID:      1,
		BlockFragment: st.headerBuf.Bytes(),
		EndStream:     true,
		EndHeaders:    false,
	})
	
	
	st.headerBuf.Reset()
	st.encodeHeaderField("cookie", cookie)
	
	const size = 1 << 20
	b := bytes.Repeat(st.headerBuf.Bytes(), size
	for len(b) > 0 {
		chunk := b
		if len(chunk) > frameSize {
			chunk = chunk[:frameSize]
		}
		b = b[len(chunk):]
		st.fr.WriteContinuation(1, len(b) == 0, chunk)
	}
	h := st.wantHeaders()
	if !h.HeadersEnded() {
		t.Fatalf("Got HEADERS without END_HEADERS set: %v", h)
	}
	headers := st.decodeHeader(h.HeaderBlockFragment())
	want := [][2]string{
		{":status", "431"},
		{"content-type", "text
		{"content-length", "63"},
	}
	if !reflect.DeepEqual(headers, want) {
		t.Errorf("Headers mismatch.\n got: %q\nwant: %q\n", headers, want)
	}
}
func TestCompressionErrorOnWrite(t *testing.T) {
	const maxStrLen = 8 << 10
	var serverConfig *http.Server
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		
	}, func(ts *httptest.Server) {
		serverConfig = ts.Config
		serverConfig.MaxHeaderBytes = maxStrLen
	})
	st.addLogFilter("connection error: COMPRESSION_ERROR")
	defer st.Close()
	st.greet()
	maxAllowed := st.sc.framer.maxHeaderStringLen()
	
	
	
	
	
	serverConfig.MaxHeaderBytes = 1 << 20
	
	
	
	
	hbf := st.encodeHeader("foo", strings.Repeat("a", maxAllowed))
	st.writeHeaders(HeadersFrameParam{
		StreamID:      1,
		BlockFragment: hbf,
		EndStream:     true,
		EndHeaders:    true,
	})
	h := st.wantHeaders()
	if !h.HeadersEnded() {
		t.Fatalf("Got HEADERS without END_HEADERS set: %v", h)
	}
	headers := st.decodeHeader(h.HeaderBlockFragment())
	want := [][2]string{
		{":status", "431"},
		{"content-type", "text
		{"content-length", "63"},
	}
	if !reflect.DeepEqual(headers, want) {
		t.Errorf("Headers mismatch.\n got: %q\nwant: %q\n", headers, want)
	}
	df := st.wantData()
	if !strings.Contains(string(df.Data()), "HTTP Error 431") {
		t.Errorf("Unexpected data body: %q", df.Data())
	}
	if !df.StreamEnded() {
		t.Fatalf("expect data stream end")
	}
	
	hbf = st.encodeHeader("bar", strings.Repeat("b", maxAllowed+1))
	st.writeHeaders(HeadersFrameParam{
		StreamID:      3,
		BlockFragment: hbf,
		EndStream:     true,
		EndHeaders:    true,
	})
	ga := st.wantGoAway()
	if ga.ErrCode != ErrCodeCompression {
		t.Errorf("GOAWAY err = %v; want ErrCodeCompression", ga.ErrCode)
	}
}
func TestCompressionErrorOnClose(t *testing.T) {
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		
	})
	st.addLogFilter("connection error: COMPRESSION_ERROR")
	defer st.Close()
	st.greet()
	hbf := st.encodeHeader("foo", "bar")
	hbf = hbf[:len(hbf)-1] 
	st.writeHeaders(HeadersFrameParam{
		StreamID:      1,
		BlockFragment: hbf,
		EndStream:     true,
		EndHeaders:    true,
	})
	ga := st.wantGoAway()
	if ga.ErrCode != ErrCodeCompression {
		t.Errorf("GOAWAY err = %v; want ErrCodeCompression", ga.ErrCode)
	}
}
func TestServerReadsTrailers(t *testing.T) {
	const testBody = "some test body"
	writeReq := func(st *serverTester) {
		st.writeHeaders(HeadersFrameParam{
			StreamID:      1, 
			BlockFragment: st.encodeHeader("trailer", "Foo, Bar", "trailer", "Baz"),
			EndStream:     false,
			EndHeaders:    true,
		})
		st.writeData(1, false, []byte(testBody))
		st.writeHeaders(HeadersFrameParam{
			StreamID: 1, 
			BlockFragment: st.encodeHeaderRaw(
				"foo", "foov",
				"bar", "barv",
				"baz", "bazv",
				"surprise", "wasn't declared; shouldn't show up",
			),
			EndStream:  true,
			EndHeaders: true,
		})
	}
	checkReq := func(r *http.Request) {
		wantTrailer := http.Header{
			"Foo": nil,
			"Bar": nil,
			"Baz": nil,
		}
		if !reflect.DeepEqual(r.Trailer, wantTrailer) {
			t.Errorf("initial Trailer = %v; want %v", r.Trailer, wantTrailer)
		}
		slurp, err := ioutil.ReadAll(r.Body)
		if string(slurp) != testBody {
			t.Errorf("read body %q; want %q", slurp, testBody)
		}
		if err != nil {
			t.Fatalf("Body slurp: %v", err)
		}
		wantTrailerAfter := http.Header{
			"Foo": {"foov"},
			"Bar": {"barv"},
			"Baz": {"bazv"},
		}
		if !reflect.DeepEqual(r.Trailer, wantTrailerAfter) {
			t.Errorf("final Trailer = %v; want %v", r.Trailer, wantTrailerAfter)
		}
	}
	testServerRequest(t, writeReq, checkReq)
}
func TestServerWritesTrailers_WithFlush(t *testing.T)    { testServerWritesTrailers(t, true) }
func TestServerWritesTrailers_WithoutFlush(t *testing.T) { testServerWritesTrailers(t, false) }
func testServerWritesTrailers(t *testing.T, withFlush bool) {
	
	testServerResponse(t, func(w http.ResponseWriter, r *http.Request) error {
		w.Header().Set("Trailer", "Server-Trailer-A, Server-Trailer-B")
		w.Header().Add("Trailer", "Server-Trailer-C")
		w.Header().Add("Trailer", "Transfer-Encoding, Content-Length, Trailer") 
		
		w.Header().Set("Foo", "Bar")
		w.Header().Set("Content-Length", "5") 
		io.WriteString(w, "Hello")
		if withFlush {
			w.(http.Flusher).Flush()
		}
		w.Header().Set("Server-Trailer-A", "valuea")
		w.Header().Set("Server-Trailer-C", "valuec") 
		
		w.Header().Set("Server-Surpise", "surprise! this isn't predeclared!")
		
		
		
		w.Header().Set("Trailer:Post-Header-Trailer", "hi1")
		w.Header().Set("Trailer:post-header-trailer2", "hi2")
		w.Header().Set("Trailer:Range", "invalid")
		w.Header().Set("Trailer:Foo\x01Bogus", "invalid")
		w.Header().Set("Transfer-Encoding", "should not be included; Forbidden by RFC 2616 14.40")
		w.Header().Set("Content-Length", "should not be included; Forbidden by RFC 2616 14.40")
		w.Header().Set("Trailer", "should not be included; Forbidden by RFC 2616 14.40")
		return nil
	}, func(st *serverTester) {
		getSlash(st)
		hf := st.wantHeaders()
		if hf.StreamEnded() {
			t.Fatal("response HEADERS had END_STREAM")
		}
		if !hf.HeadersEnded() {
			t.Fatal("response HEADERS didn't have END_HEADERS")
		}
		goth := st.decodeHeader(hf.HeaderBlockFragment())
		wanth := [][2]string{
			{":status", "200"},
			{"foo", "Bar"},
			{"trailer", "Server-Trailer-A, Server-Trailer-B"},
			{"trailer", "Server-Trailer-C"},
			{"trailer", "Transfer-Encoding, Content-Length, Trailer"},
			{"content-type", "text
			{"content-length", "5"},
		}
		if !reflect.DeepEqual(goth, wanth) {
			t.Errorf("Header mismatch.\n got: %v\nwant: %v", goth, wanth)
		}
		df := st.wantData()
		if string(df.Data()) != "Hello" {
			t.Fatalf("Client read %q; want Hello", df.Data())
		}
		if df.StreamEnded() {
			t.Fatalf("data frame had STREAM_ENDED")
		}
		tf := st.wantHeaders() 
		if !tf.StreamEnded() {
			t.Fatalf("trailers HEADERS lacked END_STREAM")
		}
		if !tf.HeadersEnded() {
			t.Fatalf("trailers HEADERS lacked END_HEADERS")
		}
		wanth = [][2]string{
			{"post-header-trailer", "hi1"},
			{"post-header-trailer2", "hi2"},
			{"server-trailer-a", "valuea"},
			{"server-trailer-c", "valuec"},
		}
		goth = st.decodeHeader(tf.HeaderBlockFragment())
		if !reflect.DeepEqual(goth, wanth) {
			t.Errorf("Header mismatch.\n got: %v\nwant: %v", goth, wanth)
		}
	})
}
func TestServerDoesntWriteInvalidHeaders(t *testing.T) {
	testServerResponse(t, func(w http.ResponseWriter, r *http.Request) error {
		w.Header().Add("OK1", "x")
		w.Header().Add("Bad:Colon", "x") 
		w.Header().Add("Bad1\x00", "x")  
		w.Header().Add("Bad2", "x\x00y") 
		return nil
	}, func(st *serverTester) {
		getSlash(st)
		hf := st.wantHeaders()
		if !hf.StreamEnded() {
			t.Error("response HEADERS lacked END_STREAM")
		}
		if !hf.HeadersEnded() {
			t.Fatal("response HEADERS didn't have END_HEADERS")
		}
		goth := st.decodeHeader(hf.HeaderBlockFragment())
		wanth := [][2]string{
			{":status", "200"},
			{"ok1", "x"},
			{"content-type", "text
			{"content-length", "0"},
		}
		if !reflect.DeepEqual(goth, wanth) {
			t.Errorf("Header mismatch.\n got: %v\nwant: %v", goth, wanth)
		}
	})
}
func BenchmarkServerGets(b *testing.B) {
	defer disableGoroutineTracking()()
	b.ReportAllocs()
	const msg = "Hello, world"
	st := newServerTester(b, func(w http.ResponseWriter, r *http.Request) {
		io.WriteString(w, msg)
	})
	defer st.Close()
	st.greet()
	
	if err := st.fr.WriteWindowUpdate(0, uint32(b.N*len(msg))); err != nil {
		b.Fatal(err)
	}
	for i := 0; i < b.N; i++ {
		id := 1 + uint32(i)*2
		st.writeHeaders(HeadersFrameParam{
			StreamID:      id,
			BlockFragment: st.encodeHeader(),
			EndStream:     true,
			EndHeaders:    true,
		})
		st.wantHeaders()
		df := st.wantData()
		if !df.StreamEnded() {
			b.Fatalf("DATA didn't have END_STREAM; got %v", df)
		}
	}
}
func BenchmarkServerPosts(b *testing.B) {
	defer disableGoroutineTracking()()
	b.ReportAllocs()
	const msg = "Hello, world"
	st := newServerTester(b, func(w http.ResponseWriter, r *http.Request) {
		
		
		
		if n, err := io.Copy(ioutil.Discard, r.Body); n != 0 || err != nil {
			b.Errorf("Copy error; got %v, %v; want 0, nil", n, err)
		}
		io.WriteString(w, msg)
	})
	defer st.Close()
	st.greet()
	
	if err := st.fr.WriteWindowUpdate(0, uint32(b.N*len(msg))); err != nil {
		b.Fatal(err)
	}
	for i := 0; i < b.N; i++ {
		id := 1 + uint32(i)*2
		st.writeHeaders(HeadersFrameParam{
			StreamID:      id,
			BlockFragment: st.encodeHeader(":method", "POST"),
			EndStream:     false,
			EndHeaders:    true,
		})
		st.writeData(id, true, nil)
		st.wantHeaders()
		df := st.wantData()
		if !df.StreamEnded() {
			b.Fatalf("DATA didn't have END_STREAM; got %v", df)
		}
	}
}
func BenchmarkServerToClientStreamDefaultOptions(b *testing.B) {
	benchmarkServerToClientStream(b)
}
func BenchmarkServerToClientStreamReuseFrames(b *testing.B) {
	benchmarkServerToClientStream(b, optFramerReuseFrames)
}
func benchmarkServerToClientStream(b *testing.B, newServerOpts ...interface{}) {
	defer disableGoroutineTracking()()
	b.ReportAllocs()
	const msgLen = 1
	
	const windowSize = 1<<16 - 1
	
	nextMsg := func(i int) []byte {
		msg := make([]byte, msgLen)
		msg[0] = byte(i)
		if len(msg) != msgLen {
			panic("invalid test setup msg length")
		}
		return msg
	}
	st := newServerTester(b, func(w http.ResponseWriter, r *http.Request) {
		
		
		
		if n, err := io.Copy(ioutil.Discard, r.Body); n != 0 || err != nil {
			b.Errorf("Copy error; got %v, %v; want 0, nil", n, err)
		}
		for i := 0; i < b.N; i += 1 {
			w.Write(nextMsg(i))
			w.(http.Flusher).Flush()
		}
	}, newServerOpts...)
	defer st.Close()
	st.greet()
	const id = uint32(1)
	st.writeHeaders(HeadersFrameParam{
		StreamID:      id,
		BlockFragment: st.encodeHeader(":method", "POST"),
		EndStream:     false,
		EndHeaders:    true,
	})
	st.writeData(id, true, nil)
	st.wantHeaders()
	var pendingWindowUpdate = uint32(0)
	for i := 0; i < b.N; i += 1 {
		expected := nextMsg(i)
		df := st.wantData()
		if bytes.Compare(expected, df.data) != 0 {
			b.Fatalf("Bad message received; want %v; got %v", expected, df.data)
		}
		
		pendingWindowUpdate += uint32(len(df.data))
		if pendingWindowUpdate >= windowSize
			if err := st.fr.WriteWindowUpdate(0, pendingWindowUpdate); err != nil {
				b.Fatal(err)
			}
			if err := st.fr.WriteWindowUpdate(id, pendingWindowUpdate); err != nil {
				b.Fatal(err)
			}
			pendingWindowUpdate = 0
		}
	}
	df := st.wantData()
	if !df.StreamEnded() {
		b.Fatalf("DATA didn't have END_STREAM; got %v", df)
	}
}
func TestIssue53(t *testing.T) {
	const data = "PRI * HTTP
		"\r\n\r\n\x00\x00\x00\x01\ainfinfin\ad"
	s := &http.Server{
		ErrorLog: log.New(io.MultiWriter(stderrv(), twriter{t: t}), "", log.LstdFlags),
		Handler: http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
			w.Write([]byte("hello"))
		}),
	}
	s2 := &Server{
		MaxReadFrameSize:             1 << 16,
		PermitProhibitedCipherSuites: true,
	}
	c := &issue53Conn{[]byte(data), false, false}
	s2.ServeConn(c, &ServeConnOpts{BaseConfig: s})
	if !c.closed {
		t.Fatal("connection is not closed")
	}
}
type issue53Conn struct {
	data    []byte
	closed  bool
	written bool
}
func (c *issue53Conn) Read(b []byte) (n int, err error) {
	if len(c.data) == 0 {
		return 0, io.EOF
	}
	n = copy(b, c.data)
	c.data = c.data[n:]
	return
}
func (c *issue53Conn) Write(b []byte) (n int, err error) {
	c.written = true
	return len(b), nil
}
func (c *issue53Conn) Close() error {
	c.closed = true
	return nil
}
func (c *issue53Conn) LocalAddr() net.Addr {
	return &net.TCPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 49706}
}
func (c *issue53Conn) RemoteAddr() net.Addr {
	return &net.TCPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 49706}
}
func (c *issue53Conn) SetDeadline(t time.Time) error      { return nil }
func (c *issue53Conn) SetReadDeadline(t time.Time) error  { return nil }
func (c *issue53Conn) SetWriteDeadline(t time.Time) error { return nil }
func TestConfigureServer(t *testing.T) {
	tests := []struct {
		name      string
		tlsConfig *tls.Config
		wantErr   string
	}{
		{
			name: "empty server",
		},
		{
			name: "just the required cipher suite",
			tlsConfig: &tls.Config{
				CipherSuites: []uint16{tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256},
			},
		},
		{
			name: "missing required cipher suite",
			tlsConfig: &tls.Config{
				CipherSuites: []uint16{tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384},
			},
			wantErr: "is missing HTTP
		},
		{
			name: "required after bad",
			tlsConfig: &tls.Config{
				CipherSuites: []uint16{tls.TLS_RSA_WITH_RC4_128_SHA, tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256},
			},
			wantErr: "contains an HTTP
		},
		{
			name: "bad after required",
			tlsConfig: &tls.Config{
				CipherSuites: []uint16{tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, tls.TLS_RSA_WITH_RC4_128_SHA},
			},
		},
	}
	for _, tt := range tests {
		srv := &http.Server{TLSConfig: tt.tlsConfig}
		err := ConfigureServer(srv, nil)
		if (err != nil) != (tt.wantErr != "") {
			if tt.wantErr != "" {
				t.Errorf("%s: success, but want error", tt.name)
			} else {
				t.Errorf("%s: unexpected error: %v", tt.name, err)
			}
		}
		if err != nil && tt.wantErr != "" && !strings.Contains(err.Error(), tt.wantErr) {
			t.Errorf("%s: err = %v; want substring %q", tt.name, err, tt.wantErr)
		}
		if err == nil && !srv.TLSConfig.PreferServerCipherSuites {
			t.Errorf("%s: PreferServerCipherSuite is false; want true", tt.name)
		}
	}
}
func TestServerRejectHeadWithBody(t *testing.T) {
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		
	})
	defer st.Close()
	st.greet()
	st.writeHeaders(HeadersFrameParam{
		StreamID:      1, 
		BlockFragment: st.encodeHeader(":method", "HEAD"),
		EndStream:     false, 
		EndHeaders:    true,
	})
	st.wantRSTStream(1, ErrCodeProtocol)
}
func TestServerNoAutoContentLengthOnHead(t *testing.T) {
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		
	})
	defer st.Close()
	st.greet()
	st.writeHeaders(HeadersFrameParam{
		StreamID:      1, 
		BlockFragment: st.encodeHeader(":method", "HEAD"),
		EndStream:     true,
		EndHeaders:    true,
	})
	h := st.wantHeaders()
	headers := st.decodeHeader(h.HeaderBlockFragment())
	want := [][2]string{
		{":status", "200"},
		{"content-type", "text
	}
	if !reflect.DeepEqual(headers, want) {
		t.Errorf("Headers mismatch.\n got: %q\nwant: %q\n", headers, want)
	}
}
func TestServerNoDuplicateContentType(t *testing.T) {
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		w.Header()["Content-Type"] = []string{""}
		fmt.Fprintf(w, "<html><head><
	})
	defer st.Close()
	st.greet()
	st.writeHeaders(HeadersFrameParam{
		StreamID:      1,
		BlockFragment: st.encodeHeader(),
		EndStream:     true,
		EndHeaders:    true,
	})
	h := st.wantHeaders()
	headers := st.decodeHeader(h.HeaderBlockFragment())
	want := [][2]string{
		{":status", "200"},
		{"content-type", ""},
		{"content-length", "41"},
	}
	if !reflect.DeepEqual(headers, want) {
		t.Errorf("Headers mismatch.\n got: %q\nwant: %q\n", headers, want)
	}
}
func disableGoroutineTracking() (restore func()) {
	old := DebugGoroutines
	DebugGoroutines = false
	return func() { DebugGoroutines = old }
}
func BenchmarkServer_GetRequest(b *testing.B) {
	defer disableGoroutineTracking()()
	b.ReportAllocs()
	const msg = "Hello, world."
	st := newServerTester(b, func(w http.ResponseWriter, r *http.Request) {
		n, err := io.Copy(ioutil.Discard, r.Body)
		if err != nil || n > 0 {
			b.Errorf("Read %d bytes, error %v; want 0 bytes.", n, err)
		}
		io.WriteString(w, msg)
	})
	defer st.Close()
	st.greet()
	
	if err := st.fr.WriteWindowUpdate(0, uint32(b.N*len(msg))); err != nil {
		b.Fatal(err)
	}
	hbf := st.encodeHeader(":method", "GET")
	for i := 0; i < b.N; i++ {
		streamID := uint32(1 + 2*i)
		st.writeHeaders(HeadersFrameParam{
			StreamID:      streamID,
			BlockFragment: hbf,
			EndStream:     true,
			EndHeaders:    true,
		})
		st.wantHeaders()
		st.wantData()
	}
}
func BenchmarkServer_PostRequest(b *testing.B) {
	defer disableGoroutineTracking()()
	b.ReportAllocs()
	const msg = "Hello, world."
	st := newServerTester(b, func(w http.ResponseWriter, r *http.Request) {
		n, err := io.Copy(ioutil.Discard, r.Body)
		if err != nil || n > 0 {
			b.Errorf("Read %d bytes, error %v; want 0 bytes.", n, err)
		}
		io.WriteString(w, msg)
	})
	defer st.Close()
	st.greet()
	
	if err := st.fr.WriteWindowUpdate(0, uint32(b.N*len(msg))); err != nil {
		b.Fatal(err)
	}
	hbf := st.encodeHeader(":method", "POST")
	for i := 0; i < b.N; i++ {
		streamID := uint32(1 + 2*i)
		st.writeHeaders(HeadersFrameParam{
			StreamID:      streamID,
			BlockFragment: hbf,
			EndStream:     false,
			EndHeaders:    true,
		})
		st.writeData(streamID, true, nil)
		st.wantHeaders()
		st.wantData()
	}
}
type connStateConn struct {
	net.Conn
	cs tls.ConnectionState
}
func (c connStateConn) ConnectionState() tls.ConnectionState { return c.cs }
func TestServerHandleCustomConn(t *testing.T) {
	var s Server
	c1, c2 := net.Pipe()
	clientDone := make(chan struct{})
	handlerDone := make(chan struct{})
	var req *http.Request
	go func() {
		defer close(clientDone)
		defer c2.Close()
		fr := NewFramer(c2, c2)
		io.WriteString(c2, ClientPreface)
		fr.WriteSettings()
		fr.WriteSettingsAck()
		f, err := fr.ReadFrame()
		if err != nil {
			t.Error(err)
			return
		}
		if sf, ok := f.(*SettingsFrame); !ok || sf.IsAck() {
			t.Errorf("Got %v; want non-ACK SettingsFrame", summarizeFrame(f))
			return
		}
		f, err = fr.ReadFrame()
		if err != nil {
			t.Error(err)
			return
		}
		if sf, ok := f.(*SettingsFrame); !ok || !sf.IsAck() {
			t.Errorf("Got %v; want ACK SettingsFrame", summarizeFrame(f))
			return
		}
		var henc hpackEncoder
		fr.WriteHeaders(HeadersFrameParam{
			StreamID:      1,
			BlockFragment: henc.encodeHeaderRaw(t, ":method", "GET", ":path", "
			EndStream:     true,
			EndHeaders:    true,
		})
		go io.Copy(ioutil.Discard, c2)
		<-handlerDone
	}()
	const testString = "my custom ConnectionState"
	fakeConnState := tls.ConnectionState{
		ServerName:  testString,
		Version:     tls.VersionTLS12,
		CipherSuite: cipher_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
	}
	go s.ServeConn(connStateConn{c1, fakeConnState}, &ServeConnOpts{
		BaseConfig: &http.Server{
			Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				defer close(handlerDone)
				req = r
			}),
		}})
	select {
	case <-clientDone:
	case <-time.After(5 * time.Second):
		t.Fatal("timeout waiting for handler")
	}
	if req.TLS == nil {
		t.Fatalf("Request.TLS is nil. Got: %#v", req)
	}
	if req.TLS.ServerName != testString {
		t.Fatalf("Request.TLS = %+v; want ServerName of %q", req.TLS, testString)
	}
}
func TestServer_Rejects_ConnHeaders(t *testing.T) {
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		t.Error("should not get to Handler")
	})
	defer st.Close()
	st.greet()
	st.bodylessReq1("connection", "foo")
	hf := st.wantHeaders()
	goth := st.decodeHeader(hf.HeaderBlockFragment())
	wanth := [][2]string{
		{":status", "400"},
		{"content-type", "text
		{"x-content-type-options", "nosniff"},
		{"content-length", "51"},
	}
	if !reflect.DeepEqual(goth, wanth) {
		t.Errorf("Got headers %v; want %v", goth, wanth)
	}
}
type hpackEncoder struct {
	enc *hpack.Encoder
	buf bytes.Buffer
}
func (he *hpackEncoder) encodeHeaderRaw(t *testing.T, headers ...string) []byte {
	if len(headers)%2 == 1 {
		panic("odd number of kv args")
	}
	he.buf.Reset()
	if he.enc == nil {
		he.enc = hpack.NewEncoder(&he.buf)
	}
	for len(headers) > 0 {
		k, v := headers[0], headers[1]
		err := he.enc.WriteField(hpack.HeaderField{Name: k, Value: v})
		if err != nil {
			t.Fatalf("HPACK encoding error for %q
		}
		headers = headers[2:]
	}
	return he.buf.Bytes()
}
func TestCheckValidHTTP2Request(t *testing.T) {
	tests := []struct {
		h    http.Header
		want error
	}{
		{
			h:    http.Header{"Te": {"trailers"}},
			want: nil,
		},
		{
			h:    http.Header{"Te": {"trailers", "bogus"}},
			want: errors.New(`request header "TE" may only be "trailers" in HTTP
		},
		{
			h:    http.Header{"Foo": {""}},
			want: nil,
		},
		{
			h:    http.Header{"Connection": {""}},
			want: errors.New(`request header "Connection" is not valid in HTTP
		},
		{
			h:    http.Header{"Proxy-Connection": {""}},
			want: errors.New(`request header "Proxy-Connection" is not valid in HTTP
		},
		{
			h:    http.Header{"Keep-Alive": {""}},
			want: errors.New(`request header "Keep-Alive" is not valid in HTTP
		},
		{
			h:    http.Header{"Upgrade": {""}},
			want: errors.New(`request header "Upgrade" is not valid in HTTP
		},
	}
	for i, tt := range tests {
		got := checkValidHTTP2RequestHeaders(tt.h)
		if !reflect.DeepEqual(got, tt.want) {
			t.Errorf("%d. checkValidHTTP2Request = %v; want %v", i, got, tt.want)
		}
	}
}
func TestExpect100ContinueAfterHandlerWrites(t *testing.T) {
	const msg = "Hello"
	const msg2 = "World"
	doRead := make(chan bool, 1)
	defer close(doRead) 
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		io.WriteString(w, msg)
		w.(http.Flusher).Flush()
		
		<-doRead
		r.Body.Read(make([]byte, 10))
		io.WriteString(w, msg2)
	}, optOnlyServer)
	defer st.Close()
	tr := &Transport{TLSClientConfig: tlsConfigInsecure}
	defer tr.CloseIdleConnections()
	req, _ := http.NewRequest("POST", st.ts.URL, io.LimitReader(neverEnding('A'), 2<<20))
	req.Header.Set("Expect", "100-continue")
	res, err := tr.RoundTrip(req)
	if err != nil {
		t.Fatal(err)
	}
	defer res.Body.Close()
	buf := make([]byte, len(msg))
	if _, err := io.ReadFull(res.Body, buf); err != nil {
		t.Fatal(err)
	}
	if string(buf) != msg {
		t.Fatalf("msg = %q; want %q", buf, msg)
	}
	doRead <- true
	if _, err := io.ReadFull(res.Body, buf); err != nil {
		t.Fatal(err)
	}
	if string(buf) != msg2 {
		t.Fatalf("second msg = %q; want %q", buf, msg2)
	}
}
type funcReader func([]byte) (n int, err error)
func (f funcReader) Read(p []byte) (n int, err error) { return f(p) }
func TestUnreadFlowControlReturned_Server(t *testing.T) {
	unblock := make(chan bool, 1)
	defer close(unblock)
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		
		
		
		<-unblock
	}, optOnlyServer)
	defer st.Close()
	tr := &Transport{TLSClientConfig: tlsConfigInsecure}
	defer tr.CloseIdleConnections()
	
	for i := 0; i < 6; i++ {
		body := io.MultiReader(
			io.LimitReader(neverEnding('A'), 16<<10),
			funcReader(func([]byte) (n int, err error) {
				unblock <- true
				return 0, io.EOF
			}),
		)
		req, _ := http.NewRequest("POST", st.ts.URL, body)
		res, err := tr.RoundTrip(req)
		if err != nil {
			t.Fatal(err)
		}
		res.Body.Close()
	}
}
func TestServerIdleTimeout(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping in short mode")
	}
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
	}, func(h2s *Server) {
		h2s.IdleTimeout = 500 * time.Millisecond
	})
	defer st.Close()
	st.greet()
	ga := st.wantGoAway()
	if ga.ErrCode != ErrCodeNo {
		t.Errorf("GOAWAY error = %v; want ErrCodeNo", ga.ErrCode)
	}
}
func TestServerIdleTimeout_AfterRequest(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping in short mode")
	}
	const timeout = 250 * time.Millisecond
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		time.Sleep(timeout * 2)
	}, func(h2s *Server) {
		h2s.IdleTimeout = timeout
	})
	defer st.Close()
	st.greet()
	
	
	st.bodylessReq1()
	st.wantHeaders()
	
	
	ga := st.wantGoAway()
	if ga.ErrCode != ErrCodeNo {
		t.Errorf("GOAWAY error = %v; want ErrCodeNo", ga.ErrCode)
	}
}
func TestRequestBodyReadCloseRace(t *testing.T) {
	for i := 0; i < 100; i++ {
		body := &requestBody{
			pipe: &pipe{
				b: new(bytes.Buffer),
			},
		}
		body.pipe.CloseWithError(io.EOF)
		done := make(chan bool, 1)
		buf := make([]byte, 10)
		go func() {
			time.Sleep(1 * time.Millisecond)
			body.Close()
			done <- true
		}()
		body.Read(buf)
		<-done
	}
}
func TestIssue20704Race(t *testing.T) {
	if testing.Short() && os.Getenv("GO_BUILDER_NAME") == "" {
		t.Skip("skipping in short mode")
	}
	const (
		itemSize  = 1 << 10
		itemCount = 100
	)
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		for i := 0; i < itemCount; i++ {
			_, err := w.Write(make([]byte, itemSize))
			if err != nil {
				return
			}
		}
	}, optOnlyServer)
	defer st.Close()
	tr := &Transport{TLSClientConfig: tlsConfigInsecure}
	defer tr.CloseIdleConnections()
	cl := &http.Client{Transport: tr}
	for i := 0; i < 1000; i++ {
		resp, err := cl.Get(st.ts.URL)
		if err != nil {
			t.Fatal(err)
		}
		
		
		resp.Body.Close()
	}
}
package http2
import "testing"
func TestFlow(t *testing.T) {
	var st flow
	var conn flow
	st.add(3)
	conn.add(2)
	if got, want := st.available(), int32(3); got != want {
		t.Errorf("available = %d; want %d", got, want)
	}
	st.setConnFlow(&conn)
	if got, want := st.available(), int32(2); got != want {
		t.Errorf("after parent setup, available = %d; want %d", got, want)
	}
	st.take(2)
	if got, want := conn.available(), int32(0); got != want {
		t.Errorf("after taking 2, conn = %d; want %d", got, want)
	}
	if got, want := st.available(), int32(0); got != want {
		t.Errorf("after taking 2, stream = %d; want %d", got, want)
	}
}
func TestFlowAdd(t *testing.T) {
	var f flow
	if !f.add(1) {
		t.Fatal("failed to add 1")
	}
	if !f.add(-1) {
		t.Fatal("failed to add -1")
	}
	if got, want := f.available(), int32(0); got != want {
		t.Fatalf("size = %d; want %d", got, want)
	}
	if !f.add(1<<31 - 1) {
		t.Fatal("failed to add 2^31-1")
	}
	if got, want := f.available(), int32(1<<31-1); got != want {
		t.Fatalf("size = %d; want %d", got, want)
	}
	if f.add(1) {
		t.Fatal("adding 1 to max shouldn't be allowed")
	}
}
package http2
import "testing"
func TestIsBadCipherBad(t *testing.T) {
	for _, c := range badCiphers {
		if !isBadCipher(c) {
			t.Errorf("Wrong result for isBadCipher(%d), want true", c)
		}
	}
}
func TestIsBadCipherGood(t *testing.T) {
	goodCiphers := map[uint16]string{
		cipher_TLS_DHE_RSA_WITH_AES_256_CCM:                "cipher_TLS_DHE_RSA_WITH_AES_256_CCM",
		cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM:            "cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM",
		cipher_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256: "cipher_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256",
	}
	for c, name := range goodCiphers {
		if isBadCipher(c) {
			t.Errorf("Wrong result for isBadCipher(%d) %s, want false", c, name)
		}
	}
}
var badCiphers = []uint16{
	cipher_TLS_NULL_WITH_NULL_NULL,
	cipher_TLS_RSA_WITH_NULL_MD5,
	cipher_TLS_RSA_WITH_NULL_SHA,
	cipher_TLS_RSA_EXPORT_WITH_RC4_40_MD5,
	cipher_TLS_RSA_WITH_RC4_128_MD5,
	cipher_TLS_RSA_WITH_RC4_128_SHA,
	cipher_TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5,
	cipher_TLS_RSA_WITH_IDEA_CBC_SHA,
	cipher_TLS_RSA_EXPORT_WITH_DES40_CBC_SHA,
	cipher_TLS_RSA_WITH_DES_CBC_SHA,
	cipher_TLS_RSA_WITH_3DES_EDE_CBC_SHA,
	cipher_TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA,
	cipher_TLS_DH_DSS_WITH_DES_CBC_SHA,
	cipher_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA,
	cipher_TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA,
	cipher_TLS_DH_RSA_WITH_DES_CBC_SHA,
	cipher_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA,
	cipher_TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA,
	cipher_TLS_DHE_DSS_WITH_DES_CBC_SHA,
	cipher_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA,
	cipher_TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA,
	cipher_TLS_DHE_RSA_WITH_DES_CBC_SHA,
	cipher_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA,
	cipher_TLS_DH_anon_EXPORT_WITH_RC4_40_MD5,
	cipher_TLS_DH_anon_WITH_RC4_128_MD5,
	cipher_TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA,
	cipher_TLS_DH_anon_WITH_DES_CBC_SHA,
	cipher_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA,
	cipher_TLS_KRB5_WITH_DES_CBC_SHA,
	cipher_TLS_KRB5_WITH_3DES_EDE_CBC_SHA,
	cipher_TLS_KRB5_WITH_RC4_128_SHA,
	cipher_TLS_KRB5_WITH_IDEA_CBC_SHA,
	cipher_TLS_KRB5_WITH_DES_CBC_MD5,
	cipher_TLS_KRB5_WITH_3DES_EDE_CBC_MD5,
	cipher_TLS_KRB5_WITH_RC4_128_MD5,
	cipher_TLS_KRB5_WITH_IDEA_CBC_MD5,
	cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA,
	cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA,
	cipher_TLS_KRB5_EXPORT_WITH_RC4_40_SHA,
	cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5,
	cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5,
	cipher_TLS_KRB5_EXPORT_WITH_RC4_40_MD5,
	cipher_TLS_PSK_WITH_NULL_SHA,
	cipher_TLS_DHE_PSK_WITH_NULL_SHA,
	cipher_TLS_RSA_PSK_WITH_NULL_SHA,
	cipher_TLS_RSA_WITH_AES_128_CBC_SHA,
	cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA,
	cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA,
	cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA,
	cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
	cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA,
	cipher_TLS_RSA_WITH_AES_256_CBC_SHA,
	cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA,
	cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA,
	cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA,
	cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
	cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA,
	cipher_TLS_RSA_WITH_NULL_SHA256,
	cipher_TLS_RSA_WITH_AES_128_CBC_SHA256,
	cipher_TLS_RSA_WITH_AES_256_CBC_SHA256,
	cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA256,
	cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA256,
	cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256,
	cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA,
	cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA,
	cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA,
	cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA,
	cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA,
	cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA,
	cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,
	cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA256,
	cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA256,
	cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256,
	cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256,
	cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA256,
	cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA256,
	cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA,
	cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA,
	cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA,
	cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA,
	cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA,
	cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA,
	cipher_TLS_PSK_WITH_RC4_128_SHA,
	cipher_TLS_PSK_WITH_3DES_EDE_CBC_SHA,
	cipher_TLS_PSK_WITH_AES_128_CBC_SHA,
	cipher_TLS_PSK_WITH_AES_256_CBC_SHA,
	cipher_TLS_DHE_PSK_WITH_RC4_128_SHA,
	cipher_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA,
	cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA,
	cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA,
	cipher_TLS_RSA_PSK_WITH_RC4_128_SHA,
	cipher_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA,
	cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA,
	cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA,
	cipher_TLS_RSA_WITH_SEED_CBC_SHA,
	cipher_TLS_DH_DSS_WITH_SEED_CBC_SHA,
	cipher_TLS_DH_RSA_WITH_SEED_CBC_SHA,
	cipher_TLS_DHE_DSS_WITH_SEED_CBC_SHA,
	cipher_TLS_DHE_RSA_WITH_SEED_CBC_SHA,
	cipher_TLS_DH_anon_WITH_SEED_CBC_SHA,
	cipher_TLS_RSA_WITH_AES_128_GCM_SHA256,
	cipher_TLS_RSA_WITH_AES_256_GCM_SHA384,
	cipher_TLS_DH_RSA_WITH_AES_128_GCM_SHA256,
	cipher_TLS_DH_RSA_WITH_AES_256_GCM_SHA384,
	cipher_TLS_DH_DSS_WITH_AES_128_GCM_SHA256,
	cipher_TLS_DH_DSS_WITH_AES_256_GCM_SHA384,
	cipher_TLS_DH_anon_WITH_AES_128_GCM_SHA256,
	cipher_TLS_DH_anon_WITH_AES_256_GCM_SHA384,
	cipher_TLS_PSK_WITH_AES_128_GCM_SHA256,
	cipher_TLS_PSK_WITH_AES_256_GCM_SHA384,
	cipher_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256,
	cipher_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384,
	cipher_TLS_PSK_WITH_AES_128_CBC_SHA256,
	cipher_TLS_PSK_WITH_AES_256_CBC_SHA384,
	cipher_TLS_PSK_WITH_NULL_SHA256,
	cipher_TLS_PSK_WITH_NULL_SHA384,
	cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256,
	cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384,
	cipher_TLS_DHE_PSK_WITH_NULL_SHA256,
	cipher_TLS_DHE_PSK_WITH_NULL_SHA384,
	cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256,
	cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384,
	cipher_TLS_RSA_PSK_WITH_NULL_SHA256,
	cipher_TLS_RSA_PSK_WITH_NULL_SHA384,
	cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256,
	cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256,
	cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256,
	cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256,
	cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256,
	cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256,
	cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256,
	cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256,
	cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256,
	cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256,
	cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256,
	cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256,
	cipher_TLS_EMPTY_RENEGOTIATION_INFO_SCSV,
	cipher_TLS_ECDH_ECDSA_WITH_NULL_SHA,
	cipher_TLS_ECDH_ECDSA_WITH_RC4_128_SHA,
	cipher_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA,
	cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA,
	cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA,
	cipher_TLS_ECDHE_ECDSA_WITH_NULL_SHA,
	cipher_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,
	cipher_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA,
	cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
	cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
	cipher_TLS_ECDH_RSA_WITH_NULL_SHA,
	cipher_TLS_ECDH_RSA_WITH_RC4_128_SHA,
	cipher_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA,
	cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA,
	cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA,
	cipher_TLS_ECDHE_RSA_WITH_NULL_SHA,
	cipher_TLS_ECDHE_RSA_WITH_RC4_128_SHA,
	cipher_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,
	cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
	cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
	cipher_TLS_ECDH_anon_WITH_NULL_SHA,
	cipher_TLS_ECDH_anon_WITH_RC4_128_SHA,
	cipher_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA,
	cipher_TLS_ECDH_anon_WITH_AES_128_CBC_SHA,
	cipher_TLS_ECDH_anon_WITH_AES_256_CBC_SHA,
	cipher_TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA,
	cipher_TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA,
	cipher_TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA,
	cipher_TLS_SRP_SHA_WITH_AES_128_CBC_SHA,
	cipher_TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA,
	cipher_TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA,
	cipher_TLS_SRP_SHA_WITH_AES_256_CBC_SHA,
	cipher_TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA,
	cipher_TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA,
	cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,
	cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,
	cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256,
	cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384,
	cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,
	cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,
	cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256,
	cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384,
	cipher_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256,
	cipher_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384,
	cipher_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256,
	cipher_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384,
	cipher_TLS_ECDHE_PSK_WITH_RC4_128_SHA,
	cipher_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA,
	cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA,
	cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA,
	cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256,
	cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384,
	cipher_TLS_ECDHE_PSK_WITH_NULL_SHA,
	cipher_TLS_ECDHE_PSK_WITH_NULL_SHA256,
	cipher_TLS_ECDHE_PSK_WITH_NULL_SHA384,
	cipher_TLS_RSA_WITH_ARIA_128_CBC_SHA256,
	cipher_TLS_RSA_WITH_ARIA_256_CBC_SHA384,
	cipher_TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256,
	cipher_TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384,
	cipher_TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256,
	cipher_TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384,
	cipher_TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256,
	cipher_TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384,
	cipher_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256,
	cipher_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384,
	cipher_TLS_DH_anon_WITH_ARIA_128_CBC_SHA256,
	cipher_TLS_DH_anon_WITH_ARIA_256_CBC_SHA384,
	cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256,
	cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384,
	cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256,
	cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384,
	cipher_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256,
	cipher_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384,
	cipher_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256,
	cipher_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384,
	cipher_TLS_RSA_WITH_ARIA_128_GCM_SHA256,
	cipher_TLS_RSA_WITH_ARIA_256_GCM_SHA384,
	cipher_TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256,
	cipher_TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384,
	cipher_TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256,
	cipher_TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384,
	cipher_TLS_DH_anon_WITH_ARIA_128_GCM_SHA256,
	cipher_TLS_DH_anon_WITH_ARIA_256_GCM_SHA384,
	cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256,
	cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384,
	cipher_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256,
	cipher_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384,
	cipher_TLS_PSK_WITH_ARIA_128_CBC_SHA256,
	cipher_TLS_PSK_WITH_ARIA_256_CBC_SHA384,
	cipher_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256,
	cipher_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384,
	cipher_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256,
	cipher_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384,
	cipher_TLS_PSK_WITH_ARIA_128_GCM_SHA256,
	cipher_TLS_PSK_WITH_ARIA_256_GCM_SHA384,
	cipher_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256,
	cipher_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384,
	cipher_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256,
	cipher_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384,
	cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256,
	cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384,
	cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256,
	cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384,
	cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256,
	cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384,
	cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256,
	cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384,
	cipher_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256,
	cipher_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384,
	cipher_TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256,
	cipher_TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384,
	cipher_TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256,
	cipher_TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384,
	cipher_TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256,
	cipher_TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384,
	cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256,
	cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384,
	cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256,
	cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384,
	cipher_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256,
	cipher_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384,
	cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256,
	cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384,
	cipher_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256,
	cipher_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384,
	cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256,
	cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384,
	cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256,
	cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384,
	cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256,
	cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384,
	cipher_TLS_RSA_WITH_AES_128_CCM,
	cipher_TLS_RSA_WITH_AES_256_CCM,
	cipher_TLS_RSA_WITH_AES_128_CCM_8,
	cipher_TLS_RSA_WITH_AES_256_CCM_8,
	cipher_TLS_PSK_WITH_AES_128_CCM,
	cipher_TLS_PSK_WITH_AES_256_CCM,
	cipher_TLS_PSK_WITH_AES_128_CCM_8,
	cipher_TLS_PSK_WITH_AES_256_CCM_8,
}
package http2
import (
	"errors"
	"fmt"
	"io"
	"io
	"net
	"reflect"
	"strconv"
	"sync"
	"testing"
	"time"
)
func TestServer_Push_Success(t *testing.T) {
	const (
		mainBody   = "<html>index page<
		pushedBody = "<html>pushed page<
		userAgent  = "testagent"
		cookie     = "testcookie"
	)
	var stURL string
	checkPromisedReq := func(r *http.Request, wantMethod string, wantH http.Header) error {
		if got, want := r.Method, wantMethod; got != want {
			return fmt.Errorf("promised Req.Method=%q, want %q", got, want)
		}
		if got, want := r.Header, wantH; !reflect.DeepEqual(got, want) {
			return fmt.Errorf("promised Req.Header=%q, want %q", got, want)
		}
		if got, want := "https:
			return fmt.Errorf("promised Req.Host=%q, want %q", got, want)
		}
		if r.Body == nil {
			return fmt.Errorf("nil Body")
		}
		if buf, err := ioutil.ReadAll(r.Body); err != nil || len(buf) != 0 {
			return fmt.Errorf("ReadAll(Body)=%q,%v, want '',nil", buf, err)
		}
		return nil
	}
	errc := make(chan error, 3)
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.RequestURI() {
		case "
			
			opt := &http.PushOptions{
				Header: http.Header{
					"User-Agent": {userAgent},
				},
			}
			if err := w.(http.Pusher).Push(stURL+"
				errc <- fmt.Errorf("error pushing 
				return
			}
			
			opt = &http.PushOptions{
				Method: "HEAD",
				Header: http.Header{
					"User-Agent": {userAgent},
					"Cookie":     {cookie},
				},
			}
			if err := w.(http.Pusher).Push("
				errc <- fmt.Errorf("error pushing 
				return
			}
			w.Header().Set("Content-Type", "text
			w.Header().Set("Content-Length", strconv.Itoa(len(mainBody)))
			w.WriteHeader(200)
			io.WriteString(w, mainBody)
			errc <- nil
		case "
			wantH := http.Header{}
			wantH.Set("User-Agent", userAgent)
			if err := checkPromisedReq(r, "GET", wantH); err != nil {
				errc <- fmt.Errorf("
				return
			}
			w.Header().Set("Content-Type", "text
			w.Header().Set("Content-Length", strconv.Itoa(len(pushedBody)))
			w.WriteHeader(200)
			io.WriteString(w, pushedBody)
			errc <- nil
		case "
			wantH := http.Header{}
			wantH.Set("User-Agent", userAgent)
			wantH.Set("Cookie", cookie)
			if err := checkPromisedReq(r, "HEAD", wantH); err != nil {
				errc <- fmt.Errorf("
				return
			}
			w.WriteHeader(204)
			errc <- nil
		default:
			errc <- fmt.Errorf("unknown RequestURL %q", r.URL.RequestURI())
		}
	})
	stURL = st.ts.URL
	
	st.greet()
	getSlash(st)
	for k := 0; k < 3; k++ {
		select {
		case <-time.After(2 * time.Second):
			t.Errorf("timeout waiting for handler %d to finish", k)
		case err := <-errc:
			if err != nil {
				t.Fatal(err)
			}
		}
	}
	checkPushPromise := func(f Frame, promiseID uint32, wantH [][2]string) error {
		pp, ok := f.(*PushPromiseFrame)
		if !ok {
			return fmt.Errorf("got a %T; want *PushPromiseFrame", f)
		}
		if !pp.HeadersEnded() {
			return fmt.Errorf("want END_HEADERS flag in PushPromiseFrame")
		}
		if got, want := pp.PromiseID, promiseID; got != want {
			return fmt.Errorf("got PromiseID %v; want %v", got, want)
		}
		gotH := st.decodeHeader(pp.HeaderBlockFragment())
		if !reflect.DeepEqual(gotH, wantH) {
			return fmt.Errorf("got promised headers %v; want %v", gotH, wantH)
		}
		return nil
	}
	checkHeaders := func(f Frame, wantH [][2]string) error {
		hf, ok := f.(*HeadersFrame)
		if !ok {
			return fmt.Errorf("got a %T; want *HeadersFrame", f)
		}
		gotH := st.decodeHeader(hf.HeaderBlockFragment())
		if !reflect.DeepEqual(gotH, wantH) {
			return fmt.Errorf("got response headers %v; want %v", gotH, wantH)
		}
		return nil
	}
	checkData := func(f Frame, wantData string) error {
		df, ok := f.(*DataFrame)
		if !ok {
			return fmt.Errorf("got a %T; want *DataFrame", f)
		}
		if gotData := string(df.Data()); gotData != wantData {
			return fmt.Errorf("got response data %q; want %q", gotData, wantData)
		}
		return nil
	}
	
	
	
	expected := map[uint32][]func(Frame) error{
		1: {
			func(f Frame) error {
				return checkPushPromise(f, 2, [][2]string{
					{":method", "GET"},
					{":scheme", "https"},
					{":authority", st.ts.Listener.Addr().String()},
					{":path", "
					{"user-agent", userAgent},
				})
			},
			func(f Frame) error {
				return checkPushPromise(f, 4, [][2]string{
					{":method", "HEAD"},
					{":scheme", "https"},
					{":authority", st.ts.Listener.Addr().String()},
					{":path", "
					{"cookie", cookie},
					{"user-agent", userAgent},
				})
			},
			func(f Frame) error {
				return checkHeaders(f, [][2]string{
					{":status", "200"},
					{"content-type", "text
					{"content-length", strconv.Itoa(len(mainBody))},
				})
			},
			func(f Frame) error {
				return checkData(f, mainBody)
			},
		},
		2: {
			func(f Frame) error {
				return checkHeaders(f, [][2]string{
					{":status", "200"},
					{"content-type", "text
					{"content-length", strconv.Itoa(len(pushedBody))},
				})
			},
			func(f Frame) error {
				return checkData(f, pushedBody)
			},
		},
		4: {
			func(f Frame) error {
				return checkHeaders(f, [][2]string{
					{":status", "204"},
				})
			},
		},
	}
	consumed := map[uint32]int{}
	for k := 0; len(expected) > 0; k++ {
		f, err := st.readFrame()
		if err != nil {
			for id, left := range expected {
				t.Errorf("stream %d: missing %d frames", id, len(left))
			}
			t.Fatalf("readFrame %d: %v", k, err)
		}
		id := f.Header().StreamID
		label := fmt.Sprintf("stream %d, frame %d", id, consumed[id])
		if len(expected[id]) == 0 {
			t.Fatalf("%s: unexpected frame %#+v", label, f)
		}
		check := expected[id][0]
		expected[id] = expected[id][1:]
		if len(expected[id]) == 0 {
			delete(expected, id)
		}
		if err := check(f); err != nil {
			t.Fatalf("%s: %v", label, err)
		}
		consumed[id]++
	}
}
func TestServer_Push_SuccessNoRace(t *testing.T) {
	
	
	errc := make(chan error, 2)
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.RequestURI() {
		case "
			opt := &http.PushOptions{
				Header: http.Header{"User-Agent": {"testagent"}},
			}
			if err := w.(http.Pusher).Push("
				errc <- fmt.Errorf("error pushing: %v", err)
				return
			}
			w.WriteHeader(200)
			errc <- nil
		case "
			
			r.Header.Set("User-Agent", "newagent")
			r.Header.Set("Cookie", "cookie")
			w.WriteHeader(200)
			errc <- nil
		default:
			errc <- fmt.Errorf("unknown RequestURL %q", r.URL.RequestURI())
		}
	})
	
	st.greet()
	getSlash(st)
	for k := 0; k < 2; k++ {
		select {
		case <-time.After(2 * time.Second):
			t.Errorf("timeout waiting for handler %d to finish", k)
		case err := <-errc:
			if err != nil {
				t.Fatal(err)
			}
		}
	}
}
func TestServer_Push_RejectRecursivePush(t *testing.T) {
	
	errc := make(chan error, 3)
	handler := func(w http.ResponseWriter, r *http.Request) error {
		baseURL := "https:
		switch r.URL.Path {
		case "
			if err := w.(http.Pusher).Push(baseURL+"
				return fmt.Errorf("first Push()=%v, want nil", err)
			}
			return nil
		case "
			if got, want := w.(http.Pusher).Push(baseURL+"
				return fmt.Errorf("Push()=%v, want %v", got, want)
			}
			return nil
		default:
			return fmt.Errorf("unexpected path: %q", r.URL.Path)
		}
	}
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		errc <- handler(w, r)
	})
	defer st.Close()
	st.greet()
	getSlash(st)
	if err := <-errc; err != nil {
		t.Errorf("First request failed: %v", err)
	}
	if err := <-errc; err != nil {
		t.Errorf("Second request failed: %v", err)
	}
}
func testServer_Push_RejectSingleRequest(t *testing.T, doPush func(http.Pusher, *http.Request) error, settings ...Setting) {
	
	errc := make(chan error, 2)
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		errc <- doPush(w.(http.Pusher), r)
	})
	defer st.Close()
	st.greet()
	if err := st.fr.WriteSettings(settings...); err != nil {
		st.t.Fatalf("WriteSettings: %v", err)
	}
	st.wantSettingsAck()
	getSlash(st)
	if err := <-errc; err != nil {
		t.Error(err)
	}
	
	hf := st.wantHeaders()
	if !hf.StreamEnded() {
		t.Error("stream should end after headers")
	}
}
func TestServer_Push_RejectIfDisabled(t *testing.T) {
	testServer_Push_RejectSingleRequest(t,
		func(p http.Pusher, r *http.Request) error {
			if got, want := p.Push("https:
				return fmt.Errorf("Push()=%v, want %v", got, want)
			}
			return nil
		},
		Setting{SettingEnablePush, 0})
}
func TestServer_Push_RejectWhenNoConcurrentStreams(t *testing.T) {
	testServer_Push_RejectSingleRequest(t,
		func(p http.Pusher, r *http.Request) error {
			if got, want := p.Push("https:
				return fmt.Errorf("Push()=%v, want %v", got, want)
			}
			return nil
		},
		Setting{SettingMaxConcurrentStreams, 0})
}
func TestServer_Push_RejectWrongScheme(t *testing.T) {
	testServer_Push_RejectSingleRequest(t,
		func(p http.Pusher, r *http.Request) error {
			if err := p.Push("http:
				return errors.New("Push() should have failed (push target URL is http)")
			}
			return nil
		})
}
func TestServer_Push_RejectMissingHost(t *testing.T) {
	testServer_Push_RejectSingleRequest(t,
		func(p http.Pusher, r *http.Request) error {
			if err := p.Push("https:pushed", nil); err == nil {
				return errors.New("Push() should have failed (push target URL missing host)")
			}
			return nil
		})
}
func TestServer_Push_RejectRelativePath(t *testing.T) {
	testServer_Push_RejectSingleRequest(t,
		func(p http.Pusher, r *http.Request) error {
			if err := p.Push("..
				return errors.New("Push() should have failed (push target is a relative path)")
			}
			return nil
		})
}
func TestServer_Push_RejectForbiddenMethod(t *testing.T) {
	testServer_Push_RejectSingleRequest(t,
		func(p http.Pusher, r *http.Request) error {
			if err := p.Push("https:
				return errors.New("Push() should have failed (cannot promise a POST)")
			}
			return nil
		})
}
func TestServer_Push_RejectForbiddenHeader(t *testing.T) {
	testServer_Push_RejectSingleRequest(t,
		func(p http.Pusher, r *http.Request) error {
			header := http.Header{
				"Content-Length":   {"10"},
				"Content-Encoding": {"gzip"},
				"Trailer":          {"Foo"},
				"Te":               {"trailers"},
				"Host":             {"test.com"},
				":authority":       {"test.com"},
			}
			if err := p.Push("https:
				return errors.New("Push() should have failed (forbidden headers)")
			}
			return nil
		})
}
func TestServer_Push_StateTransitions(t *testing.T) {
	const body = "foo"
	gotPromise := make(chan bool)
	finishedPush := make(chan bool)
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.RequestURI() {
		case "
			if err := w.(http.Pusher).Push("
				t.Errorf("Push error: %v", err)
			}
			
			
			<-finishedPush
		case "
			<-gotPromise
		}
		w.Header().Set("Content-Type", "text
		w.Header().Set("Content-Length", strconv.Itoa(len(body)))
		w.WriteHeader(200)
		io.WriteString(w, body)
	})
	defer st.Close()
	st.greet()
	if st.stream(2) != nil {
		t.Fatal("stream 2 should be empty")
	}
	if got, want := st.streamState(2), stateIdle; got != want {
		t.Fatalf("streamState(2)=%v, want %v", got, want)
	}
	getSlash(st)
	
	st.wantPushPromise()
	if got, want := st.streamState(2), stateHalfClosedRemote; got != want {
		t.Fatalf("streamState(2)=%v, want %v", got, want)
	}
	
	
	
	
	close(gotPromise)
	st.wantHeaders()
	if df := st.wantData(); !df.StreamEnded() {
		t.Fatal("expected END_STREAM flag on DATA")
	}
	if got, want := st.streamState(2), stateClosed; got != want {
		t.Fatalf("streamState(2)=%v, want %v", got, want)
	}
	close(finishedPush)
}
func TestServer_Push_RejectAfterGoAway(t *testing.T) {
	var readyOnce sync.Once
	ready := make(chan struct{})
	errc := make(chan error, 2)
	st := newServerTester(t, func(w http.ResponseWriter, r *http.Request) {
		select {
		case <-ready:
		case <-time.After(5 * time.Second):
			errc <- fmt.Errorf("timeout waiting for GOAWAY to be processed")
		}
		if got, want := w.(http.Pusher).Push("https:
			errc <- fmt.Errorf("Push()=%v, want %v", got, want)
		}
		errc <- nil
	})
	defer st.Close()
	st.greet()
	getSlash(st)
	
	st.fr.WriteGoAway(1, ErrCodeNo, nil)
	go func() {
		for {
			select {
			case <-ready:
				return
			default:
			}
			st.sc.serveMsgCh <- func(loopNum int) {
				if !st.sc.pushEnabled {
					readyOnce.Do(func() { close(ready) })
				}
			}
		}
	}()
	if err := <-errc; err != nil {
		t.Error(err)
	}
}
package context 
func Background() Context {
	return background
}
func TODO() Context {
	return todo
}
package context
import (
	"errors"
	"fmt"
	"sync"
	"time"
)
type emptyCtx int
func (*emptyCtx) Deadline() (deadline time.Time, ok bool) {
	return
}
func (*emptyCtx) Done() <-chan struct{} {
	return nil
}
func (*emptyCtx) Err() error {
	return nil
}
func (*emptyCtx) Value(key interface{}) interface{} {
	return nil
}
func (e *emptyCtx) String() string {
	switch e {
	case background:
		return "context.Background"
	case todo:
		return "context.TODO"
	}
	return "unknown empty Context"
}
var (
	background = new(emptyCtx)
	todo       = new(emptyCtx)
)
var Canceled = errors.New("context canceled")
var DeadlineExceeded = errors.New("context deadline exceeded")
func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {
	c := newCancelCtx(parent)
	propagateCancel(parent, c)
	return c, func() { c.cancel(true, Canceled) }
}
func newCancelCtx(parent Context) *cancelCtx {
	return &cancelCtx{
		Context: parent,
		done:    make(chan struct{}),
	}
}
func propagateCancel(parent Context, child canceler) {
	if parent.Done() == nil {
		return 
	}
	if p, ok := parentCancelCtx(parent); ok {
		p.mu.Lock()
		if p.err != nil {
			
			child.cancel(false, p.err)
		} else {
			if p.children == nil {
				p.children = make(map[canceler]bool)
			}
			p.children[child] = true
		}
		p.mu.Unlock()
	} else {
		go func() {
			select {
			case <-parent.Done():
				child.cancel(false, parent.Err())
			case <-child.Done():
			}
		}()
	}
}
func parentCancelCtx(parent Context) (*cancelCtx, bool) {
	for {
		switch c := parent.(type) {
		case *cancelCtx:
			return c, true
		case *timerCtx:
			return c.cancelCtx, true
		case *valueCtx:
			parent = c.Context
		default:
			return nil, false
		}
	}
}
func removeChild(parent Context, child canceler) {
	p, ok := parentCancelCtx(parent)
	if !ok {
		return
	}
	p.mu.Lock()
	if p.children != nil {
		delete(p.children, child)
	}
	p.mu.Unlock()
}
type canceler interface {
	cancel(removeFromParent bool, err error)
	Done() <-chan struct{}
}
type cancelCtx struct {
	Context
	done chan struct{} 
	mu       sync.Mutex
	children map[canceler]bool 
	err      error             
}
func (c *cancelCtx) Done() <-chan struct{} {
	return c.done
}
func (c *cancelCtx) Err() error {
	c.mu.Lock()
	defer c.mu.Unlock()
	return c.err
}
func (c *cancelCtx) String() string {
	return fmt.Sprintf("%v.WithCancel", c.Context)
}
func (c *cancelCtx) cancel(removeFromParent bool, err error) {
	if err == nil {
		panic("context: internal error: missing cancel error")
	}
	c.mu.Lock()
	if c.err != nil {
		c.mu.Unlock()
		return 
	}
	c.err = err
	close(c.done)
	for child := range c.children {
		
		child.cancel(false, err)
	}
	c.children = nil
	c.mu.Unlock()
	if removeFromParent {
		removeChild(c.Context, c)
	}
}
func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) {
	if cur, ok := parent.Deadline(); ok && cur.Before(deadline) {
		
		return WithCancel(parent)
	}
	c := &timerCtx{
		cancelCtx: newCancelCtx(parent),
		deadline:  deadline,
	}
	propagateCancel(parent, c)
	d := deadline.Sub(time.Now())
	if d <= 0 {
		c.cancel(true, DeadlineExceeded) 
		return c, func() { c.cancel(true, Canceled) }
	}
	c.mu.Lock()
	defer c.mu.Unlock()
	if c.err == nil {
		c.timer = time.AfterFunc(d, func() {
			c.cancel(true, DeadlineExceeded)
		})
	}
	return c, func() { c.cancel(true, Canceled) }
}
type timerCtx struct {
	*cancelCtx
	timer *time.Timer 
	deadline time.Time
}
func (c *timerCtx) Deadline() (deadline time.Time, ok bool) {
	return c.deadline, true
}
func (c *timerCtx) String() string {
	return fmt.Sprintf("%v.WithDeadline(%s [%s])", c.cancelCtx.Context, c.deadline, c.deadline.Sub(time.Now()))
}
func (c *timerCtx) cancel(removeFromParent bool, err error) {
	c.cancelCtx.cancel(false, err)
	if removeFromParent {
		
		removeChild(c.cancelCtx.Context, c)
	}
	c.mu.Lock()
	if c.timer != nil {
		c.timer.Stop()
		c.timer = nil
	}
	c.mu.Unlock()
}
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {
	return WithDeadline(parent, time.Now().Add(timeout))
}
func WithValue(parent Context, key interface{}, val interface{}) Context {
	return &valueCtx{parent, key, val}
}
type valueCtx struct {
	Context
	key, val interface{}
}
func (c *valueCtx) String() string {
	return fmt.Sprintf("%v.WithValue(%#v, %#v)", c.Context, c.key, c.val)
}
func (c *valueCtx) Value(key interface{}) interface{} {
	if c.key == key {
		return c.val
	}
	return c.Context.Value(key)
}
package context
import "context" 
type Context = context.Context
type CancelFunc = context.CancelFunc
package ctxhttp
import (
	"io"
	"net
	"net
	"testing"
	"context"
)
func TestGo17Context(t *testing.T) {
	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		io.WriteString(w, "ok")
	}))
	defer ts.Close()
	ctx := context.Background()
	resp, err := Get(ctx, http.DefaultClient, ts.URL)
	if resp == nil || err != nil {
		t.Fatalf("error received from client: %v %v", err, resp)
	}
	resp.Body.Close()
}
package ctxhttp 
import (
	"io"
	"net
	"net
	"strings"
	"golang.org
)
func nop() {}
var (
	testHookContextDoneBeforeHeaders = nop
	testHookDoReturned               = nop
	testHookDidBodyClose             = nop
)
func Do(ctx context.Context, client *http.Client, req *http.Request) (*http.Response, error) {
	if client == nil {
		client = http.DefaultClient
	}
	
	cancel := make(chan struct{})
	req.Cancel = cancel
	type responseAndError struct {
		resp *http.Response
		err  error
	}
	result := make(chan responseAndError, 1)
	
	
	testHookDoReturned := testHookDoReturned
	testHookDidBodyClose := testHookDidBodyClose
	go func() {
		resp, err := client.Do(req)
		testHookDoReturned()
		result <- responseAndError{resp, err}
	}()
	var resp *http.Response
	select {
	case <-ctx.Done():
		testHookContextDoneBeforeHeaders()
		close(cancel)
		
		go func() {
			if r := <-result; r.resp != nil {
				testHookDidBodyClose()
				r.resp.Body.Close()
			}
		}()
		return nil, ctx.Err()
	case r := <-result:
		var err error
		resp, err = r.resp, r.err
		if err != nil {
			return resp, err
		}
	}
	c := make(chan struct{})
	go func() {
		select {
		case <-ctx.Done():
			close(cancel)
		case <-c:
			
		}
	}()
	resp.Body = &notifyingReader{resp.Body, c}
	return resp, nil
}
func Get(ctx context.Context, client *http.Client, url string) (*http.Response, error) {
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}
	return Do(ctx, client, req)
}
func Head(ctx context.Context, client *http.Client, url string) (*http.Response, error) {
	req, err := http.NewRequest("HEAD", url, nil)
	if err != nil {
		return nil, err
	}
	return Do(ctx, client, req)
}
func Post(ctx context.Context, client *http.Client, url string, bodyType string, body io.Reader) (*http.Response, error) {
	req, err := http.NewRequest("POST", url, body)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", bodyType)
	return Do(ctx, client, req)
}
func PostForm(ctx context.Context, client *http.Client, url string, data url.Values) (*http.Response, error) {
	return Post(ctx, client, url, "application
}
type notifyingReader struct {
	io.ReadCloser
	notify chan<- struct{}
}
func (r *notifyingReader) Read(p []byte) (int, error) {
	n, err := r.ReadCloser.Read(p)
	if err != nil && r.notify != nil {
		close(r.notify)
		r.notify = nil
	}
	return n, err
}
func (r *notifyingReader) Close() error {
	err := r.ReadCloser.Close()
	if r.notify != nil {
		close(r.notify)
		r.notify = nil
	}
	return err
}
package ctxhttp
import (
	"io"
	"io
	"net
	"net
	"testing"
	"time"
	"golang.org
)
const (
	requestDuration = 100 * time.Millisecond
	requestBody     = "ok"
)
func okHandler(w http.ResponseWriter, r *http.Request) {
	time.Sleep(requestDuration)
	io.WriteString(w, requestBody)
}
func TestNoTimeout(t *testing.T) {
	ts := httptest.NewServer(http.HandlerFunc(okHandler))
	defer ts.Close()
	ctx := context.Background()
	res, err := Get(ctx, nil, ts.URL)
	if err != nil {
		t.Fatal(err)
	}
	defer res.Body.Close()
	slurp, err := ioutil.ReadAll(res.Body)
	if err != nil {
		t.Fatal(err)
	}
	if string(slurp) != requestBody {
		t.Errorf("body = %q; want %q", slurp, requestBody)
	}
}
func TestCancelBeforeHeaders(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())
	blockServer := make(chan struct{})
	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		cancel()
		<-blockServer
		io.WriteString(w, requestBody)
	}))
	defer ts.Close()
	defer close(blockServer)
	res, err := Get(ctx, nil, ts.URL)
	if err == nil {
		res.Body.Close()
		t.Fatal("Get returned unexpected nil error")
	}
	if err != context.Canceled {
		t.Errorf("err = %v; want %v", err, context.Canceled)
	}
}
func TestCancelAfterHangingRequest(t *testing.T) {
	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		w.(http.Flusher).Flush()
		<-w.(http.CloseNotifier).CloseNotify()
	}))
	defer ts.Close()
	ctx, cancel := context.WithCancel(context.Background())
	resp, err := Get(ctx, nil, ts.URL)
	if err != nil {
		t.Fatalf("unexpected error in Get: %v", err)
	}
	
	
	
	cancel()
	done := make(chan struct{})
	go func() {
		b, err := ioutil.ReadAll(resp.Body)
		if len(b) != 0 || err == nil {
			t.Errorf(`Read got (%q, %v); want ("", error)`, b, err)
		}
		close(done)
	}()
	select {
	case <-time.After(1 * time.Second):
		t.Errorf("Test timed out")
	case <-done:
	}
}
package ctxhttp
import (
	"net"
	"net
	"net
	"sync"
	"testing"
	"time"
	"golang.org
)
func TestClosesResponseBodyOnCancel(t *testing.T) {
	defer func() { testHookContextDoneBeforeHeaders = nop }()
	defer func() { testHookDoReturned = nop }()
	defer func() { testHookDidBodyClose = nop }()
	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {}))
	defer ts.Close()
	ctx, cancel := context.WithCancel(context.Background())
	
	enteredDonePath := make(chan struct{})
	testHookContextDoneBeforeHeaders = func() {
		close(enteredDonePath)
	}
	testHookDoReturned = func() {
		
		
		cancel()
		
		
		
		
		<-enteredDonePath
	}
	sawBodyClose := make(chan struct{})
	testHookDidBodyClose = func() { close(sawBodyClose) }
	tr := &http.Transport{}
	defer tr.CloseIdleConnections()
	c := &http.Client{Transport: tr}
	req, _ := http.NewRequest("GET", ts.URL, nil)
	_, doErr := Do(ctx, c, req)
	select {
	case <-sawBodyClose:
	case <-time.After(5 * time.Second):
		t.Fatal("timeout waiting for body to close")
	}
	if doErr != ctx.Err() {
		t.Errorf("Do error = %v; want %v", doErr, ctx.Err())
	}
}
type noteCloseConn struct {
	net.Conn
	onceClose sync.Once
	closefn   func()
}
func (c *noteCloseConn) Close() error {
	c.onceClose.Do(c.closefn)
	return c.Conn.Close()
}
package ctxhttp 
import (
	"io"
	"net
	"net
	"strings"
	"golang.org
)
func Do(ctx context.Context, client *http.Client, req *http.Request) (*http.Response, error) {
	if client == nil {
		client = http.DefaultClient
	}
	resp, err := client.Do(req.WithContext(ctx))
	
	
	if err != nil {
		select {
		case <-ctx.Done():
			err = ctx.Err()
		default:
		}
	}
	return resp, err
}
func Get(ctx context.Context, client *http.Client, url string) (*http.Response, error) {
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}
	return Do(ctx, client, req)
}
func Head(ctx context.Context, client *http.Client, url string) (*http.Response, error) {
	req, err := http.NewRequest("HEAD", url, nil)
	if err != nil {
		return nil, err
	}
	return Do(ctx, client, req)
}
func Post(ctx context.Context, client *http.Client, url string, bodyType string, body io.Reader) (*http.Response, error) {
	req, err := http.NewRequest("POST", url, body)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", bodyType)
	return Do(ctx, client, req)
}
func PostForm(ctx context.Context, client *http.Client, url string, data url.Values) (*http.Response, error) {
	return Post(ctx, client, url, "application
}
package context_test
import (
	"fmt"
	"time"
	"golang.org
)
func ExampleWithTimeout() {
	
	
	ctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)
	defer cancel()
	select {
	case <-time.After(1 * time.Second):
		fmt.Println("overslept")
	case <-ctx.Done():
		fmt.Println(ctx.Err()) 
	}
	
	
}
package context
import "time"
type Context interface {
	
	
	
	Deadline() (deadline time.Time, ok bool)
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	Done() <-chan struct{}
	
	
	
	
	Err() error
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	Value(key interface{}) interface{}
}
type CancelFunc func()
package context
import (
	"fmt"
	"math
	"runtime"
	"strings"
	"sync"
	"testing"
	"time"
)
type otherContext struct {
	Context
}
func TestBackground(t *testing.T) {
	c := Background()
	if c == nil {
		t.Fatalf("Background returned nil")
	}
	select {
	case x := <-c.Done():
		t.Errorf("<-c.Done() == %v want nothing (it should block)", x)
	default:
	}
	if got, want := fmt.Sprint(c), "context.Background"; got != want {
		t.Errorf("Background().String() = %q want %q", got, want)
	}
}
func TestTODO(t *testing.T) {
	c := TODO()
	if c == nil {
		t.Fatalf("TODO returned nil")
	}
	select {
	case x := <-c.Done():
		t.Errorf("<-c.Done() == %v want nothing (it should block)", x)
	default:
	}
	if got, want := fmt.Sprint(c), "context.TODO"; got != want {
		t.Errorf("TODO().String() = %q want %q", got, want)
	}
}
func TestWithCancel(t *testing.T) {
	c1, cancel := WithCancel(Background())
	if got, want := fmt.Sprint(c1), "context.Background.WithCancel"; got != want {
		t.Errorf("c1.String() = %q want %q", got, want)
	}
	o := otherContext{c1}
	c2, _ := WithCancel(o)
	contexts := []Context{c1, o, c2}
	for i, c := range contexts {
		if d := c.Done(); d == nil {
			t.Errorf("c[%d].Done() == %v want non-nil", i, d)
		}
		if e := c.Err(); e != nil {
			t.Errorf("c[%d].Err() == %v want nil", i, e)
		}
		select {
		case x := <-c.Done():
			t.Errorf("<-c.Done() == %v want nothing (it should block)", x)
		default:
		}
	}
	cancel()
	time.Sleep(100 * time.Millisecond) 
	for i, c := range contexts {
		select {
		case <-c.Done():
		default:
			t.Errorf("<-c[%d].Done() blocked, but shouldn't have", i)
		}
		if e := c.Err(); e != Canceled {
			t.Errorf("c[%d].Err() == %v want %v", i, e, Canceled)
		}
	}
}
func TestParentFinishesChild(t *testing.T) {
	
	
	
	parent, cancel := WithCancel(Background())
	cancelChild, stop := WithCancel(parent)
	defer stop()
	valueChild := WithValue(parent, "key", "value")
	timerChild, stop := WithTimeout(valueChild, 10000*time.Hour)
	defer stop()
	select {
	case x := <-parent.Done():
		t.Errorf("<-parent.Done() == %v want nothing (it should block)", x)
	case x := <-cancelChild.Done():
		t.Errorf("<-cancelChild.Done() == %v want nothing (it should block)", x)
	case x := <-timerChild.Done():
		t.Errorf("<-timerChild.Done() == %v want nothing (it should block)", x)
	case x := <-valueChild.Done():
		t.Errorf("<-valueChild.Done() == %v want nothing (it should block)", x)
	default:
	}
	
	pc := parent.(*cancelCtx)
	cc := cancelChild.(*cancelCtx)
	tc := timerChild.(*timerCtx)
	pc.mu.Lock()
	if len(pc.children) != 2 || !pc.children[cc] || !pc.children[tc] {
		t.Errorf("bad linkage: pc.children = %v, want %v and %v",
			pc.children, cc, tc)
	}
	pc.mu.Unlock()
	if p, ok := parentCancelCtx(cc.Context); !ok || p != pc {
		t.Errorf("bad linkage: parentCancelCtx(cancelChild.Context) = %v, %v want %v, true", p, ok, pc)
	}
	if p, ok := parentCancelCtx(tc.Context); !ok || p != pc {
		t.Errorf("bad linkage: parentCancelCtx(timerChild.Context) = %v, %v want %v, true", p, ok, pc)
	}
	cancel()
	pc.mu.Lock()
	if len(pc.children) != 0 {
		t.Errorf("pc.cancel didn't clear pc.children = %v", pc.children)
	}
	pc.mu.Unlock()
	
	check := func(ctx Context, name string) {
		select {
		case <-ctx.Done():
		default:
			t.Errorf("<-%s.Done() blocked, but shouldn't have", name)
		}
		if e := ctx.Err(); e != Canceled {
			t.Errorf("%s.Err() == %v want %v", name, e, Canceled)
		}
	}
	check(parent, "parent")
	check(cancelChild, "cancelChild")
	check(valueChild, "valueChild")
	check(timerChild, "timerChild")
	
	precanceledChild := WithValue(parent, "key", "value")
	select {
	case <-precanceledChild.Done():
	default:
		t.Errorf("<-precanceledChild.Done() blocked, but shouldn't have")
	}
	if e := precanceledChild.Err(); e != Canceled {
		t.Errorf("precanceledChild.Err() == %v want %v", e, Canceled)
	}
}
func TestChildFinishesFirst(t *testing.T) {
	cancelable, stop := WithCancel(Background())
	defer stop()
	for _, parent := range []Context{Background(), cancelable} {
		child, cancel := WithCancel(parent)
		select {
		case x := <-parent.Done():
			t.Errorf("<-parent.Done() == %v want nothing (it should block)", x)
		case x := <-child.Done():
			t.Errorf("<-child.Done() == %v want nothing (it should block)", x)
		default:
		}
		cc := child.(*cancelCtx)
		pc, pcok := parent.(*cancelCtx) 
		if p, ok := parentCancelCtx(cc.Context); ok != pcok || (ok && pc != p) {
			t.Errorf("bad linkage: parentCancelCtx(cc.Context) = %v, %v want %v, %v", p, ok, pc, pcok)
		}
		if pcok {
			pc.mu.Lock()
			if len(pc.children) != 1 || !pc.children[cc] {
				t.Errorf("bad linkage: pc.children = %v, cc = %v", pc.children, cc)
			}
			pc.mu.Unlock()
		}
		cancel()
		if pcok {
			pc.mu.Lock()
			if len(pc.children) != 0 {
				t.Errorf("child's cancel didn't remove self from pc.children = %v", pc.children)
			}
			pc.mu.Unlock()
		}
		
		select {
		case <-child.Done():
		default:
			t.Errorf("<-child.Done() blocked, but shouldn't have")
		}
		if e := child.Err(); e != Canceled {
			t.Errorf("child.Err() == %v want %v", e, Canceled)
		}
		
		select {
		case x := <-parent.Done():
			t.Errorf("<-parent.Done() == %v want nothing (it should block)", x)
		default:
		}
		if e := parent.Err(); e != nil {
			t.Errorf("parent.Err() == %v want nil", e)
		}
	}
}
func testDeadline(c Context, wait time.Duration, t *testing.T) {
	select {
	case <-time.After(wait):
		t.Fatalf("context should have timed out")
	case <-c.Done():
	}
	if e := c.Err(); e != DeadlineExceeded {
		t.Errorf("c.Err() == %v want %v", e, DeadlineExceeded)
	}
}
func TestDeadline(t *testing.T) {
	t.Parallel()
	const timeUnit = 500 * time.Millisecond
	c, _ := WithDeadline(Background(), time.Now().Add(1*timeUnit))
	if got, prefix := fmt.Sprint(c), "context.Background.WithDeadline("; !strings.HasPrefix(got, prefix) {
		t.Errorf("c.String() = %q want prefix %q", got, prefix)
	}
	testDeadline(c, 2*timeUnit, t)
	c, _ = WithDeadline(Background(), time.Now().Add(1*timeUnit))
	o := otherContext{c}
	testDeadline(o, 2*timeUnit, t)
	c, _ = WithDeadline(Background(), time.Now().Add(1*timeUnit))
	o = otherContext{c}
	c, _ = WithDeadline(o, time.Now().Add(3*timeUnit))
	testDeadline(c, 2*timeUnit, t)
}
func TestTimeout(t *testing.T) {
	t.Parallel()
	const timeUnit = 500 * time.Millisecond
	c, _ := WithTimeout(Background(), 1*timeUnit)
	if got, prefix := fmt.Sprint(c), "context.Background.WithDeadline("; !strings.HasPrefix(got, prefix) {
		t.Errorf("c.String() = %q want prefix %q", got, prefix)
	}
	testDeadline(c, 2*timeUnit, t)
	c, _ = WithTimeout(Background(), 1*timeUnit)
	o := otherContext{c}
	testDeadline(o, 2*timeUnit, t)
	c, _ = WithTimeout(Background(), 1*timeUnit)
	o = otherContext{c}
	c, _ = WithTimeout(o, 3*timeUnit)
	testDeadline(c, 2*timeUnit, t)
}
func TestCanceledTimeout(t *testing.T) {
	t.Parallel()
	const timeUnit = 500 * time.Millisecond
	c, _ := WithTimeout(Background(), 2*timeUnit)
	o := otherContext{c}
	c, cancel := WithTimeout(o, 4*timeUnit)
	cancel()
	time.Sleep(1 * timeUnit) 
	select {
	case <-c.Done():
	default:
		t.Errorf("<-c.Done() blocked, but shouldn't have")
	}
	if e := c.Err(); e != Canceled {
		t.Errorf("c.Err() == %v want %v", e, Canceled)
	}
}
type key1 int
type key2 int
var k1 = key1(1)
var k2 = key2(1) 
var k3 = key2(3) 
func TestValues(t *testing.T) {
	check := func(c Context, nm, v1, v2, v3 string) {
		if v, ok := c.Value(k1).(string); ok == (len(v1) == 0) || v != v1 {
			t.Errorf(`%s.Value(k1).(string) = %q, %t want %q, %t`, nm, v, ok, v1, len(v1) != 0)
		}
		if v, ok := c.Value(k2).(string); ok == (len(v2) == 0) || v != v2 {
			t.Errorf(`%s.Value(k2).(string) = %q, %t want %q, %t`, nm, v, ok, v2, len(v2) != 0)
		}
		if v, ok := c.Value(k3).(string); ok == (len(v3) == 0) || v != v3 {
			t.Errorf(`%s.Value(k3).(string) = %q, %t want %q, %t`, nm, v, ok, v3, len(v3) != 0)
		}
	}
	c0 := Background()
	check(c0, "c0", "", "", "")
	c1 := WithValue(Background(), k1, "c1k1")
	check(c1, "c1", "c1k1", "", "")
	if got, want := fmt.Sprint(c1), `context.Background.WithValue(1, "c1k1")`; got != want {
		t.Errorf("c.String() = %q want %q", got, want)
	}
	c2 := WithValue(c1, k2, "c2k2")
	check(c2, "c2", "c1k1", "c2k2", "")
	c3 := WithValue(c2, k3, "c3k3")
	check(c3, "c2", "c1k1", "c2k2", "c3k3")
	c4 := WithValue(c3, k1, nil)
	check(c4, "c4", "", "c2k2", "c3k3")
	o0 := otherContext{Background()}
	check(o0, "o0", "", "", "")
	o1 := otherContext{WithValue(Background(), k1, "c1k1")}
	check(o1, "o1", "c1k1", "", "")
	o2 := WithValue(o1, k2, "o2k2")
	check(o2, "o2", "c1k1", "o2k2", "")
	o3 := otherContext{c4}
	check(o3, "o3", "", "c2k2", "c3k3")
	o4 := WithValue(o3, k3, nil)
	check(o4, "o4", "", "c2k2", "")
}
func TestAllocs(t *testing.T) {
	bg := Background()
	for _, test := range []struct {
		desc       string
		f          func()
		limit      float64
		gccgoLimit float64
	}{
		{
			desc:       "Background()",
			f:          func() { Background() },
			limit:      0,
			gccgoLimit: 0,
		},
		{
			desc: fmt.Sprintf("WithValue(bg, %v, nil)", k1),
			f: func() {
				c := WithValue(bg, k1, nil)
				c.Value(k1)
			},
			limit:      3,
			gccgoLimit: 3,
		},
		{
			desc: "WithTimeout(bg, 15*time.Millisecond)",
			f: func() {
				c, _ := WithTimeout(bg, 15*time.Millisecond)
				<-c.Done()
			},
			limit:      8,
			gccgoLimit: 16,
		},
		{
			desc: "WithCancel(bg)",
			f: func() {
				c, cancel := WithCancel(bg)
				cancel()
				<-c.Done()
			},
			limit:      5,
			gccgoLimit: 8,
		},
		{
			desc: "WithTimeout(bg, 100*time.Millisecond)",
			f: func() {
				c, cancel := WithTimeout(bg, 100*time.Millisecond)
				cancel()
				<-c.Done()
			},
			limit:      8,
			gccgoLimit: 25,
		},
	} {
		limit := test.limit
		if runtime.Compiler == "gccgo" {
			
			
			limit = test.gccgoLimit
		}
		if n := testing.AllocsPerRun(100, test.f); n > limit {
			t.Errorf("%s allocs = %f want %d", test.desc, n, int(limit))
		}
	}
}
func TestSimultaneousCancels(t *testing.T) {
	root, cancel := WithCancel(Background())
	m := map[Context]CancelFunc{root: cancel}
	q := []Context{root}
	
	for len(q) != 0 && len(m) < 100 {
		parent := q[0]
		q = q[1:]
		for i := 0; i < 4; i++ {
			ctx, cancel := WithCancel(parent)
			m[ctx] = cancel
			q = append(q, ctx)
		}
	}
	
	var wg sync.WaitGroup
	wg.Add(len(m))
	for _, cancel := range m {
		go func(cancel CancelFunc) {
			cancel()
			wg.Done()
		}(cancel)
	}
	
	for ctx := range m {
		select {
		case <-ctx.Done():
		case <-time.After(1 * time.Second):
			buf := make([]byte, 10<<10)
			n := runtime.Stack(buf, true)
			t.Fatalf("timed out waiting for <-ctx.Done(); stacks:\n%s", buf[:n])
		}
	}
	
	done := make(chan struct{})
	go func() {
		wg.Wait()
		close(done)
	}()
	select {
	case <-done:
	case <-time.After(1 * time.Second):
		buf := make([]byte, 10<<10)
		n := runtime.Stack(buf, true)
		t.Fatalf("timed out waiting for cancel functions; stacks:\n%s", buf[:n])
	}
}
func TestInterlockedCancels(t *testing.T) {
	parent, cancelParent := WithCancel(Background())
	child, cancelChild := WithCancel(parent)
	go func() {
		parent.Done()
		cancelChild()
	}()
	cancelParent()
	select {
	case <-child.Done():
	case <-time.After(1 * time.Second):
		buf := make([]byte, 10<<10)
		n := runtime.Stack(buf, true)
		t.Fatalf("timed out waiting for child.Done(); stacks:\n%s", buf[:n])
	}
}
func TestLayersCancel(t *testing.T) {
	testLayers(t, time.Now().UnixNano(), false)
}
func TestLayersTimeout(t *testing.T) {
	testLayers(t, time.Now().UnixNano(), true)
}
func testLayers(t *testing.T, seed int64, testTimeout bool) {
	rand.Seed(seed)
	errorf := func(format string, a ...interface{}) {
		t.Errorf(fmt.Sprintf("seed=%d: %s", seed, format), a...)
	}
	const (
		timeout   = 200 * time.Millisecond
		minLayers = 30
	)
	type value int
	var (
		vals      []*value
		cancels   []CancelFunc
		numTimers int
		ctx       = Background()
	)
	for i := 0; i < minLayers || numTimers == 0 || len(cancels) == 0 || len(vals) == 0; i++ {
		switch rand.Intn(3) {
		case 0:
			v := new(value)
			ctx = WithValue(ctx, v, v)
			vals = append(vals, v)
		case 1:
			var cancel CancelFunc
			ctx, cancel = WithCancel(ctx)
			cancels = append(cancels, cancel)
		case 2:
			var cancel CancelFunc
			ctx, cancel = WithTimeout(ctx, timeout)
			cancels = append(cancels, cancel)
			numTimers++
		}
	}
	checkValues := func(when string) {
		for _, key := range vals {
			if val := ctx.Value(key).(*value); key != val {
				errorf("%s: ctx.Value(%p) = %p want %p", when, key, val, key)
			}
		}
	}
	select {
	case <-ctx.Done():
		errorf("ctx should not be canceled yet")
	default:
	}
	if s, prefix := fmt.Sprint(ctx), "context.Background."; !strings.HasPrefix(s, prefix) {
		t.Errorf("ctx.String() = %q want prefix %q", s, prefix)
	}
	t.Log(ctx)
	checkValues("before cancel")
	if testTimeout {
		select {
		case <-ctx.Done():
		case <-time.After(timeout + 100*time.Millisecond):
			errorf("ctx should have timed out")
		}
		checkValues("after timeout")
	} else {
		cancel := cancels[rand.Intn(len(cancels))]
		cancel()
		select {
		case <-ctx.Done():
		default:
			errorf("ctx should be canceled")
		}
		checkValues("after cancel")
	}
}
func TestCancelRemoves(t *testing.T) {
	checkChildren := func(when string, ctx Context, want int) {
		if got := len(ctx.(*cancelCtx).children); got != want {
			t.Errorf("%s: context has %d children, want %d", when, got, want)
		}
	}
	ctx, _ := WithCancel(Background())
	checkChildren("after creation", ctx, 0)
	_, cancel := WithCancel(ctx)
	checkChildren("with WithCancel child ", ctx, 1)
	cancel()
	checkChildren("after cancelling WithCancel child", ctx, 0)
	ctx, _ = WithCancel(Background())
	checkChildren("after creation", ctx, 0)
	_, cancel = WithTimeout(ctx, 60*time.Minute)
	checkChildren("with WithTimeout child ", ctx, 1)
	cancel()
	checkChildren("after cancelling WithTimeout child", ctx, 0)
}
package context
import (
	"context" 
	"time"
)
var (
	todo       = context.TODO()
	background = context.Background()
)
var Canceled = context.Canceled
var DeadlineExceeded = context.DeadlineExceeded
func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {
	ctx, f := context.WithCancel(parent)
	return ctx, CancelFunc(f)
}
func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) {
	ctx, f := context.WithDeadline(parent, deadline)
	return ctx, CancelFunc(f)
}
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {
	return WithDeadline(parent, time.Now().Add(timeout))
}
func WithValue(parent Context, key interface{}, val interface{}) Context {
	return context.WithValue(parent, key, val)
}
package nettest
import (
	"fmt"
	"runtime"
)
func maxOpenFiles() int {
	return defaultMaxOpenFiles
}
func supportsRawIPSocket() (string, bool) {
	return fmt.Sprintf("not supported on %s", runtime.GOOS), false
}
func supportsIPv6MulticastDeliveryOnLoopback() bool {
	return false
}
func causesIPv6Crash() bool {
	return false
}
func protocolNotSupported(err error) bool {
	return false
}
package nettest
func supportsIPv6MulticastDeliveryOnLoopback() bool {
	return true
}
func causesIPv6Crash() bool {
	return false
}
package nettest
import "net"
func IsMulticastCapable(network string, ifi *net.Interface) (net.IP, bool) {
	switch network {
	case "ip", "ip4", "ip6":
	default:
		return nil, false
	}
	if ifi == nil || ifi.Flags&net.FlagUp == 0 || ifi.Flags&net.FlagMulticast == 0 {
		return nil, false
	}
	return hasRoutableIP(network, ifi)
}
func RoutedInterface(network string, flags net.Flags) *net.Interface {
	switch network {
	case "ip", "ip4", "ip6":
	default:
		return nil
	}
	ift, err := net.Interfaces()
	if err != nil {
		return nil
	}
	for _, ifi := range ift {
		if ifi.Flags&flags != flags {
			continue
		}
		if _, ok := hasRoutableIP(network, &ifi); !ok {
			continue
		}
		return &ifi
	}
	return nil
}
func hasRoutableIP(network string, ifi *net.Interface) (net.IP, bool) {
	ifat, err := ifi.Addrs()
	if err != nil {
		return nil, false
	}
	for _, ifa := range ifat {
		switch ifa := ifa.(type) {
		case *net.IPAddr:
			if ip := routableIP(network, ifa.IP); ip != nil {
				return ip, true
			}
		case *net.IPNet:
			if ip := routableIP(network, ifa.IP); ip != nil {
				return ip, true
			}
		}
	}
	return nil, false
}
func routableIP(network string, ip net.IP) net.IP {
	if !ip.IsLoopback() && !ip.IsLinkLocalUnicast() && !ip.IsGlobalUnicast() {
		return nil
	}
	switch network {
	case "ip4":
		if ip := ip.To4(); ip != nil {
			return ip
		}
	case "ip6":
		if ip.IsLoopback() { 
			return nil
		}
		if ip := ip.To16(); ip != nil && ip.To4() == nil {
			return ip
		}
	default:
		if ip := ip.To4(); ip != nil {
			return ip
		}
		if ip := ip.To16(); ip != nil {
			return ip
		}
	}
	return nil
}
package nettest
import (
	"fmt"
	"runtime"
	"syscall"
)
func maxOpenFiles() int {
	return 4 * defaultMaxOpenFiles 
}
func supportsRawIPSocket() (string, bool) {
	
	
	
	
	
	
	
	s, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_RAW, 0)
	if err == syscall.WSAEACCES {
		return fmt.Sprintf("no access to raw socket allowed on %s", runtime.GOOS), false
	}
	if err != nil {
		return err.Error(), false
	}
	syscall.Closesocket(s)
	return "", true
}
func supportsIPv6MulticastDeliveryOnLoopback() bool {
	return true
}
func causesIPv6Crash() bool {
	return false
}
package nettest
import (
	"fmt"
	"os"
	"runtime"
	"syscall"
)
func maxOpenFiles() int {
	var rlim syscall.Rlimit
	if err := syscall.Getrlimit(syscall.RLIMIT_NOFILE, &rlim); err != nil {
		return defaultMaxOpenFiles
	}
	return int(rlim.Cur)
}
func supportsRawIPSocket() (string, bool) {
	if os.Getuid() != 0 {
		return fmt.Sprintf("must be root on %s", runtime.GOOS), false
	}
	return "", true
}
package nettest
import (
	"os"
	"syscall"
)
func protocolNotSupported(err error) bool {
	switch err := err.(type) {
	case syscall.Errno:
		switch err {
		case syscall.EPROTONOSUPPORT, syscall.ENOPROTOOPT:
			return true
		}
	case *os.SyscallError:
		switch err := err.Err.(type) {
		case syscall.Errno:
			switch err {
			case syscall.EPROTONOSUPPORT, syscall.ENOPROTOOPT:
				return true
			}
		}
	}
	return false
}
package nettest 
import (
	"fmt"
	"io
	"net"
	"os"
	"runtime"
)
var (
	supportsIPv4 bool
	supportsIPv6 bool
)
func init() {
	if ln, err := net.Listen("tcp4", "127.0.0.1:0"); err == nil {
		ln.Close()
		supportsIPv4 = true
	}
	if ln, err := net.Listen("tcp6", "[::1]:0"); err == nil {
		ln.Close()
		supportsIPv6 = true
	}
}
func SupportsIPv4() bool { return supportsIPv4 }
func SupportsIPv6() bool { return supportsIPv6 }
func SupportsRawIPSocket() (string, bool) {
	return supportsRawIPSocket()
}
func SupportsIPv6MulticastDeliveryOnLoopback() bool {
	return supportsIPv6MulticastDeliveryOnLoopback()
}
func ProtocolNotSupported(err error) bool {
	return protocolNotSupported(err)
}
func TestableNetwork(network string) bool {
	
	
	switch network {
	case "unix", "unixgram":
		switch runtime.GOOS {
		case "android", "nacl", "plan9", "windows":
			return false
		}
		if runtime.GOOS == "darwin" && (runtime.GOARCH == "arm" || runtime.GOARCH == "arm64") {
			return false
		}
	case "unixpacket":
		switch runtime.GOOS {
		case "android", "darwin", "freebsd", "nacl", "plan9", "windows":
			return false
		}
	}
	return true
}
func NewLocalListener(network string) (net.Listener, error) {
	switch network {
	case "tcp":
		if supportsIPv4 {
			if ln, err := net.Listen("tcp4", "127.0.0.1:0"); err == nil {
				return ln, nil
			}
		}
		if supportsIPv6 {
			return net.Listen("tcp6", "[::1]:0")
		}
	case "tcp4":
		if supportsIPv4 {
			return net.Listen("tcp4", "127.0.0.1:0")
		}
	case "tcp6":
		if supportsIPv6 {
			return net.Listen("tcp6", "[::1]:0")
		}
	case "unix", "unixpacket":
		return net.Listen(network, localPath())
	}
	return nil, fmt.Errorf("%s is not supported", network)
}
func NewLocalPacketListener(network string) (net.PacketConn, error) {
	switch network {
	case "udp":
		if supportsIPv4 {
			if c, err := net.ListenPacket("udp4", "127.0.0.1:0"); err == nil {
				return c, nil
			}
		}
		if supportsIPv6 {
			return net.ListenPacket("udp6", "[::1]:0")
		}
	case "udp4":
		if supportsIPv4 {
			return net.ListenPacket("udp4", "127.0.0.1:0")
		}
	case "udp6":
		if supportsIPv6 {
			return net.ListenPacket("udp6", "[::1]:0")
		}
	case "unixgram":
		return net.ListenPacket(network, localPath())
	}
	return nil, fmt.Errorf("%s is not supported", network)
}
func localPath() string {
	f, err := ioutil.TempFile("", "nettest")
	if err != nil {
		panic(err)
	}
	path := f.Name()
	f.Close()
	os.Remove(path)
	return path
}
package nettest
import (
	"runtime"
	"strconv"
	"strings"
	"syscall"
)
var darwinVersion int
func init() {
	if runtime.GOOS == "darwin" {
		
		s, err := syscall.Sysctl("kern.osrelease")
		if err != nil {
			return
		}
		ss := strings.Split(s, ".")
		if len(ss) == 0 {
			return
		}
		darwinVersion, _ = strconv.Atoi(ss[0])
	}
}
func supportsIPv6MulticastDeliveryOnLoopback() bool {
	switch runtime.GOOS {
	case "freebsd":
		
		
		
		
		return false
	case "darwin":
		return !causesIPv6Crash()
	default:
		return true
	}
}
func causesIPv6Crash() bool {
	
	
	
	return darwinVersion < 13
}
package nettest
const defaultMaxOpenFiles = 256
func MaxOpenFiles() int { return maxOpenFiles() }
package timeseries 
import (
	"fmt"
	"log"
	"time"
)
const (
	timeSeriesNumBuckets       = 64
	minuteHourSeriesNumBuckets = 60
)
var timeSeriesResolutions = []time.Duration{
	1 * time.Second,
	10 * time.Second,
	1 * time.Minute,
	10 * time.Minute,
	1 * time.Hour,
	6 * time.Hour,
	24 * time.Hour,          
	7 * 24 * time.Hour,      
	4 * 7 * 24 * time.Hour,  
	16 * 7 * 24 * time.Hour, 
}
var minuteHourSeriesResolutions = []time.Duration{
	1 * time.Second,
	1 * time.Minute,
}
type Observable interface {
	Multiply(ratio float64)    
	Add(other Observable)      
	Clear()                    
	CopyFrom(other Observable) 
}
type Float float64
func NewFloat() Observable {
	f := Float(0)
	return &f
}
func (f *Float) String() string { return fmt.Sprintf("%g", f.Value()) }
func (f *Float) Value() float64 { return float64(*f) }
func (f *Float) Multiply(ratio float64) { *f *= Float(ratio) }
func (f *Float) Add(other Observable) {
	o := other.(*Float)
	*f += *o
}
func (f *Float) Clear() { *f = 0 }
func (f *Float) CopyFrom(other Observable) {
	o := other.(*Float)
	*f = *o
}
type Clock interface {
	Time() time.Time
}
type defaultClock int
var defaultClockInstance defaultClock
func (defaultClock) Time() time.Time { return time.Now() }
type tsLevel struct {
	oldest   int               
	newest   int               
	end      time.Time         
	size     time.Duration     
	buckets  []Observable      
	provider func() Observable 
}
func (l *tsLevel) Clear() {
	l.oldest = 0
	l.newest = len(l.buckets) - 1
	l.end = time.Time{}
	for i := range l.buckets {
		if l.buckets[i] != nil {
			l.buckets[i].Clear()
			l.buckets[i] = nil
		}
	}
}
func (l *tsLevel) InitLevel(size time.Duration, numBuckets int, f func() Observable) {
	l.size = size
	l.provider = f
	l.buckets = make([]Observable, numBuckets)
}
type timeSeries struct {
	provider    func() Observable 
	numBuckets  int               
	levels      []*tsLevel        
	lastAdd     time.Time         
	total       Observable        
	clock       Clock             
	pending     Observable        
	pendingTime time.Time         
	dirty       bool              
}
func (ts *timeSeries) init(resolutions []time.Duration, f func() Observable, numBuckets int, clock Clock) {
	ts.provider = f
	ts.numBuckets = numBuckets
	ts.clock = clock
	ts.levels = make([]*tsLevel, len(resolutions))
	for i := range resolutions {
		if i > 0 && resolutions[i-1] >= resolutions[i] {
			log.Print("timeseries: resolutions must be monotonically increasing")
			break
		}
		newLevel := new(tsLevel)
		newLevel.InitLevel(resolutions[i], ts.numBuckets, ts.provider)
		ts.levels[i] = newLevel
	}
	ts.Clear()
}
func (ts *timeSeries) Clear() {
	ts.lastAdd = time.Time{}
	ts.total = ts.resetObservation(ts.total)
	ts.pending = ts.resetObservation(ts.pending)
	ts.pendingTime = time.Time{}
	ts.dirty = false
	for i := range ts.levels {
		ts.levels[i].Clear()
	}
}
func (ts *timeSeries) Add(observation Observable) {
	ts.AddWithTime(observation, ts.clock.Time())
}
func (ts *timeSeries) AddWithTime(observation Observable, t time.Time) {
	smallBucketDuration := ts.levels[0].size
	if t.After(ts.lastAdd) {
		ts.lastAdd = t
	}
	if t.After(ts.pendingTime) {
		ts.advance(t)
		ts.mergePendingUpdates()
		ts.pendingTime = ts.levels[0].end
		ts.pending.CopyFrom(observation)
		ts.dirty = true
	} else if t.After(ts.pendingTime.Add(-1 * smallBucketDuration)) {
		
		
		
		ts.pending.Add(observation)
		ts.dirty = true
	} else {
		ts.mergeValue(observation, t)
	}
}
func (ts *timeSeries) mergeValue(observation Observable, t time.Time) {
	for _, level := range ts.levels {
		index := (ts.numBuckets - 1) - int(level.end.Sub(t)
		if 0 <= index && index < ts.numBuckets {
			bucketNumber := (level.oldest + index) % ts.numBuckets
			if level.buckets[bucketNumber] == nil {
				level.buckets[bucketNumber] = level.provider()
			}
			level.buckets[bucketNumber].Add(observation)
		}
	}
	ts.total.Add(observation)
}
func (ts *timeSeries) mergePendingUpdates() {
	if ts.dirty {
		ts.mergeValue(ts.pending, ts.pendingTime)
		ts.pending = ts.resetObservation(ts.pending)
		ts.dirty = false
	}
}
func (ts *timeSeries) advance(t time.Time) {
	if !t.After(ts.levels[0].end) {
		return
	}
	for i := 0; i < len(ts.levels); i++ {
		level := ts.levels[i]
		if !level.end.Before(t) {
			break
		}
		
		
		if !t.Before(level.end.Add(level.size * time.Duration(ts.numBuckets))) {
			for _, b := range level.buckets {
				ts.resetObservation(b)
			}
			level.end = time.Unix(0, (t.UnixNano()
		}
		for t.After(level.end) {
			level.end = level.end.Add(level.size)
			level.newest = level.oldest
			level.oldest = (level.oldest + 1) % ts.numBuckets
			ts.resetObservation(level.buckets[level.newest])
		}
		t = level.end
	}
}
func (ts *timeSeries) Latest(level, num int) Observable {
	now := ts.clock.Time()
	if ts.levels[0].end.Before(now) {
		ts.advance(now)
	}
	ts.mergePendingUpdates()
	result := ts.provider()
	l := ts.levels[level]
	index := l.newest
	for i := 0; i < num; i++ {
		if l.buckets[index] != nil {
			result.Add(l.buckets[index])
		}
		if index == 0 {
			index = ts.numBuckets
		}
		index--
	}
	return result
}
func (ts *timeSeries) LatestBuckets(level, num int) []Observable {
	if level < 0 || level > len(ts.levels) {
		log.Print("timeseries: bad level argument: ", level)
		return nil
	}
	if num < 0 || num >= ts.numBuckets {
		log.Print("timeseries: bad num argument: ", num)
		return nil
	}
	results := make([]Observable, num)
	now := ts.clock.Time()
	if ts.levels[0].end.Before(now) {
		ts.advance(now)
	}
	ts.mergePendingUpdates()
	l := ts.levels[level]
	index := l.newest
	for i := 0; i < num; i++ {
		result := ts.provider()
		results[i] = result
		if l.buckets[index] != nil {
			result.CopyFrom(l.buckets[index])
		}
		if index == 0 {
			index = ts.numBuckets
		}
		index -= 1
	}
	return results
}
func (ts *timeSeries) ScaleBy(factor float64) {
	for _, l := range ts.levels {
		for i := 0; i < ts.numBuckets; i++ {
			l.buckets[i].Multiply(factor)
		}
	}
	ts.total.Multiply(factor)
	ts.pending.Multiply(factor)
}
func (ts *timeSeries) Range(start, finish time.Time) Observable {
	return ts.ComputeRange(start, finish, 1)[0]
}
func (ts *timeSeries) Recent(delta time.Duration) Observable {
	now := ts.clock.Time()
	return ts.Range(now.Add(-delta), now)
}
func (ts *timeSeries) Total() Observable {
	ts.mergePendingUpdates()
	return ts.total
}
func (ts *timeSeries) ComputeRange(start, finish time.Time, num int) []Observable {
	if start.After(finish) {
		log.Printf("timeseries: start > finish, %v>%v", start, finish)
		return nil
	}
	if num < 0 {
		log.Printf("timeseries: num < 0, %v", num)
		return nil
	}
	results := make([]Observable, num)
	for _, l := range ts.levels {
		if !start.Before(l.end.Add(-l.size * time.Duration(ts.numBuckets))) {
			ts.extract(l, start, finish, num, results)
			return results
		}
	}
	
	
	
	ts.extract(ts.levels[len(ts.levels)-1], start, finish, num, results)
	return results
}
func (ts *timeSeries) RecentList(delta time.Duration, num int) []Observable {
	if delta < 0 {
		return nil
	}
	now := ts.clock.Time()
	return ts.ComputeRange(now.Add(-delta), now, num)
}
func (ts *timeSeries) extract(l *tsLevel, start, finish time.Time, num int, results []Observable) {
	ts.mergePendingUpdates()
	srcInterval := l.size
	dstInterval := finish.Sub(start) 
	dstStart := start
	srcStart := l.end.Add(-srcInterval * time.Duration(ts.numBuckets))
	srcIndex := 0
	
	if dstStart.After(srcStart) {
		advance := dstStart.Sub(srcStart) 
		srcIndex += int(advance)
		srcStart = srcStart.Add(advance * srcInterval)
	}
	
	
	
	
	
	for i := 0; i < num; i++ {
		results[i] = ts.resetObservation(results[i])
		dstEnd := dstStart.Add(dstInterval)
		for srcIndex < ts.numBuckets && srcStart.Before(dstEnd) {
			srcEnd := srcStart.Add(srcInterval)
			if srcEnd.After(ts.lastAdd) {
				srcEnd = ts.lastAdd
			}
			if !srcEnd.Before(dstStart) {
				srcValue := l.buckets[(srcIndex+l.oldest)%ts.numBuckets]
				if !srcStart.Before(dstStart) && !srcEnd.After(dstEnd) {
					
					if srcValue != nil {
						results[i].Add(srcValue)
					}
				} else {
					
					overlapStart := maxTime(srcStart, dstStart)
					overlapEnd := minTime(srcEnd, dstEnd)
					base := srcEnd.Sub(srcStart)
					fraction := overlapEnd.Sub(overlapStart).Seconds() 
					used := ts.provider()
					if srcValue != nil {
						used.CopyFrom(srcValue)
					}
					used.Multiply(fraction)
					results[i].Add(used)
				}
				if srcEnd.After(dstEnd) {
					break
				}
			}
			srcIndex++
			srcStart = srcStart.Add(srcInterval)
		}
		dstStart = dstStart.Add(dstInterval)
	}
}
func (ts *timeSeries) resetObservation(observation Observable) Observable {
	if observation == nil {
		observation = ts.provider()
	} else {
		observation.Clear()
	}
	return observation
}
type TimeSeries struct {
	timeSeries
}
func NewTimeSeries(f func() Observable) *TimeSeries {
	return NewTimeSeriesWithClock(f, defaultClockInstance)
}
func NewTimeSeriesWithClock(f func() Observable, clock Clock) *TimeSeries {
	ts := new(TimeSeries)
	ts.timeSeries.init(timeSeriesResolutions, f, timeSeriesNumBuckets, clock)
	return ts
}
type MinuteHourSeries struct {
	timeSeries
}
func NewMinuteHourSeries(f func() Observable) *MinuteHourSeries {
	return NewMinuteHourSeriesWithClock(f, defaultClockInstance)
}
func NewMinuteHourSeriesWithClock(f func() Observable, clock Clock) *MinuteHourSeries {
	ts := new(MinuteHourSeries)
	ts.timeSeries.init(minuteHourSeriesResolutions, f,
		minuteHourSeriesNumBuckets, clock)
	return ts
}
func (ts *MinuteHourSeries) Minute() Observable {
	return ts.timeSeries.Latest(0, 60)
}
func (ts *MinuteHourSeries) Hour() Observable {
	return ts.timeSeries.Latest(1, 60)
}
func minTime(a, b time.Time) time.Time {
	if a.Before(b) {
		return a
	}
	return b
}
func maxTime(a, b time.Time) time.Time {
	if a.After(b) {
		return a
	}
	return b
}
package timeseries
import (
	"math"
	"testing"
	"time"
)
func isNear(x *Float, y float64, tolerance float64) bool {
	return math.Abs(x.Value()-y) < tolerance
}
func isApproximate(x *Float, y float64) bool {
	return isNear(x, y, 1e-2)
}
func checkApproximate(t *testing.T, o Observable, y float64) {
	x := o.(*Float)
	if !isApproximate(x, y) {
		t.Errorf("Wanted %g, got %g", y, x.Value())
	}
}
func checkNear(t *testing.T, o Observable, y, tolerance float64) {
	x := o.(*Float)
	if !isNear(x, y, tolerance) {
		t.Errorf("Wanted %g +- %g, got %g", y, tolerance, x.Value())
	}
}
var baseTime = time.Date(2013, 1, 1, 0, 0, 0, 0, time.UTC)
func tu(s int64) time.Time {
	return baseTime.Add(time.Duration(s) * time.Second)
}
func tu2(s int64, ns int64) time.Time {
	return baseTime.Add(time.Duration(s)*time.Second + time.Duration(ns)*time.Nanosecond)
}
func TestBasicTimeSeries(t *testing.T) {
	ts := NewTimeSeries(NewFloat)
	fo := new(Float)
	*fo = Float(10)
	ts.AddWithTime(fo, tu(1))
	ts.AddWithTime(fo, tu(1))
	ts.AddWithTime(fo, tu(1))
	ts.AddWithTime(fo, tu(1))
	checkApproximate(t, ts.Range(tu(0), tu(1)), 40)
	checkApproximate(t, ts.Total(), 40)
	ts.AddWithTime(fo, tu(3))
	ts.AddWithTime(fo, tu(3))
	ts.AddWithTime(fo, tu(3))
	checkApproximate(t, ts.Range(tu(0), tu(2)), 40)
	checkApproximate(t, ts.Range(tu(2), tu(4)), 30)
	checkApproximate(t, ts.Total(), 70)
	ts.AddWithTime(fo, tu(1))
	ts.AddWithTime(fo, tu(1))
	checkApproximate(t, ts.Range(tu(0), tu(2)), 60)
	checkApproximate(t, ts.Range(tu(2), tu(4)), 30)
	checkApproximate(t, ts.Total(), 90)
	*fo = Float(100)
	ts.AddWithTime(fo, tu(100))
	checkApproximate(t, ts.Range(tu(99), tu(100)), 100)
	checkApproximate(t, ts.Range(tu(0), tu(4)), 36)
	checkApproximate(t, ts.Total(), 190)
	*fo = Float(10)
	ts.AddWithTime(fo, tu(1))
	ts.AddWithTime(fo, tu(1))
	checkApproximate(t, ts.Range(tu(0), tu(4)), 44)
	checkApproximate(t, ts.Range(tu(37), tu2(100, 100e6)), 100)
	checkApproximate(t, ts.Range(tu(50), tu2(100, 100e6)), 100)
	checkApproximate(t, ts.Range(tu(99), tu2(100, 100e6)), 100)
	checkApproximate(t, ts.Total(), 210)
	for i, l := range ts.ComputeRange(tu(36), tu(100), 64) {
		if i == 63 {
			checkApproximate(t, l, 100)
		} else {
			checkApproximate(t, l, 0)
		}
	}
	checkApproximate(t, ts.Range(tu(0), tu(100)), 210)
	checkApproximate(t, ts.Range(tu(10), tu(100)), 100)
	for i, l := range ts.ComputeRange(tu(0), tu(100), 100) {
		if i < 10 {
			checkApproximate(t, l, 11)
		} else if i >= 90 {
			checkApproximate(t, l, 10)
		} else {
			checkApproximate(t, l, 0)
		}
	}
}
func TestFloat(t *testing.T) {
	f := Float(1)
	if g, w := f.String(), "1"; g != w {
		t.Errorf("Float(1).String = %q; want %q", g, w)
	}
	f2 := Float(2)
	var o Observable = &f2
	f.Add(o)
	if g, w := f.Value(), 3.0; g != w {
		t.Errorf("Float post-add = %v; want %v", g, w)
	}
	f.Multiply(2)
	if g, w := f.Value(), 6.0; g != w {
		t.Errorf("Float post-multiply = %v; want %v", g, w)
	}
	f.Clear()
	if g, w := f.Value(), 0.0; g != w {
		t.Errorf("Float post-clear = %v; want %v", g, w)
	}
	f.CopyFrom(&f2)
	if g, w := f.Value(), 2.0; g != w {
		t.Errorf("Float post-CopyFrom = %v; want %v", g, w)
	}
}
type mockClock struct {
	time time.Time
}
func (m *mockClock) Time() time.Time { return m.time }
func (m *mockClock) Set(t time.Time) { m.time = t }
const buckets = 6
var testResolutions = []time.Duration{
	10 * time.Second,  
	100 * time.Second, 
	10 * time.Minute,  
}
type TestTimeSeries struct {
	timeSeries
}
func TestExpectedErrorRate(t *testing.T) {
	ts := new(TestTimeSeries)
	fake := new(mockClock)
	fake.Set(time.Now())
	ts.timeSeries.init(testResolutions, NewFloat, buckets, fake)
	for i := 1; i <= 61*61; i++ {
		fake.Set(fake.Time().Add(1 * time.Second))
		ob := Float(1)
		ts.AddWithTime(&ob, fake.Time())
		
		checkNear(t, ts.Latest(0, buckets), min(float64(i), 60), 10)
		checkNear(t, ts.Latest(1, buckets), min(float64(i), 600), 100)
		checkNear(t, ts.Latest(2, buckets), min(float64(i), 3600), 600)
	}
}
func min(a, b float64) float64 {
	if a < b {
		return a
	}
	return b
}
package iana 
const (
	DiffServCS0        = 0x0  
	DiffServCS1        = 0x20 
	DiffServCS2        = 0x40 
	DiffServCS3        = 0x60 
	DiffServCS4        = 0x80 
	DiffServCS5        = 0xa0 
	DiffServCS6        = 0xc0 
	DiffServCS7        = 0xe0 
	DiffServAF11       = 0x28 
	DiffServAF12       = 0x30 
	DiffServAF13       = 0x38 
	DiffServAF21       = 0x48 
	DiffServAF22       = 0x50 
	DiffServAF23       = 0x58 
	DiffServAF31       = 0x68 
	DiffServAF32       = 0x70 
	DiffServAF33       = 0x78 
	DiffServAF41       = 0x88 
	DiffServAF42       = 0x90 
	DiffServAF43       = 0x98 
	DiffServEF         = 0xb8 
	DiffServVOICEADMIT = 0xb0 
)
const (
	NotECNTransport       = 0x0 
	ECNTransport1         = 0x1 
	ECNTransport0         = 0x2 
	CongestionExperienced = 0x3 
)
const (
	ProtocolIP             = 0   
	ProtocolHOPOPT         = 0   
	ProtocolICMP           = 1   
	ProtocolIGMP           = 2   
	ProtocolGGP            = 3   
	ProtocolIPv4           = 4   
	ProtocolST             = 5   
	ProtocolTCP            = 6   
	ProtocolCBT            = 7   
	ProtocolEGP            = 8   
	ProtocolIGP            = 9   
	ProtocolBBNRCCMON      = 10  
	ProtocolNVPII          = 11  
	ProtocolPUP            = 12  
	ProtocolEMCON          = 14  
	ProtocolXNET           = 15  
	ProtocolCHAOS          = 16  
	ProtocolUDP            = 17  
	ProtocolMUX            = 18  
	ProtocolDCNMEAS        = 19  
	ProtocolHMP            = 20  
	ProtocolPRM            = 21  
	ProtocolXNSIDP         = 22  
	ProtocolTRUNK1         = 23  
	ProtocolTRUNK2         = 24  
	ProtocolLEAF1          = 25  
	ProtocolLEAF2          = 26  
	ProtocolRDP            = 27  
	ProtocolIRTP           = 28  
	ProtocolISOTP4         = 29  
	ProtocolNETBLT         = 30  
	ProtocolMFENSP         = 31  
	ProtocolMERITINP       = 32  
	ProtocolDCCP           = 33  
	Protocol3PC            = 34  
	ProtocolIDPR           = 35  
	ProtocolXTP            = 36  
	ProtocolDDP            = 37  
	ProtocolIDPRCMTP       = 38  
	ProtocolTPPP           = 39  
	ProtocolIL             = 40  
	ProtocolIPv6           = 41  
	ProtocolSDRP           = 42  
	ProtocolIPv6Route      = 43  
	ProtocolIPv6Frag       = 44  
	ProtocolIDRP           = 45  
	ProtocolRSVP           = 46  
	ProtocolGRE            = 47  
	ProtocolDSR            = 48  
	ProtocolBNA            = 49  
	ProtocolESP            = 50  
	ProtocolAH             = 51  
	ProtocolINLSP          = 52  
	ProtocolNARP           = 54  
	ProtocolMOBILE         = 55  
	ProtocolTLSP           = 56  
	ProtocolSKIP           = 57  
	ProtocolIPv6ICMP       = 58  
	ProtocolIPv6NoNxt      = 59  
	ProtocolIPv6Opts       = 60  
	ProtocolCFTP           = 62  
	ProtocolSATEXPAK       = 64  
	ProtocolKRYPTOLAN      = 65  
	ProtocolRVD            = 66  
	ProtocolIPPC           = 67  
	ProtocolSATMON         = 69  
	ProtocolVISA           = 70  
	ProtocolIPCV           = 71  
	ProtocolCPNX           = 72  
	ProtocolCPHB           = 73  
	ProtocolWSN            = 74  
	ProtocolPVP            = 75  
	ProtocolBRSATMON       = 76  
	ProtocolSUNND          = 77  
	ProtocolWBMON          = 78  
	ProtocolWBEXPAK        = 79  
	ProtocolISOIP          = 80  
	ProtocolVMTP           = 81  
	ProtocolSECUREVMTP     = 82  
	ProtocolVINES          = 83  
	ProtocolTTP            = 84  
	ProtocolIPTM           = 84  
	ProtocolNSFNETIGP      = 85  
	ProtocolDGP            = 86  
	ProtocolTCF            = 87  
	ProtocolEIGRP          = 88  
	ProtocolOSPFIGP        = 89  
	ProtocolSpriteRPC      = 90  
	ProtocolLARP           = 91  
	ProtocolMTP            = 92  
	ProtocolAX25           = 93  
	ProtocolIPIP           = 94  
	ProtocolSCCSP          = 96  
	ProtocolETHERIP        = 97  
	ProtocolENCAP          = 98  
	ProtocolGMTP           = 100 
	ProtocolIFMP           = 101 
	ProtocolPNNI           = 102 
	ProtocolPIM            = 103 
	ProtocolARIS           = 104 
	ProtocolSCPS           = 105 
	ProtocolQNX            = 106 
	ProtocolAN             = 107 
	ProtocolIPComp         = 108 
	ProtocolSNP            = 109 
	ProtocolCompaqPeer     = 110 
	ProtocolIPXinIP        = 111 
	ProtocolVRRP           = 112 
	ProtocolPGM            = 113 
	ProtocolL2TP           = 115 
	ProtocolDDX            = 116 
	ProtocolIATP           = 117 
	ProtocolSTP            = 118 
	ProtocolSRP            = 119 
	ProtocolUTI            = 120 
	ProtocolSMP            = 121 
	ProtocolPTP            = 123 
	ProtocolISIS           = 124 
	ProtocolFIRE           = 125 
	ProtocolCRTP           = 126 
	ProtocolCRUDP          = 127 
	ProtocolSSCOPMCE       = 128 
	ProtocolIPLT           = 129 
	ProtocolSPS            = 130 
	ProtocolPIPE           = 131 
	ProtocolSCTP           = 132 
	ProtocolFC             = 133 
	ProtocolRSVPE2EIGNORE  = 134 
	ProtocolMobilityHeader = 135 
	ProtocolUDPLite        = 136 
	ProtocolMPLSinIP       = 137 
	ProtocolMANET          = 138 
	ProtocolHIP            = 139 
	ProtocolShim6          = 140 
	ProtocolWESP           = 141 
	ProtocolROHC           = 142 
	ProtocolReserved       = 255 
)
package main
import (
	"bytes"
	"encoding
	"fmt"
	"go
	"io"
	"io
	"net
	"os"
	"strconv"
	"strings"
)
var registries = []struct {
	url   string
	parse func(io.Writer, io.Reader) error
}{
	{
		"http:
		parseDSCPRegistry,
	},
	{
		"http:
		parseTOSTCByte,
	},
	{
		"http:
		parseProtocolNumbers,
	},
}
func main() {
	var bb bytes.Buffer
	fmt.Fprintf(&bb, "
	fmt.Fprintf(&bb, "
	fmt.Fprintf(&bb, "
	fmt.Fprintf(&bb, `package iana 
	for _, r := range registries {
		resp, err := http.Get(r.url)
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(1)
		}
		defer resp.Body.Close()
		if resp.StatusCode != http.StatusOK {
			fmt.Fprintf(os.Stderr, "got HTTP status code %v for %v\n", resp.StatusCode, r.url)
			os.Exit(1)
		}
		if err := r.parse(&bb, resp.Body); err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(1)
		}
		fmt.Fprintf(&bb, "\n")
	}
	b, err := format.Source(bb.Bytes())
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	if err := ioutil.WriteFile("const.go", b, 0644); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}
func parseDSCPRegistry(w io.Writer, r io.Reader) error {
	dec := xml.NewDecoder(r)
	var dr dscpRegistry
	if err := dec.Decode(&dr); err != nil {
		return err
	}
	drs := dr.escape()
	fmt.Fprintf(w, "
	fmt.Fprintf(w, "const (\n")
	for _, dr := range drs {
		fmt.Fprintf(w, "DiffServ%s = %#x", dr.Name, dr.Value)
		fmt.Fprintf(w, "
	}
	fmt.Fprintf(w, ")\n")
	return nil
}
type dscpRegistry struct {
	XMLName     xml.Name `xml:"registry"`
	Title       string   `xml:"title"`
	Updated     string   `xml:"updated"`
	Note        string   `xml:"note"`
	RegTitle    string   `xml:"registry>title"`
	PoolRecords []struct {
		Name  string `xml:"name"`
		Space string `xml:"space"`
	} `xml:"registry>record"`
	Records []struct {
		Name  string `xml:"name"`
		Space string `xml:"space"`
	} `xml:"registry>registry>record"`
}
type canonDSCPRecord struct {
	OrigName string
	Name     string
	Value    int
}
func (drr *dscpRegistry) escape() []canonDSCPRecord {
	drs := make([]canonDSCPRecord, len(drr.Records))
	sr := strings.NewReplacer(
		"+", "",
		"-", "",
		"
		".", "",
		" ", "",
	)
	for i, dr := range drr.Records {
		s := strings.TrimSpace(dr.Name)
		drs[i].OrigName = s
		drs[i].Name = sr.Replace(s)
		n, err := strconv.ParseUint(dr.Space, 2, 8)
		if err != nil {
			continue
		}
		drs[i].Value = int(n) << 2
	}
	return drs
}
func parseTOSTCByte(w io.Writer, r io.Reader) error {
	dec := xml.NewDecoder(r)
	var ttb tosTCByte
	if err := dec.Decode(&ttb); err != nil {
		return err
	}
	trs := ttb.escape()
	fmt.Fprintf(w, "
	fmt.Fprintf(w, "const (\n")
	for _, tr := range trs {
		fmt.Fprintf(w, "%s = %#x", tr.Keyword, tr.Value)
		fmt.Fprintf(w, "
	}
	fmt.Fprintf(w, ")\n")
	return nil
}
type tosTCByte struct {
	XMLName  xml.Name `xml:"registry"`
	Title    string   `xml:"title"`
	Updated  string   `xml:"updated"`
	Note     string   `xml:"note"`
	RegTitle string   `xml:"registry>title"`
	Records  []struct {
		Binary  string `xml:"binary"`
		Keyword string `xml:"keyword"`
	} `xml:"registry>record"`
}
type canonTOSTCByteRecord struct {
	OrigKeyword string
	Keyword     string
	Value       int
}
func (ttb *tosTCByte) escape() []canonTOSTCByteRecord {
	trs := make([]canonTOSTCByteRecord, len(ttb.Records))
	sr := strings.NewReplacer(
		"Capable", "",
		"(", "",
		")", "",
		"+", "",
		"-", "",
		"
		".", "",
		" ", "",
	)
	for i, tr := range ttb.Records {
		s := strings.TrimSpace(tr.Keyword)
		trs[i].OrigKeyword = s
		ss := strings.Split(s, " ")
		if len(ss) > 1 {
			trs[i].Keyword = strings.Join(ss[1:], " ")
		} else {
			trs[i].Keyword = ss[0]
		}
		trs[i].Keyword = sr.Replace(trs[i].Keyword)
		n, err := strconv.ParseUint(tr.Binary, 2, 8)
		if err != nil {
			continue
		}
		trs[i].Value = int(n)
	}
	return trs
}
func parseProtocolNumbers(w io.Writer, r io.Reader) error {
	dec := xml.NewDecoder(r)
	var pn protocolNumbers
	if err := dec.Decode(&pn); err != nil {
		return err
	}
	prs := pn.escape()
	prs = append([]canonProtocolRecord{{
		Name:  "IP",
		Descr: "IPv4 encapsulation, pseudo protocol number",
		Value: 0,
	}}, prs...)
	fmt.Fprintf(w, "
	fmt.Fprintf(w, "const (\n")
	for _, pr := range prs {
		if pr.Name == "" {
			continue
		}
		fmt.Fprintf(w, "Protocol%s = %d", pr.Name, pr.Value)
		s := pr.Descr
		if s == "" {
			s = pr.OrigName
		}
		fmt.Fprintf(w, "
	}
	fmt.Fprintf(w, ")\n")
	return nil
}
type protocolNumbers struct {
	XMLName  xml.Name `xml:"registry"`
	Title    string   `xml:"title"`
	Updated  string   `xml:"updated"`
	RegTitle string   `xml:"registry>title"`
	Note     string   `xml:"registry>note"`
	Records  []struct {
		Value string `xml:"value"`
		Name  string `xml:"name"`
		Descr string `xml:"description"`
	} `xml:"registry>record"`
}
type canonProtocolRecord struct {
	OrigName string
	Name     string
	Descr    string
	Value    int
}
func (pn *protocolNumbers) escape() []canonProtocolRecord {
	prs := make([]canonProtocolRecord, len(pn.Records))
	sr := strings.NewReplacer(
		"-in-", "in",
		"-within-", "within",
		"-over-", "over",
		"+", "P",
		"-", "",
		"
		".", "",
		" ", "",
	)
	for i, pr := range pn.Records {
		if strings.Contains(pr.Name, "Deprecated") ||
			strings.Contains(pr.Name, "deprecated") {
			continue
		}
		prs[i].OrigName = pr.Name
		s := strings.TrimSpace(pr.Name)
		switch pr.Name {
		case "ISIS over IPv4":
			prs[i].Name = "ISIS"
		case "manet":
			prs[i].Name = "MANET"
		default:
			prs[i].Name = sr.Replace(s)
		}
		ss := strings.Split(pr.Descr, "\n")
		for i := range ss {
			ss[i] = strings.TrimSpace(ss[i])
		}
		if len(ss) > 1 {
			prs[i].Descr = strings.Join(ss, " ")
		} else {
			prs[i].Descr = ss[0]
		}
		prs[i].Value, _ = strconv.Atoi(pr.Value)
	}
	return prs
}
package socket
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0x1c
	sysSOCK_RAW = 0x3
)
type iovec struct {
	Base *byte
	Len  uint64
}
type msghdr struct {
	Name       *byte
	Namelen    uint32
	Pad_cgo_0  [4]byte
	Iov        *iovec
	Iovlen     int32
	Pad_cgo_1  [4]byte
	Control    *byte
	Controllen uint32
	Flags      int32
}
type cmsghdr struct {
	Len   uint32
	Level int32
	Type  int32
}
type sockaddrInet struct {
	Len    uint8
	Family uint8
	Port   uint16
	Addr   [4]byte 
	Zero   [8]int8
}
type sockaddrInet6 struct {
	Len      uint8
	Family   uint8
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte 
	Scope_id uint32
}
const (
	sizeofIovec   = 0x10
	sizeofMsghdr  = 0x30
	sizeofCmsghdr = 0xc
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x1c
)
package socket
import "unsafe"
func (v *iovec) set(b []byte) {
	v.Base = (*int8)(unsafe.Pointer(&b[0]))
	v.Len = uint64(len(b))
}
package socket
import (
	"net"
	"os"
	"syscall"
)
func (c *Conn) recvMsgs(ms []Message, flags int) (int, error) {
	hs := make(mmsghdrs, len(ms))
	var parseFn func([]byte, string) (net.Addr, error)
	if c.network != "tcp" {
		parseFn = parseInetAddr
	}
	if err := hs.pack(ms, parseFn, nil); err != nil {
		return 0, err
	}
	var operr error
	var n int
	fn := func(s uintptr) bool {
		n, operr = recvmmsg(s, hs, flags)
		if operr == syscall.EAGAIN {
			return false
		}
		return true
	}
	if err := c.c.Read(fn); err != nil {
		return n, err
	}
	if operr != nil {
		return n, os.NewSyscallError("recvmmsg", operr)
	}
	if err := hs[:n].unpack(ms[:n], parseFn, c.network); err != nil {
		return n, err
	}
	return n, nil
}
func (c *Conn) sendMsgs(ms []Message, flags int) (int, error) {
	hs := make(mmsghdrs, len(ms))
	var marshalFn func(net.Addr) []byte
	if c.network != "tcp" {
		marshalFn = marshalInetAddr
	}
	if err := hs.pack(ms, nil, marshalFn); err != nil {
		return 0, err
	}
	var operr error
	var n int
	fn := func(s uintptr) bool {
		n, operr = sendmmsg(s, hs, flags)
		if operr == syscall.EAGAIN {
			return false
		}
		return true
	}
	if err := c.c.Write(fn); err != nil {
		return n, err
	}
	if operr != nil {
		return n, os.NewSyscallError("sendmmsg", operr)
	}
	if err := hs[:n].unpack(ms[:n], nil, ""); err != nil {
		return n, err
	}
	return n, nil
}
package socket
import "unsafe"
func (v *iovec) set(b []byte) {
	v.Base = (*byte)(unsafe.Pointer(&b[0]))
	v.Len = uint32(len(b))
}
package socket
import (
	"errors"
	"syscall"
	"unsafe"
)
func probeProtocolStack() int {
	var p uintptr
	return int(unsafe.Sizeof(p))
}
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0x17
	sysSOCK_RAW = 0x3
)
type sockaddrInet struct {
	Family uint16
	Port   uint16
	Addr   [4]byte 
	Zero   [8]uint8
}
type sockaddrInet6 struct {
	Family   uint16
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte 
	Scope_id uint32
}
const (
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x1c
)
func getsockopt(s uintptr, level, name int, b []byte) (int, error) {
	l := uint32(len(b))
	err := syscall.Getsockopt(syscall.Handle(s), int32(level), int32(name), (*byte)(unsafe.Pointer(&b[0])), (*int32)(unsafe.Pointer(&l)))
	return int(l), err
}
func setsockopt(s uintptr, level, name int, b []byte) error {
	return syscall.Setsockopt(syscall.Handle(s), int32(level), int32(name), (*byte)(unsafe.Pointer(&b[0])), int32(len(b)))
}
func recvmsg(s uintptr, h *msghdr, flags int) (int, error) {
	return 0, errors.New("not implemented")
}
func sendmsg(s uintptr, h *msghdr, flags int) (int, error) {
	return 0, errors.New("not implemented")
}
func recvmmsg(s uintptr, hs []mmsghdr, flags int) (int, error) {
	return 0, errors.New("not implemented")
}
func sendmmsg(s uintptr, hs []mmsghdr, flags int) (int, error) {
	return 0, errors.New("not implemented")
}
package socket
func (h *cmsghdr) set(l, lvl, typ int) {
	h.Len = uint32(l)
	h.Level = int32(lvl)
	h.Type = int32(typ)
}
package socket
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0xa
	sysSOCK_RAW = 0x3
)
type iovec struct {
	Base *byte
	Len  uint64
}
type msghdr struct {
	Name       *byte
	Namelen    uint32
	Pad_cgo_0  [4]byte
	Iov        *iovec
	Iovlen     uint64
	Control    *byte
	Controllen uint64
	Flags      int32
	Pad_cgo_1  [4]byte
}
type mmsghdr struct {
	Hdr       msghdr
	Len       uint32
	Pad_cgo_0 [4]byte
}
type cmsghdr struct {
	Len   uint64
	Level int32
	Type  int32
}
type sockaddrInet struct {
	Family uint16
	Port   uint16
	Addr   [4]byte 
	X__pad [8]uint8
}
type sockaddrInet6 struct {
	Family   uint16
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte 
	Scope_id uint32
}
const (
	sizeofIovec   = 0x10
	sizeofMsghdr  = 0x38
	sizeofMmsghdr = 0x40
	sizeofCmsghdr = 0x10
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x1c
)
package socket
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0xa
	sysSOCK_RAW = 0x3
)
type iovec struct {
	Base *byte
	Len  uint64
}
type msghdr struct {
	Name       *byte
	Namelen    uint32
	Pad_cgo_0  [4]byte
	Iov        *iovec
	Iovlen     uint64
	Control    *byte
	Controllen uint64
	Flags      int32
	Pad_cgo_1  [4]byte
}
type mmsghdr struct {
	Hdr       msghdr
	Len       uint32
	Pad_cgo_0 [4]byte
}
type cmsghdr struct {
	Len   uint64
	Level int32
	Type  int32
}
type sockaddrInet struct {
	Family uint16
	Port   uint16
	Addr   [4]byte 
	X__pad [8]uint8
}
type sockaddrInet6 struct {
	Family   uint16
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte 
	Scope_id uint32
}
const (
	sizeofIovec   = 0x10
	sizeofMsghdr  = 0x38
	sizeofMmsghdr = 0x40
	sizeofCmsghdr = 0x10
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x1c
)
package socket
type iovec struct{}
func (v *iovec) set(b []byte) {}
package socket
const (
	sysRECVMMSG = 0x10ef
	sysSENDMMSG = 0x10f7
)
package socket
const (
	sysRECVMMSG = 0x16d
	sysSENDMMSG = 0x176
)
package socket
import "unsafe"
func probeProtocolStack() int {
	var p uintptr
	return int(unsafe.Sizeof(p))
}
package socket
import (
	"syscall"
	"unsafe"
)
func getsockopt(s uintptr, level, name int, b []byte) (int, error) {
	l := uint32(len(b))
	_, _, errno := syscall.Syscall6(syscall.SYS_GETSOCKOPT, s, uintptr(level), uintptr(name), uintptr(unsafe.Pointer(&b[0])), uintptr(unsafe.Pointer(&l)), 0)
	return int(l), errnoErr(errno)
}
func setsockopt(s uintptr, level, name int, b []byte) error {
	_, _, errno := syscall.Syscall6(syscall.SYS_SETSOCKOPT, s, uintptr(level), uintptr(name), uintptr(unsafe.Pointer(&b[0])), uintptr(len(b)), 0)
	return errnoErr(errno)
}
func recvmsg(s uintptr, h *msghdr, flags int) (int, error) {
	n, _, errno := syscall.Syscall(syscall.SYS_RECVMSG, s, uintptr(unsafe.Pointer(h)), uintptr(flags))
	return int(n), errnoErr(errno)
}
func sendmsg(s uintptr, h *msghdr, flags int) (int, error) {
	n, _, errno := syscall.Syscall(syscall.SYS_SENDMSG, s, uintptr(unsafe.Pointer(h)), uintptr(flags))
	return int(n), errnoErr(errno)
}
package socket
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0x18
	sysSOCK_RAW = 0x3
)
type iovec struct {
	Base *byte
	Len  uint32
}
type msghdr struct {
	Name       *byte
	Namelen    uint32
	Iov        *iovec
	Iovlen     uint32
	Control    *byte
	Controllen uint32
	Flags      int32
}
type cmsghdr struct {
	Len   uint32
	Level int32
	Type  int32
}
type sockaddrInet struct {
	Len    uint8
	Family uint8
	Port   uint16
	Addr   [4]byte 
	Zero   [8]int8
}
type sockaddrInet6 struct {
	Len      uint8
	Family   uint8
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte 
	Scope_id uint32
}
const (
	sizeofIovec   = 0x8
	sizeofMsghdr  = 0x1c
	sizeofCmsghdr = 0xc
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x1c
)
package socket
import "net"
type mmsghdrs []mmsghdr
func (hs mmsghdrs) pack(ms []Message, parseFn func([]byte, string) (net.Addr, error), marshalFn func(net.Addr) []byte) error {
	for i := range hs {
		vs := make([]iovec, len(ms[i].Buffers))
		var sa []byte
		if parseFn != nil {
			sa = make([]byte, sizeofSockaddrInet6)
		}
		if marshalFn != nil {
			sa = marshalFn(ms[i].Addr)
		}
		hs[i].Hdr.pack(vs, ms[i].Buffers, ms[i].OOB, sa)
	}
	return nil
}
func (hs mmsghdrs) unpack(ms []Message, parseFn func([]byte, string) (net.Addr, error), hint string) error {
	for i := range hs {
		ms[i].N = int(hs[i].Len)
		ms[i].NN = hs[i].Hdr.controllen()
		ms[i].Flags = hs[i].Hdr.flags()
		if parseFn != nil {
			var err error
			ms[i].Addr, err = parseFn(hs[i].Hdr.name(), hint)
			if err != nil {
				return err
			}
		}
	}
	return nil
}
package socket
import "unsafe"
func (h *msghdr) pack(vs []iovec, bs [][]byte, oob []byte, sa []byte) {
	for i := range vs {
		vs[i].set(bs[i])
	}
	h.Iov = &vs[0]
	h.Iovlen = int32(len(vs))
	if len(oob) > 0 {
		h.Accrights = (*int8)(unsafe.Pointer(&oob[0]))
		h.Accrightslen = int32(len(oob))
	}
	if sa != nil {
		h.Name = (*byte)(unsafe.Pointer(&sa[0]))
		h.Namelen = uint32(len(sa))
	}
}
func (h *msghdr) controllen() int {
	return int(h.Accrightslen)
}
func (h *msghdr) flags() int {
	return int(NativeEndian.Uint32(h.Pad_cgo_2[:]))
}
package socket
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0xa
	sysSOCK_RAW = 0x3
)
type iovec struct {
	Base *byte
	Len  uint32
}
type msghdr struct {
	Name       *byte
	Namelen    uint32
	Iov        *iovec
	Iovlen     uint32
	Control    *byte
	Controllen uint32
	Flags      int32
}
type mmsghdr struct {
	Hdr msghdr
	Len uint32
}
type cmsghdr struct {
	Len   uint32
	Level int32
	Type  int32
}
type sockaddrInet struct {
	Family uint16
	Port   uint16
	Addr   [4]byte 
	X__pad [8]uint8
}
type sockaddrInet6 struct {
	Family   uint16
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte 
	Scope_id uint32
}
const (
	sizeofIovec   = 0x8
	sizeofMsghdr  = 0x1c
	sizeofMmsghdr = 0x20
	sizeofCmsghdr = 0xc
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x1c
)
package socket
import (
	"syscall"
	"unsafe"
)
func probeProtocolStack() int { return 8 }
const (
	sysSETSOCKOPT = 0xe
	sysGETSOCKOPT = 0xf
	sysSENDMSG    = 0x10
	sysRECVMSG    = 0x11
	sysRECVMMSG   = 0x13
	sysSENDMMSG   = 0x14
)
func socketcall(call, a0, a1, a2, a3, a4, a5 uintptr) (uintptr, syscall.Errno)
func rawsocketcall(call, a0, a1, a2, a3, a4, a5 uintptr) (uintptr, syscall.Errno)
func getsockopt(s uintptr, level, name int, b []byte) (int, error) {
	l := uint32(len(b))
	_, errno := socketcall(sysGETSOCKOPT, s, uintptr(level), uintptr(name), uintptr(unsafe.Pointer(&b[0])), uintptr(unsafe.Pointer(&l)), 0)
	return int(l), errnoErr(errno)
}
func setsockopt(s uintptr, level, name int, b []byte) error {
	_, errno := socketcall(sysSETSOCKOPT, s, uintptr(level), uintptr(name), uintptr(unsafe.Pointer(&b[0])), uintptr(len(b)), 0)
	return errnoErr(errno)
}
func recvmsg(s uintptr, h *msghdr, flags int) (int, error) {
	n, errno := socketcall(sysRECVMSG, s, uintptr(unsafe.Pointer(h)), uintptr(flags), 0, 0, 0)
	return int(n), errnoErr(errno)
}
func sendmsg(s uintptr, h *msghdr, flags int) (int, error) {
	n, errno := socketcall(sysSENDMSG, s, uintptr(unsafe.Pointer(h)), uintptr(flags), 0, 0, 0)
	return int(n), errnoErr(errno)
}
func recvmmsg(s uintptr, hs []mmsghdr, flags int) (int, error) {
	n, errno := socketcall(sysRECVMMSG, s, uintptr(unsafe.Pointer(&hs[0])), uintptr(len(hs)), uintptr(flags), 0, 0)
	return int(n), errnoErr(errno)
}
func sendmmsg(s uintptr, hs []mmsghdr, flags int) (int, error) {
	n, errno := socketcall(sysSENDMMSG, s, uintptr(unsafe.Pointer(&hs[0])), uintptr(len(hs)), uintptr(flags), 0, 0)
	return int(n), errnoErr(errno)
}
package socket
import (
	"os"
	"syscall"
)
func (c *Conn) recvMsg(m *Message, flags int) error {
	var h msghdr
	vs := make([]iovec, len(m.Buffers))
	var sa []byte
	if c.network != "tcp" {
		sa = make([]byte, sizeofSockaddrInet6)
	}
	h.pack(vs, m.Buffers, m.OOB, sa)
	var operr error
	var n int
	fn := func(s uintptr) bool {
		n, operr = recvmsg(s, &h, flags)
		if operr == syscall.EAGAIN {
			return false
		}
		return true
	}
	if err := c.c.Read(fn); err != nil {
		return err
	}
	if operr != nil {
		return os.NewSyscallError("recvmsg", operr)
	}
	if c.network != "tcp" {
		var err error
		m.Addr, err = parseInetAddr(sa[:], c.network)
		if err != nil {
			return err
		}
	}
	m.N = n
	m.NN = h.controllen()
	m.Flags = h.flags()
	return nil
}
func (c *Conn) sendMsg(m *Message, flags int) error {
	var h msghdr
	vs := make([]iovec, len(m.Buffers))
	var sa []byte
	if m.Addr != nil {
		sa = marshalInetAddr(m.Addr)
	}
	h.pack(vs, m.Buffers, m.OOB, sa)
	var operr error
	var n int
	fn := func(s uintptr) bool {
		n, operr = sendmsg(s, &h, flags)
		if operr == syscall.EAGAIN {
			return false
		}
		return true
	}
	if err := c.c.Write(fn); err != nil {
		return err
	}
	if operr != nil {
		return os.NewSyscallError("sendmsg", operr)
	}
	m.N = n
	m.NN = len(m.OOB)
	return nil
}
package socket
import "errors"
func (c *Conn) recvMsg(m *Message, flags int) error {
	return errors.New("not implemented")
}
func (c *Conn) sendMsg(m *Message, flags int) error {
	return errors.New("not implemented")
}
func (c *Conn) recvMsgs(ms []Message, flags int) (int, error) {
	return 0, errors.New("not implemented")
}
func (c *Conn) sendMsgs(ms []Message, flags int) (int, error) {
	return 0, errors.New("not implemented")
}
package socket
import (
	"errors"
	"net"
	"runtime"
	"unsafe"
)
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0xa
	sysSOCK_RAW = 0x3
)
func probeProtocolStack() int {
	switch runtime.GOARCH {
	case "amd64p32", "mips64p32":
		return 4
	default:
		var p uintptr
		return int(unsafe.Sizeof(p))
	}
}
func marshalInetAddr(ip net.IP, port int, zone string) []byte {
	return nil
}
func parseInetAddr(b []byte, network string) (net.Addr, error) {
	return nil, errors.New("not implemented")
}
func getsockopt(s uintptr, level, name int, b []byte) (int, error) {
	return 0, errors.New("not implemented")
}
func setsockopt(s uintptr, level, name int, b []byte) error {
	return errors.New("not implemented")
}
func recvmsg(s uintptr, h *msghdr, flags int) (int, error) {
	return 0, errors.New("not implemented")
}
func sendmsg(s uintptr, h *msghdr, flags int) (int, error) {
	return 0, errors.New("not implemented")
}
func recvmmsg(s uintptr, hs []mmsghdr, flags int) (int, error) {
	return 0, errors.New("not implemented")
}
func sendmmsg(s uintptr, hs []mmsghdr, flags int) (int, error) {
	return 0, errors.New("not implemented")
}
package socket
const (
	sysRECVMMSG = 0x157
	sysSENDMMSG = 0x15d
)
package socket
#include <sys
#include <netinet
*
import "C"
const (
	sysAF_UNSPEC = C.AF_UNSPEC
	sysAF_INET   = C.AF_INET
	sysAF_INET6  = C.AF_INET6
	sysSOCK_RAW = C.SOCK_RAW
)
type iovec C.struct_iovec
type msghdr C.struct_msghdr
type cmsghdr C.struct_cmsghdr
type sockaddrInet C.struct_sockaddr_in
type sockaddrInet6 C.struct_sockaddr_in6
const (
	sizeofIovec   = C.sizeof_struct_iovec
	sizeofMsghdr  = C.sizeof_struct_msghdr
	sizeofCmsghdr = C.sizeof_struct_cmsghdr
	sizeofSockaddrInet  = C.sizeof_struct_sockaddr_in
	sizeofSockaddrInet6 = C.sizeof_struct_sockaddr_in6
)
package socket
const (
	sysRECVMMSG = 0xf3
	sysSENDMMSG = 0x10d
)
package socket
import "syscall"
var (
	errEAGAIN error = syscall.EAGAIN
	errEINVAL error = syscall.EINVAL
	errENOENT error = syscall.ENOENT
)
func errnoErr(errno syscall.Errno) error {
	switch errno {
	case 0:
		return nil
	case syscall.EAGAIN:
		return errEAGAIN
	case syscall.EINVAL:
		return errEINVAL
	case syscall.ENOENT:
		return errENOENT
	}
	return errno
}
package socket
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0x1e
	sysSOCK_RAW = 0x3
)
type iovec struct {
	Base *byte
	Len  uint32
}
type msghdr struct {
	Name       *byte
	Namelen    uint32
	Iov        *iovec
	Iovlen     int32
	Control    *byte
	Controllen uint32
	Flags      int32
}
type cmsghdr struct {
	Len   uint32
	Level int32
	Type  int32
}
type sockaddrInet struct {
	Len    uint8
	Family uint8
	Port   uint16
	Addr   [4]byte 
	Zero   [8]int8
}
type sockaddrInet6 struct {
	Len      uint8
	Family   uint8
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte 
	Scope_id uint32
}
const (
	sizeofIovec   = 0x8
	sizeofMsghdr  = 0x1c
	sizeofCmsghdr = 0xc
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x1c
)
package socket
import "unsafe"
func (v *iovec) set(b []byte) {
	v.Base = (*byte)(unsafe.Pointer(&b[0]))
	v.Len = uint64(len(b))
}
package socket
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0x18
	sysSOCK_RAW = 0x3
)
type iovec struct {
	Base *byte
	Len  uint64
}
type msghdr struct {
	Name       *byte
	Namelen    uint32
	Pad_cgo_0  [4]byte
	Iov        *iovec
	Iovlen     int32
	Pad_cgo_1  [4]byte
	Control    *byte
	Controllen uint32
	Flags      int32
}
type mmsghdr struct {
	Hdr       msghdr
	Len       uint32
	Pad_cgo_0 [4]byte
}
type cmsghdr struct {
	Len   uint32
	Level int32
	Type  int32
}
type sockaddrInet struct {
	Len    uint8
	Family uint8
	Port   uint16
	Addr   [4]byte 
	Zero   [8]int8
}
type sockaddrInet6 struct {
	Len      uint8
	Family   uint8
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte 
	Scope_id uint32
}
const (
	sizeofIovec   = 0x10
	sizeofMsghdr  = 0x30
	sizeofMmsghdr = 0x40
	sizeofCmsghdr = 0xc
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x1c
)
package socket
import (
	"syscall"
	"unsafe"
)
func probeProtocolStack() int { return 4 }
const (
	sysSETSOCKOPT = 0xe
	sysGETSOCKOPT = 0xf
	sysSENDMSG    = 0x10
	sysRECVMSG    = 0x11
	sysRECVMMSG   = 0x13
	sysSENDMMSG   = 0x14
)
func socketcall(call, a0, a1, a2, a3, a4, a5 uintptr) (uintptr, syscall.Errno)
func rawsocketcall(call, a0, a1, a2, a3, a4, a5 uintptr) (uintptr, syscall.Errno)
func getsockopt(s uintptr, level, name int, b []byte) (int, error) {
	l := uint32(len(b))
	_, errno := socketcall(sysGETSOCKOPT, s, uintptr(level), uintptr(name), uintptr(unsafe.Pointer(&b[0])), uintptr(unsafe.Pointer(&l)), 0)
	return int(l), errnoErr(errno)
}
func setsockopt(s uintptr, level, name int, b []byte) error {
	_, errno := socketcall(sysSETSOCKOPT, s, uintptr(level), uintptr(name), uintptr(unsafe.Pointer(&b[0])), uintptr(len(b)), 0)
	return errnoErr(errno)
}
func recvmsg(s uintptr, h *msghdr, flags int) (int, error) {
	n, errno := socketcall(sysRECVMSG, s, uintptr(unsafe.Pointer(h)), uintptr(flags), 0, 0, 0)
	return int(n), errnoErr(errno)
}
func sendmsg(s uintptr, h *msghdr, flags int) (int, error) {
	n, errno := socketcall(sysSENDMSG, s, uintptr(unsafe.Pointer(h)), uintptr(flags), 0, 0, 0)
	return int(n), errnoErr(errno)
}
func recvmmsg(s uintptr, hs []mmsghdr, flags int) (int, error) {
	n, errno := socketcall(sysRECVMMSG, s, uintptr(unsafe.Pointer(&hs[0])), uintptr(len(hs)), uintptr(flags), 0, 0)
	return int(n), errnoErr(errno)
}
func sendmmsg(s uintptr, hs []mmsghdr, flags int) (int, error) {
	n, errno := socketcall(sysSENDMMSG, s, uintptr(unsafe.Pointer(&hs[0])), uintptr(len(hs)), uintptr(flags), 0, 0)
	return int(n), errnoErr(errno)
}
package socket
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0x1c
	sysSOCK_RAW = 0x3
)
type iovec struct {
	Base *byte
	Len  uint32
}
type msghdr struct {
	Name       *byte
	Namelen    uint32
	Iov        *iovec
	Iovlen     int32
	Control    *byte
	Controllen uint32
	Flags      int32
}
type cmsghdr struct {
	Len   uint32
	Level int32
	Type  int32
}
type sockaddrInet struct {
	Len    uint8
	Family uint8
	Port   uint16
	Addr   [4]byte 
	Zero   [8]int8
}
type sockaddrInet6 struct {
	Len      uint8
	Family   uint8
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte 
	Scope_id uint32
}
const (
	sizeofIovec   = 0x8
	sizeofMsghdr  = 0x1c
	sizeofCmsghdr = 0xc
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x1c
)
package socket
import "syscall"
var (
	errERROR_IO_PENDING error = syscall.ERROR_IO_PENDING
	errEINVAL           error = syscall.EINVAL
)
func errnoErr(errno syscall.Errno) error {
	switch errno {
	case 0:
		return nil
	case syscall.ERROR_IO_PENDING:
		return errERROR_IO_PENDING
	case syscall.EINVAL:
		return errEINVAL
	}
	return errno
}
package socket
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0xa
	sysSOCK_RAW = 0x3
)
type iovec struct {
	Base *byte
	Len  uint64
}
type msghdr struct {
	Name       *byte
	Namelen    uint32
	Pad_cgo_0  [4]byte
	Iov        *iovec
	Iovlen     uint64
	Control    *byte
	Controllen uint64
	Flags      int32
	Pad_cgo_1  [4]byte
}
type mmsghdr struct {
	Hdr       msghdr
	Len       uint32
	Pad_cgo_0 [4]byte
}
type cmsghdr struct {
	Len   uint64
	Level int32
	Type  int32
}
type sockaddrInet struct {
	Family uint16
	Port   uint16
	Addr   [4]byte 
	X__pad [8]uint8
}
type sockaddrInet6 struct {
	Family   uint16
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte 
	Scope_id uint32
}
const (
	sizeofIovec   = 0x10
	sizeofMsghdr  = 0x38
	sizeofMmsghdr = 0x40
	sizeofCmsghdr = 0x10
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x1c
)
package socket
func probeProtocolStack() int { return 4 }
package socket
func (h *cmsghdr) set(l, lvl, typ int) {
	h.Len = uint32(l)
	h.Level = int32(lvl)
	h.Type = int32(typ)
}
package socket
const (
	sysRECVMMSG = 0x10ef
	sysSENDMMSG = 0x10f7
)
package socket
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0x1e
	sysSOCK_RAW = 0x3
)
type iovec struct {
	Base *byte
	Len  uint32
}
type msghdr struct {
	Name       *byte
	Namelen    uint32
	Iov        *iovec
	Iovlen     int32
	Control    *byte
	Controllen uint32
	Flags      int32
}
type cmsghdr struct {
	Len   uint32
	Level int32
	Type  int32
}
type sockaddrInet struct {
	Len    uint8
	Family uint8
	Port   uint16
	Addr   [4]byte 
	Zero   [8]int8
}
type sockaddrInet6 struct {
	Len      uint8
	Family   uint8
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte 
	Scope_id uint32
}
const (
	sizeofIovec   = 0x8
	sizeofMsghdr  = 0x1c
	sizeofCmsghdr = 0xc
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x1c
)
package socket
import (
	"errors"
	"net"
	"os"
	"reflect"
	"runtime"
)
type Conn struct {
	c net.Conn
}
func NewConn(c net.Conn) (*Conn, error) {
	return &Conn{c: c}, nil
}
func (o *Option) get(c *Conn, b []byte) (int, error) {
	s, err := socketOf(c.c)
	if err != nil {
		return 0, err
	}
	n, err := getsockopt(s, o.Level, o.Name, b)
	return n, os.NewSyscallError("getsockopt", err)
}
func (o *Option) set(c *Conn, b []byte) error {
	s, err := socketOf(c.c)
	if err != nil {
		return err
	}
	return os.NewSyscallError("setsockopt", setsockopt(s, o.Level, o.Name, b))
}
func socketOf(c net.Conn) (uintptr, error) {
	switch c.(type) {
	case *net.TCPConn, *net.UDPConn, *net.IPConn:
		v := reflect.ValueOf(c)
		switch e := v.Elem(); e.Kind() {
		case reflect.Struct:
			fd := e.FieldByName("conn").FieldByName("fd")
			switch e := fd.Elem(); e.Kind() {
			case reflect.Struct:
				sysfd := e.FieldByName("sysfd")
				if runtime.GOOS == "windows" {
					return uintptr(sysfd.Uint()), nil
				}
				return uintptr(sysfd.Int()), nil
			}
		}
	}
	return 0, errors.New("invalid type")
}
package socket
import "net"
type mmsghdr struct{}
type mmsghdrs []mmsghdr
func (hs mmsghdrs) pack(ms []Message, parseFn func([]byte, string) (net.Addr, error), marshalFn func(net.Addr) []byte) error {
	return nil
}
func (hs mmsghdrs) unpack(ms []Message, parseFn func([]byte, string) (net.Addr, error), hint string) error {
	return nil
}
package socket
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0x1e
	sysSOCK_RAW = 0x3
)
type iovec struct {
	Base *byte
	Len  uint64
}
type msghdr struct {
	Name       *byte
	Namelen    uint32
	Pad_cgo_0  [4]byte
	Iov        *iovec
	Iovlen     int32
	Pad_cgo_1  [4]byte
	Control    *byte
	Controllen uint32
	Flags      int32
}
type cmsghdr struct {
	Len   uint32
	Level int32
	Type  int32
}
type sockaddrInet struct {
	Len    uint8
	Family uint8
	Port   uint16
	Addr   [4]byte 
	Zero   [8]int8
}
type sockaddrInet6 struct {
	Len      uint8
	Family   uint8
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte 
	Scope_id uint32
}
const (
	sizeofIovec   = 0x10
	sizeofMsghdr  = 0x30
	sizeofCmsghdr = 0xc
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x1c
)
package socket
import "unsafe"
func (h *msghdr) setIov(vs []iovec) {
	h.Iov = &vs[0]
	h.Iovlen = uint64(len(vs))
}
func (h *msghdr) setControl(b []byte) {
	h.Control = (*byte)(unsafe.Pointer(&b[0]))
	h.Controllen = uint64(len(b))
}
package socket
#include <sys
#include <netinet
*
import "C"
const (
	sysAF_UNSPEC = C.AF_UNSPEC
	sysAF_INET   = C.AF_INET
	sysAF_INET6  = C.AF_INET6
	sysSOCK_RAW = C.SOCK_RAW
)
type iovec C.struct_iovec
type msghdr C.struct_msghdr
type cmsghdr C.struct_cmsghdr
type sockaddrInet C.struct_sockaddr_in
type sockaddrInet6 C.struct_sockaddr_in6
const (
	sizeofIovec   = C.sizeof_struct_iovec
	sizeofMsghdr  = C.sizeof_struct_msghdr
	sizeofCmsghdr = C.sizeof_struct_cmsghdr
	sizeofSockaddrInet  = C.sizeof_struct_sockaddr_in
	sizeofSockaddrInet6 = C.sizeof_struct_sockaddr_in6
)
package socket
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0xa
	sysSOCK_RAW = 0x3
)
type iovec struct {
	Base *byte
	Len  uint32
}
type msghdr struct {
	Name       *byte
	Namelen    uint32
	Iov        *iovec
	Iovlen     uint32
	Control    *byte
	Controllen uint32
	Flags      int32
}
type mmsghdr struct {
	Hdr msghdr
	Len uint32
}
type cmsghdr struct {
	Len   uint32
	Level int32
	Type  int32
}
type sockaddrInet struct {
	Family uint16
	Port   uint16
	Addr   [4]byte 
	X__pad [8]uint8
}
type sockaddrInet6 struct {
	Family   uint16
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte 
	Scope_id uint32
}
const (
	sizeofIovec   = 0x8
	sizeofMsghdr  = 0x1c
	sizeofMmsghdr = 0x20
	sizeofCmsghdr = 0xc
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x1c
)
package socket 
import (
	"errors"
	"net"
	"unsafe"
)
type Option struct {
	Level int 
	Name  int 
	Len   int 
}
func (o *Option) Get(c *Conn, b []byte) (int, error) {
	if o.Name < 1 || o.Len < 1 {
		return 0, errors.New("invalid option")
	}
	if len(b) < o.Len {
		return 0, errors.New("short buffer")
	}
	return o.get(c, b)
}
func (o *Option) GetInt(c *Conn) (int, error) {
	if o.Len != 1 && o.Len != 4 {
		return 0, errors.New("invalid option")
	}
	var b []byte
	var bb [4]byte
	if o.Len == 1 {
		b = bb[:1]
	} else {
		b = bb[:4]
	}
	n, err := o.get(c, b)
	if err != nil {
		return 0, err
	}
	if n != o.Len {
		return 0, errors.New("invalid option length")
	}
	if o.Len == 1 {
		return int(b[0]), nil
	}
	return int(NativeEndian.Uint32(b[:4])), nil
}
func (o *Option) Set(c *Conn, b []byte) error {
	if o.Name < 1 || o.Len < 1 {
		return errors.New("invalid option")
	}
	if len(b) < o.Len {
		return errors.New("short buffer")
	}
	return o.set(c, b)
}
func (o *Option) SetInt(c *Conn, v int) error {
	if o.Len != 1 && o.Len != 4 {
		return errors.New("invalid option")
	}
	var b []byte
	if o.Len == 1 {
		b = []byte{byte(v)}
	} else {
		var bb [4]byte
		NativeEndian.PutUint32(bb[:o.Len], uint32(v))
		b = bb[:4]
	}
	return o.set(c, b)
}
func controlHeaderLen() int {
	return roundup(sizeofCmsghdr)
}
func controlMessageLen(dataLen int) int {
	return roundup(sizeofCmsghdr) + dataLen
}
func ControlMessageSpace(dataLen int) int {
	return roundup(sizeofCmsghdr) + roundup(dataLen)
}
type ControlMessage []byte
func (m ControlMessage) Data(dataLen int) []byte {
	l := controlHeaderLen()
	if len(m) < l || len(m) < l+dataLen {
		return nil
	}
	return m[l : l+dataLen]
}
func (m ControlMessage) Next(dataLen int) ControlMessage {
	l := ControlMessageSpace(dataLen)
	if len(m) < l {
		return nil
	}
	return m[l:]
}
func (m ControlMessage) MarshalHeader(lvl, typ, dataLen int) error {
	if len(m) < controlHeaderLen() {
		return errors.New("short message")
	}
	h := (*cmsghdr)(unsafe.Pointer(&m[0]))
	h.set(controlMessageLen(dataLen), lvl, typ)
	return nil
}
func (m ControlMessage) ParseHeader() (lvl, typ, dataLen int, err error) {
	l := controlHeaderLen()
	if len(m) < l {
		return 0, 0, 0, errors.New("short message")
	}
	h := (*cmsghdr)(unsafe.Pointer(&m[0]))
	return h.lvl(), h.typ(), int(uint64(h.len()) - uint64(l)), nil
}
func (m ControlMessage) Marshal(lvl, typ int, data []byte) (ControlMessage, error) {
	l := len(data)
	if len(m) < ControlMessageSpace(l) {
		return nil, errors.New("short message")
	}
	h := (*cmsghdr)(unsafe.Pointer(&m[0]))
	h.set(controlMessageLen(l), lvl, typ)
	if l > 0 {
		copy(m.Data(l), data)
	}
	return m.Next(l), nil
}
func (m ControlMessage) Parse() ([]ControlMessage, error) {
	var ms []ControlMessage
	for len(m) >= controlHeaderLen() {
		h := (*cmsghdr)(unsafe.Pointer(&m[0]))
		l := h.len()
		if l <= 0 {
			return nil, errors.New("invalid header length")
		}
		if uint64(l) < uint64(controlHeaderLen()) {
			return nil, errors.New("invalid message length")
		}
		if uint64(l) > uint64(len(m)) {
			return nil, errors.New("short buffer")
		}
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		ms = append(ms, ControlMessage(m[:l]))
		ll := l - controlHeaderLen()
		if len(m) >= ControlMessageSpace(ll) {
			m = m[ControlMessageSpace(ll):]
		} else {
			m = m[controlMessageLen(ll):]
		}
	}
	return ms, nil
}
func NewControlMessage(dataLen []int) ControlMessage {
	var l int
	for i := range dataLen {
		l += ControlMessageSpace(dataLen[i])
	}
	return make([]byte, l)
}
type Message struct {
	
	
	
	
	Buffers [][]byte
	
	
	OOB []byte
	
	
	
	
	
	Addr net.Addr
	N     int 
	NN    int 
	Flags int 
}
func (c *Conn) RecvMsg(m *Message, flags int) error {
	return c.recvMsg(m, flags)
}
func (c *Conn) SendMsg(m *Message, flags int) error {
	return c.sendMsg(m, flags)
}
func (c *Conn) RecvMsgs(ms []Message, flags int) (int, error) {
	return c.recvMsgs(ms, flags)
}
func (c *Conn) SendMsgs(ms []Message, flags int) (int, error) {
	return c.sendMsgs(ms, flags)
}
package socket
import "errors"
func recvmmsg(s uintptr, hs []mmsghdr, flags int) (int, error) {
	return 0, errors.New("not implemented")
}
func sendmmsg(s uintptr, hs []mmsghdr, flags int) (int, error) {
	return 0, errors.New("not implemented")
}
package socket
type msghdr struct{}
func (h *msghdr) pack(vs []iovec, bs [][]byte, oob []byte, sa []byte) {}
func (h *msghdr) name() []byte                                        { return nil }
func (h *msghdr) controllen() int                                     { return 0 }
func (h *msghdr) flags() int                                          { return 0 }
package socket
#include <sys
#include <netinet
*
import "C"
const (
	sysAF_UNSPEC = C.AF_UNSPEC
	sysAF_INET   = C.AF_INET
	sysAF_INET6  = C.AF_INET6
	sysSOCK_RAW = C.SOCK_RAW
)
type iovec C.struct_iovec
type msghdr C.struct_msghdr
type mmsghdr C.struct_mmsghdr
type cmsghdr C.struct_cmsghdr
type sockaddrInet C.struct_sockaddr_in
type sockaddrInet6 C.struct_sockaddr_in6
const (
	sizeofIovec   = C.sizeof_struct_iovec
	sizeofMsghdr  = C.sizeof_struct_msghdr
	sizeofMmsghdr = C.sizeof_struct_mmsghdr
	sizeofCmsghdr = C.sizeof_struct_cmsghdr
	sizeofSockaddrInet  = C.sizeof_struct_sockaddr_in
	sizeofSockaddrInet6 = C.sizeof_struct_sockaddr_in6
)
package socket
const (
	sysRECVMMSG = 0x14ae
	sysSENDMMSG = 0x14b6
)
package socket_test
import (
	"bytes"
	"fmt"
	"net"
	"runtime"
	"testing"
	"golang.org
	"golang.org
)
type mockControl struct {
	Level int
	Type  int
	Data  []byte
}
func TestControlMessage(t *testing.T) {
	for _, tt := range []struct {
		cs []mockControl
	}{
		{
			[]mockControl{
				{Level: 1, Type: 1},
			},
		},
		{
			[]mockControl{
				{Level: 2, Type: 2, Data: []byte{0xfe}},
			},
		},
		{
			[]mockControl{
				{Level: 3, Type: 3, Data: []byte{0xfe, 0xff, 0xff, 0xfe}},
			},
		},
		{
			[]mockControl{
				{Level: 4, Type: 4, Data: []byte{0xfe, 0xff, 0xff, 0xfe, 0xfe, 0xff, 0xff, 0xfe}},
			},
		},
		{
			[]mockControl{
				{Level: 4, Type: 4, Data: []byte{0xfe, 0xff, 0xff, 0xfe, 0xfe, 0xff, 0xff, 0xfe}},
				{Level: 2, Type: 2, Data: []byte{0xfe}},
			},
		},
	} {
		var w []byte
		var tailPadLen int
		mm := socket.NewControlMessage([]int{0})
		for i, c := range tt.cs {
			m := socket.NewControlMessage([]int{len(c.Data)})
			l := len(m) - len(mm)
			if i == len(tt.cs)-1 && l > len(c.Data) {
				tailPadLen = l - len(c.Data)
			}
			w = append(w, m...)
		}
		var err error
		ww := make([]byte, len(w))
		copy(ww, w)
		m := socket.ControlMessage(ww)
		for _, c := range tt.cs {
			if err = m.MarshalHeader(c.Level, c.Type, len(c.Data)); err != nil {
				t.Fatalf("(%v).MarshalHeader() = %v", tt.cs, err)
			}
			copy(m.Data(len(c.Data)), c.Data)
			m = m.Next(len(c.Data))
		}
		m = socket.ControlMessage(w)
		for _, c := range tt.cs {
			m, err = m.Marshal(c.Level, c.Type, c.Data)
			if err != nil {
				t.Fatalf("(%v).Marshal() = %v", tt.cs, err)
			}
		}
		if !bytes.Equal(ww, w) {
			t.Fatalf("got %#v; want %#v", ww, w)
		}
		ws := [][]byte{w}
		if tailPadLen > 0 {
			
			nopad := w[:len(w)-tailPadLen]
			ws = append(ws, [][]byte{nopad}...)
		}
		for _, w := range ws {
			ms, err := socket.ControlMessage(w).Parse()
			if err != nil {
				t.Fatalf("(%v).Parse() = %v", tt.cs, err)
			}
			for i, m := range ms {
				lvl, typ, dataLen, err := m.ParseHeader()
				if err != nil {
					t.Fatalf("(%v).ParseHeader() = %v", tt.cs, err)
				}
				if lvl != tt.cs[i].Level || typ != tt.cs[i].Type || dataLen != len(tt.cs[i].Data) {
					t.Fatalf("%v: got %d, %d, %d; want %d, %d, %d", tt.cs[i], lvl, typ, dataLen, tt.cs[i].Level, tt.cs[i].Type, len(tt.cs[i].Data))
				}
			}
		}
	}
}
func TestUDP(t *testing.T) {
	c, err := nettest.NewLocalPacketListener("udp")
	if err != nil {
		t.Skipf("not supported on %s
	}
	defer c.Close()
	t.Run("Message", func(t *testing.T) {
		testUDPMessage(t, c.(net.Conn))
	})
	switch runtime.GOOS {
	case "linux":
		t.Run("Messages", func(t *testing.T) {
			testUDPMessages(t, c.(net.Conn))
		})
	}
}
func testUDPMessage(t *testing.T, c net.Conn) {
	cc, err := socket.NewConn(c)
	if err != nil {
		t.Fatal(err)
	}
	data := []byte("HELLO-R-U-THERE")
	wm := socket.Message{
		Buffers: bytes.SplitAfter(data, []byte("-")),
		Addr:    c.LocalAddr(),
	}
	if err := cc.SendMsg(&wm, 0); err != nil {
		t.Fatal(err)
	}
	b := make([]byte, 32)
	rm := socket.Message{
		Buffers: [][]byte{b[:1], b[1:3], b[3:7], b[7:11], b[11:]},
	}
	if err := cc.RecvMsg(&rm, 0); err != nil {
		t.Fatal(err)
	}
	if !bytes.Equal(b[:rm.N], data) {
		t.Fatalf("got %#v; want %#v", b[:rm.N], data)
	}
}
func testUDPMessages(t *testing.T, c net.Conn) {
	cc, err := socket.NewConn(c)
	if err != nil {
		t.Fatal(err)
	}
	data := []byte("HELLO-R-U-THERE")
	wmbs := bytes.SplitAfter(data, []byte("-"))
	wms := []socket.Message{
		{Buffers: wmbs[:1], Addr: c.LocalAddr()},
		{Buffers: wmbs[1:], Addr: c.LocalAddr()},
	}
	n, err := cc.SendMsgs(wms, 0)
	if err != nil {
		t.Fatal(err)
	}
	if n != len(wms) {
		t.Fatalf("got %d; want %d", n, len(wms))
	}
	b := make([]byte, 32)
	rmbs := [][][]byte{{b[:len(wmbs[0])]}, {b[len(wmbs[0]):]}}
	rms := []socket.Message{
		{Buffers: rmbs[0]},
		{Buffers: rmbs[1]},
	}
	n, err = cc.RecvMsgs(rms, 0)
	if err != nil {
		t.Fatal(err)
	}
	if n != len(rms) {
		t.Fatalf("got %d; want %d", n, len(rms))
	}
	nn := 0
	for i := 0; i < n; i++ {
		nn += rms[i].N
	}
	if !bytes.Equal(b[:nn], data) {
		t.Fatalf("got %#v; want %#v", b[:nn], data)
	}
}
func BenchmarkUDP(b *testing.B) {
	c, err := nettest.NewLocalPacketListener("udp")
	if err != nil {
		b.Skipf("not supported on %s
	}
	defer c.Close()
	cc, err := socket.NewConn(c.(net.Conn))
	if err != nil {
		b.Fatal(err)
	}
	data := []byte("HELLO-R-U-THERE")
	wm := socket.Message{
		Buffers: [][]byte{data},
		Addr:    c.LocalAddr(),
	}
	rm := socket.Message{
		Buffers: [][]byte{make([]byte, 128)},
		OOB:     make([]byte, 128),
	}
	for M := 1; M <= 1<<9; M = M << 1 {
		b.Run(fmt.Sprintf("Iter-%d", M), func(b *testing.B) {
			for i := 0; i < b.N; i++ {
				for j := 0; j < M; j++ {
					if err := cc.SendMsg(&wm, 0); err != nil {
						b.Fatal(err)
					}
					if err := cc.RecvMsg(&rm, 0); err != nil {
						b.Fatal(err)
					}
				}
			}
		})
		switch runtime.GOOS {
		case "linux":
			wms := make([]socket.Message, M)
			for i := range wms {
				wms[i].Buffers = [][]byte{data}
				wms[i].Addr = c.LocalAddr()
			}
			rms := make([]socket.Message, M)
			for i := range rms {
				rms[i].Buffers = [][]byte{make([]byte, 128)}
				rms[i].OOB = make([]byte, 128)
			}
			b.Run(fmt.Sprintf("Batch-%d", M), func(b *testing.B) {
				for i := 0; i < b.N; i++ {
					if _, err := cc.SendMsgs(wms, 0); err != nil {
						b.Fatal(err)
					}
					if _, err := cc.RecvMsgs(rms, 0); err != nil {
						b.Fatal(err)
					}
				}
			})
		}
	}
}
package socket
import (
	"syscall"
	"unsafe"
)
func probeProtocolStack() int {
	var p uintptr
	return int(unsafe.Sizeof(p))
}
func recvmmsg(s uintptr, hs []mmsghdr, flags int) (int, error) {
	n, _, errno := syscall.Syscall6(sysRECVMMSG, s, uintptr(unsafe.Pointer(&hs[0])), uintptr(len(hs)), uintptr(flags), 0, 0)
	return int(n), errnoErr(errno)
}
func sendmmsg(s uintptr, hs []mmsghdr, flags int) (int, error) {
	n, _, errno := syscall.Syscall6(sysSENDMMSG, s, uintptr(unsafe.Pointer(&hs[0])), uintptr(len(hs)), uintptr(flags), 0, 0)
	return int(n), errnoErr(errno)
}
package socket
#include <sys
#include <netinet
*
import "C"
const (
	sysAF_UNSPEC = C.AF_UNSPEC
	sysAF_INET   = C.AF_INET
	sysAF_INET6  = C.AF_INET6
	sysSOCK_RAW = C.SOCK_RAW
)
type iovec C.struct_iovec
type msghdr C.struct_msghdr
type cmsghdr C.struct_cmsghdr
type sockaddrInet C.struct_sockaddr_in
type sockaddrInet6 C.struct_sockaddr_in6
const (
	sizeofIovec   = C.sizeof_struct_iovec
	sizeofMsghdr  = C.sizeof_struct_msghdr
	sizeofCmsghdr = C.sizeof_struct_cmsghdr
	sizeofSockaddrInet  = C.sizeof_struct_sockaddr_in
	sizeofSockaddrInet6 = C.sizeof_struct_sockaddr_in6
)
package socket
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0x1a
	sysSOCK_RAW = 0x4
)
type iovec struct {
	Base *int8
	Len  uint64
}
type msghdr struct {
	Name         *byte
	Namelen      uint32
	Pad_cgo_0    [4]byte
	Iov          *iovec
	Iovlen       int32
	Pad_cgo_1    [4]byte
	Accrights    *int8
	Accrightslen int32
	Pad_cgo_2    [4]byte
}
type cmsghdr struct {
	Len   uint32
	Level int32
	Type  int32
}
type sockaddrInet struct {
	Family uint16
	Port   uint16
	Addr   [4]byte 
	Zero   [8]int8
}
type sockaddrInet6 struct {
	Family         uint16
	Port           uint16
	Flowinfo       uint32
	Addr           [16]byte 
	Scope_id       uint32
	X__sin6_src_id uint32
}
const (
	sizeofIovec   = 0x10
	sizeofMsghdr  = 0x30
	sizeofCmsghdr = 0xc
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x20
)
package socket
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0xa
	sysSOCK_RAW = 0x3
)
type iovec struct {
	Base *byte
	Len  uint64
}
type msghdr struct {
	Name       *byte
	Namelen    uint32
	Pad_cgo_0  [4]byte
	Iov        *iovec
	Iovlen     uint64
	Control    *byte
	Controllen uint64
	Flags      int32
	Pad_cgo_1  [4]byte
}
type mmsghdr struct {
	Hdr       msghdr
	Len       uint32
	Pad_cgo_0 [4]byte
}
type cmsghdr struct {
	Len   uint64
	Level int32
	Type  int32
}
type sockaddrInet struct {
	Family uint16
	Port   uint16
	Addr   [4]byte 
	X__pad [8]uint8
}
type sockaddrInet6 struct {
	Family   uint16
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte 
	Scope_id uint32
}
const (
	sizeofIovec   = 0x10
	sizeofMsghdr  = 0x38
	sizeofMmsghdr = 0x40
	sizeofCmsghdr = 0x10
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x1c
)
package socket
import "unsafe"
func (h *msghdr) pack(vs []iovec, bs [][]byte, oob []byte, sa []byte) {
	for i := range vs {
		vs[i].set(bs[i])
	}
	h.setIov(vs)
	if len(oob) > 0 {
		h.Control = (*byte)(unsafe.Pointer(&oob[0]))
		h.Controllen = uint32(len(oob))
	}
	if sa != nil {
		h.Name = (*byte)(unsafe.Pointer(&sa[0]))
		h.Namelen = uint32(len(sa))
	}
}
func (h *msghdr) name() []byte {
	if h.Name != nil && h.Namelen > 0 {
		return (*[sizeofSockaddrInet6]byte)(unsafe.Pointer(h.Name))[:h.Namelen]
	}
	return nil
}
func (h *msghdr) controllen() int {
	return int(h.Controllen)
}
func (h *msghdr) flags() int {
	return int(h.Flags)
}
package socket
import (
	"encoding
	"errors"
	"net"
	"runtime"
	"strconv"
	"sync"
	"time"
)
func marshalInetAddr(a net.Addr) []byte {
	switch a := a.(type) {
	case *net.TCPAddr:
		return marshalSockaddr(a.IP, a.Port, a.Zone)
	case *net.UDPAddr:
		return marshalSockaddr(a.IP, a.Port, a.Zone)
	case *net.IPAddr:
		return marshalSockaddr(a.IP, 0, a.Zone)
	default:
		return nil
	}
}
func marshalSockaddr(ip net.IP, port int, zone string) []byte {
	if ip4 := ip.To4(); ip4 != nil {
		b := make([]byte, sizeofSockaddrInet)
		switch runtime.GOOS {
		case "linux", "solaris", "windows":
			NativeEndian.PutUint16(b[:2], uint16(sysAF_INET))
		default:
			b[0] = sizeofSockaddrInet
			b[1] = sysAF_INET
		}
		binary.BigEndian.PutUint16(b[2:4], uint16(port))
		copy(b[4:8], ip4)
		return b
	}
	if ip6 := ip.To16(); ip6 != nil && ip.To4() == nil {
		b := make([]byte, sizeofSockaddrInet6)
		switch runtime.GOOS {
		case "linux", "solaris", "windows":
			NativeEndian.PutUint16(b[:2], uint16(sysAF_INET6))
		default:
			b[0] = sizeofSockaddrInet6
			b[1] = sysAF_INET6
		}
		binary.BigEndian.PutUint16(b[2:4], uint16(port))
		copy(b[8:24], ip6)
		if zone != "" {
			NativeEndian.PutUint32(b[24:28], uint32(zoneCache.index(zone)))
		}
		return b
	}
	return nil
}
func parseInetAddr(b []byte, network string) (net.Addr, error) {
	if len(b) < 2 {
		return nil, errors.New("invalid address")
	}
	var af int
	switch runtime.GOOS {
	case "linux", "solaris", "windows":
		af = int(NativeEndian.Uint16(b[:2]))
	default:
		af = int(b[1])
	}
	var ip net.IP
	var zone string
	if af == sysAF_INET {
		if len(b) < sizeofSockaddrInet {
			return nil, errors.New("short address")
		}
		ip = make(net.IP, net.IPv4len)
		copy(ip, b[4:8])
	}
	if af == sysAF_INET6 {
		if len(b) < sizeofSockaddrInet6 {
			return nil, errors.New("short address")
		}
		ip = make(net.IP, net.IPv6len)
		copy(ip, b[8:24])
		if id := int(NativeEndian.Uint32(b[24:28])); id > 0 {
			zone = zoneCache.name(id)
		}
	}
	switch network {
	case "tcp", "tcp4", "tcp6":
		return &net.TCPAddr{IP: ip, Port: int(binary.BigEndian.Uint16(b[2:4])), Zone: zone}, nil
	case "udp", "udp4", "udp6":
		return &net.UDPAddr{IP: ip, Port: int(binary.BigEndian.Uint16(b[2:4])), Zone: zone}, nil
	default:
		return &net.IPAddr{IP: ip, Zone: zone}, nil
	}
}
type ipv6ZoneCache struct {
	sync.RWMutex                
	lastFetched  time.Time      
	toIndex      map[string]int 
	toName       map[int]string 
}
var zoneCache = ipv6ZoneCache{
	toIndex: make(map[string]int),
	toName:  make(map[int]string),
}
func (zc *ipv6ZoneCache) update(ift []net.Interface) {
	zc.Lock()
	defer zc.Unlock()
	now := time.Now()
	if zc.lastFetched.After(now.Add(-60 * time.Second)) {
		return
	}
	zc.lastFetched = now
	if len(ift) == 0 {
		var err error
		if ift, err = net.Interfaces(); err != nil {
			return
		}
	}
	zc.toIndex = make(map[string]int, len(ift))
	zc.toName = make(map[int]string, len(ift))
	for _, ifi := range ift {
		zc.toIndex[ifi.Name] = ifi.Index
		if _, ok := zc.toName[ifi.Index]; !ok {
			zc.toName[ifi.Index] = ifi.Name
		}
	}
}
func (zc *ipv6ZoneCache) name(zone int) string {
	zoneCache.update(nil)
	zoneCache.RLock()
	defer zoneCache.RUnlock()
	name, ok := zoneCache.toName[zone]
	if !ok {
		name = strconv.Itoa(zone)
	}
	return name
}
func (zc *ipv6ZoneCache) index(zone string) int {
	zoneCache.update(nil)
	zoneCache.RLock()
	defer zoneCache.RUnlock()
	index, ok := zoneCache.toIndex[zone]
	if !ok {
		index, _ = strconv.Atoi(zone)
	}
	return index
}
package socket
const (
	sysRECVMMSG = 0x157
	sysSENDMMSG = 0x15d
)
package socket
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0x18
	sysSOCK_RAW = 0x3
)
type iovec struct {
	Base *byte
	Len  uint32
}
type msghdr struct {
	Name       *byte
	Namelen    uint32
	Iov        *iovec
	Iovlen     int32
	Control    *byte
	Controllen uint32
	Flags      int32
}
type cmsghdr struct {
	Len   uint32
	Level int32
	Type  int32
}
type sockaddrInet struct {
	Len    uint8
	Family uint8
	Port   uint16
	Addr   [4]byte 
	Zero   [8]int8
}
type sockaddrInet6 struct {
	Len      uint8
	Family   uint8
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte 
	Scope_id uint32
}
const (
	sizeofIovec   = 0x8
	sizeofMsghdr  = 0x1c
	sizeofCmsghdr = 0xc
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x1c
)
package socket
import "errors"
func (c *Conn) recvMsgs(ms []Message, flags int) (int, error) {
	return 0, errors.New("not implemented")
}
func (c *Conn) sendMsgs(ms []Message, flags int) (int, error) {
	return 0, errors.New("not implemented")
}
package socket
func probeProtocolStack() int { return 4 }
package socket
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0xa
	sysSOCK_RAW = 0x3
)
type iovec struct {
	Base *byte
	Len  uint64
}
type msghdr struct {
	Name       *byte
	Namelen    uint32
	Pad_cgo_0  [4]byte
	Iov        *iovec
	Iovlen     uint64
	Control    *byte
	Controllen uint64
	Flags      int32
	Pad_cgo_1  [4]byte
}
type mmsghdr struct {
	Hdr       msghdr
	Len       uint32
	Pad_cgo_0 [4]byte
}
type cmsghdr struct {
	Len   uint64
	Level int32
	Type  int32
}
type sockaddrInet struct {
	Family uint16
	Port   uint16
	Addr   [4]byte 
	X__pad [8]uint8
}
type sockaddrInet6 struct {
	Family   uint16
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte 
	Scope_id uint32
}
const (
	sizeofIovec   = 0x10
	sizeofMsghdr  = 0x38
	sizeofMmsghdr = 0x40
	sizeofCmsghdr = 0x10
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x1c
)
package socket
func (h *msghdr) setIov(vs []iovec) {
	h.Iov = &vs[0]
	h.Iovlen = int32(len(vs))
}
package socket
import "errors"
func (c *Conn) recvMsg(m *Message, flags int) error {
	return errors.New("not implemented")
}
func (c *Conn) sendMsg(m *Message, flags int) error {
	return errors.New("not implemented")
}
package socket
import (
	"syscall"
	"unsafe"
)
const (
	sysRECVMMSG = 0x1db
	sysSENDMMSG = 0x1dc
)
func recvmmsg(s uintptr, hs []mmsghdr, flags int) (int, error) {
	n, _, errno := syscall.Syscall6(sysRECVMMSG, s, uintptr(unsafe.Pointer(&hs[0])), uintptr(len(hs)), uintptr(flags), 0, 0)
	return int(n), errnoErr(errno)
}
func sendmmsg(s uintptr, hs []mmsghdr, flags int) (int, error) {
	n, _, errno := syscall.Syscall6(sysSENDMMSG, s, uintptr(unsafe.Pointer(&hs[0])), uintptr(len(hs)), uintptr(flags), 0, 0)
	return int(n), errnoErr(errno)
}
package socket
#include <linux
#include <linux
#define _GNU_SOURCE
#include <sys
*
import "C"
const (
	sysAF_UNSPEC = C.AF_UNSPEC
	sysAF_INET   = C.AF_INET
	sysAF_INET6  = C.AF_INET6
	sysSOCK_RAW = C.SOCK_RAW
)
type iovec C.struct_iovec
type msghdr C.struct_msghdr
type mmsghdr C.struct_mmsghdr
type cmsghdr C.struct_cmsghdr
type sockaddrInet C.struct_sockaddr_in
type sockaddrInet6 C.struct_sockaddr_in6
const (
	sizeofIovec   = C.sizeof_struct_iovec
	sizeofMsghdr  = C.sizeof_struct_msghdr
	sizeofMmsghdr = C.sizeof_struct_mmsghdr
	sizeofCmsghdr = C.sizeof_struct_cmsghdr
	sizeofSockaddrInet  = C.sizeof_struct_sockaddr_in
	sizeofSockaddrInet6 = C.sizeof_struct_sockaddr_in6
)
package socket
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0xa
	sysSOCK_RAW = 0x3
)
type iovec struct {
	Base *byte
	Len  uint64
}
type msghdr struct {
	Name       *byte
	Namelen    uint32
	Pad_cgo_0  [4]byte
	Iov        *iovec
	Iovlen     uint64
	Control    *byte
	Controllen uint64
	Flags      int32
	Pad_cgo_1  [4]byte
}
type mmsghdr struct {
	Hdr       msghdr
	Len       uint32
	Pad_cgo_0 [4]byte
}
type cmsghdr struct {
	Len   uint64
	Level int32
	Type  int32
}
type sockaddrInet struct {
	Family uint16
	Port   uint16
	Addr   [4]byte 
	X__pad [8]uint8
}
type sockaddrInet6 struct {
	Family   uint16
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte 
	Scope_id uint32
}
const (
	sizeofIovec   = 0x10
	sizeofMsghdr  = 0x38
	sizeofMmsghdr = 0x40
	sizeofCmsghdr = 0x10
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x1c
)
package socket
import (
	"encoding
	"unsafe"
)
var (
	
	
	NativeEndian binary.ByteOrder
	kernelAlign int
)
func init() {
	i := uint32(1)
	b := (*[4]byte)(unsafe.Pointer(&i))
	if b[0] == 1 {
		NativeEndian = binary.LittleEndian
	} else {
		NativeEndian = binary.BigEndian
	}
	kernelAlign = probeProtocolStack()
}
func roundup(l int) int {
	return (l + kernelAlign - 1) & ^(kernelAlign - 1)
}
package socket
const (
	sysRECVMMSG = 0x14ae
	sysSENDMMSG = 0x14b6
)
package socket
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0x18
	sysSOCK_RAW = 0x3
)
type iovec struct {
	Base *byte
	Len  uint32
}
type msghdr struct {
	Name       *byte
	Namelen    uint32
	Iov        *iovec
	Iovlen     uint32
	Control    *byte
	Controllen uint32
	Flags      int32
}
type cmsghdr struct {
	Len   uint32
	Level int32
	Type  int32
}
type sockaddrInet struct {
	Len    uint8
	Family uint8
	Port   uint16
	Addr   [4]byte 
	Zero   [8]int8
}
type sockaddrInet6 struct {
	Len      uint8
	Family   uint8
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte 
	Scope_id uint32
}
const (
	sizeofIovec   = 0x8
	sizeofMsghdr  = 0x1c
	sizeofCmsghdr = 0xc
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x1c
)
package socket
import (
	"errors"
	"net"
	"os"
	"syscall"
)
type Conn struct {
	network string
	c       syscall.RawConn
}
func NewConn(c net.Conn) (*Conn, error) {
	var err error
	var cc Conn
	switch c := c.(type) {
	case *net.TCPConn:
		cc.network = "tcp"
		cc.c, err = c.SyscallConn()
	case *net.UDPConn:
		cc.network = "udp"
		cc.c, err = c.SyscallConn()
	case *net.IPConn:
		cc.network = "ip"
		cc.c, err = c.SyscallConn()
	default:
		return nil, errors.New("unknown connection type")
	}
	if err != nil {
		return nil, err
	}
	return &cc, nil
}
func (o *Option) get(c *Conn, b []byte) (int, error) {
	var operr error
	var n int
	fn := func(s uintptr) {
		n, operr = getsockopt(s, o.Level, o.Name, b)
	}
	if err := c.c.Control(fn); err != nil {
		return 0, err
	}
	return n, os.NewSyscallError("getsockopt", operr)
}
func (o *Option) set(c *Conn, b []byte) error {
	var operr error
	fn := func(s uintptr) {
		operr = setsockopt(s, o.Level, o.Name, b)
	}
	if err := c.c.Control(fn); err != nil {
		return err
	}
	return os.NewSyscallError("setsockopt", operr)
}
package socket
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0x18
	sysSOCK_RAW = 0x3
)
type iovec struct {
	Base *byte
	Len  uint64
}
type msghdr struct {
	Name       *byte
	Namelen    uint32
	Pad_cgo_0  [4]byte
	Iov        *iovec
	Iovlen     uint32
	Pad_cgo_1  [4]byte
	Control    *byte
	Controllen uint32
	Flags      int32
}
type cmsghdr struct {
	Len   uint32
	Level int32
	Type  int32
}
type sockaddrInet struct {
	Len    uint8
	Family uint8
	Port   uint16
	Addr   [4]byte 
	Zero   [8]int8
}
type sockaddrInet6 struct {
	Len      uint8
	Family   uint8
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte 
	Scope_id uint32
}
const (
	sizeofIovec   = 0x10
	sizeofMsghdr  = 0x30
	sizeofCmsghdr = 0xc
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x1c
)
package socket
#include <sys
#include <netinet
*
import "C"
const (
	sysAF_UNSPEC = C.AF_UNSPEC
	sysAF_INET   = C.AF_INET
	sysAF_INET6  = C.AF_INET6
	sysSOCK_RAW = C.SOCK_RAW
)
type iovec C.struct_iovec
type msghdr C.struct_msghdr
type cmsghdr C.struct_cmsghdr
type sockaddrInet C.struct_sockaddr_in
type sockaddrInet6 C.struct_sockaddr_in6
const (
	sizeofIovec   = C.sizeof_struct_iovec
	sizeofMsghdr  = C.sizeof_struct_msghdr
	sizeofCmsghdr = C.sizeof_struct_cmsghdr
	sizeofSockaddrInet  = C.sizeof_struct_sockaddr_in
	sizeofSockaddrInet6 = C.sizeof_struct_sockaddr_in6
)
package socket
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0xa
	sysSOCK_RAW = 0x3
)
type iovec struct {
	Base *byte
	Len  uint32
}
type msghdr struct {
	Name       *byte
	Namelen    uint32
	Iov        *iovec
	Iovlen     uint32
	Control    *byte
	Controllen uint32
	Flags      int32
}
type mmsghdr struct {
	Hdr msghdr
	Len uint32
}
type cmsghdr struct {
	Len   uint32
	Level int32
	Type  int32
}
type sockaddrInet struct {
	Family uint16
	Port   uint16
	Addr   [4]byte 
	X__pad [8]uint8
}
type sockaddrInet6 struct {
	Family   uint16
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte 
	Scope_id uint32
}
const (
	sizeofIovec   = 0x8
	sizeofMsghdr  = 0x1c
	sizeofMmsghdr = 0x20
	sizeofCmsghdr = 0xc
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x1c
)
package socket
import "unsafe"
func (h *msghdr) pack(vs []iovec, bs [][]byte, oob []byte, sa []byte) {
	for i := range vs {
		vs[i].set(bs[i])
	}
	h.setIov(vs)
	if len(oob) > 0 {
		h.setControl(oob)
	}
	if sa != nil {
		h.Name = (*byte)(unsafe.Pointer(&sa[0]))
		h.Namelen = uint32(len(sa))
	}
}
func (h *msghdr) name() []byte {
	if h.Name != nil && h.Namelen > 0 {
		return (*[sizeofSockaddrInet6]byte)(unsafe.Pointer(h.Name))[:h.Namelen]
	}
	return nil
}
func (h *msghdr) controllen() int {
	return int(h.Controllen)
}
func (h *msghdr) flags() int {
	return int(h.Flags)
}
package socket
type cmsghdr struct{}
const sizeofCmsghdr = 0
func (h *cmsghdr) len() int { return 0 }
func (h *cmsghdr) lvl() int { return 0 }
func (h *cmsghdr) typ() int { return 0 }
func (h *cmsghdr) set(l, lvl, typ int) {}
package socket
func (h *msghdr) setIov(vs []iovec) {
	h.Iov = &vs[0]
	h.Iovlen = uint32(len(vs))
}
package socket
func (h *cmsghdr) len() int { return int(h.Len) }
func (h *cmsghdr) lvl() int { return int(h.Level) }
func (h *cmsghdr) typ() int { return int(h.Type) }
package socket
#include <sys
#include <netinet
*
import "C"
const (
	sysAF_UNSPEC = C.AF_UNSPEC
	sysAF_INET   = C.AF_INET
	sysAF_INET6  = C.AF_INET6
	sysSOCK_RAW = C.SOCK_RAW
)
type iovec C.struct_iovec
type msghdr C.struct_msghdr
type cmsghdr C.struct_cmsghdr
type sockaddrInet C.struct_sockaddr_in
type sockaddrInet6 C.struct_sockaddr_in6
const (
	sizeofIovec   = C.sizeof_struct_iovec
	sizeofMsghdr  = C.sizeof_struct_msghdr
	sizeofCmsghdr = C.sizeof_struct_cmsghdr
	sizeofSockaddrInet  = C.sizeof_struct_sockaddr_in
	sizeofSockaddrInet6 = C.sizeof_struct_sockaddr_in6
)
package socket
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0x1c
	sysSOCK_RAW = 0x3
)
type iovec struct {
	Base *byte
	Len  uint64
}
type msghdr struct {
	Name       *byte
	Namelen    uint32
	Pad_cgo_0  [4]byte
	Iov        *iovec
	Iovlen     int32
	Pad_cgo_1  [4]byte
	Control    *byte
	Controllen uint32
	Flags      int32
}
type cmsghdr struct {
	Len   uint32
	Level int32
	Type  int32
}
type sockaddrInet struct {
	Len    uint8
	Family uint8
	Port   uint16
	Addr   [4]byte 
	Zero   [8]int8
}
type sockaddrInet6 struct {
	Len      uint8
	Family   uint8
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte 
	Scope_id uint32
}
const (
	sizeofIovec   = 0x10
	sizeofMsghdr  = 0x30
	sizeofCmsghdr = 0xc
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x1c
)
package socket
import "unsafe"
func (h *msghdr) setIov(vs []iovec) {
	h.Iov = &vs[0]
	h.Iovlen = uint32(len(vs))
}
func (h *msghdr) setControl(b []byte) {
	h.Control = (*byte)(unsafe.Pointer(&b[0]))
	h.Controllen = uint32(len(b))
}
package socket
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0x18
	sysSOCK_RAW = 0x3
)
type iovec struct {
	Base *byte
	Len  uint32
}
type msghdr struct {
	Name       *byte
	Namelen    uint32
	Iov        *iovec
	Iovlen     int32
	Control    *byte
	Controllen uint32
	Flags      int32
}
type mmsghdr struct {
	Hdr msghdr
	Len uint32
}
type cmsghdr struct {
	Len   uint32
	Level int32
	Type  int32
}
type sockaddrInet struct {
	Len    uint8
	Family uint8
	Port   uint16
	Addr   [4]byte 
	Zero   [8]int8
}
type sockaddrInet6 struct {
	Len      uint8
	Family   uint8
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte 
	Scope_id uint32
}
const (
	sizeofIovec   = 0x8
	sizeofMsghdr  = 0x1c
	sizeofMmsghdr = 0x20
	sizeofCmsghdr = 0xc
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x1c
)
package socket
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0xa
	sysSOCK_RAW = 0x3
)
type iovec struct {
	Base *byte
	Len  uint64
}
type msghdr struct {
	Name       *byte
	Namelen    uint32
	Pad_cgo_0  [4]byte
	Iov        *iovec
	Iovlen     uint64
	Control    *byte
	Controllen uint64
	Flags      int32
	Pad_cgo_1  [4]byte
}
type mmsghdr struct {
	Hdr       msghdr
	Len       uint32
	Pad_cgo_0 [4]byte
}
type cmsghdr struct {
	Len   uint64
	Level int32
	Type  int32
}
type sockaddrInet struct {
	Family uint16
	Port   uint16
	Addr   [4]byte 
	X__pad [8]uint8
}
type sockaddrInet6 struct {
	Family   uint16
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte 
	Scope_id uint32
}
const (
	sizeofIovec   = 0x10
	sizeofMsghdr  = 0x38
	sizeofMmsghdr = 0x40
	sizeofCmsghdr = 0x10
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x1c
)
package socket
func (h *cmsghdr) set(l, lvl, typ int) {
	h.Len = uint64(l)
	h.Level = int32(lvl)
	h.Type = int32(typ)
}
package socket
import (
	"errors"
	"runtime"
	"syscall"
	"unsafe"
)
func probeProtocolStack() int {
	switch runtime.GOARCH {
	case "amd64":
		return 4
	default:
		var p uintptr
		return int(unsafe.Sizeof(p))
	}
}
var (
	procGetsockopt uintptr
	procSetsockopt uintptr
	procRecvmsg    uintptr
	procSendmsg    uintptr
)
func sysvicall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (uintptr, uintptr, syscall.Errno)
func rawSysvicall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (uintptr, uintptr, syscall.Errno)
func getsockopt(s uintptr, level, name int, b []byte) (int, error) {
	l := uint32(len(b))
	_, _, errno := sysvicall6(uintptr(unsafe.Pointer(&procGetsockopt)), 5, s, uintptr(level), uintptr(name), uintptr(unsafe.Pointer(&b[0])), uintptr(unsafe.Pointer(&l)), 0)
	return int(l), errnoErr(errno)
}
func setsockopt(s uintptr, level, name int, b []byte) error {
	_, _, errno := sysvicall6(uintptr(unsafe.Pointer(&procSetsockopt)), 5, s, uintptr(level), uintptr(name), uintptr(unsafe.Pointer(&b[0])), uintptr(len(b)), 0)
	return errnoErr(errno)
}
func recvmsg(s uintptr, h *msghdr, flags int) (int, error) {
	n, _, errno := sysvicall6(uintptr(unsafe.Pointer(&procRecvmsg)), 3, s, uintptr(unsafe.Pointer(h)), uintptr(flags), 0, 0, 0)
	return int(n), errnoErr(errno)
}
func sendmsg(s uintptr, h *msghdr, flags int) (int, error) {
	n, _, errno := sysvicall6(uintptr(unsafe.Pointer(&procSendmsg)), 3, s, uintptr(unsafe.Pointer(h)), uintptr(flags), 0, 0, 0)
	return int(n), errnoErr(errno)
}
func recvmmsg(s uintptr, hs []mmsghdr, flags int) (int, error) {
	return 0, errors.New("not implemented")
}
func sendmmsg(s uintptr, hs []mmsghdr, flags int) (int, error) {
	return 0, errors.New("not implemented")
}
package socket
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0xa
	sysSOCK_RAW = 0x3
)
type iovec struct {
	Base *byte
	Len  uint32
}
type msghdr struct {
	Name       *byte
	Namelen    uint32
	Iov        *iovec
	Iovlen     uint32
	Control    *byte
	Controllen uint32
	Flags      int32
}
type mmsghdr struct {
	Hdr msghdr
	Len uint32
}
type cmsghdr struct {
	Len   uint32
	Level int32
	Type  int32
}
type sockaddrInet struct {
	Family uint16
	Port   uint16
	Addr   [4]byte 
	X__pad [8]uint8
}
type sockaddrInet6 struct {
	Family   uint16
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte 
	Scope_id uint32
}
const (
	sizeofIovec   = 0x8
	sizeofMsghdr  = 0x1c
	sizeofMmsghdr = 0x20
	sizeofCmsghdr = 0xc
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x1c
)
package socket
const (
	sysRECVMMSG = 0x12b
	sysSENDMMSG = 0x133
)
package socket
func (h *cmsghdr) set(l, lvl, typ int) {
	h.Len = uint32(l)
	h.Level = int32(lvl)
	h.Type = int32(typ)
}
package socket_test
import (
	"net"
	"runtime"
	"syscall"
	"testing"
	"golang.org
	"golang.org
)
func TestSocket(t *testing.T) {
	t.Run("Option", func(t *testing.T) {
		testSocketOption(t, &socket.Option{Level: syscall.SOL_SOCKET, Name: syscall.SO_RCVBUF, Len: 4})
	})
}
func testSocketOption(t *testing.T, so *socket.Option) {
	c, err := nettest.NewLocalPacketListener("udp")
	if err != nil {
		t.Skipf("not supported on %s
	}
	defer c.Close()
	cc, err := socket.NewConn(c.(net.Conn))
	if err != nil {
		t.Fatal(err)
	}
	const N = 2048
	if err := so.SetInt(cc, N); err != nil {
		t.Fatal(err)
	}
	n, err := so.GetInt(cc)
	if err != nil {
		t.Fatal(err)
	}
	if n < N {
		t.Fatalf("got %d; want greater than or equal to %d", n, N)
	}
}
package socket
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0x1c
	sysSOCK_RAW = 0x3
)
type iovec struct {
	Base *byte
	Len  uint32
}
type msghdr struct {
	Name       *byte
	Namelen    uint32
	Iov        *iovec
	Iovlen     int32
	Control    *byte
	Controllen uint32
	Flags      int32
}
type cmsghdr struct {
	Len   uint32
	Level int32
	Type  int32
}
type sockaddrInet struct {
	Len    uint8
	Family uint8
	Port   uint16
	Addr   [4]byte 
	Zero   [8]int8
}
type sockaddrInet6 struct {
	Len      uint8
	Family   uint8
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte 
	Scope_id uint32
}
const (
	sizeofIovec   = 0x8
	sizeofMsghdr  = 0x1c
	sizeofCmsghdr = 0xc
	sizeofSockaddrInet  = 0x10
	sizeofSockaddrInet6 = 0x1c
)
package netutil
import (
	"errors"
	"fmt"
	"io"
	"io
	"net"
	"net
	"sync"
	"sync
	"testing"
	"time"
	"golang.org
)
func TestLimitListener(t *testing.T) {
	const max = 5
	attempts := (nettest.MaxOpenFiles() - max) 
	if attempts > 256 { 
		attempts = 256
	}
	l, err := net.Listen("tcp", "127.0.0.1:0")
	if err != nil {
		t.Fatal(err)
	}
	defer l.Close()
	l = LimitListener(l, max)
	var open int32
	go http.Serve(l, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if n := atomic.AddInt32(&open, 1); n > max {
			t.Errorf("%d open connections, want <= %d", n, max)
		}
		defer atomic.AddInt32(&open, -1)
		time.Sleep(10 * time.Millisecond)
		fmt.Fprint(w, "some body")
	}))
	var wg sync.WaitGroup
	var failed int32
	for i := 0; i < attempts; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			c := http.Client{Timeout: 3 * time.Second}
			r, err := c.Get("http:
			if err != nil {
				t.Log(err)
				atomic.AddInt32(&failed, 1)
				return
			}
			defer r.Body.Close()
			io.Copy(ioutil.Discard, r.Body)
		}()
	}
	wg.Wait()
	
	
	if int(failed) >= attempts
		t.Errorf("%d requests failed within %d attempts", failed, attempts)
	}
}
type errorListener struct {
	net.Listener
}
func (errorListener) Accept() (net.Conn, error) {
	return nil, errFake
}
var errFake = errors.New("fake error from errorListener")
func TestLimitListenerError(t *testing.T) {
	donec := make(chan bool, 1)
	go func() {
		const n = 2
		ll := LimitListener(errorListener{}, n)
		for i := 0; i < n+1; i++ {
			_, err := ll.Accept()
			if err != errFake {
				t.Fatalf("Accept error = %v; want errFake", err)
			}
		}
		donec <- true
	}()
	select {
	case <-donec:
	case <-time.After(5 * time.Second):
		t.Fatal("timeout. deadlock?")
	}
}
package netutil 
import (
	"net"
	"sync"
)
func LimitListener(l net.Listener, n int) net.Listener {
	return &limitListener{l, make(chan struct{}, n)}
}
type limitListener struct {
	net.Listener
	sem chan struct{}
}
func (l *limitListener) acquire() { l.sem <- struct{}{} }
func (l *limitListener) release() { <-l.sem }
func (l *limitListener) Accept() (net.Conn, error) {
	l.acquire()
	c, err := l.Listener.Accept()
	if err != nil {
		l.release()
		return nil, err
	}
	return &limitListenerConn{Conn: c, release: l.release}, nil
}
type limitListenerConn struct {
	net.Conn
	releaseOnce sync.Once
	release     func()
}
func (l *limitListenerConn) Close() error {
	err := l.Conn.Close()
	l.releaseOnce.Do(l.release)
	return err
}
package html
var isSpecialElementMap = map[string]bool{
	"address":    true,
	"applet":     true,
	"area":       true,
	"article":    true,
	"aside":      true,
	"base":       true,
	"basefont":   true,
	"bgsound":    true,
	"blockquote": true,
	"body":       true,
	"br":         true,
	"button":     true,
	"caption":    true,
	"center":     true,
	"col":        true,
	"colgroup":   true,
	"dd":         true,
	"details":    true,
	"dir":        true,
	"div":        true,
	"dl":         true,
	"dt":         true,
	"embed":      true,
	"fieldset":   true,
	"figcaption": true,
	"figure":     true,
	"footer":     true,
	"form":       true,
	"frame":      true,
	"frameset":   true,
	"h1":         true,
	"h2":         true,
	"h3":         true,
	"h4":         true,
	"h5":         true,
	"h6":         true,
	"head":       true,
	"header":     true,
	"hgroup":     true,
	"hr":         true,
	"html":       true,
	"iframe":     true,
	"img":        true,
	"input":      true,
	"isindex":    true,
	"li":         true,
	"link":       true,
	"listing":    true,
	"marquee":    true,
	"menu":       true,
	"meta":       true,
	"nav":        true,
	"noembed":    true,
	"noframes":   true,
	"noscript":   true,
	"object":     true,
	"ol":         true,
	"p":          true,
	"param":      true,
	"plaintext":  true,
	"pre":        true,
	"script":     true,
	"section":    true,
	"select":     true,
	"source":     true,
	"style":      true,
	"summary":    true,
	"table":      true,
	"tbody":      true,
	"td":         true,
	"template":   true,
	"textarea":   true,
	"tfoot":      true,
	"th":         true,
	"thead":      true,
	"title":      true,
	"tr":         true,
	"track":      true,
	"ul":         true,
	"wbr":        true,
	"xmp":        true,
}
func isSpecialElement(element *Node) bool {
	switch element.Namespace {
	case "", "html":
		return isSpecialElementMap[element.Data]
	case "svg":
		return element.Data == "foreignObject"
	}
	return false
}
package html
import (
	"bytes"
	"errors"
	"io"
	"strconv"
	"strings"
	"golang.org
)
type TokenType uint32
const (
	
	ErrorToken TokenType = iota
	
	TextToken
	
	StartTagToken
	
	EndTagToken
	
	SelfClosingTagToken
	
	CommentToken
	
	DoctypeToken
)
var ErrBufferExceeded = errors.New("max buffer exceeded")
func (t TokenType) String() string {
	switch t {
	case ErrorToken:
		return "Error"
	case TextToken:
		return "Text"
	case StartTagToken:
		return "StartTag"
	case EndTagToken:
		return "EndTag"
	case SelfClosingTagToken:
		return "SelfClosingTag"
	case CommentToken:
		return "Comment"
	case DoctypeToken:
		return "Doctype"
	}
	return "Invalid(" + strconv.Itoa(int(t)) + ")"
}
type Attribute struct {
	Namespace, Key, Val string
}
type Token struct {
	Type     TokenType
	DataAtom atom.Atom
	Data     string
	Attr     []Attribute
}
func (t Token) tagString() string {
	if len(t.Attr) == 0 {
		return t.Data
	}
	buf := bytes.NewBufferString(t.Data)
	for _, a := range t.Attr {
		buf.WriteByte(' ')
		buf.WriteString(a.Key)
		buf.WriteString(`="`)
		escape(buf, a.Val)
		buf.WriteByte('"')
	}
	return buf.String()
}
func (t Token) String() string {
	switch t.Type {
	case ErrorToken:
		return ""
	case TextToken:
		return EscapeString(t.Data)
	case StartTagToken:
		return "<" + t.tagString() + ">"
	case EndTagToken:
		return "<
	case SelfClosingTagToken:
		return "<" + t.tagString() + "
	case CommentToken:
		return "<!--" + t.Data + "-->"
	case DoctypeToken:
		return "<!DOCTYPE " + t.Data + ">"
	}
	return "Invalid(" + strconv.Itoa(int(t.Type)) + ")"
}
type span struct {
	start, end int
}
type Tokenizer struct {
	
	r io.Reader
	
	tt TokenType
	
	
	
	
	
	
	
	err error
	
	
	
	
	readErr error
	
	
	raw span
	buf []byte
	
	maxBuf int
	
	
	data span
	
	
	
	pendingAttr   [2]span
	attr          [][2]span
	nAttrReturned int
	
	
	
	
	rawTag string
	
	textIsRaw bool
	
	
	convertNUL bool
	
	allowCDATA bool
}
func (z *Tokenizer) AllowCDATA(allowCDATA bool) {
	z.allowCDATA = allowCDATA
}
func (z *Tokenizer) NextIsNotRawText() {
	z.rawTag = ""
}
func (z *Tokenizer) Err() error {
	if z.tt != ErrorToken {
		return nil
	}
	return z.err
}
func (z *Tokenizer) readByte() byte {
	if z.raw.end >= len(z.buf) {
		
		
		if z.readErr != nil {
			z.err = z.readErr
			return 0
		}
		
		
		
		c := cap(z.buf)
		d := z.raw.end - z.raw.start
		var buf1 []byte
		if 2*d > c {
			buf1 = make([]byte, d, 2*c)
		} else {
			buf1 = z.buf[:d]
		}
		copy(buf1, z.buf[z.raw.start:z.raw.end])
		if x := z.raw.start; x != 0 {
			
			z.data.start -= x
			z.data.end -= x
			z.pendingAttr[0].start -= x
			z.pendingAttr[0].end -= x
			z.pendingAttr[1].start -= x
			z.pendingAttr[1].end -= x
			for i := range z.attr {
				z.attr[i][0].start -= x
				z.attr[i][0].end -= x
				z.attr[i][1].start -= x
				z.attr[i][1].end -= x
			}
		}
		z.raw.start, z.raw.end, z.buf = 0, d, buf1[:d]
		
		
		var n int
		n, z.readErr = readAtLeastOneByte(z.r, buf1[d:cap(buf1)])
		if n == 0 {
			z.err = z.readErr
			return 0
		}
		z.buf = buf1[:d+n]
	}
	x := z.buf[z.raw.end]
	z.raw.end++
	if z.maxBuf > 0 && z.raw.end-z.raw.start >= z.maxBuf {
		z.err = ErrBufferExceeded
		return 0
	}
	return x
}
func (z *Tokenizer) Buffered() []byte {
	return z.buf[z.raw.end:]
}
func readAtLeastOneByte(r io.Reader, b []byte) (int, error) {
	for i := 0; i < 100; i++ {
		n, err := r.Read(b)
		if n != 0 || err != nil {
			return n, err
		}
	}
	return 0, io.ErrNoProgress
}
func (z *Tokenizer) skipWhiteSpace() {
	if z.err != nil {
		return
	}
	for {
		c := z.readByte()
		if z.err != nil {
			return
		}
		switch c {
		case ' ', '\n', '\r', '\t', '\f':
			
		default:
			z.raw.end--
			return
		}
	}
}
func (z *Tokenizer) readRawOrRCDATA() {
	if z.rawTag == "script" {
		z.readScript()
		z.textIsRaw = true
		z.rawTag = ""
		return
	}
loop:
	for {
		c := z.readByte()
		if z.err != nil {
			break loop
		}
		if c != '<' {
			continue loop
		}
		c = z.readByte()
		if z.err != nil {
			break loop
		}
		if c != '
			continue loop
		}
		if z.readRawEndTag() || z.err != nil {
			break loop
		}
	}
	z.data.end = z.raw.end
	
	z.textIsRaw = z.rawTag != "textarea" && z.rawTag != "title"
	z.rawTag = ""
}
func (z *Tokenizer) readRawEndTag() bool {
	for i := 0; i < len(z.rawTag); i++ {
		c := z.readByte()
		if z.err != nil {
			return false
		}
		if c != z.rawTag[i] && c != z.rawTag[i]-('a'-'A') {
			z.raw.end--
			return false
		}
	}
	c := z.readByte()
	if z.err != nil {
		return false
	}
	switch c {
	case ' ', '\n', '\r', '\t', '\f', '
		
		z.raw.end -= 3 + len(z.rawTag)
		return true
	}
	z.raw.end--
	return false
}
func (z *Tokenizer) readScript() {
	defer func() {
		z.data.end = z.raw.end
	}()
	var c byte
scriptData:
	c = z.readByte()
	if z.err != nil {
		return
	}
	if c == '<' {
		goto scriptDataLessThanSign
	}
	goto scriptData
scriptDataLessThanSign:
	c = z.readByte()
	if z.err != nil {
		return
	}
	switch c {
	case '
		goto scriptDataEndTagOpen
	case '!':
		goto scriptDataEscapeStart
	}
	z.raw.end--
	goto scriptData
scriptDataEndTagOpen:
	if z.readRawEndTag() || z.err != nil {
		return
	}
	goto scriptData
scriptDataEscapeStart:
	c = z.readByte()
	if z.err != nil {
		return
	}
	if c == '-' {
		goto scriptDataEscapeStartDash
	}
	z.raw.end--
	goto scriptData
scriptDataEscapeStartDash:
	c = z.readByte()
	if z.err != nil {
		return
	}
	if c == '-' {
		goto scriptDataEscapedDashDash
	}
	z.raw.end--
	goto scriptData
scriptDataEscaped:
	c = z.readByte()
	if z.err != nil {
		return
	}
	switch c {
	case '-':
		goto scriptDataEscapedDash
	case '<':
		goto scriptDataEscapedLessThanSign
	}
	goto scriptDataEscaped
scriptDataEscapedDash:
	c = z.readByte()
	if z.err != nil {
		return
	}
	switch c {
	case '-':
		goto scriptDataEscapedDashDash
	case '<':
		goto scriptDataEscapedLessThanSign
	}
	goto scriptDataEscaped
scriptDataEscapedDashDash:
	c = z.readByte()
	if z.err != nil {
		return
	}
	switch c {
	case '-':
		goto scriptDataEscapedDashDash
	case '<':
		goto scriptDataEscapedLessThanSign
	case '>':
		goto scriptData
	}
	goto scriptDataEscaped
scriptDataEscapedLessThanSign:
	c = z.readByte()
	if z.err != nil {
		return
	}
	if c == '
		goto scriptDataEscapedEndTagOpen
	}
	if 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z' {
		goto scriptDataDoubleEscapeStart
	}
	z.raw.end--
	goto scriptData
scriptDataEscapedEndTagOpen:
	if z.readRawEndTag() || z.err != nil {
		return
	}
	goto scriptDataEscaped
scriptDataDoubleEscapeStart:
	z.raw.end--
	for i := 0; i < len("script"); i++ {
		c = z.readByte()
		if z.err != nil {
			return
		}
		if c != "script"[i] && c != "SCRIPT"[i] {
			z.raw.end--
			goto scriptDataEscaped
		}
	}
	c = z.readByte()
	if z.err != nil {
		return
	}
	switch c {
	case ' ', '\n', '\r', '\t', '\f', '
		goto scriptDataDoubleEscaped
	}
	z.raw.end--
	goto scriptDataEscaped
scriptDataDoubleEscaped:
	c = z.readByte()
	if z.err != nil {
		return
	}
	switch c {
	case '-':
		goto scriptDataDoubleEscapedDash
	case '<':
		goto scriptDataDoubleEscapedLessThanSign
	}
	goto scriptDataDoubleEscaped
scriptDataDoubleEscapedDash:
	c = z.readByte()
	if z.err != nil {
		return
	}
	switch c {
	case '-':
		goto scriptDataDoubleEscapedDashDash
	case '<':
		goto scriptDataDoubleEscapedLessThanSign
	}
	goto scriptDataDoubleEscaped
scriptDataDoubleEscapedDashDash:
	c = z.readByte()
	if z.err != nil {
		return
	}
	switch c {
	case '-':
		goto scriptDataDoubleEscapedDashDash
	case '<':
		goto scriptDataDoubleEscapedLessThanSign
	case '>':
		goto scriptData
	}
	goto scriptDataDoubleEscaped
scriptDataDoubleEscapedLessThanSign:
	c = z.readByte()
	if z.err != nil {
		return
	}
	if c == '
		goto scriptDataDoubleEscapeEnd
	}
	z.raw.end--
	goto scriptDataDoubleEscaped
scriptDataDoubleEscapeEnd:
	if z.readRawEndTag() {
		z.raw.end += len("<
		goto scriptDataEscaped
	}
	if z.err != nil {
		return
	}
	goto scriptDataDoubleEscaped
}
func (z *Tokenizer) readComment() {
	z.data.start = z.raw.end
	defer func() {
		if z.data.end < z.data.start {
			
			z.data.end = z.data.start
		}
	}()
	for dashCount := 2; ; {
		c := z.readByte()
		if z.err != nil {
			
			if dashCount > 2 {
				dashCount = 2
			}
			z.data.end = z.raw.end - dashCount
			return
		}
		switch c {
		case '-':
			dashCount++
			continue
		case '>':
			if dashCount >= 2 {
				z.data.end = z.raw.end - len("-->")
				return
			}
		case '!':
			if dashCount >= 2 {
				c = z.readByte()
				if z.err != nil {
					z.data.end = z.raw.end
					return
				}
				if c == '>' {
					z.data.end = z.raw.end - len("--!>")
					return
				}
			}
		}
		dashCount = 0
	}
}
func (z *Tokenizer) readUntilCloseAngle() {
	z.data.start = z.raw.end
	for {
		c := z.readByte()
		if z.err != nil {
			z.data.end = z.raw.end
			return
		}
		if c == '>' {
			z.data.end = z.raw.end - len(">")
			return
		}
	}
}
func (z *Tokenizer) readMarkupDeclaration() TokenType {
	z.data.start = z.raw.end
	var c [2]byte
	for i := 0; i < 2; i++ {
		c[i] = z.readByte()
		if z.err != nil {
			z.data.end = z.raw.end
			return CommentToken
		}
	}
	if c[0] == '-' && c[1] == '-' {
		z.readComment()
		return CommentToken
	}
	z.raw.end -= 2
	if z.readDoctype() {
		return DoctypeToken
	}
	if z.allowCDATA && z.readCDATA() {
		z.convertNUL = true
		return TextToken
	}
	
	z.readUntilCloseAngle()
	return CommentToken
}
func (z *Tokenizer) readDoctype() bool {
	const s = "DOCTYPE"
	for i := 0; i < len(s); i++ {
		c := z.readByte()
		if z.err != nil {
			z.data.end = z.raw.end
			return false
		}
		if c != s[i] && c != s[i]+('a'-'A') {
			
			z.raw.end = z.data.start
			return false
		}
	}
	if z.skipWhiteSpace(); z.err != nil {
		z.data.start = z.raw.end
		z.data.end = z.raw.end
		return true
	}
	z.readUntilCloseAngle()
	return true
}
func (z *Tokenizer) readCDATA() bool {
	const s = "[CDATA["
	for i := 0; i < len(s); i++ {
		c := z.readByte()
		if z.err != nil {
			z.data.end = z.raw.end
			return false
		}
		if c != s[i] {
			
			z.raw.end = z.data.start
			return false
		}
	}
	z.data.start = z.raw.end
	brackets := 0
	for {
		c := z.readByte()
		if z.err != nil {
			z.data.end = z.raw.end
			return true
		}
		switch c {
		case ']':
			brackets++
		case '>':
			if brackets >= 2 {
				z.data.end = z.raw.end - len("]]>")
				return true
			}
			brackets = 0
		default:
			brackets = 0
		}
	}
}
func (z *Tokenizer) startTagIn(ss ...string) bool {
loop:
	for _, s := range ss {
		if z.data.end-z.data.start != len(s) {
			continue loop
		}
		for i := 0; i < len(s); i++ {
			c := z.buf[z.data.start+i]
			if 'A' <= c && c <= 'Z' {
				c += 'a' - 'A'
			}
			if c != s[i] {
				continue loop
			}
		}
		return true
	}
	return false
}
func (z *Tokenizer) readStartTag() TokenType {
	z.readTag(true)
	if z.err != nil {
		return ErrorToken
	}
	
	c, raw := z.buf[z.data.start], false
	if 'A' <= c && c <= 'Z' {
		c += 'a' - 'A'
	}
	switch c {
	case 'i':
		raw = z.startTagIn("iframe")
	case 'n':
		raw = z.startTagIn("noembed", "noframes", "noscript")
	case 'p':
		raw = z.startTagIn("plaintext")
	case 's':
		raw = z.startTagIn("script", "style")
	case 't':
		raw = z.startTagIn("textarea", "title")
	case 'x':
		raw = z.startTagIn("xmp")
	}
	if raw {
		z.rawTag = strings.ToLower(string(z.buf[z.data.start:z.data.end]))
	}
	
	if z.err == nil && z.buf[z.raw.end-2] == '
		return SelfClosingTagToken
	}
	return StartTagToken
}
func (z *Tokenizer) readTag(saveAttr bool) {
	z.attr = z.attr[:0]
	z.nAttrReturned = 0
	
	z.readTagName()
	if z.skipWhiteSpace(); z.err != nil {
		return
	}
	for {
		c := z.readByte()
		if z.err != nil || c == '>' {
			break
		}
		z.raw.end--
		z.readTagAttrKey()
		z.readTagAttrVal()
		
		if saveAttr && z.pendingAttr[0].start != z.pendingAttr[0].end {
			z.attr = append(z.attr, z.pendingAttr)
		}
		if z.skipWhiteSpace(); z.err != nil {
			break
		}
	}
}
func (z *Tokenizer) readTagName() {
	z.data.start = z.raw.end - 1
	for {
		c := z.readByte()
		if z.err != nil {
			z.data.end = z.raw.end
			return
		}
		switch c {
		case ' ', '\n', '\r', '\t', '\f':
			z.data.end = z.raw.end - 1
			return
		case '
			z.raw.end--
			z.data.end = z.raw.end
			return
		}
	}
}
func (z *Tokenizer) readTagAttrKey() {
	z.pendingAttr[0].start = z.raw.end
	for {
		c := z.readByte()
		if z.err != nil {
			z.pendingAttr[0].end = z.raw.end
			return
		}
		switch c {
		case ' ', '\n', '\r', '\t', '\f', '
			z.pendingAttr[0].end = z.raw.end - 1
			return
		case '=', '>':
			z.raw.end--
			z.pendingAttr[0].end = z.raw.end
			return
		}
	}
}
func (z *Tokenizer) readTagAttrVal() {
	z.pendingAttr[1].start = z.raw.end
	z.pendingAttr[1].end = z.raw.end
	if z.skipWhiteSpace(); z.err != nil {
		return
	}
	c := z.readByte()
	if z.err != nil {
		return
	}
	if c != '=' {
		z.raw.end--
		return
	}
	if z.skipWhiteSpace(); z.err != nil {
		return
	}
	quote := z.readByte()
	if z.err != nil {
		return
	}
	switch quote {
	case '>':
		z.raw.end--
		return
	case '\'', '"':
		z.pendingAttr[1].start = z.raw.end
		for {
			c := z.readByte()
			if z.err != nil {
				z.pendingAttr[1].end = z.raw.end
				return
			}
			if c == quote {
				z.pendingAttr[1].end = z.raw.end - 1
				return
			}
		}
	default:
		z.pendingAttr[1].start = z.raw.end - 1
		for {
			c := z.readByte()
			if z.err != nil {
				z.pendingAttr[1].end = z.raw.end
				return
			}
			switch c {
			case ' ', '\n', '\r', '\t', '\f':
				z.pendingAttr[1].end = z.raw.end - 1
				return
			case '>':
				z.raw.end--
				z.pendingAttr[1].end = z.raw.end
				return
			}
		}
	}
}
func (z *Tokenizer) Next() TokenType {
	z.raw.start = z.raw.end
	z.data.start = z.raw.end
	z.data.end = z.raw.end
	if z.err != nil {
		z.tt = ErrorToken
		return z.tt
	}
	if z.rawTag != "" {
		if z.rawTag == "plaintext" {
			
			for z.err == nil {
				z.readByte()
			}
			z.data.end = z.raw.end
			z.textIsRaw = true
		} else {
			z.readRawOrRCDATA()
		}
		if z.data.end > z.data.start {
			z.tt = TextToken
			z.convertNUL = true
			return z.tt
		}
	}
	z.textIsRaw = false
	z.convertNUL = false
loop:
	for {
		c := z.readByte()
		if z.err != nil {
			break loop
		}
		if c != '<' {
			continue loop
		}
		
		
		c = z.readByte()
		if z.err != nil {
			break loop
		}
		var tokenType TokenType
		switch {
		case 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z':
			tokenType = StartTagToken
		case c == '
			tokenType = EndTagToken
		case c == '!' || c == '?':
			
			
			tokenType = CommentToken
		default:
			
			z.raw.end--
			continue
		}
		
		
		
		if x := z.raw.end - len("<a"); z.raw.start < x {
			z.raw.end = x
			z.data.end = x
			z.tt = TextToken
			return z.tt
		}
		switch tokenType {
		case StartTagToken:
			z.tt = z.readStartTag()
			return z.tt
		case EndTagToken:
			c = z.readByte()
			if z.err != nil {
				break loop
			}
			if c == '>' {
				
				
				
				z.tt = CommentToken
				return z.tt
			}
			if 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z' {
				z.readTag(false)
				if z.err != nil {
					z.tt = ErrorToken
				} else {
					z.tt = EndTagToken
				}
				return z.tt
			}
			z.raw.end--
			z.readUntilCloseAngle()
			z.tt = CommentToken
			return z.tt
		case CommentToken:
			if c == '!' {
				z.tt = z.readMarkupDeclaration()
				return z.tt
			}
			z.raw.end--
			z.readUntilCloseAngle()
			z.tt = CommentToken
			return z.tt
		}
	}
	if z.raw.start < z.raw.end {
		z.data.end = z.raw.end
		z.tt = TextToken
		return z.tt
	}
	z.tt = ErrorToken
	return z.tt
}
func (z *Tokenizer) Raw() []byte {
	return z.buf[z.raw.start:z.raw.end]
}
func convertNewlines(s []byte) []byte {
	for i, c := range s {
		if c != '\r' {
			continue
		}
		src := i + 1
		if src >= len(s) || s[src] != '\n' {
			s[i] = '\n'
			continue
		}
		dst := i
		for src < len(s) {
			if s[src] == '\r' {
				if src+1 < len(s) && s[src+1] == '\n' {
					src++
				}
				s[dst] = '\n'
			} else {
				s[dst] = s[src]
			}
			src++
			dst++
		}
		return s[:dst]
	}
	return s
}
var (
	nul         = []byte("\x00")
	replacement = []byte("\ufffd")
)
func (z *Tokenizer) Text() []byte {
	switch z.tt {
	case TextToken, CommentToken, DoctypeToken:
		s := z.buf[z.data.start:z.data.end]
		z.data.start = z.raw.end
		z.data.end = z.raw.end
		s = convertNewlines(s)
		if (z.convertNUL || z.tt == CommentToken) && bytes.Contains(s, nul) {
			s = bytes.Replace(s, nul, replacement, -1)
		}
		if !z.textIsRaw {
			s = unescape(s, false)
		}
		return s
	}
	return nil
}
func (z *Tokenizer) TagName() (name []byte, hasAttr bool) {
	if z.data.start < z.data.end {
		switch z.tt {
		case StartTagToken, EndTagToken, SelfClosingTagToken:
			s := z.buf[z.data.start:z.data.end]
			z.data.start = z.raw.end
			z.data.end = z.raw.end
			return lower(s), z.nAttrReturned < len(z.attr)
		}
	}
	return nil, false
}
func (z *Tokenizer) TagAttr() (key, val []byte, moreAttr bool) {
	if z.nAttrReturned < len(z.attr) {
		switch z.tt {
		case StartTagToken, SelfClosingTagToken:
			x := z.attr[z.nAttrReturned]
			z.nAttrReturned++
			key = z.buf[x[0].start:x[0].end]
			val = z.buf[x[1].start:x[1].end]
			return lower(key), unescape(convertNewlines(val), true), z.nAttrReturned < len(z.attr)
		}
	}
	return nil, nil, false
}
func (z *Tokenizer) Token() Token {
	t := Token{Type: z.tt}
	switch z.tt {
	case TextToken, CommentToken, DoctypeToken:
		t.Data = string(z.Text())
	case StartTagToken, SelfClosingTagToken, EndTagToken:
		name, moreAttr := z.TagName()
		for moreAttr {
			var key, val []byte
			key, val, moreAttr = z.TagAttr()
			t.Attr = append(t.Attr, Attribute{"", atom.String(key), string(val)})
		}
		if a := atom.Lookup(name); a != 0 {
			t.DataAtom, t.Data = a, a.String()
		} else {
			t.DataAtom, t.Data = 0, string(name)
		}
	}
	return t
}
func (z *Tokenizer) SetMaxBuf(n int) {
	z.maxBuf = n
}
func NewTokenizer(r io.Reader) *Tokenizer {
	return NewTokenizerFragment(r, "")
}
func NewTokenizerFragment(r io.Reader, contextTag string) *Tokenizer {
	z := &Tokenizer{
		r:   r,
		buf: make([]byte, 0, 4096),
	}
	if contextTag != "" {
		switch s := strings.ToLower(contextTag); s {
		case "iframe", "noembed", "noframes", "noscript", "plaintext", "script", "style", "title", "textarea", "xmp":
			z.rawTag = s
		}
	}
	return z
}
package html
import (
	"bytes"
	"io"
	"io
	"reflect"
	"runtime"
	"strings"
	"testing"
)
type tokenTest struct {
	
	desc string
	
	html string
	
	golden string
}
var tokenTests = []tokenTest{
	{
		"empty",
		"",
		"",
	},
	
	
	{
		"text",
		"foo  bar",
		"foo  bar",
	},
	
	{
		"entity",
		"one &lt; two",
		"one &lt; two",
	},
	
	
	{
		"tags",
		"<a>b<c
		"<a>$b$<c
	},
	
	{
		"not a tag #0",
		"<",
		"&lt;",
	},
	{
		"not a tag #1",
		"<
		"&lt;
	},
	{
		"not a tag #2",
		"<
		"<!---->",
	},
	{
		"not a tag #3",
		"a<
		"a$<!---->$b",
	},
	{
		"not a tag #4",
		"<
		"<!-- -->",
	},
	{
		"not a tag #5",
		"<
		"<!--.-->",
	},
	{
		"not a tag #6",
		"<
		"<!--.-->",
	},
	{
		"not a tag #7",
		"a < b",
		"a &lt; b",
	},
	{
		"not a tag #8",
		"<.>",
		"&lt;.&gt;",
	},
	{
		"not a tag #9",
		"a<<<b>>>c",
		"a&lt;&lt;$<b>$&gt;&gt;c",
	},
	{
		"not a tag #10",
		"if x<0 and y < 0 then x*y>0",
		"if x&lt;0 and y &lt; 0 then x*y&gt;0",
	},
	{
		"not a tag #11",
		"<<p>",
		"&lt;$<p>",
	},
	
	{
		"tag name eof #0",
		"<a",
		"",
	},
	{
		"tag name eof #1",
		"<a ",
		"",
	},
	{
		"tag name eof #2",
		"a<b",
		"a",
	},
	{
		"tag name eof #3",
		"<a><b",
		"<a>",
	},
	{
		"tag name eof #4",
		`<a x`,
		``,
	},
	
	{
		"malformed tag #0",
		`<p<
		`<p< p="">`,
	},
	{
		"malformed tag #1",
		`<p <
		`<p <="" p="">`,
	},
	{
		"malformed tag #2",
		`<p id`,
		``,
	},
	{
		"malformed tag #3",
		`<p id=`,
		``,
	},
	{
		"malformed tag #4",
		`<p id=>`,
		`<p id="">`,
	},
	{
		"malformed tag #5",
		`<p id=0`,
		``,
	},
	{
		"malformed tag #6",
		`<p id=0<
		`<p id="0&lt;
	},
	{
		"malformed tag #7",
		`<p id="0<
		``,
	},
	{
		"malformed tag #8",
		`<p id="0"<
		`<p id="0" <="" p="">`,
	},
	{
		"malformed tag #9",
		`<p><
		`<p>`,
	},
	
	{
		"basic raw text",
		"<script><a><
		"<script>$&lt;a&gt;&lt;
	},
	{
		"unfinished script end tag",
		"<SCRIPT>a<
		"<script>$a&lt;
	},
	{
		"broken script end tag",
		"<SCRIPT>a<
		"<script>$a&lt;
	},
	{
		"EOF in script end tag",
		"<SCRIPT>a<
		"<script>$a&lt;
	},
	{
		"scriptx end tag",
		"<SCRIPT>a<
		"<script>$a&lt;
	},
	{
		"' ' completes script end tag",
		"<SCRIPT>a<
		"<script>$a",
	},
	{
		"'>' completes script end tag",
		"<SCRIPT>a<
		"<script>$a$<
	},
	{
		"self-closing script end tag",
		"<SCRIPT>a<
		"<script>$a$<
	},
	{
		"nested script tag",
		"<SCRIPT>a<
		"<script>$a&lt;
	},
	{
		"script end tag after unfinished",
		"<SCRIPT>a<
		"<script>$a&lt;
	},
	{
		"script
		"<script>a<
		"<script>$a&lt;
	},
	{
		"style element with entity",
		"<style>&apos;",
		"<style>$&amp;apos;",
	},
	{
		"textarea with tag",
		"<textarea><div><
		"<textarea>$&lt;div&gt;$<
	},
	{
		"title with tag and entity",
		"<title><b>K&amp;R C<
		"<title>$&lt;b&gt;K&amp;R C&lt;
	},
	
	{
		"Proper DOCTYPE",
		"<!DOCTYPE html>",
		"<!DOCTYPE html>",
	},
	{
		"DOCTYPE with no space",
		"<!doctypehtml>",
		"<!DOCTYPE html>",
	},
	{
		"DOCTYPE with two spaces",
		"<!doctype  html>",
		"<!DOCTYPE html>",
	},
	{
		"looks like DOCTYPE but isn't",
		"<!DOCUMENT html>",
		"<!--DOCUMENT html-->",
	},
	{
		"DOCTYPE at EOF",
		"<!DOCtype",
		"<!DOCTYPE >",
	},
	
	{
		"XML processing instruction",
		"<?xml?>",
		"<!--?xml?-->",
	},
	
	{
		"comment0",
		"abc<b><!-- skipme --><
		"abc$<b>$<!-- skipme -->$<
	},
	{
		"comment1",
		"a<!-->z",
		"a$<!---->$z",
	},
	{
		"comment2",
		"a<!--->z",
		"a$<!---->$z",
	},
	{
		"comment3",
		"a<!--x>-->z",
		"a$<!--x>-->$z",
	},
	{
		"comment4",
		"a<!--x->-->z",
		"a$<!--x->-->$z",
	},
	{
		"comment5",
		"a<!>z",
		"a$<!---->$z",
	},
	{
		"comment6",
		"a<!->z",
		"a$<!----->$z",
	},
	{
		"comment7",
		"a<!---<>z",
		"a$<!---<>z-->",
	},
	{
		"comment8",
		"a<!--z",
		"a$<!--z-->",
	},
	{
		"comment9",
		"a<!--z-",
		"a$<!--z-->",
	},
	{
		"comment10",
		"a<!--z--",
		"a$<!--z-->",
	},
	{
		"comment11",
		"a<!--z---",
		"a$<!--z--->",
	},
	{
		"comment12",
		"a<!--z----",
		"a$<!--z---->",
	},
	{
		"comment13",
		"a<!--x--!>z",
		"a$<!--x-->$z",
	},
	
	{
		"backslash",
		`<p id="a\"b">`,
		`<p id="a\" b"="">`,
	},
	
	
	{
		"tricky",
		"<p \t\n iD=\"a&quot;B\"  foo=\"bar\"><EM>te&lt;&amp;;xt<
		`<p id="a&#34;B" foo="bar">$<em>$te&lt;&amp;;xt$<
	},
	
	
	{
		"noSuchEntity",
		`<a b="c&noSuchEntity;d">&lt;&alsoDoesntExist;&`,
		`<a b="c&amp;noSuchEntity;d">$&lt;&amp;alsoDoesntExist;&amp;`,
	},
	{
		"entity without semicolon",
		`&notit;&notin;<a b="q=z&amp=5&notice=hello&not;=world">`,
		`¬it;∉$<a b="q=z&amp;amp=5&amp;notice=hello¬=world">`,
	},
	{
		"entity with digits",
		"&frac12;",
		"½",
	},
	
	
	{
		"Empty attribute",
		`<input disabled FOO>`,
		`<input disabled="" foo="">`,
	},
	{
		"Empty attribute, whitespace",
		`<input disabled FOO >`,
		`<input disabled="" foo="">`,
	},
	{
		"Unquoted attribute value",
		`<input value=yes FOO=BAR>`,
		`<input value="yes" foo="BAR">`,
	},
	{
		"Unquoted attribute value, spaces",
		`<input value = yes FOO = BAR>`,
		`<input value="yes" foo="BAR">`,
	},
	{
		"Unquoted attribute value, trailing space",
		`<input value=yes FOO=BAR >`,
		`<input value="yes" foo="BAR">`,
	},
	{
		"Single-quoted attribute value",
		`<input value='yes' FOO='BAR'>`,
		`<input value="yes" foo="BAR">`,
	},
	{
		"Single-quoted attribute value, trailing space",
		`<input value='yes' FOO='BAR' >`,
		`<input value="yes" foo="BAR">`,
	},
	{
		"Double-quoted attribute value",
		`<input value="I'm an attribute" FOO="BAR">`,
		`<input value="I&#39;m an attribute" foo="BAR">`,
	},
	{
		"Attribute name characters",
		`<meta http-equiv="content-type">`,
		`<meta http-equiv="content-type">`,
	},
	{
		"Mixed attributes",
		`a<P V="0 1" w='2' X=3 y>z`,
		`a$<p v="0 1" w="2" x="3" y="">$z`,
	},
	{
		"Attributes with a solitary single quote",
		`<p id=can't><p id=won't>`,
		`<p id="can&#39;t">$<p id="won&#39;t">`,
	},
}
func TestTokenizer(t *testing.T) {
loop:
	for _, tt := range tokenTests {
		z := NewTokenizer(strings.NewReader(tt.html))
		if tt.golden != "" {
			for i, s := range strings.Split(tt.golden, "$") {
				if z.Next() == ErrorToken {
					t.Errorf("%s token %d: want %q got error %v", tt.desc, i, s, z.Err())
					continue loop
				}
				actual := z.Token().String()
				if s != actual {
					t.Errorf("%s token %d: want %q got %q", tt.desc, i, s, actual)
					continue loop
				}
			}
		}
		z.Next()
		if z.Err() != io.EOF {
			t.Errorf("%s: want EOF got %q", tt.desc, z.Err())
		}
	}
}
func TestMaxBuffer(t *testing.T) {
	
	z := NewTokenizer(strings.NewReader("<" + strings.Repeat("t", 10)))
	z.SetMaxBuf(5)
	tt := z.Next()
	if got, want := tt, ErrorToken; got != want {
		t.Fatalf("token type: got: %v want: %v", got, want)
	}
	if got, want := z.Err(), ErrBufferExceeded; got != want {
		t.Errorf("error type: got: %v want: %v", got, want)
	}
	if got, want := string(z.Raw()), "<tttt"; got != want {
		t.Fatalf("buffered before overflow: got: %q want: %q", got, want)
	}
}
func TestMaxBufferReconstruction(t *testing.T) {
	
	
tests:
	for _, test := range tokenTests {
		for maxBuf := 1; ; maxBuf++ {
			r := strings.NewReader(test.html)
			z := NewTokenizer(r)
			z.SetMaxBuf(maxBuf)
			var tokenized bytes.Buffer
			for {
				tt := z.Next()
				tokenized.Write(z.Raw())
				if tt == ErrorToken {
					if err := z.Err(); err != io.EOF && err != ErrBufferExceeded {
						t.Errorf("%s: unexpected error: %v", test.desc, err)
					}
					break
				}
			}
			
			assembled, err := ioutil.ReadAll(io.MultiReader(&tokenized, bytes.NewReader(z.Buffered()), r))
			if err != nil {
				t.Errorf("%s: ReadAll: %v", test.desc, err)
				continue tests
			}
			if got, want := string(assembled), test.html; got != want {
				t.Errorf("%s: reassembled html:\n got: %q\nwant: %q", test.desc, got, want)
				continue tests
			}
			
			
			if z.Err() == io.EOF {
				break
			}
		} 
	} 
}
func TestPassthrough(t *testing.T) {
	
	
	for _, test := range tokenTests {
		z := NewTokenizer(strings.NewReader(test.html))
		var parsed bytes.Buffer
		for {
			tt := z.Next()
			parsed.Write(z.Raw())
			if tt == ErrorToken {
				break
			}
		}
		if got, want := parsed.String(), test.html; got != want {
			t.Errorf("%s: parsed output:\n got: %q\nwant: %q", test.desc, got, want)
		}
	}
}
func TestBufAPI(t *testing.T) {
	s := "0<a>1<
	z := NewTokenizer(bytes.NewBufferString(s))
	var result bytes.Buffer
	depth := 0
loop:
	for {
		tt := z.Next()
		switch tt {
		case ErrorToken:
			if z.Err() != io.EOF {
				t.Error(z.Err())
			}
			break loop
		case TextToken:
			if depth > 0 {
				result.Write(z.Text())
			}
		case StartTagToken, EndTagToken:
			tn, _ := z.TagName()
			if len(tn) == 1 && tn[0] == 'a' {
				if tt == StartTagToken {
					depth++
				} else {
					depth--
				}
			}
		}
	}
	u := "14567"
	v := string(result.Bytes())
	if u != v {
		t.Errorf("TestBufAPI: want %q got %q", u, v)
	}
}
func TestConvertNewlines(t *testing.T) {
	testCases := map[string]string{
		"Mac\rDOS\r\nUnix\n":    "Mac\nDOS\nUnix\n",
		"Unix\nMac\rDOS\r\n":    "Unix\nMac\nDOS\n",
		"DOS\r\nDOS\r\nDOS\r\n": "DOS\nDOS\nDOS\n",
		"":         "",
		"\n":       "\n",
		"\n\r":     "\n\n",
		"\r":       "\n",
		"\r\n":     "\n",
		"\r\n\n":   "\n\n",
		"\r\n\r":   "\n\n",
		"\r\n\r\n": "\n\n",
		"\r\r":     "\n\n",
		"\r\r\n":   "\n\n",
		"\r\r\n\n": "\n\n\n",
		"\r\r\r\n": "\n\n\n",
		"\r \n":    "\n \n",
		"xyz":      "xyz",
	}
	for in, want := range testCases {
		if got := string(convertNewlines([]byte(in))); got != want {
			t.Errorf("input %q: got %q, want %q", in, got, want)
		}
	}
}
func TestReaderEdgeCases(t *testing.T) {
	const s = "<p>An io.Reader can return (0, nil) or (n, io.EOF).<
	testCases := []io.Reader{
		&zeroOneByteReader{s: s},
		&eofStringsReader{s: s},
		&stuckReader{},
	}
	for i, tc := range testCases {
		got := []TokenType{}
		z := NewTokenizer(tc)
		for {
			tt := z.Next()
			if tt == ErrorToken {
				break
			}
			got = append(got, tt)
		}
		if err := z.Err(); err != nil && err != io.EOF {
			if err != io.ErrNoProgress {
				t.Errorf("i=%d: %v", i, err)
			}
			continue
		}
		want := []TokenType{
			StartTagToken,
			TextToken,
			EndTagToken,
		}
		if !reflect.DeepEqual(got, want) {
			t.Errorf("i=%d: got %v, want %v", i, got, want)
			continue
		}
	}
}
type zeroOneByteReader struct {
	s string
	n int
}
func (r *zeroOneByteReader) Read(p []byte) (int, error) {
	if len(p) == 0 {
		return 0, nil
	}
	if len(r.s) == 0 {
		return 0, io.EOF
	}
	r.n++
	if r.n%2 != 0 {
		return 0, nil
	}
	p[0], r.s = r.s[0], r.s[1:]
	return 1, nil
}
type eofStringsReader struct {
	s string
}
func (r *eofStringsReader) Read(p []byte) (int, error) {
	n := copy(p, r.s)
	r.s = r.s[n:]
	if r.s != "" {
		return n, nil
	}
	return n, io.EOF
}
type stuckReader struct{}
func (*stuckReader) Read(p []byte) (int, error) {
	return 0, nil
}
const (
	rawLevel = iota
	lowLevel
	highLevel
)
func benchmarkTokenizer(b *testing.B, level int) {
	buf, err := ioutil.ReadFile("testdata
	if err != nil {
		b.Fatalf("could not read testdata
	}
	b.SetBytes(int64(len(buf)))
	runtime.GC()
	b.ReportAllocs()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		z := NewTokenizer(bytes.NewBuffer(buf))
		for {
			tt := z.Next()
			if tt == ErrorToken {
				if err := z.Err(); err != nil && err != io.EOF {
					b.Fatalf("tokenizer error: %v", err)
				}
				break
			}
			switch level {
			case rawLevel:
				
				
				z.Raw()
			case lowLevel:
				
				
				switch tt {
				case TextToken, CommentToken, DoctypeToken:
					z.Text()
				case StartTagToken, SelfClosingTagToken:
					_, more := z.TagName()
					for more {
						_, _, more = z.TagAttr()
					}
				case EndTagToken:
					z.TagName()
				}
			case highLevel:
				
				
				z.Token()
			}
		}
	}
}
func BenchmarkRawLevelTokenizer(b *testing.B)  { benchmarkTokenizer(b, rawLevel) }
func BenchmarkLowLevelTokenizer(b *testing.B)  { benchmarkTokenizer(b, lowLevel) }
func BenchmarkHighLevelTokenizer(b *testing.B) { benchmarkTokenizer(b, highLevel) }
package html
import (
	"testing"
	"unicode
)
func TestEntityLength(t *testing.T) {
	
	
	
	for k, v := range entity {
		if 1+len(k) < utf8.RuneLen(v) {
			t.Error("escaped entity &" + k + " is shorter than its UTF-8 encoding " + string(v))
		}
		if len(k) > longestEntityWithoutSemicolon && k[len(k)-1] != ';' {
			t.Errorf("entity name %s is %d characters, but longestEntityWithoutSemicolon=%d", k, len(k), longestEntityWithoutSemicolon)
		}
	}
	for k, v := range entity2 {
		if 1+len(k) < utf8.RuneLen(v[0])+utf8.RuneLen(v[1]) {
			t.Error("escaped entity &" + k + " is shorter than its UTF-8 encoding " + string(v[0]) + string(v[1]))
		}
	}
}
package html
import (
	"strings"
)
func parseDoctype(s string) (n *Node, quirks bool) {
	n = &Node{Type: DoctypeNode}
	
	space := strings.IndexAny(s, whitespace)
	if space == -1 {
		space = len(s)
	}
	n.Data = s[:space]
	
	if n.Data != "html" {
		quirks = true
	}
	n.Data = strings.ToLower(n.Data)
	s = strings.TrimLeft(s[space:], whitespace)
	if len(s) < 6 {
		
		
		return n, quirks || s != ""
	}
	key := strings.ToLower(s[:6])
	s = s[6:]
	for key == "public" || key == "system" {
		s = strings.TrimLeft(s, whitespace)
		if s == "" {
			break
		}
		quote := s[0]
		if quote != '"' && quote != '\'' {
			break
		}
		s = s[1:]
		q := strings.IndexRune(s, rune(quote))
		var id string
		if q == -1 {
			id = s
			s = ""
		} else {
			id = s[:q]
			s = s[q+1:]
		}
		n.Attr = append(n.Attr, Attribute{Key: key, Val: id})
		if key == "public" {
			key = "system"
		} else {
			key = ""
		}
	}
	if key != "" || s != "" {
		quirks = true
	} else if len(n.Attr) > 0 {
		if n.Attr[0].Key == "public" {
			public := strings.ToLower(n.Attr[0].Val)
			switch public {
			case "-
				quirks = true
			default:
				for _, q := range quirkyIDs {
					if strings.HasPrefix(public, q) {
						quirks = true
						break
					}
				}
			}
			
			if len(n.Attr) == 1 && (strings.HasPrefix(public, "-
				strings.HasPrefix(public, "-
				quirks = true
			}
		}
		if lastAttr := n.Attr[len(n.Attr)-1]; lastAttr.Key == "system" &&
			strings.ToLower(lastAttr.Val) == "http:
			quirks = true
		}
	}
	return n, quirks
}
var quirkyIDs = []string{
	"+
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
	"-
}
package html
import (
	"bytes"
	"testing"
)
func TestRenderer(t *testing.T) {
	nodes := [...]*Node{
		0: {
			Type: ElementNode,
			Data: "html",
		},
		1: {
			Type: ElementNode,
			Data: "head",
		},
		2: {
			Type: ElementNode,
			Data: "body",
		},
		3: {
			Type: TextNode,
			Data: "0<1",
		},
		4: {
			Type: ElementNode,
			Data: "p",
			Attr: []Attribute{
				{
					Key: "id",
					Val: "A",
				},
				{
					Key: "foo",
					Val: `abc"def`,
				},
			},
		},
		5: {
			Type: TextNode,
			Data: "2",
		},
		6: {
			Type: ElementNode,
			Data: "b",
			Attr: []Attribute{
				{
					Key: "empty",
					Val: "",
				},
			},
		},
		7: {
			Type: TextNode,
			Data: "3",
		},
		8: {
			Type: ElementNode,
			Data: "i",
			Attr: []Attribute{
				{
					Key: "backslash",
					Val: `\`,
				},
			},
		},
		9: {
			Type: TextNode,
			Data: "&4",
		},
		10: {
			Type: TextNode,
			Data: "5",
		},
		11: {
			Type: ElementNode,
			Data: "blockquote",
		},
		12: {
			Type: ElementNode,
			Data: "br",
		},
		13: {
			Type: TextNode,
			Data: "6",
		},
	}
	
	
	
	
	treeAsText := [...]string{
		0: `<html>`,
		1: `.	<head>`,
		2: `.	<body>`,
		3: `.	.	"0&lt;1"`,
		4: `.	.	<p id="A" foo="abc&#34;def">`,
		5: `.	.	.	"2"`,
		6: `.	.	.	<b empty="">`,
		7: `.	.	.	.	"3"`,
		8: `.	.	.	<i backslash="\">`,
		9: `.	.	.	.	"&amp;4"`,
		10: `.	.	"5"`,
		11: `.	.	<blockquote>`,
		12: `.	.	<br>`,
		13: `.	.	"6"`,
	}
	if len(nodes) != len(treeAsText) {
		t.Fatal("len(nodes) != len(treeAsText)")
	}
	var stack [8]*Node
	for i, line := range treeAsText {
		level := 0
		for line[0] == '.' {
			
			line = line[2:]
			level++
		}
		n := nodes[i]
		if level == 0 {
			if stack[0] != nil {
				t.Fatal("multiple root nodes")
			}
			stack[0] = n
		} else {
			stack[level-1].AppendChild(n)
			stack[level] = n
			for i := level + 1; i < len(stack); i++ {
				stack[i] = nil
			}
		}
		
		for j, m := range nodes {
			if err := checkNodeConsistency(m); err != nil {
				t.Fatalf("i=%d, j=%d: %v", i, j, err)
			}
		}
	}
	want := `<html><head><
		`2<b empty="">3<
		`5<blockquote><
	b := new(bytes.Buffer)
	if err := Render(b, nodes[0]); err != nil {
		t.Fatal(err)
	}
	if got := b.String(); got != want {
		t.Errorf("got vs want:\n%s\n%s\n", got, want)
	}
}
package html
import (
	"golang.org
)
type NodeType uint32
const (
	ErrorNode NodeType = iota
	TextNode
	DocumentNode
	ElementNode
	CommentNode
	DoctypeNode
	scopeMarkerNode
)
var scopeMarker = Node{Type: scopeMarkerNode}
type Node struct {
	Parent, FirstChild, LastChild, PrevSibling, NextSibling *Node
	Type      NodeType
	DataAtom  atom.Atom
	Data      string
	Namespace string
	Attr      []Attribute
}
func (n *Node) InsertBefore(newChild, oldChild *Node) {
	if newChild.Parent != nil || newChild.PrevSibling != nil || newChild.NextSibling != nil {
		panic("html: InsertBefore called for an attached child Node")
	}
	var prev, next *Node
	if oldChild != nil {
		prev, next = oldChild.PrevSibling, oldChild
	} else {
		prev = n.LastChild
	}
	if prev != nil {
		prev.NextSibling = newChild
	} else {
		n.FirstChild = newChild
	}
	if next != nil {
		next.PrevSibling = newChild
	} else {
		n.LastChild = newChild
	}
	newChild.Parent = n
	newChild.PrevSibling = prev
	newChild.NextSibling = next
}
func (n *Node) AppendChild(c *Node) {
	if c.Parent != nil || c.PrevSibling != nil || c.NextSibling != nil {
		panic("html: AppendChild called for an attached child Node")
	}
	last := n.LastChild
	if last != nil {
		last.NextSibling = c
	} else {
		n.FirstChild = c
	}
	n.LastChild = c
	c.Parent = n
	c.PrevSibling = last
}
func (n *Node) RemoveChild(c *Node) {
	if c.Parent != n {
		panic("html: RemoveChild called for a non-child Node")
	}
	if n.FirstChild == c {
		n.FirstChild = c.NextSibling
	}
	if c.NextSibling != nil {
		c.NextSibling.PrevSibling = c.PrevSibling
	}
	if n.LastChild == c {
		n.LastChild = c.PrevSibling
	}
	if c.PrevSibling != nil {
		c.PrevSibling.NextSibling = c.NextSibling
	}
	c.Parent = nil
	c.PrevSibling = nil
	c.NextSibling = nil
}
func reparentChildren(dst, src *Node) {
	for {
		child := src.FirstChild
		if child == nil {
			break
		}
		src.RemoveChild(child)
		dst.AppendChild(child)
	}
}
func (n *Node) clone() *Node {
	m := &Node{
		Type:     n.Type,
		DataAtom: n.DataAtom,
		Data:     n.Data,
		Attr:     make([]Attribute, len(n.Attr)),
	}
	copy(m.Attr, n.Attr)
	return m
}
type nodeStack []*Node
func (s *nodeStack) pop() *Node {
	i := len(*s)
	n := (*s)[i-1]
	*s = (*s)[:i-1]
	return n
}
func (s *nodeStack) top() *Node {
	if i := len(*s); i > 0 {
		return (*s)[i-1]
	}
	return nil
}
func (s *nodeStack) index(n *Node) int {
	for i := len(*s) - 1; i >= 0; i-- {
		if (*s)[i] == n {
			return i
		}
	}
	return -1
}
func (s *nodeStack) insert(i int, n *Node) {
	(*s) = append(*s, nil)
	copy((*s)[i+1:], (*s)[i:])
	(*s)[i] = n
}
func (s *nodeStack) remove(n *Node) {
	i := s.index(n)
	if i == -1 {
		return
	}
	copy((*s)[i:], (*s)[i+1:])
	j := len(*s) - 1
	(*s)[j] = nil
	*s = (*s)[:j]
}
Package html implements an HTML5-compliant tokenizer and parser.
Tokenization is done by creating a Tokenizer for an io.Reader r. It is the
caller's responsibility to ensure that r provides UTF-8 encoded HTML.
	z := html.NewTokenizer(r)
Given a Tokenizer z, the HTML is tokenized by repeatedly calling z.Next(),
which parses the next token and returns its type, or an error:
	for {
		tt := z.Next()
		if tt == html.ErrorToken {
			
			return ...
		}
		
	}
There are two APIs for retrieving the current token. The high-level API is to
call Token; the low-level API is to call Text or TagName 
allow optionally calling Raw after Next but before Token, Text, TagName, or
TagAttr. In EBNF notation, the valid call sequence per token is:
	Next {Raw} [ Token | Text | TagName {TagAttr} ]
Token returns an independent data structure that completely describes a token.
Entities (such as "&lt;") are unescaped, tag names and attribute keys are
lower-cased, and attributes are collected into a []Attribute. For example:
	for {
		if z.Next() == html.ErrorToken {
			
			return z.Err()
		}
		emitToken(z.Token())
	}
The low-level API performs fewer allocations and copies, but the contents of
the []byte values returned by Text, TagName and TagAttr may change on the next
call to Next. For example, to extract an HTML page's anchor text:
	depth := 0
	for {
		tt := z.Next()
		switch tt {
		case ErrorToken:
			return z.Err()
		case TextToken:
			if depth > 0 {
				
				
				emitBytes(z.Text())
			}
		case StartTagToken, EndTagToken:
			tn, _ := z.TagName()
			if len(tn) == 1 && tn[0] == 'a' {
				if tt == StartTagToken {
					depth++
				} else {
					depth--
				}
			}
		}
	}
Parsing is done by calling Parse with an io.Reader, which returns the root of
the parse tree (the document element) as a *Node. It is the caller's
responsibility to ensure that the Reader provides UTF-8 encoded HTML. For
example, to process each anchor node in depth-first order:
	doc, err := html.Parse(r)
	if err != nil {
		
	}
	var f func(*html.Node)
	f = func(n *html.Node) {
		if n.Type == html.ElementNode && n.Data == "a" {
			
		}
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			f(c)
		}
	}
	f(doc)
The relevant specifications include:
https:
https:
*
package html 
package html
import (
	"fmt"
)
func checkTreeConsistency(n *Node) error {
	return checkTreeConsistency1(n, 0)
}
func checkTreeConsistency1(n *Node, depth int) error {
	if depth == 1e4 {
		return fmt.Errorf("html: tree looks like it contains a cycle")
	}
	if err := checkNodeConsistency(n); err != nil {
		return err
	}
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		if err := checkTreeConsistency1(c, depth+1); err != nil {
			return err
		}
	}
	return nil
}
func checkNodeConsistency(n *Node) error {
	if n == nil {
		return nil
	}
	nParent := 0
	for p := n.Parent; p != nil; p = p.Parent {
		nParent++
		if nParent == 1e4 {
			return fmt.Errorf("html: parent list looks like an infinite loop")
		}
	}
	nForward := 0
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		nForward++
		if nForward == 1e6 {
			return fmt.Errorf("html: forward list of children looks like an infinite loop")
		}
		if c.Parent != n {
			return fmt.Errorf("html: inconsistent child
		}
	}
	nBackward := 0
	for c := n.LastChild; c != nil; c = c.PrevSibling {
		nBackward++
		if nBackward == 1e6 {
			return fmt.Errorf("html: backward list of children looks like an infinite loop")
		}
		if c.Parent != n {
			return fmt.Errorf("html: inconsistent child
		}
	}
	if n.Parent != nil {
		if n.Parent == n {
			return fmt.Errorf("html: inconsistent parent relationship")
		}
		if n.Parent == n.FirstChild {
			return fmt.Errorf("html: inconsistent parent
		}
		if n.Parent == n.LastChild {
			return fmt.Errorf("html: inconsistent parent
		}
		if n.Parent == n.PrevSibling {
			return fmt.Errorf("html: inconsistent parent
		}
		if n.Parent == n.NextSibling {
			return fmt.Errorf("html: inconsistent parent
		}
		parentHasNAsAChild := false
		for c := n.Parent.FirstChild; c != nil; c = c.NextSibling {
			if c == n {
				parentHasNAsAChild = true
				break
			}
		}
		if !parentHasNAsAChild {
			return fmt.Errorf("html: inconsistent parent
		}
	}
	if n.PrevSibling != nil && n.PrevSibling.NextSibling != n {
		return fmt.Errorf("html: inconsistent prev
	}
	if n.NextSibling != nil && n.NextSibling.PrevSibling != n {
		return fmt.Errorf("html: inconsistent next
	}
	if (n.FirstChild == nil) != (n.LastChild == nil) {
		return fmt.Errorf("html: inconsistent first
	}
	if n.FirstChild != nil && n.FirstChild == n.LastChild {
		
		if n.FirstChild.PrevSibling != nil || n.FirstChild.NextSibling != nil {
			return fmt.Errorf("html: inconsistent sole child's sibling relationship")
		}
	}
	seen := map[*Node]bool{}
	var last *Node
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		if seen[c] {
			return fmt.Errorf("html: inconsistent repeated child")
		}
		seen[c] = true
		last = c
	}
	if last != n.LastChild {
		return fmt.Errorf("html: inconsistent last relationship")
	}
	var first *Node
	for c := n.LastChild; c != nil; c = c.PrevSibling {
		if !seen[c] {
			return fmt.Errorf("html: inconsistent missing child")
		}
		delete(seen, c)
		first = c
	}
	if first != n.FirstChild {
		return fmt.Errorf("html: inconsistent first relationship")
	}
	if len(seen) != 0 {
		return fmt.Errorf("html: inconsistent forwards
	}
	return nil
}
package html
import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"io"
	"io
	"os"
	"path
	"runtime"
	"sort"
	"strings"
	"testing"
	"golang.org
)
func readParseTest(r *bufio.Reader) (text, want, context string, err error) {
	line, err := r.ReadSlice('\n')
	if err != nil {
		return "", "", "", err
	}
	var b []byte
	
	if string(line) != "#data\n" {
		return "", "", "", fmt.Errorf(`got %q want "#data\n"`, line)
	}
	for {
		line, err = r.ReadSlice('\n')
		if err != nil {
			return "", "", "", err
		}
		if line[0] == '#' {
			break
		}
		b = append(b, line...)
	}
	text = strings.TrimSuffix(string(b), "\n")
	b = b[:0]
	
	if string(line) != "#errors\n" {
		return "", "", "", fmt.Errorf(`got %q want "#errors\n"`, line)
	}
	for {
		line, err = r.ReadSlice('\n')
		if err != nil {
			return "", "", "", err
		}
		if line[0] == '#' {
			break
		}
	}
	if string(line) == "#document-fragment\n" {
		line, err = r.ReadSlice('\n')
		if err != nil {
			return "", "", "", err
		}
		context = strings.TrimSpace(string(line))
		line, err = r.ReadSlice('\n')
		if err != nil {
			return "", "", "", err
		}
	}
	
	if string(line) != "#document\n" {
		return "", "", "", fmt.Errorf(`got %q want "#document\n"`, line)
	}
	inQuote := false
	for {
		line, err = r.ReadSlice('\n')
		if err != nil && err != io.EOF {
			return "", "", "", err
		}
		trimmed := bytes.Trim(line, "| \n")
		if len(trimmed) > 0 {
			if line[0] == '|' && trimmed[0] == '"' {
				inQuote = true
			}
			if trimmed[len(trimmed)-1] == '"' && !(line[0] == '|' && len(trimmed) == 1) {
				inQuote = false
			}
		}
		if len(line) == 0 || len(line) == 1 && line[0] == '\n' && !inQuote {
			break
		}
		b = append(b, line...)
	}
	return text, string(b), context, nil
}
func dumpIndent(w io.Writer, level int) {
	io.WriteString(w, "| ")
	for i := 0; i < level; i++ {
		io.WriteString(w, "  ")
	}
}
type sortedAttributes []Attribute
func (a sortedAttributes) Len() int {
	return len(a)
}
func (a sortedAttributes) Less(i, j int) bool {
	if a[i].Namespace != a[j].Namespace {
		return a[i].Namespace < a[j].Namespace
	}
	return a[i].Key < a[j].Key
}
func (a sortedAttributes) Swap(i, j int) {
	a[i], a[j] = a[j], a[i]
}
func dumpLevel(w io.Writer, n *Node, level int) error {
	dumpIndent(w, level)
	switch n.Type {
	case ErrorNode:
		return errors.New("unexpected ErrorNode")
	case DocumentNode:
		return errors.New("unexpected DocumentNode")
	case ElementNode:
		if n.Namespace != "" {
			fmt.Fprintf(w, "<%s %s>", n.Namespace, n.Data)
		} else {
			fmt.Fprintf(w, "<%s>", n.Data)
		}
		attr := sortedAttributes(n.Attr)
		sort.Sort(attr)
		for _, a := range attr {
			io.WriteString(w, "\n")
			dumpIndent(w, level+1)
			if a.Namespace != "" {
				fmt.Fprintf(w, `%s %s="%s"`, a.Namespace, a.Key, a.Val)
			} else {
				fmt.Fprintf(w, `%s="%s"`, a.Key, a.Val)
			}
		}
	case TextNode:
		fmt.Fprintf(w, `"%s"`, n.Data)
	case CommentNode:
		fmt.Fprintf(w, "<!-- %s -->", n.Data)
	case DoctypeNode:
		fmt.Fprintf(w, "<!DOCTYPE %s", n.Data)
		if n.Attr != nil {
			var p, s string
			for _, a := range n.Attr {
				switch a.Key {
				case "public":
					p = a.Val
				case "system":
					s = a.Val
				}
			}
			if p != "" || s != "" {
				fmt.Fprintf(w, ` "%s"`, p)
				fmt.Fprintf(w, ` "%s"`, s)
			}
		}
		io.WriteString(w, ">")
	case scopeMarkerNode:
		return errors.New("unexpected scopeMarkerNode")
	default:
		return errors.New("unknown node type")
	}
	io.WriteString(w, "\n")
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		if err := dumpLevel(w, c, level+1); err != nil {
			return err
		}
	}
	return nil
}
func dump(n *Node) (string, error) {
	if n == nil || n.FirstChild == nil {
		return "", nil
	}
	var b bytes.Buffer
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		if err := dumpLevel(&b, c, 0); err != nil {
			return "", err
		}
	}
	return b.String(), nil
}
const testDataDir = "testdata
func TestParser(t *testing.T) {
	testFiles, err := filepath.Glob(testDataDir + "*.dat")
	if err != nil {
		t.Fatal(err)
	}
	for _, tf := range testFiles {
		f, err := os.Open(tf)
		if err != nil {
			t.Fatal(err)
		}
		defer f.Close()
		r := bufio.NewReader(f)
		for i := 0; ; i++ {
			text, want, context, err := readParseTest(r)
			if err == io.EOF {
				break
			}
			if err != nil {
				t.Fatal(err)
			}
			err = testParseCase(text, want, context)
			if err != nil {
				t.Errorf("%s test #%d %q, %s", tf, i, text, err)
			}
		}
	}
}
func testParseCase(text, want, context string) (err error) {
	defer func() {
		if x := recover(); x != nil {
			switch e := x.(type) {
			case error:
				err = e
			default:
				err = fmt.Errorf("%v", e)
			}
		}
	}()
	var doc *Node
	if context == "" {
		doc, err = Parse(strings.NewReader(text))
		if err != nil {
			return err
		}
	} else {
		contextNode := &Node{
			Type:     ElementNode,
			DataAtom: atom.Lookup([]byte(context)),
			Data:     context,
		}
		nodes, err := ParseFragment(strings.NewReader(text), contextNode)
		if err != nil {
			return err
		}
		doc = &Node{
			Type: DocumentNode,
		}
		for _, n := range nodes {
			doc.AppendChild(n)
		}
	}
	if err := checkTreeConsistency(doc); err != nil {
		return err
	}
	got, err := dump(doc)
	if err != nil {
		return err
	}
	
	if got != want {
		return fmt.Errorf("got vs want:\n----\n%s----\n%s----", got, want)
	}
	if renderTestBlacklist[text] || context != "" {
		return nil
	}
	
	pr, pw := io.Pipe()
	go func() {
		pw.CloseWithError(Render(pw, doc))
	}()
	doc1, err := Parse(pr)
	if err != nil {
		return err
	}
	got1, err := dump(doc1)
	if err != nil {
		return err
	}
	if got != got1 {
		return fmt.Errorf("got vs got1:\n----\n%s----\n%s----", got, got1)
	}
	return nil
}
var renderTestBlacklist = map[string]bool{
	
	
	`<a><table><td><a><table><
	
	`<p><table><
	
	`<a href="blah">aba<table><a href="foo">br<tr><td><
	`<a><table><a><
	`<a><table><td><a><table><
	
	`<!DOCTYPE html><body><b><nobr>1<table><nobr><
	
	
	`<table><plaintext><td>`:                                   true,
	`<!doctype html><table><plaintext><
	`<!doctype html><table><tbody><plaintext><
	`<!doctype html><table><tbody><tr><plaintext><
	
	`<!doctype html><form><table><
	
	`<!doctype html><script><!--<script `:          true,
	`<!doctype html><script><!--<script <`:         true,
	`<!doctype html><script><!--<script <a`:        true,
	`<!doctype html><script><!--<script <
	`<!doctype html><script><!--<script <
	`<!doctype html><script><!--<script <
	`<!doctype html><script><!--<script <
	`<!doctype html><script><!--<script -`:         true,
	`<!doctype html><script><!--<script -a`:        true,
	`<!doctype html><script><!--<script -<`:        true,
	`<!doctype html><script><!--<script --`:        true,
	`<!doctype html><script><!--<script --a`:       true,
	`<!doctype html><script><!--<script --<`:       true,
	`<script><!--<script `:                         true,
	`<script><!--<script <a`:                       true,
	`<script><!--<script <
	`<script><!--<script <
	`<script><!--<script -`:                        true,
	`<script><!--<script -a`:                       true,
	`<script><!--<script --`:                       true,
	`<script><!--<script --a`:                      true,
	`<script><!--<script <`:                        true,
	`<script><!--<script <
	`<script><!--<script <
	
	
	`<!doctype html><p><a><plaintext>b`: true,
}
func TestNodeConsistency(t *testing.T) {
	
	inconsistentNode := &Node{
		Type:     ElementNode,
		DataAtom: atom.Frameset,
		Data:     "table",
	}
	_, err := ParseFragment(strings.NewReader("<p>hello<
	if err == nil {
		t.Errorf("got nil error, want non-nil")
	}
}
func BenchmarkParser(b *testing.B) {
	buf, err := ioutil.ReadFile("testdata
	if err != nil {
		b.Fatalf("could not read testdata
	}
	b.SetBytes(int64(len(buf)))
	runtime.GC()
	b.ReportAllocs()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		Parse(bytes.NewBuffer(buf))
	}
}
package html
const longestEntityWithoutSemicolon = 6
var entity = map[string]rune{
	"AElig;":                           '\U000000C6',
	"AMP;":                             '\U00000026',
	"Aacute;":                          '\U000000C1',
	"Abreve;":                          '\U00000102',
	"Acirc;":                           '\U000000C2',
	"Acy;":                             '\U00000410',
	"Afr;":                             '\U0001D504',
	"Agrave;":                          '\U000000C0',
	"Alpha;":                           '\U00000391',
	"Amacr;":                           '\U00000100',
	"And;":                             '\U00002A53',
	"Aogon;":                           '\U00000104',
	"Aopf;":                            '\U0001D538',
	"ApplyFunction;":                   '\U00002061',
	"Aring;":                           '\U000000C5',
	"Ascr;":                            '\U0001D49C',
	"Assign;":                          '\U00002254',
	"Atilde;":                          '\U000000C3',
	"Auml;":                            '\U000000C4',
	"Backslash;":                       '\U00002216',
	"Barv;":                            '\U00002AE7',
	"Barwed;":                          '\U00002306',
	"Bcy;":                             '\U00000411',
	"Because;":                         '\U00002235',
	"Bernoullis;":                      '\U0000212C',
	"Beta;":                            '\U00000392',
	"Bfr;":                             '\U0001D505',
	"Bopf;":                            '\U0001D539',
	"Breve;":                           '\U000002D8',
	"Bscr;":                            '\U0000212C',
	"Bumpeq;":                          '\U0000224E',
	"CHcy;":                            '\U00000427',
	"COPY;":                            '\U000000A9',
	"Cacute;":                          '\U00000106',
	"Cap;":                             '\U000022D2',
	"CapitalDifferentialD;":            '\U00002145',
	"Cayleys;":                         '\U0000212D',
	"Ccaron;":                          '\U0000010C',
	"Ccedil;":                          '\U000000C7',
	"Ccirc;":                           '\U00000108',
	"Cconint;":                         '\U00002230',
	"Cdot;":                            '\U0000010A',
	"Cedilla;":                         '\U000000B8',
	"CenterDot;":                       '\U000000B7',
	"Cfr;":                             '\U0000212D',
	"Chi;":                             '\U000003A7',
	"CircleDot;":                       '\U00002299',
	"CircleMinus;":                     '\U00002296',
	"CirclePlus;":                      '\U00002295',
	"CircleTimes;":                     '\U00002297',
	"ClockwiseContourIntegral;":        '\U00002232',
	"CloseCurlyDoubleQuote;":           '\U0000201D',
	"CloseCurlyQuote;":                 '\U00002019',
	"Colon;":                           '\U00002237',
	"Colone;":                          '\U00002A74',
	"Congruent;":                       '\U00002261',
	"Conint;":                          '\U0000222F',
	"ContourIntegral;":                 '\U0000222E',
	"Copf;":                            '\U00002102',
	"Coproduct;":                       '\U00002210',
	"CounterClockwiseContourIntegral;": '\U00002233',
	"Cross;":                    '\U00002A2F',
	"Cscr;":                     '\U0001D49E',
	"Cup;":                      '\U000022D3',
	"CupCap;":                   '\U0000224D',
	"DD;":                       '\U00002145',
	"DDotrahd;":                 '\U00002911',
	"DJcy;":                     '\U00000402',
	"DScy;":                     '\U00000405',
	"DZcy;":                     '\U0000040F',
	"Dagger;":                   '\U00002021',
	"Darr;":                     '\U000021A1',
	"Dashv;":                    '\U00002AE4',
	"Dcaron;":                   '\U0000010E',
	"Dcy;":                      '\U00000414',
	"Del;":                      '\U00002207',
	"Delta;":                    '\U00000394',
	"Dfr;":                      '\U0001D507',
	"DiacriticalAcute;":         '\U000000B4',
	"DiacriticalDot;":           '\U000002D9',
	"DiacriticalDoubleAcute;":   '\U000002DD',
	"DiacriticalGrave;":         '\U00000060',
	"DiacriticalTilde;":         '\U000002DC',
	"Diamond;":                  '\U000022C4',
	"DifferentialD;":            '\U00002146',
	"Dopf;":                     '\U0001D53B',
	"Dot;":                      '\U000000A8',
	"DotDot;":                   '\U000020DC',
	"DotEqual;":                 '\U00002250',
	"DoubleContourIntegral;":    '\U0000222F',
	"DoubleDot;":                '\U000000A8',
	"DoubleDownArrow;":          '\U000021D3',
	"DoubleLeftArrow;":          '\U000021D0',
	"DoubleLeftRightArrow;":     '\U000021D4',
	"DoubleLeftTee;":            '\U00002AE4',
	"DoubleLongLeftArrow;":      '\U000027F8',
	"DoubleLongLeftRightArrow;": '\U000027FA',
	"DoubleLongRightArrow;":     '\U000027F9',
	"DoubleRightArrow;":         '\U000021D2',
	"DoubleRightTee;":           '\U000022A8',
	"DoubleUpArrow;":            '\U000021D1',
	"DoubleUpDownArrow;":        '\U000021D5',
	"DoubleVerticalBar;":        '\U00002225',
	"DownArrow;":                '\U00002193',
	"DownArrowBar;":             '\U00002913',
	"DownArrowUpArrow;":         '\U000021F5',
	"DownBreve;":                '\U00000311',
	"DownLeftRightVector;":      '\U00002950',
	"DownLeftTeeVector;":        '\U0000295E',
	"DownLeftVector;":           '\U000021BD',
	"DownLeftVectorBar;":        '\U00002956',
	"DownRightTeeVector;":       '\U0000295F',
	"DownRightVector;":          '\U000021C1',
	"DownRightVectorBar;":       '\U00002957',
	"DownTee;":                  '\U000022A4',
	"DownTeeArrow;":             '\U000021A7',
	"Downarrow;":                '\U000021D3',
	"Dscr;":                     '\U0001D49F',
	"Dstrok;":                   '\U00000110',
	"ENG;":                      '\U0000014A',
	"ETH;":                      '\U000000D0',
	"Eacute;":                   '\U000000C9',
	"Ecaron;":                   '\U0000011A',
	"Ecirc;":                    '\U000000CA',
	"Ecy;":                      '\U0000042D',
	"Edot;":                     '\U00000116',
	"Efr;":                      '\U0001D508',
	"Egrave;":                   '\U000000C8',
	"Element;":                  '\U00002208',
	"Emacr;":                    '\U00000112',
	"EmptySmallSquare;":         '\U000025FB',
	"EmptyVerySmallSquare;":     '\U000025AB',
	"Eogon;":                    '\U00000118',
	"Eopf;":                     '\U0001D53C',
	"Epsilon;":                  '\U00000395',
	"Equal;":                    '\U00002A75',
	"EqualTilde;":               '\U00002242',
	"Equilibrium;":              '\U000021CC',
	"Escr;":                     '\U00002130',
	"Esim;":                     '\U00002A73',
	"Eta;":                      '\U00000397',
	"Euml;":                     '\U000000CB',
	"Exists;":                   '\U00002203',
	"ExponentialE;":             '\U00002147',
	"Fcy;":                      '\U00000424',
	"Ffr;":                      '\U0001D509',
	"FilledSmallSquare;":        '\U000025FC',
	"FilledVerySmallSquare;":    '\U000025AA',
	"Fopf;":                     '\U0001D53D',
	"ForAll;":                   '\U00002200',
	"Fouriertrf;":               '\U00002131',
	"Fscr;":                     '\U00002131',
	"GJcy;":                     '\U00000403',
	"GT;":                       '\U0000003E',
	"Gamma;":                    '\U00000393',
	"Gammad;":                   '\U000003DC',
	"Gbreve;":                   '\U0000011E',
	"Gcedil;":                   '\U00000122',
	"Gcirc;":                    '\U0000011C',
	"Gcy;":                      '\U00000413',
	"Gdot;":                     '\U00000120',
	"Gfr;":                      '\U0001D50A',
	"Gg;":                       '\U000022D9',
	"Gopf;":                     '\U0001D53E',
	"GreaterEqual;":             '\U00002265',
	"GreaterEqualLess;":         '\U000022DB',
	"GreaterFullEqual;":         '\U00002267',
	"GreaterGreater;":           '\U00002AA2',
	"GreaterLess;":              '\U00002277',
	"GreaterSlantEqual;":        '\U00002A7E',
	"GreaterTilde;":             '\U00002273',
	"Gscr;":                     '\U0001D4A2',
	"Gt;":                       '\U0000226B',
	"HARDcy;":                   '\U0000042A',
	"Hacek;":                    '\U000002C7',
	"Hat;":                      '\U0000005E',
	"Hcirc;":                    '\U00000124',
	"Hfr;":                      '\U0000210C',
	"HilbertSpace;":             '\U0000210B',
	"Hopf;":                     '\U0000210D',
	"HorizontalLine;":           '\U00002500',
	"Hscr;":                     '\U0000210B',
	"Hstrok;":                   '\U00000126',
	"HumpDownHump;":             '\U0000224E',
	"HumpEqual;":                '\U0000224F',
	"IEcy;":                     '\U00000415',
	"IJlig;":                    '\U00000132',
	"IOcy;":                     '\U00000401',
	"Iacute;":                   '\U000000CD',
	"Icirc;":                    '\U000000CE',
	"Icy;":                      '\U00000418',
	"Idot;":                     '\U00000130',
	"Ifr;":                      '\U00002111',
	"Igrave;":                   '\U000000CC',
	"Im;":                       '\U00002111',
	"Imacr;":                    '\U0000012A',
	"ImaginaryI;":               '\U00002148',
	"Implies;":                  '\U000021D2',
	"Int;":                      '\U0000222C',
	"Integral;":                 '\U0000222B',
	"Intersection;":             '\U000022C2',
	"InvisibleComma;":           '\U00002063',
	"InvisibleTimes;":           '\U00002062',
	"Iogon;":                    '\U0000012E',
	"Iopf;":                     '\U0001D540',
	"Iota;":                     '\U00000399',
	"Iscr;":                     '\U00002110',
	"Itilde;":                   '\U00000128',
	"Iukcy;":                    '\U00000406',
	"Iuml;":                     '\U000000CF',
	"Jcirc;":                    '\U00000134',
	"Jcy;":                      '\U00000419',
	"Jfr;":                      '\U0001D50D',
	"Jopf;":                     '\U0001D541',
	"Jscr;":                     '\U0001D4A5',
	"Jsercy;":                   '\U00000408',
	"Jukcy;":                    '\U00000404',
	"KHcy;":                     '\U00000425',
	"KJcy;":                     '\U0000040C',
	"Kappa;":                    '\U0000039A',
	"Kcedil;":                   '\U00000136',
	"Kcy;":                      '\U0000041A',
	"Kfr;":                      '\U0001D50E',
	"Kopf;":                     '\U0001D542',
	"Kscr;":                     '\U0001D4A6',
	"LJcy;":                     '\U00000409',
	"LT;":                       '\U0000003C',
	"Lacute;":                   '\U00000139',
	"Lambda;":                   '\U0000039B',
	"Lang;":                     '\U000027EA',
	"Laplacetrf;":               '\U00002112',
	"Larr;":                     '\U0000219E',
	"Lcaron;":                   '\U0000013D',
	"Lcedil;":                   '\U0000013B',
	"Lcy;":                      '\U0000041B',
	"LeftAngleBracket;":         '\U000027E8',
	"LeftArrow;":                '\U00002190',
	"LeftArrowBar;":             '\U000021E4',
	"LeftArrowRightArrow;":      '\U000021C6',
	"LeftCeiling;":              '\U00002308',
	"LeftDoubleBracket;":        '\U000027E6',
	"LeftDownTeeVector;":        '\U00002961',
	"LeftDownVector;":           '\U000021C3',
	"LeftDownVectorBar;":        '\U00002959',
	"LeftFloor;":                '\U0000230A',
	"LeftRightArrow;":           '\U00002194',
	"LeftRightVector;":          '\U0000294E',
	"LeftTee;":                  '\U000022A3',
	"LeftTeeArrow;":             '\U000021A4',
	"LeftTeeVector;":            '\U0000295A',
	"LeftTriangle;":             '\U000022B2',
	"LeftTriangleBar;":          '\U000029CF',
	"LeftTriangleEqual;":        '\U000022B4',
	"LeftUpDownVector;":         '\U00002951',
	"LeftUpTeeVector;":          '\U00002960',
	"LeftUpVector;":             '\U000021BF',
	"LeftUpVectorBar;":          '\U00002958',
	"LeftVector;":               '\U000021BC',
	"LeftVectorBar;":            '\U00002952',
	"Leftarrow;":                '\U000021D0',
	"Leftrightarrow;":           '\U000021D4',
	"LessEqualGreater;":         '\U000022DA',
	"LessFullEqual;":            '\U00002266',
	"LessGreater;":              '\U00002276',
	"LessLess;":                 '\U00002AA1',
	"LessSlantEqual;":           '\U00002A7D',
	"LessTilde;":                '\U00002272',
	"Lfr;":                      '\U0001D50F',
	"Ll;":                       '\U000022D8',
	"Lleftarrow;":               '\U000021DA',
	"Lmidot;":                   '\U0000013F',
	"LongLeftArrow;":            '\U000027F5',
	"LongLeftRightArrow;":       '\U000027F7',
	"LongRightArrow;":           '\U000027F6',
	"Longleftarrow;":            '\U000027F8',
	"Longleftrightarrow;":       '\U000027FA',
	"Longrightarrow;":           '\U000027F9',
	"Lopf;":                     '\U0001D543',
	"LowerLeftArrow;":           '\U00002199',
	"LowerRightArrow;":          '\U00002198',
	"Lscr;":                     '\U00002112',
	"Lsh;":                      '\U000021B0',
	"Lstrok;":                   '\U00000141',
	"Lt;":                       '\U0000226A',
	"Map;":                      '\U00002905',
	"Mcy;":                      '\U0000041C',
	"MediumSpace;":              '\U0000205F',
	"Mellintrf;":                '\U00002133',
	"Mfr;":                      '\U0001D510',
	"MinusPlus;":                '\U00002213',
	"Mopf;":                     '\U0001D544',
	"Mscr;":                     '\U00002133',
	"Mu;":                       '\U0000039C',
	"NJcy;":                     '\U0000040A',
	"Nacute;":                   '\U00000143',
	"Ncaron;":                   '\U00000147',
	"Ncedil;":                   '\U00000145',
	"Ncy;":                      '\U0000041D',
	"NegativeMediumSpace;":      '\U0000200B',
	"NegativeThickSpace;":       '\U0000200B',
	"NegativeThinSpace;":        '\U0000200B',
	"NegativeVeryThinSpace;":    '\U0000200B',
	"NestedGreaterGreater;":     '\U0000226B',
	"NestedLessLess;":           '\U0000226A',
	"NewLine;":                  '\U0000000A',
	"Nfr;":                      '\U0001D511',
	"NoBreak;":                  '\U00002060',
	"NonBreakingSpace;":         '\U000000A0',
	"Nopf;":                     '\U00002115',
	"Not;":                      '\U00002AEC',
	"NotCongruent;":             '\U00002262',
	"NotCupCap;":                '\U0000226D',
	"NotDoubleVerticalBar;":     '\U00002226',
	"NotElement;":               '\U00002209',
	"NotEqual;":                 '\U00002260',
	"NotExists;":                '\U00002204',
	"NotGreater;":               '\U0000226F',
	"NotGreaterEqual;":          '\U00002271',
	"NotGreaterLess;":           '\U00002279',
	"NotGreaterTilde;":          '\U00002275',
	"NotLeftTriangle;":          '\U000022EA',
	"NotLeftTriangleEqual;":     '\U000022EC',
	"NotLess;":                  '\U0000226E',
	"NotLessEqual;":             '\U00002270',
	"NotLessGreater;":           '\U00002278',
	"NotLessTilde;":             '\U00002274',
	"NotPrecedes;":              '\U00002280',
	"NotPrecedesSlantEqual;":    '\U000022E0',
	"NotReverseElement;":        '\U0000220C',
	"NotRightTriangle;":         '\U000022EB',
	"NotRightTriangleEqual;":    '\U000022ED',
	"NotSquareSubsetEqual;":     '\U000022E2',
	"NotSquareSupersetEqual;":   '\U000022E3',
	"NotSubsetEqual;":           '\U00002288',
	"NotSucceeds;":              '\U00002281',
	"NotSucceedsSlantEqual;":    '\U000022E1',
	"NotSupersetEqual;":         '\U00002289',
	"NotTilde;":                 '\U00002241',
	"NotTildeEqual;":            '\U00002244',
	"NotTildeFullEqual;":        '\U00002247',
	"NotTildeTilde;":            '\U00002249',
	"NotVerticalBar;":           '\U00002224',
	"Nscr;":                     '\U0001D4A9',
	"Ntilde;":                   '\U000000D1',
	"Nu;":                       '\U0000039D',
	"OElig;":                    '\U00000152',
	"Oacute;":                   '\U000000D3',
	"Ocirc;":                    '\U000000D4',
	"Ocy;":                      '\U0000041E',
	"Odblac;":                   '\U00000150',
	"Ofr;":                      '\U0001D512',
	"Ograve;":                   '\U000000D2',
	"Omacr;":                    '\U0000014C',
	"Omega;":                    '\U000003A9',
	"Omicron;":                  '\U0000039F',
	"Oopf;":                     '\U0001D546',
	"OpenCurlyDoubleQuote;":     '\U0000201C',
	"OpenCurlyQuote;":           '\U00002018',
	"Or;":                       '\U00002A54',
	"Oscr;":                     '\U0001D4AA',
	"Oslash;":                   '\U000000D8',
	"Otilde;":                   '\U000000D5',
	"Otimes;":                   '\U00002A37',
	"Ouml;":                     '\U000000D6',
	"OverBar;":                  '\U0000203E',
	"OverBrace;":                '\U000023DE',
	"OverBracket;":              '\U000023B4',
	"OverParenthesis;":          '\U000023DC',
	"PartialD;":                 '\U00002202',
	"Pcy;":                      '\U0000041F',
	"Pfr;":                      '\U0001D513',
	"Phi;":                      '\U000003A6',
	"Pi;":                       '\U000003A0',
	"PlusMinus;":                '\U000000B1',
	"Poincareplane;":            '\U0000210C',
	"Popf;":                     '\U00002119',
	"Pr;":                       '\U00002ABB',
	"Precedes;":                 '\U0000227A',
	"PrecedesEqual;":            '\U00002AAF',
	"PrecedesSlantEqual;":       '\U0000227C',
	"PrecedesTilde;":            '\U0000227E',
	"Prime;":                    '\U00002033',
	"Product;":                  '\U0000220F',
	"Proportion;":               '\U00002237',
	"Proportional;":             '\U0000221D',
	"Pscr;":                     '\U0001D4AB',
	"Psi;":                      '\U000003A8',
	"QUOT;":                     '\U00000022',
	"Qfr;":                      '\U0001D514',
	"Qopf;":                     '\U0000211A',
	"Qscr;":                     '\U0001D4AC',
	"RBarr;":                    '\U00002910',
	"REG;":                      '\U000000AE',
	"Racute;":                   '\U00000154',
	"Rang;":                     '\U000027EB',
	"Rarr;":                     '\U000021A0',
	"Rarrtl;":                   '\U00002916',
	"Rcaron;":                   '\U00000158',
	"Rcedil;":                   '\U00000156',
	"Rcy;":                      '\U00000420',
	"Re;":                       '\U0000211C',
	"ReverseElement;":           '\U0000220B',
	"ReverseEquilibrium;":       '\U000021CB',
	"ReverseUpEquilibrium;":     '\U0000296F',
	"Rfr;":                      '\U0000211C',
	"Rho;":                      '\U000003A1',
	"RightAngleBracket;":        '\U000027E9',
	"RightArrow;":               '\U00002192',
	"RightArrowBar;":            '\U000021E5',
	"RightArrowLeftArrow;":      '\U000021C4',
	"RightCeiling;":             '\U00002309',
	"RightDoubleBracket;":       '\U000027E7',
	"RightDownTeeVector;":       '\U0000295D',
	"RightDownVector;":          '\U000021C2',
	"RightDownVectorBar;":       '\U00002955',
	"RightFloor;":               '\U0000230B',
	"RightTee;":                 '\U000022A2',
	"RightTeeArrow;":            '\U000021A6',
	"RightTeeVector;":           '\U0000295B',
	"RightTriangle;":            '\U000022B3',
	"RightTriangleBar;":         '\U000029D0',
	"RightTriangleEqual;":       '\U000022B5',
	"RightUpDownVector;":        '\U0000294F',
	"RightUpTeeVector;":         '\U0000295C',
	"RightUpVector;":            '\U000021BE',
	"RightUpVectorBar;":         '\U00002954',
	"RightVector;":              '\U000021C0',
	"RightVectorBar;":           '\U00002953',
	"Rightarrow;":               '\U000021D2',
	"Ropf;":                     '\U0000211D',
	"RoundImplies;":             '\U00002970',
	"Rrightarrow;":              '\U000021DB',
	"Rscr;":                     '\U0000211B',
	"Rsh;":                      '\U000021B1',
	"RuleDelayed;":              '\U000029F4',
	"SHCHcy;":                   '\U00000429',
	"SHcy;":                     '\U00000428',
	"SOFTcy;":                   '\U0000042C',
	"Sacute;":                   '\U0000015A',
	"Sc;":                       '\U00002ABC',
	"Scaron;":                   '\U00000160',
	"Scedil;":                   '\U0000015E',
	"Scirc;":                    '\U0000015C',
	"Scy;":                      '\U00000421',
	"Sfr;":                      '\U0001D516',
	"ShortDownArrow;":           '\U00002193',
	"ShortLeftArrow;":           '\U00002190',
	"ShortRightArrow;":          '\U00002192',
	"ShortUpArrow;":             '\U00002191',
	"Sigma;":                    '\U000003A3',
	"SmallCircle;":              '\U00002218',
	"Sopf;":                     '\U0001D54A',
	"Sqrt;":                     '\U0000221A',
	"Square;":                   '\U000025A1',
	"SquareIntersection;":       '\U00002293',
	"SquareSubset;":             '\U0000228F',
	"SquareSubsetEqual;":        '\U00002291',
	"SquareSuperset;":           '\U00002290',
	"SquareSupersetEqual;":      '\U00002292',
	"SquareUnion;":              '\U00002294',
	"Sscr;":                     '\U0001D4AE',
	"Star;":                     '\U000022C6',
	"Sub;":                      '\U000022D0',
	"Subset;":                   '\U000022D0',
	"SubsetEqual;":              '\U00002286',
	"Succeeds;":                 '\U0000227B',
	"SucceedsEqual;":            '\U00002AB0',
	"SucceedsSlantEqual;":       '\U0000227D',
	"SucceedsTilde;":            '\U0000227F',
	"SuchThat;":                 '\U0000220B',
	"Sum;":                      '\U00002211',
	"Sup;":                      '\U000022D1',
	"Superset;":                 '\U00002283',
	"SupersetEqual;":            '\U00002287',
	"Supset;":                   '\U000022D1',
	"THORN;":                    '\U000000DE',
	"TRADE;":                    '\U00002122',
	"TSHcy;":                    '\U0000040B',
	"TScy;":                     '\U00000426',
	"Tab;":                      '\U00000009',
	"Tau;":                      '\U000003A4',
	"Tcaron;":                   '\U00000164',
	"Tcedil;":                   '\U00000162',
	"Tcy;":                      '\U00000422',
	"Tfr;":                      '\U0001D517',
	"Therefore;":                '\U00002234',
	"Theta;":                    '\U00000398',
	"ThinSpace;":                '\U00002009',
	"Tilde;":                    '\U0000223C',
	"TildeEqual;":               '\U00002243',
	"TildeFullEqual;":           '\U00002245',
	"TildeTilde;":               '\U00002248',
	"Topf;":                     '\U0001D54B',
	"TripleDot;":                '\U000020DB',
	"Tscr;":                     '\U0001D4AF',
	"Tstrok;":                   '\U00000166',
	"Uacute;":                   '\U000000DA',
	"Uarr;":                     '\U0000219F',
	"Uarrocir;":                 '\U00002949',
	"Ubrcy;":                    '\U0000040E',
	"Ubreve;":                   '\U0000016C',
	"Ucirc;":                    '\U000000DB',
	"Ucy;":                      '\U00000423',
	"Udblac;":                   '\U00000170',
	"Ufr;":                      '\U0001D518',
	"Ugrave;":                   '\U000000D9',
	"Umacr;":                    '\U0000016A',
	"UnderBar;":                 '\U0000005F',
	"UnderBrace;":               '\U000023DF',
	"UnderBracket;":             '\U000023B5',
	"UnderParenthesis;":         '\U000023DD',
	"Union;":                    '\U000022C3',
	"UnionPlus;":                '\U0000228E',
	"Uogon;":                    '\U00000172',
	"Uopf;":                     '\U0001D54C',
	"UpArrow;":                  '\U00002191',
	"UpArrowBar;":               '\U00002912',
	"UpArrowDownArrow;":         '\U000021C5',
	"UpDownArrow;":              '\U00002195',
	"UpEquilibrium;":            '\U0000296E',
	"UpTee;":                    '\U000022A5',
	"UpTeeArrow;":               '\U000021A5',
	"Uparrow;":                  '\U000021D1',
	"Updownarrow;":              '\U000021D5',
	"UpperLeftArrow;":           '\U00002196',
	"UpperRightArrow;":          '\U00002197',
	"Upsi;":                     '\U000003D2',
	"Upsilon;":                  '\U000003A5',
	"Uring;":                    '\U0000016E',
	"Uscr;":                     '\U0001D4B0',
	"Utilde;":                   '\U00000168',
	"Uuml;":                     '\U000000DC',
	"VDash;":                    '\U000022AB',
	"Vbar;":                     '\U00002AEB',
	"Vcy;":                      '\U00000412',
	"Vdash;":                    '\U000022A9',
	"Vdashl;":                   '\U00002AE6',
	"Vee;":                      '\U000022C1',
	"Verbar;":                   '\U00002016',
	"Vert;":                     '\U00002016',
	"VerticalBar;":              '\U00002223',
	"VerticalLine;":             '\U0000007C',
	"VerticalSeparator;":        '\U00002758',
	"VerticalTilde;":            '\U00002240',
	"VeryThinSpace;":            '\U0000200A',
	"Vfr;":                      '\U0001D519',
	"Vopf;":                     '\U0001D54D',
	"Vscr;":                     '\U0001D4B1',
	"Vvdash;":                   '\U000022AA',
	"Wcirc;":                    '\U00000174',
	"Wedge;":                    '\U000022C0',
	"Wfr;":                      '\U0001D51A',
	"Wopf;":                     '\U0001D54E',
	"Wscr;":                     '\U0001D4B2',
	"Xfr;":                      '\U0001D51B',
	"Xi;":                       '\U0000039E',
	"Xopf;":                     '\U0001D54F',
	"Xscr;":                     '\U0001D4B3',
	"YAcy;":                     '\U0000042F',
	"YIcy;":                     '\U00000407',
	"YUcy;":                     '\U0000042E',
	"Yacute;":                   '\U000000DD',
	"Ycirc;":                    '\U00000176',
	"Ycy;":                      '\U0000042B',
	"Yfr;":                      '\U0001D51C',
	"Yopf;":                     '\U0001D550',
	"Yscr;":                     '\U0001D4B4',
	"Yuml;":                     '\U00000178',
	"ZHcy;":                     '\U00000416',
	"Zacute;":                   '\U00000179',
	"Zcaron;":                   '\U0000017D',
	"Zcy;":                      '\U00000417',
	"Zdot;":                     '\U0000017B',
	"ZeroWidthSpace;":           '\U0000200B',
	"Zeta;":                     '\U00000396',
	"Zfr;":                      '\U00002128',
	"Zopf;":                     '\U00002124',
	"Zscr;":                     '\U0001D4B5',
	"aacute;":                   '\U000000E1',
	"abreve;":                   '\U00000103',
	"ac;":                       '\U0000223E',
	"acd;":                      '\U0000223F',
	"acirc;":                    '\U000000E2',
	"acute;":                    '\U000000B4',
	"acy;":                      '\U00000430',
	"aelig;":                    '\U000000E6',
	"af;":                       '\U00002061',
	"afr;":                      '\U0001D51E',
	"agrave;":                   '\U000000E0',
	"alefsym;":                  '\U00002135',
	"aleph;":                    '\U00002135',
	"alpha;":                    '\U000003B1',
	"amacr;":                    '\U00000101',
	"amalg;":                    '\U00002A3F',
	"amp;":                      '\U00000026',
	"and;":                      '\U00002227',
	"andand;":                   '\U00002A55',
	"andd;":                     '\U00002A5C',
	"andslope;":                 '\U00002A58',
	"andv;":                     '\U00002A5A',
	"ang;":                      '\U00002220',
	"ange;":                     '\U000029A4',
	"angle;":                    '\U00002220',
	"angmsd;":                   '\U00002221',
	"angmsdaa;":                 '\U000029A8',
	"angmsdab;":                 '\U000029A9',
	"angmsdac;":                 '\U000029AA',
	"angmsdad;":                 '\U000029AB',
	"angmsdae;":                 '\U000029AC',
	"angmsdaf;":                 '\U000029AD',
	"angmsdag;":                 '\U000029AE',
	"angmsdah;":                 '\U000029AF',
	"angrt;":                    '\U0000221F',
	"angrtvb;":                  '\U000022BE',
	"angrtvbd;":                 '\U0000299D',
	"angsph;":                   '\U00002222',
	"angst;":                    '\U000000C5',
	"angzarr;":                  '\U0000237C',
	"aogon;":                    '\U00000105',
	"aopf;":                     '\U0001D552',
	"ap;":                       '\U00002248',
	"apE;":                      '\U00002A70',
	"apacir;":                   '\U00002A6F',
	"ape;":                      '\U0000224A',
	"apid;":                     '\U0000224B',
	"apos;":                     '\U00000027',
	"approx;":                   '\U00002248',
	"approxeq;":                 '\U0000224A',
	"aring;":                    '\U000000E5',
	"ascr;":                     '\U0001D4B6',
	"ast;":                      '\U0000002A',
	"asymp;":                    '\U00002248',
	"asympeq;":                  '\U0000224D',
	"atilde;":                   '\U000000E3',
	"auml;":                     '\U000000E4',
	"awconint;":                 '\U00002233',
	"awint;":                    '\U00002A11',
	"bNot;":                     '\U00002AED',
	"backcong;":                 '\U0000224C',
	"backepsilon;":              '\U000003F6',
	"backprime;":                '\U00002035',
	"backsim;":                  '\U0000223D',
	"backsimeq;":                '\U000022CD',
	"barvee;":                   '\U000022BD',
	"barwed;":                   '\U00002305',
	"barwedge;":                 '\U00002305',
	"bbrk;":                     '\U000023B5',
	"bbrktbrk;":                 '\U000023B6',
	"bcong;":                    '\U0000224C',
	"bcy;":                      '\U00000431',
	"bdquo;":                    '\U0000201E',
	"becaus;":                   '\U00002235',
	"because;":                  '\U00002235',
	"bemptyv;":                  '\U000029B0',
	"bepsi;":                    '\U000003F6',
	"bernou;":                   '\U0000212C',
	"beta;":                     '\U000003B2',
	"beth;":                     '\U00002136',
	"between;":                  '\U0000226C',
	"bfr;":                      '\U0001D51F',
	"bigcap;":                   '\U000022C2',
	"bigcirc;":                  '\U000025EF',
	"bigcup;":                   '\U000022C3',
	"bigodot;":                  '\U00002A00',
	"bigoplus;":                 '\U00002A01',
	"bigotimes;":                '\U00002A02',
	"bigsqcup;":                 '\U00002A06',
	"bigstar;":                  '\U00002605',
	"bigtriangledown;":          '\U000025BD',
	"bigtriangleup;":            '\U000025B3',
	"biguplus;":                 '\U00002A04',
	"bigvee;":                   '\U000022C1',
	"bigwedge;":                 '\U000022C0',
	"bkarow;":                   '\U0000290D',
	"blacklozenge;":             '\U000029EB',
	"blacksquare;":              '\U000025AA',
	"blacktriangle;":            '\U000025B4',
	"blacktriangledown;":        '\U000025BE',
	"blacktriangleleft;":        '\U000025C2',
	"blacktriangleright;":       '\U000025B8',
	"blank;":                    '\U00002423',
	"blk12;":                    '\U00002592',
	"blk14;":                    '\U00002591',
	"blk34;":                    '\U00002593',
	"block;":                    '\U00002588',
	"bnot;":                     '\U00002310',
	"bopf;":                     '\U0001D553',
	"bot;":                      '\U000022A5',
	"bottom;":                   '\U000022A5',
	"bowtie;":                   '\U000022C8',
	"boxDL;":                    '\U00002557',
	"boxDR;":                    '\U00002554',
	"boxDl;":                    '\U00002556',
	"boxDr;":                    '\U00002553',
	"boxH;":                     '\U00002550',
	"boxHD;":                    '\U00002566',
	"boxHU;":                    '\U00002569',
	"boxHd;":                    '\U00002564',
	"boxHu;":                    '\U00002567',
	"boxUL;":                    '\U0000255D',
	"boxUR;":                    '\U0000255A',
	"boxUl;":                    '\U0000255C',
	"boxUr;":                    '\U00002559',
	"boxV;":                     '\U00002551',
	"boxVH;":                    '\U0000256C',
	"boxVL;":                    '\U00002563',
	"boxVR;":                    '\U00002560',
	"boxVh;":                    '\U0000256B',
	"boxVl;":                    '\U00002562',
	"boxVr;":                    '\U0000255F',
	"boxbox;":                   '\U000029C9',
	"boxdL;":                    '\U00002555',
	"boxdR;":                    '\U00002552',
	"boxdl;":                    '\U00002510',
	"boxdr;":                    '\U0000250C',
	"boxh;":                     '\U00002500',
	"boxhD;":                    '\U00002565',
	"boxhU;":                    '\U00002568',
	"boxhd;":                    '\U0000252C',
	"boxhu;":                    '\U00002534',
	"boxminus;":                 '\U0000229F',
	"boxplus;":                  '\U0000229E',
	"boxtimes;":                 '\U000022A0',
	"boxuL;":                    '\U0000255B',
	"boxuR;":                    '\U00002558',
	"boxul;":                    '\U00002518',
	"boxur;":                    '\U00002514',
	"boxv;":                     '\U00002502',
	"boxvH;":                    '\U0000256A',
	"boxvL;":                    '\U00002561',
	"boxvR;":                    '\U0000255E',
	"boxvh;":                    '\U0000253C',
	"boxvl;":                    '\U00002524',
	"boxvr;":                    '\U0000251C',
	"bprime;":                   '\U00002035',
	"breve;":                    '\U000002D8',
	"brvbar;":                   '\U000000A6',
	"bscr;":                     '\U0001D4B7',
	"bsemi;":                    '\U0000204F',
	"bsim;":                     '\U0000223D',
	"bsime;":                    '\U000022CD',
	"bsol;":                     '\U0000005C',
	"bsolb;":                    '\U000029C5',
	"bsolhsub;":                 '\U000027C8',
	"bull;":                     '\U00002022',
	"bullet;":                   '\U00002022',
	"bump;":                     '\U0000224E',
	"bumpE;":                    '\U00002AAE',
	"bumpe;":                    '\U0000224F',
	"bumpeq;":                   '\U0000224F',
	"cacute;":                   '\U00000107',
	"cap;":                      '\U00002229',
	"capand;":                   '\U00002A44',
	"capbrcup;":                 '\U00002A49',
	"capcap;":                   '\U00002A4B',
	"capcup;":                   '\U00002A47',
	"capdot;":                   '\U00002A40',
	"caret;":                    '\U00002041',
	"caron;":                    '\U000002C7',
	"ccaps;":                    '\U00002A4D',
	"ccaron;":                   '\U0000010D',
	"ccedil;":                   '\U000000E7',
	"ccirc;":                    '\U00000109',
	"ccups;":                    '\U00002A4C',
	"ccupssm;":                  '\U00002A50',
	"cdot;":                     '\U0000010B',
	"cedil;":                    '\U000000B8',
	"cemptyv;":                  '\U000029B2',
	"cent;":                     '\U000000A2',
	"centerdot;":                '\U000000B7',
	"cfr;":                      '\U0001D520',
	"chcy;":                     '\U00000447',
	"check;":                    '\U00002713',
	"checkmark;":                '\U00002713',
	"chi;":                      '\U000003C7',
	"cir;":                      '\U000025CB',
	"cirE;":                     '\U000029C3',
	"circ;":                     '\U000002C6',
	"circeq;":                   '\U00002257',
	"circlearrowleft;":          '\U000021BA',
	"circlearrowright;":         '\U000021BB',
	"circledR;":                 '\U000000AE',
	"circledS;":                 '\U000024C8',
	"circledast;":               '\U0000229B',
	"circledcirc;":              '\U0000229A',
	"circleddash;":              '\U0000229D',
	"cire;":                     '\U00002257',
	"cirfnint;":                 '\U00002A10',
	"cirmid;":                   '\U00002AEF',
	"cirscir;":                  '\U000029C2',
	"clubs;":                    '\U00002663',
	"clubsuit;":                 '\U00002663',
	"colon;":                    '\U0000003A',
	"colone;":                   '\U00002254',
	"coloneq;":                  '\U00002254',
	"comma;":                    '\U0000002C',
	"commat;":                   '\U00000040',
	"comp;":                     '\U00002201',
	"compfn;":                   '\U00002218',
	"complement;":               '\U00002201',
	"complexes;":                '\U00002102',
	"cong;":                     '\U00002245',
	"congdot;":                  '\U00002A6D',
	"conint;":                   '\U0000222E',
	"copf;":                     '\U0001D554',
	"coprod;":                   '\U00002210',
	"copy;":                     '\U000000A9',
	"copysr;":                   '\U00002117',
	"crarr;":                    '\U000021B5',
	"cross;":                    '\U00002717',
	"cscr;":                     '\U0001D4B8',
	"csub;":                     '\U00002ACF',
	"csube;":                    '\U00002AD1',
	"csup;":                     '\U00002AD0',
	"csupe;":                    '\U00002AD2',
	"ctdot;":                    '\U000022EF',
	"cudarrl;":                  '\U00002938',
	"cudarrr;":                  '\U00002935',
	"cuepr;":                    '\U000022DE',
	"cuesc;":                    '\U000022DF',
	"cularr;":                   '\U000021B6',
	"cularrp;":                  '\U0000293D',
	"cup;":                      '\U0000222A',
	"cupbrcap;":                 '\U00002A48',
	"cupcap;":                   '\U00002A46',
	"cupcup;":                   '\U00002A4A',
	"cupdot;":                   '\U0000228D',
	"cupor;":                    '\U00002A45',
	"curarr;":                   '\U000021B7',
	"curarrm;":                  '\U0000293C',
	"curlyeqprec;":              '\U000022DE',
	"curlyeqsucc;":              '\U000022DF',
	"curlyvee;":                 '\U000022CE',
	"curlywedge;":               '\U000022CF',
	"curren;":                   '\U000000A4',
	"curvearrowleft;":           '\U000021B6',
	"curvearrowright;":          '\U000021B7',
	"cuvee;":                    '\U000022CE',
	"cuwed;":                    '\U000022CF',
	"cwconint;":                 '\U00002232',
	"cwint;":                    '\U00002231',
	"cylcty;":                   '\U0000232D',
	"dArr;":                     '\U000021D3',
	"dHar;":                     '\U00002965',
	"dagger;":                   '\U00002020',
	"daleth;":                   '\U00002138',
	"darr;":                     '\U00002193',
	"dash;":                     '\U00002010',
	"dashv;":                    '\U000022A3',
	"dbkarow;":                  '\U0000290F',
	"dblac;":                    '\U000002DD',
	"dcaron;":                   '\U0000010F',
	"dcy;":                      '\U00000434',
	"dd;":                       '\U00002146',
	"ddagger;":                  '\U00002021',
	"ddarr;":                    '\U000021CA',
	"ddotseq;":                  '\U00002A77',
	"deg;":                      '\U000000B0',
	"delta;":                    '\U000003B4',
	"demptyv;":                  '\U000029B1',
	"dfisht;":                   '\U0000297F',
	"dfr;":                      '\U0001D521',
	"dharl;":                    '\U000021C3',
	"dharr;":                    '\U000021C2',
	"diam;":                     '\U000022C4',
	"diamond;":                  '\U000022C4',
	"diamondsuit;":              '\U00002666',
	"diams;":                    '\U00002666',
	"die;":                      '\U000000A8',
	"digamma;":                  '\U000003DD',
	"disin;":                    '\U000022F2',
	"div;":                      '\U000000F7',
	"divide;":                   '\U000000F7',
	"divideontimes;":            '\U000022C7',
	"divonx;":                   '\U000022C7',
	"djcy;":                     '\U00000452',
	"dlcorn;":                   '\U0000231E',
	"dlcrop;":                   '\U0000230D',
	"dollar;":                   '\U00000024',
	"dopf;":                     '\U0001D555',
	"dot;":                      '\U000002D9',
	"doteq;":                    '\U00002250',
	"doteqdot;":                 '\U00002251',
	"dotminus;":                 '\U00002238',
	"dotplus;":                  '\U00002214',
	"dotsquare;":                '\U000022A1',
	"doublebarwedge;":           '\U00002306',
	"downarrow;":                '\U00002193',
	"downdownarrows;":           '\U000021CA',
	"downharpoonleft;":          '\U000021C3',
	"downharpoonright;":         '\U000021C2',
	"drbkarow;":                 '\U00002910',
	"drcorn;":                   '\U0000231F',
	"drcrop;":                   '\U0000230C',
	"dscr;":                     '\U0001D4B9',
	"dscy;":                     '\U00000455',
	"dsol;":                     '\U000029F6',
	"dstrok;":                   '\U00000111',
	"dtdot;":                    '\U000022F1',
	"dtri;":                     '\U000025BF',
	"dtrif;":                    '\U000025BE',
	"duarr;":                    '\U000021F5',
	"duhar;":                    '\U0000296F',
	"dwangle;":                  '\U000029A6',
	"dzcy;":                     '\U0000045F',
	"dzigrarr;":                 '\U000027FF',
	"eDDot;":                    '\U00002A77',
	"eDot;":                     '\U00002251',
	"eacute;":                   '\U000000E9',
	"easter;":                   '\U00002A6E',
	"ecaron;":                   '\U0000011B',
	"ecir;":                     '\U00002256',
	"ecirc;":                    '\U000000EA',
	"ecolon;":                   '\U00002255',
	"ecy;":                      '\U0000044D',
	"edot;":                     '\U00000117',
	"ee;":                       '\U00002147',
	"efDot;":                    '\U00002252',
	"efr;":                      '\U0001D522',
	"eg;":                       '\U00002A9A',
	"egrave;":                   '\U000000E8',
	"egs;":                      '\U00002A96',
	"egsdot;":                   '\U00002A98',
	"el;":                       '\U00002A99',
	"elinters;":                 '\U000023E7',
	"ell;":                      '\U00002113',
	"els;":                      '\U00002A95',
	"elsdot;":                   '\U00002A97',
	"emacr;":                    '\U00000113',
	"empty;":                    '\U00002205',
	"emptyset;":                 '\U00002205',
	"emptyv;":                   '\U00002205',
	"emsp;":                     '\U00002003',
	"emsp13;":                   '\U00002004',
	"emsp14;":                   '\U00002005',
	"eng;":                      '\U0000014B',
	"ensp;":                     '\U00002002',
	"eogon;":                    '\U00000119',
	"eopf;":                     '\U0001D556',
	"epar;":                     '\U000022D5',
	"eparsl;":                   '\U000029E3',
	"eplus;":                    '\U00002A71',
	"epsi;":                     '\U000003B5',
	"epsilon;":                  '\U000003B5',
	"epsiv;":                    '\U000003F5',
	"eqcirc;":                   '\U00002256',
	"eqcolon;":                  '\U00002255',
	"eqsim;":                    '\U00002242',
	"eqslantgtr;":               '\U00002A96',
	"eqslantless;":              '\U00002A95',
	"equals;":                   '\U0000003D',
	"equest;":                   '\U0000225F',
	"equiv;":                    '\U00002261',
	"equivDD;":                  '\U00002A78',
	"eqvparsl;":                 '\U000029E5',
	"erDot;":                    '\U00002253',
	"erarr;":                    '\U00002971',
	"escr;":                     '\U0000212F',
	"esdot;":                    '\U00002250',
	"esim;":                     '\U00002242',
	"eta;":                      '\U000003B7',
	"eth;":                      '\U000000F0',
	"euml;":                     '\U000000EB',
	"euro;":                     '\U000020AC',
	"excl;":                     '\U00000021',
	"exist;":                    '\U00002203',
	"expectation;":              '\U00002130',
	"exponentiale;":             '\U00002147',
	"fallingdotseq;":            '\U00002252',
	"fcy;":                      '\U00000444',
	"female;":                   '\U00002640',
	"ffilig;":                   '\U0000FB03',
	"fflig;":                    '\U0000FB00',
	"ffllig;":                   '\U0000FB04',
	"ffr;":                      '\U0001D523',
	"filig;":                    '\U0000FB01',
	"flat;":                     '\U0000266D',
	"fllig;":                    '\U0000FB02',
	"fltns;":                    '\U000025B1',
	"fnof;":                     '\U00000192',
	"fopf;":                     '\U0001D557',
	"forall;":                   '\U00002200',
	"fork;":                     '\U000022D4',
	"forkv;":                    '\U00002AD9',
	"fpartint;":                 '\U00002A0D',
	"frac12;":                   '\U000000BD',
	"frac13;":                   '\U00002153',
	"frac14;":                   '\U000000BC',
	"frac15;":                   '\U00002155',
	"frac16;":                   '\U00002159',
	"frac18;":                   '\U0000215B',
	"frac23;":                   '\U00002154',
	"frac25;":                   '\U00002156',
	"frac34;":                   '\U000000BE',
	"frac35;":                   '\U00002157',
	"frac38;":                   '\U0000215C',
	"frac45;":                   '\U00002158',
	"frac56;":                   '\U0000215A',
	"frac58;":                   '\U0000215D',
	"frac78;":                   '\U0000215E',
	"frasl;":                    '\U00002044',
	"frown;":                    '\U00002322',
	"fscr;":                     '\U0001D4BB',
	"gE;":                       '\U00002267',
	"gEl;":                      '\U00002A8C',
	"gacute;":                   '\U000001F5',
	"gamma;":                    '\U000003B3',
	"gammad;":                   '\U000003DD',
	"gap;":                      '\U00002A86',
	"gbreve;":                   '\U0000011F',
	"gcirc;":                    '\U0000011D',
	"gcy;":                      '\U00000433',
	"gdot;":                     '\U00000121',
	"ge;":                       '\U00002265',
	"gel;":                      '\U000022DB',
	"geq;":                      '\U00002265',
	"geqq;":                     '\U00002267',
	"geqslant;":                 '\U00002A7E',
	"ges;":                      '\U00002A7E',
	"gescc;":                    '\U00002AA9',
	"gesdot;":                   '\U00002A80',
	"gesdoto;":                  '\U00002A82',
	"gesdotol;":                 '\U00002A84',
	"gesles;":                   '\U00002A94',
	"gfr;":                      '\U0001D524',
	"gg;":                       '\U0000226B',
	"ggg;":                      '\U000022D9',
	"gimel;":                    '\U00002137',
	"gjcy;":                     '\U00000453',
	"gl;":                       '\U00002277',
	"glE;":                      '\U00002A92',
	"gla;":                      '\U00002AA5',
	"glj;":                      '\U00002AA4',
	"gnE;":                      '\U00002269',
	"gnap;":                     '\U00002A8A',
	"gnapprox;":                 '\U00002A8A',
	"gne;":                      '\U00002A88',
	"gneq;":                     '\U00002A88',
	"gneqq;":                    '\U00002269',
	"gnsim;":                    '\U000022E7',
	"gopf;":                     '\U0001D558',
	"grave;":                    '\U00000060',
	"gscr;":                     '\U0000210A',
	"gsim;":                     '\U00002273',
	"gsime;":                    '\U00002A8E',
	"gsiml;":                    '\U00002A90',
	"gt;":                       '\U0000003E',
	"gtcc;":                     '\U00002AA7',
	"gtcir;":                    '\U00002A7A',
	"gtdot;":                    '\U000022D7',
	"gtlPar;":                   '\U00002995',
	"gtquest;":                  '\U00002A7C',
	"gtrapprox;":                '\U00002A86',
	"gtrarr;":                   '\U00002978',
	"gtrdot;":                   '\U000022D7',
	"gtreqless;":                '\U000022DB',
	"gtreqqless;":               '\U00002A8C',
	"gtrless;":                  '\U00002277',
	"gtrsim;":                   '\U00002273',
	"hArr;":                     '\U000021D4',
	"hairsp;":                   '\U0000200A',
	"half;":                     '\U000000BD',
	"hamilt;":                   '\U0000210B',
	"hardcy;":                   '\U0000044A',
	"harr;":                     '\U00002194',
	"harrcir;":                  '\U00002948',
	"harrw;":                    '\U000021AD',
	"hbar;":                     '\U0000210F',
	"hcirc;":                    '\U00000125',
	"hearts;":                   '\U00002665',
	"heartsuit;":                '\U00002665',
	"hellip;":                   '\U00002026',
	"hercon;":                   '\U000022B9',
	"hfr;":                      '\U0001D525',
	"hksearow;":                 '\U00002925',
	"hkswarow;":                 '\U00002926',
	"hoarr;":                    '\U000021FF',
	"homtht;":                   '\U0000223B',
	"hookleftarrow;":            '\U000021A9',
	"hookrightarrow;":           '\U000021AA',
	"hopf;":                     '\U0001D559',
	"horbar;":                   '\U00002015',
	"hscr;":                     '\U0001D4BD',
	"hslash;":                   '\U0000210F',
	"hstrok;":                   '\U00000127',
	"hybull;":                   '\U00002043',
	"hyphen;":                   '\U00002010',
	"iacute;":                   '\U000000ED',
	"ic;":                       '\U00002063',
	"icirc;":                    '\U000000EE',
	"icy;":                      '\U00000438',
	"iecy;":                     '\U00000435',
	"iexcl;":                    '\U000000A1',
	"iff;":                      '\U000021D4',
	"ifr;":                      '\U0001D526',
	"igrave;":                   '\U000000EC',
	"ii;":                       '\U00002148',
	"iiiint;":                   '\U00002A0C',
	"iiint;":                    '\U0000222D',
	"iinfin;":                   '\U000029DC',
	"iiota;":                    '\U00002129',
	"ijlig;":                    '\U00000133',
	"imacr;":                    '\U0000012B',
	"image;":                    '\U00002111',
	"imagline;":                 '\U00002110',
	"imagpart;":                 '\U00002111',
	"imath;":                    '\U00000131',
	"imof;":                     '\U000022B7',
	"imped;":                    '\U000001B5',
	"in;":                       '\U00002208',
	"incare;":                   '\U00002105',
	"infin;":                    '\U0000221E',
	"infintie;":                 '\U000029DD',
	"inodot;":                   '\U00000131',
	"int;":                      '\U0000222B',
	"intcal;":                   '\U000022BA',
	"integers;":                 '\U00002124',
	"intercal;":                 '\U000022BA',
	"intlarhk;":                 '\U00002A17',
	"intprod;":                  '\U00002A3C',
	"iocy;":                     '\U00000451',
	"iogon;":                    '\U0000012F',
	"iopf;":                     '\U0001D55A',
	"iota;":                     '\U000003B9',
	"iprod;":                    '\U00002A3C',
	"iquest;":                   '\U000000BF',
	"iscr;":                     '\U0001D4BE',
	"isin;":                     '\U00002208',
	"isinE;":                    '\U000022F9',
	"isindot;":                  '\U000022F5',
	"isins;":                    '\U000022F4',
	"isinsv;":                   '\U000022F3',
	"isinv;":                    '\U00002208',
	"it;":                       '\U00002062',
	"itilde;":                   '\U00000129',
	"iukcy;":                    '\U00000456',
	"iuml;":                     '\U000000EF',
	"jcirc;":                    '\U00000135',
	"jcy;":                      '\U00000439',
	"jfr;":                      '\U0001D527',
	"jmath;":                    '\U00000237',
	"jopf;":                     '\U0001D55B',
	"jscr;":                     '\U0001D4BF',
	"jsercy;":                   '\U00000458',
	"jukcy;":                    '\U00000454',
	"kappa;":                    '\U000003BA',
	"kappav;":                   '\U000003F0',
	"kcedil;":                   '\U00000137',
	"kcy;":                      '\U0000043A',
	"kfr;":                      '\U0001D528',
	"kgreen;":                   '\U00000138',
	"khcy;":                     '\U00000445',
	"kjcy;":                     '\U0000045C',
	"kopf;":                     '\U0001D55C',
	"kscr;":                     '\U0001D4C0',
	"lAarr;":                    '\U000021DA',
	"lArr;":                     '\U000021D0',
	"lAtail;":                   '\U0000291B',
	"lBarr;":                    '\U0000290E',
	"lE;":                       '\U00002266',
	"lEg;":                      '\U00002A8B',
	"lHar;":                     '\U00002962',
	"lacute;":                   '\U0000013A',
	"laemptyv;":                 '\U000029B4',
	"lagran;":                   '\U00002112',
	"lambda;":                   '\U000003BB',
	"lang;":                     '\U000027E8',
	"langd;":                    '\U00002991',
	"langle;":                   '\U000027E8',
	"lap;":                      '\U00002A85',
	"laquo;":                    '\U000000AB',
	"larr;":                     '\U00002190',
	"larrb;":                    '\U000021E4',
	"larrbfs;":                  '\U0000291F',
	"larrfs;":                   '\U0000291D',
	"larrhk;":                   '\U000021A9',
	"larrlp;":                   '\U000021AB',
	"larrpl;":                   '\U00002939',
	"larrsim;":                  '\U00002973',
	"larrtl;":                   '\U000021A2',
	"lat;":                      '\U00002AAB',
	"latail;":                   '\U00002919',
	"late;":                     '\U00002AAD',
	"lbarr;":                    '\U0000290C',
	"lbbrk;":                    '\U00002772',
	"lbrace;":                   '\U0000007B',
	"lbrack;":                   '\U0000005B',
	"lbrke;":                    '\U0000298B',
	"lbrksld;":                  '\U0000298F',
	"lbrkslu;":                  '\U0000298D',
	"lcaron;":                   '\U0000013E',
	"lcedil;":                   '\U0000013C',
	"lceil;":                    '\U00002308',
	"lcub;":                     '\U0000007B',
	"lcy;":                      '\U0000043B',
	"ldca;":                     '\U00002936',
	"ldquo;":                    '\U0000201C',
	"ldquor;":                   '\U0000201E',
	"ldrdhar;":                  '\U00002967',
	"ldrushar;":                 '\U0000294B',
	"ldsh;":                     '\U000021B2',
	"le;":                       '\U00002264',
	"leftarrow;":                '\U00002190',
	"leftarrowtail;":            '\U000021A2',
	"leftharpoondown;":          '\U000021BD',
	"leftharpoonup;":            '\U000021BC',
	"leftleftarrows;":           '\U000021C7',
	"leftrightarrow;":           '\U00002194',
	"leftrightarrows;":          '\U000021C6',
	"leftrightharpoons;":        '\U000021CB',
	"leftrightsquigarrow;":      '\U000021AD',
	"leftthreetimes;":           '\U000022CB',
	"leg;":                      '\U000022DA',
	"leq;":                      '\U00002264',
	"leqq;":                     '\U00002266',
	"leqslant;":                 '\U00002A7D',
	"les;":                      '\U00002A7D',
	"lescc;":                    '\U00002AA8',
	"lesdot;":                   '\U00002A7F',
	"lesdoto;":                  '\U00002A81',
	"lesdotor;":                 '\U00002A83',
	"lesges;":                   '\U00002A93',
	"lessapprox;":               '\U00002A85',
	"lessdot;":                  '\U000022D6',
	"lesseqgtr;":                '\U000022DA',
	"lesseqqgtr;":               '\U00002A8B',
	"lessgtr;":                  '\U00002276',
	"lesssim;":                  '\U00002272',
	"lfisht;":                   '\U0000297C',
	"lfloor;":                   '\U0000230A',
	"lfr;":                      '\U0001D529',
	"lg;":                       '\U00002276',
	"lgE;":                      '\U00002A91',
	"lhard;":                    '\U000021BD',
	"lharu;":                    '\U000021BC',
	"lharul;":                   '\U0000296A',
	"lhblk;":                    '\U00002584',
	"ljcy;":                     '\U00000459',
	"ll;":                       '\U0000226A',
	"llarr;":                    '\U000021C7',
	"llcorner;":                 '\U0000231E',
	"llhard;":                   '\U0000296B',
	"lltri;":                    '\U000025FA',
	"lmidot;":                   '\U00000140',
	"lmoust;":                   '\U000023B0',
	"lmoustache;":               '\U000023B0',
	"lnE;":                      '\U00002268',
	"lnap;":                     '\U00002A89',
	"lnapprox;":                 '\U00002A89',
	"lne;":                      '\U00002A87',
	"lneq;":                     '\U00002A87',
	"lneqq;":                    '\U00002268',
	"lnsim;":                    '\U000022E6',
	"loang;":                    '\U000027EC',
	"loarr;":                    '\U000021FD',
	"lobrk;":                    '\U000027E6',
	"longleftarrow;":            '\U000027F5',
	"longleftrightarrow;":       '\U000027F7',
	"longmapsto;":               '\U000027FC',
	"longrightarrow;":           '\U000027F6',
	"looparrowleft;":            '\U000021AB',
	"looparrowright;":           '\U000021AC',
	"lopar;":                    '\U00002985',
	"lopf;":                     '\U0001D55D',
	"loplus;":                   '\U00002A2D',
	"lotimes;":                  '\U00002A34',
	"lowast;":                   '\U00002217',
	"lowbar;":                   '\U0000005F',
	"loz;":                      '\U000025CA',
	"lozenge;":                  '\U000025CA',
	"lozf;":                     '\U000029EB',
	"lpar;":                     '\U00000028',
	"lparlt;":                   '\U00002993',
	"lrarr;":                    '\U000021C6',
	"lrcorner;":                 '\U0000231F',
	"lrhar;":                    '\U000021CB',
	"lrhard;":                   '\U0000296D',
	"lrm;":                      '\U0000200E',
	"lrtri;":                    '\U000022BF',
	"lsaquo;":                   '\U00002039',
	"lscr;":                     '\U0001D4C1',
	"lsh;":                      '\U000021B0',
	"lsim;":                     '\U00002272',
	"lsime;":                    '\U00002A8D',
	"lsimg;":                    '\U00002A8F',
	"lsqb;":                     '\U0000005B',
	"lsquo;":                    '\U00002018',
	"lsquor;":                   '\U0000201A',
	"lstrok;":                   '\U00000142',
	"lt;":                       '\U0000003C',
	"ltcc;":                     '\U00002AA6',
	"ltcir;":                    '\U00002A79',
	"ltdot;":                    '\U000022D6',
	"lthree;":                   '\U000022CB',
	"ltimes;":                   '\U000022C9',
	"ltlarr;":                   '\U00002976',
	"ltquest;":                  '\U00002A7B',
	"ltrPar;":                   '\U00002996',
	"ltri;":                     '\U000025C3',
	"ltrie;":                    '\U000022B4',
	"ltrif;":                    '\U000025C2',
	"lurdshar;":                 '\U0000294A',
	"luruhar;":                  '\U00002966',
	"mDDot;":                    '\U0000223A',
	"macr;":                     '\U000000AF',
	"male;":                     '\U00002642',
	"malt;":                     '\U00002720',
	"maltese;":                  '\U00002720',
	"map;":                      '\U000021A6',
	"mapsto;":                   '\U000021A6',
	"mapstodown;":               '\U000021A7',
	"mapstoleft;":               '\U000021A4',
	"mapstoup;":                 '\U000021A5',
	"marker;":                   '\U000025AE',
	"mcomma;":                   '\U00002A29',
	"mcy;":                      '\U0000043C',
	"mdash;":                    '\U00002014',
	"measuredangle;":            '\U00002221',
	"mfr;":                      '\U0001D52A',
	"mho;":                      '\U00002127',
	"micro;":                    '\U000000B5',
	"mid;":                      '\U00002223',
	"midast;":                   '\U0000002A',
	"midcir;":                   '\U00002AF0',
	"middot;":                   '\U000000B7',
	"minus;":                    '\U00002212',
	"minusb;":                   '\U0000229F',
	"minusd;":                   '\U00002238',
	"minusdu;":                  '\U00002A2A',
	"mlcp;":                     '\U00002ADB',
	"mldr;":                     '\U00002026',
	"mnplus;":                   '\U00002213',
	"models;":                   '\U000022A7',
	"mopf;":                     '\U0001D55E',
	"mp;":                       '\U00002213',
	"mscr;":                     '\U0001D4C2',
	"mstpos;":                   '\U0000223E',
	"mu;":                       '\U000003BC',
	"multimap;":                 '\U000022B8',
	"mumap;":                    '\U000022B8',
	"nLeftarrow;":               '\U000021CD',
	"nLeftrightarrow;":          '\U000021CE',
	"nRightarrow;":              '\U000021CF',
	"nVDash;":                   '\U000022AF',
	"nVdash;":                   '\U000022AE',
	"nabla;":                    '\U00002207',
	"nacute;":                   '\U00000144',
	"nap;":                      '\U00002249',
	"napos;":                    '\U00000149',
	"napprox;":                  '\U00002249',
	"natur;":                    '\U0000266E',
	"natural;":                  '\U0000266E',
	"naturals;":                 '\U00002115',
	"nbsp;":                     '\U000000A0',
	"ncap;":                     '\U00002A43',
	"ncaron;":                   '\U00000148',
	"ncedil;":                   '\U00000146',
	"ncong;":                    '\U00002247',
	"ncup;":                     '\U00002A42',
	"ncy;":                      '\U0000043D',
	"ndash;":                    '\U00002013',
	"ne;":                       '\U00002260',
	"neArr;":                    '\U000021D7',
	"nearhk;":                   '\U00002924',
	"nearr;":                    '\U00002197',
	"nearrow;":                  '\U00002197',
	"nequiv;":                   '\U00002262',
	"nesear;":                   '\U00002928',
	"nexist;":                   '\U00002204',
	"nexists;":                  '\U00002204',
	"nfr;":                      '\U0001D52B',
	"nge;":                      '\U00002271',
	"ngeq;":                     '\U00002271',
	"ngsim;":                    '\U00002275',
	"ngt;":                      '\U0000226F',
	"ngtr;":                     '\U0000226F',
	"nhArr;":                    '\U000021CE',
	"nharr;":                    '\U000021AE',
	"nhpar;":                    '\U00002AF2',
	"ni;":                       '\U0000220B',
	"nis;":                      '\U000022FC',
	"nisd;":                     '\U000022FA',
	"niv;":                      '\U0000220B',
	"njcy;":                     '\U0000045A',
	"nlArr;":                    '\U000021CD',
	"nlarr;":                    '\U0000219A',
	"nldr;":                     '\U00002025',
	"nle;":                      '\U00002270',
	"nleftarrow;":               '\U0000219A',
	"nleftrightarrow;":          '\U000021AE',
	"nleq;":                     '\U00002270',
	"nless;":                    '\U0000226E',
	"nlsim;":                    '\U00002274',
	"nlt;":                      '\U0000226E',
	"nltri;":                    '\U000022EA',
	"nltrie;":                   '\U000022EC',
	"nmid;":                     '\U00002224',
	"nopf;":                     '\U0001D55F',
	"not;":                      '\U000000AC',
	"notin;":                    '\U00002209',
	"notinva;":                  '\U00002209',
	"notinvb;":                  '\U000022F7',
	"notinvc;":                  '\U000022F6',
	"notni;":                    '\U0000220C',
	"notniva;":                  '\U0000220C',
	"notnivb;":                  '\U000022FE',
	"notnivc;":                  '\U000022FD',
	"npar;":                     '\U00002226',
	"nparallel;":                '\U00002226',
	"npolint;":                  '\U00002A14',
	"npr;":                      '\U00002280',
	"nprcue;":                   '\U000022E0',
	"nprec;":                    '\U00002280',
	"nrArr;":                    '\U000021CF',
	"nrarr;":                    '\U0000219B',
	"nrightarrow;":              '\U0000219B',
	"nrtri;":                    '\U000022EB',
	"nrtrie;":                   '\U000022ED',
	"nsc;":                      '\U00002281',
	"nsccue;":                   '\U000022E1',
	"nscr;":                     '\U0001D4C3',
	"nshortmid;":                '\U00002224',
	"nshortparallel;":           '\U00002226',
	"nsim;":                     '\U00002241',
	"nsime;":                    '\U00002244',
	"nsimeq;":                   '\U00002244',
	"nsmid;":                    '\U00002224',
	"nspar;":                    '\U00002226',
	"nsqsube;":                  '\U000022E2',
	"nsqsupe;":                  '\U000022E3',
	"nsub;":                     '\U00002284',
	"nsube;":                    '\U00002288',
	"nsubseteq;":                '\U00002288',
	"nsucc;":                    '\U00002281',
	"nsup;":                     '\U00002285',
	"nsupe;":                    '\U00002289',
	"nsupseteq;":                '\U00002289',
	"ntgl;":                     '\U00002279',
	"ntilde;":                   '\U000000F1',
	"ntlg;":                     '\U00002278',
	"ntriangleleft;":            '\U000022EA',
	"ntrianglelefteq;":          '\U000022EC',
	"ntriangleright;":           '\U000022EB',
	"ntrianglerighteq;":         '\U000022ED',
	"nu;":                       '\U000003BD',
	"num;":                      '\U00000023',
	"numero;":                   '\U00002116',
	"numsp;":                    '\U00002007',
	"nvDash;":                   '\U000022AD',
	"nvHarr;":                   '\U00002904',
	"nvdash;":                   '\U000022AC',
	"nvinfin;":                  '\U000029DE',
	"nvlArr;":                   '\U00002902',
	"nvrArr;":                   '\U00002903',
	"nwArr;":                    '\U000021D6',
	"nwarhk;":                   '\U00002923',
	"nwarr;":                    '\U00002196',
	"nwarrow;":                  '\U00002196',
	"nwnear;":                   '\U00002927',
	"oS;":                       '\U000024C8',
	"oacute;":                   '\U000000F3',
	"oast;":                     '\U0000229B',
	"ocir;":                     '\U0000229A',
	"ocirc;":                    '\U000000F4',
	"ocy;":                      '\U0000043E',
	"odash;":                    '\U0000229D',
	"odblac;":                   '\U00000151',
	"odiv;":                     '\U00002A38',
	"odot;":                     '\U00002299',
	"odsold;":                   '\U000029BC',
	"oelig;":                    '\U00000153',
	"ofcir;":                    '\U000029BF',
	"ofr;":                      '\U0001D52C',
	"ogon;":                     '\U000002DB',
	"ograve;":                   '\U000000F2',
	"ogt;":                      '\U000029C1',
	"ohbar;":                    '\U000029B5',
	"ohm;":                      '\U000003A9',
	"oint;":                     '\U0000222E',
	"olarr;":                    '\U000021BA',
	"olcir;":                    '\U000029BE',
	"olcross;":                  '\U000029BB',
	"oline;":                    '\U0000203E',
	"olt;":                      '\U000029C0',
	"omacr;":                    '\U0000014D',
	"omega;":                    '\U000003C9',
	"omicron;":                  '\U000003BF',
	"omid;":                     '\U000029B6',
	"ominus;":                   '\U00002296',
	"oopf;":                     '\U0001D560',
	"opar;":                     '\U000029B7',
	"operp;":                    '\U000029B9',
	"oplus;":                    '\U00002295',
	"or;":                       '\U00002228',
	"orarr;":                    '\U000021BB',
	"ord;":                      '\U00002A5D',
	"order;":                    '\U00002134',
	"orderof;":                  '\U00002134',
	"ordf;":                     '\U000000AA',
	"ordm;":                     '\U000000BA',
	"origof;":                   '\U000022B6',
	"oror;":                     '\U00002A56',
	"orslope;":                  '\U00002A57',
	"orv;":                      '\U00002A5B',
	"oscr;":                     '\U00002134',
	"oslash;":                   '\U000000F8',
	"osol;":                     '\U00002298',
	"otilde;":                   '\U000000F5',
	"otimes;":                   '\U00002297',
	"otimesas;":                 '\U00002A36',
	"ouml;":                     '\U000000F6',
	"ovbar;":                    '\U0000233D',
	"par;":                      '\U00002225',
	"para;":                     '\U000000B6',
	"parallel;":                 '\U00002225',
	"parsim;":                   '\U00002AF3',
	"parsl;":                    '\U00002AFD',
	"part;":                     '\U00002202',
	"pcy;":                      '\U0000043F',
	"percnt;":                   '\U00000025',
	"period;":                   '\U0000002E',
	"permil;":                   '\U00002030',
	"perp;":                     '\U000022A5',
	"pertenk;":                  '\U00002031',
	"pfr;":                      '\U0001D52D',
	"phi;":                      '\U000003C6',
	"phiv;":                     '\U000003D5',
	"phmmat;":                   '\U00002133',
	"phone;":                    '\U0000260E',
	"pi;":                       '\U000003C0',
	"pitchfork;":                '\U000022D4',
	"piv;":                      '\U000003D6',
	"planck;":                   '\U0000210F',
	"planckh;":                  '\U0000210E',
	"plankv;":                   '\U0000210F',
	"plus;":                     '\U0000002B',
	"plusacir;":                 '\U00002A23',
	"plusb;":                    '\U0000229E',
	"pluscir;":                  '\U00002A22',
	"plusdo;":                   '\U00002214',
	"plusdu;":                   '\U00002A25',
	"pluse;":                    '\U00002A72',
	"plusmn;":                   '\U000000B1',
	"plussim;":                  '\U00002A26',
	"plustwo;":                  '\U00002A27',
	"pm;":                       '\U000000B1',
	"pointint;":                 '\U00002A15',
	"popf;":                     '\U0001D561',
	"pound;":                    '\U000000A3',
	"pr;":                       '\U0000227A',
	"prE;":                      '\U00002AB3',
	"prap;":                     '\U00002AB7',
	"prcue;":                    '\U0000227C',
	"pre;":                      '\U00002AAF',
	"prec;":                     '\U0000227A',
	"precapprox;":               '\U00002AB7',
	"preccurlyeq;":              '\U0000227C',
	"preceq;":                   '\U00002AAF',
	"precnapprox;":              '\U00002AB9',
	"precneqq;":                 '\U00002AB5',
	"precnsim;":                 '\U000022E8',
	"precsim;":                  '\U0000227E',
	"prime;":                    '\U00002032',
	"primes;":                   '\U00002119',
	"prnE;":                     '\U00002AB5',
	"prnap;":                    '\U00002AB9',
	"prnsim;":                   '\U000022E8',
	"prod;":                     '\U0000220F',
	"profalar;":                 '\U0000232E',
	"profline;":                 '\U00002312',
	"profsurf;":                 '\U00002313',
	"prop;":                     '\U0000221D',
	"propto;":                   '\U0000221D',
	"prsim;":                    '\U0000227E',
	"prurel;":                   '\U000022B0',
	"pscr;":                     '\U0001D4C5',
	"psi;":                      '\U000003C8',
	"puncsp;":                   '\U00002008',
	"qfr;":                      '\U0001D52E',
	"qint;":                     '\U00002A0C',
	"qopf;":                     '\U0001D562',
	"qprime;":                   '\U00002057',
	"qscr;":                     '\U0001D4C6',
	"quaternions;":              '\U0000210D',
	"quatint;":                  '\U00002A16',
	"quest;":                    '\U0000003F',
	"questeq;":                  '\U0000225F',
	"quot;":                     '\U00000022',
	"rAarr;":                    '\U000021DB',
	"rArr;":                     '\U000021D2',
	"rAtail;":                   '\U0000291C',
	"rBarr;":                    '\U0000290F',
	"rHar;":                     '\U00002964',
	"racute;":                   '\U00000155',
	"radic;":                    '\U0000221A',
	"raemptyv;":                 '\U000029B3',
	"rang;":                     '\U000027E9',
	"rangd;":                    '\U00002992',
	"range;":                    '\U000029A5',
	"rangle;":                   '\U000027E9',
	"raquo;":                    '\U000000BB',
	"rarr;":                     '\U00002192',
	"rarrap;":                   '\U00002975',
	"rarrb;":                    '\U000021E5',
	"rarrbfs;":                  '\U00002920',
	"rarrc;":                    '\U00002933',
	"rarrfs;":                   '\U0000291E',
	"rarrhk;":                   '\U000021AA',
	"rarrlp;":                   '\U000021AC',
	"rarrpl;":                   '\U00002945',
	"rarrsim;":                  '\U00002974',
	"rarrtl;":                   '\U000021A3',
	"rarrw;":                    '\U0000219D',
	"ratail;":                   '\U0000291A',
	"ratio;":                    '\U00002236',
	"rationals;":                '\U0000211A',
	"rbarr;":                    '\U0000290D',
	"rbbrk;":                    '\U00002773',
	"rbrace;":                   '\U0000007D',
	"rbrack;":                   '\U0000005D',
	"rbrke;":                    '\U0000298C',
	"rbrksld;":                  '\U0000298E',
	"rbrkslu;":                  '\U00002990',
	"rcaron;":                   '\U00000159',
	"rcedil;":                   '\U00000157',
	"rceil;":                    '\U00002309',
	"rcub;":                     '\U0000007D',
	"rcy;":                      '\U00000440',
	"rdca;":                     '\U00002937',
	"rdldhar;":                  '\U00002969',
	"rdquo;":                    '\U0000201D',
	"rdquor;":                   '\U0000201D',
	"rdsh;":                     '\U000021B3',
	"real;":                     '\U0000211C',
	"realine;":                  '\U0000211B',
	"realpart;":                 '\U0000211C',
	"reals;":                    '\U0000211D',
	"rect;":                     '\U000025AD',
	"reg;":                      '\U000000AE',
	"rfisht;":                   '\U0000297D',
	"rfloor;":                   '\U0000230B',
	"rfr;":                      '\U0001D52F',
	"rhard;":                    '\U000021C1',
	"rharu;":                    '\U000021C0',
	"rharul;":                   '\U0000296C',
	"rho;":                      '\U000003C1',
	"rhov;":                     '\U000003F1',
	"rightarrow;":               '\U00002192',
	"rightarrowtail;":           '\U000021A3',
	"rightharpoondown;":         '\U000021C1',
	"rightharpoonup;":           '\U000021C0',
	"rightleftarrows;":          '\U000021C4',
	"rightleftharpoons;":        '\U000021CC',
	"rightrightarrows;":         '\U000021C9',
	"rightsquigarrow;":          '\U0000219D',
	"rightthreetimes;":          '\U000022CC',
	"ring;":                     '\U000002DA',
	"risingdotseq;":             '\U00002253',
	"rlarr;":                    '\U000021C4',
	"rlhar;":                    '\U000021CC',
	"rlm;":                      '\U0000200F',
	"rmoust;":                   '\U000023B1',
	"rmoustache;":               '\U000023B1',
	"rnmid;":                    '\U00002AEE',
	"roang;":                    '\U000027ED',
	"roarr;":                    '\U000021FE',
	"robrk;":                    '\U000027E7',
	"ropar;":                    '\U00002986',
	"ropf;":                     '\U0001D563',
	"roplus;":                   '\U00002A2E',
	"rotimes;":                  '\U00002A35',
	"rpar;":                     '\U00000029',
	"rpargt;":                   '\U00002994',
	"rppolint;":                 '\U00002A12',
	"rrarr;":                    '\U000021C9',
	"rsaquo;":                   '\U0000203A',
	"rscr;":                     '\U0001D4C7',
	"rsh;":                      '\U000021B1',
	"rsqb;":                     '\U0000005D',
	"rsquo;":                    '\U00002019',
	"rsquor;":                   '\U00002019',
	"rthree;":                   '\U000022CC',
	"rtimes;":                   '\U000022CA',
	"rtri;":                     '\U000025B9',
	"rtrie;":                    '\U000022B5',
	"rtrif;":                    '\U000025B8',
	"rtriltri;":                 '\U000029CE',
	"ruluhar;":                  '\U00002968',
	"rx;":                       '\U0000211E',
	"sacute;":                   '\U0000015B',
	"sbquo;":                    '\U0000201A',
	"sc;":                       '\U0000227B',
	"scE;":                      '\U00002AB4',
	"scap;":                     '\U00002AB8',
	"scaron;":                   '\U00000161',
	"sccue;":                    '\U0000227D',
	"sce;":                      '\U00002AB0',
	"scedil;":                   '\U0000015F',
	"scirc;":                    '\U0000015D',
	"scnE;":                     '\U00002AB6',
	"scnap;":                    '\U00002ABA',
	"scnsim;":                   '\U000022E9',
	"scpolint;":                 '\U00002A13',
	"scsim;":                    '\U0000227F',
	"scy;":                      '\U00000441',
	"sdot;":                     '\U000022C5',
	"sdotb;":                    '\U000022A1',
	"sdote;":                    '\U00002A66',
	"seArr;":                    '\U000021D8',
	"searhk;":                   '\U00002925',
	"searr;":                    '\U00002198',
	"searrow;":                  '\U00002198',
	"sect;":                     '\U000000A7',
	"semi;":                     '\U0000003B',
	"seswar;":                   '\U00002929',
	"setminus;":                 '\U00002216',
	"setmn;":                    '\U00002216',
	"sext;":                     '\U00002736',
	"sfr;":                      '\U0001D530',
	"sfrown;":                   '\U00002322',
	"sharp;":                    '\U0000266F',
	"shchcy;":                   '\U00000449',
	"shcy;":                     '\U00000448',
	"shortmid;":                 '\U00002223',
	"shortparallel;":            '\U00002225',
	"shy;":                      '\U000000AD',
	"sigma;":                    '\U000003C3',
	"sigmaf;":                   '\U000003C2',
	"sigmav;":                   '\U000003C2',
	"sim;":                      '\U0000223C',
	"simdot;":                   '\U00002A6A',
	"sime;":                     '\U00002243',
	"simeq;":                    '\U00002243',
	"simg;":                     '\U00002A9E',
	"simgE;":                    '\U00002AA0',
	"siml;":                     '\U00002A9D',
	"simlE;":                    '\U00002A9F',
	"simne;":                    '\U00002246',
	"simplus;":                  '\U00002A24',
	"simrarr;":                  '\U00002972',
	"slarr;":                    '\U00002190',
	"smallsetminus;":            '\U00002216',
	"smashp;":                   '\U00002A33',
	"smeparsl;":                 '\U000029E4',
	"smid;":                     '\U00002223',
	"smile;":                    '\U00002323',
	"smt;":                      '\U00002AAA',
	"smte;":                     '\U00002AAC',
	"softcy;":                   '\U0000044C',
	"sol;":                      '\U0000002F',
	"solb;":                     '\U000029C4',
	"solbar;":                   '\U0000233F',
	"sopf;":                     '\U0001D564',
	"spades;":                   '\U00002660',
	"spadesuit;":                '\U00002660',
	"spar;":                     '\U00002225',
	"sqcap;":                    '\U00002293',
	"sqcup;":                    '\U00002294',
	"sqsub;":                    '\U0000228F',
	"sqsube;":                   '\U00002291',
	"sqsubset;":                 '\U0000228F',
	"sqsubseteq;":               '\U00002291',
	"sqsup;":                    '\U00002290',
	"sqsupe;":                   '\U00002292',
	"sqsupset;":                 '\U00002290',
	"sqsupseteq;":               '\U00002292',
	"squ;":                      '\U000025A1',
	"square;":                   '\U000025A1',
	"squarf;":                   '\U000025AA',
	"squf;":                     '\U000025AA',
	"srarr;":                    '\U00002192',
	"sscr;":                     '\U0001D4C8',
	"ssetmn;":                   '\U00002216',
	"ssmile;":                   '\U00002323',
	"sstarf;":                   '\U000022C6',
	"star;":                     '\U00002606',
	"starf;":                    '\U00002605',
	"straightepsilon;":          '\U000003F5',
	"straightphi;":              '\U000003D5',
	"strns;":                    '\U000000AF',
	"sub;":                      '\U00002282',
	"subE;":                     '\U00002AC5',
	"subdot;":                   '\U00002ABD',
	"sube;":                     '\U00002286',
	"subedot;":                  '\U00002AC3',
	"submult;":                  '\U00002AC1',
	"subnE;":                    '\U00002ACB',
	"subne;":                    '\U0000228A',
	"subplus;":                  '\U00002ABF',
	"subrarr;":                  '\U00002979',
	"subset;":                   '\U00002282',
	"subseteq;":                 '\U00002286',
	"subseteqq;":                '\U00002AC5',
	"subsetneq;":                '\U0000228A',
	"subsetneqq;":               '\U00002ACB',
	"subsim;":                   '\U00002AC7',
	"subsub;":                   '\U00002AD5',
	"subsup;":                   '\U00002AD3',
	"succ;":                     '\U0000227B',
	"succapprox;":               '\U00002AB8',
	"succcurlyeq;":              '\U0000227D',
	"succeq;":                   '\U00002AB0',
	"succnapprox;":              '\U00002ABA',
	"succneqq;":                 '\U00002AB6',
	"succnsim;":                 '\U000022E9',
	"succsim;":                  '\U0000227F',
	"sum;":                      '\U00002211',
	"sung;":                     '\U0000266A',
	"sup;":                      '\U00002283',
	"sup1;":                     '\U000000B9',
	"sup2;":                     '\U000000B2',
	"sup3;":                     '\U000000B3',
	"supE;":                     '\U00002AC6',
	"supdot;":                   '\U00002ABE',
	"supdsub;":                  '\U00002AD8',
	"supe;":                     '\U00002287',
	"supedot;":                  '\U00002AC4',
	"suphsol;":                  '\U000027C9',
	"suphsub;":                  '\U00002AD7',
	"suplarr;":                  '\U0000297B',
	"supmult;":                  '\U00002AC2',
	"supnE;":                    '\U00002ACC',
	"supne;":                    '\U0000228B',
	"supplus;":                  '\U00002AC0',
	"supset;":                   '\U00002283',
	"supseteq;":                 '\U00002287',
	"supseteqq;":                '\U00002AC6',
	"supsetneq;":                '\U0000228B',
	"supsetneqq;":               '\U00002ACC',
	"supsim;":                   '\U00002AC8',
	"supsub;":                   '\U00002AD4',
	"supsup;":                   '\U00002AD6',
	"swArr;":                    '\U000021D9',
	"swarhk;":                   '\U00002926',
	"swarr;":                    '\U00002199',
	"swarrow;":                  '\U00002199',
	"swnwar;":                   '\U0000292A',
	"szlig;":                    '\U000000DF',
	"target;":                   '\U00002316',
	"tau;":                      '\U000003C4',
	"tbrk;":                     '\U000023B4',
	"tcaron;":                   '\U00000165',
	"tcedil;":                   '\U00000163',
	"tcy;":                      '\U00000442',
	"tdot;":                     '\U000020DB',
	"telrec;":                   '\U00002315',
	"tfr;":                      '\U0001D531',
	"there4;":                   '\U00002234',
	"therefore;":                '\U00002234',
	"theta;":                    '\U000003B8',
	"thetasym;":                 '\U000003D1',
	"thetav;":                   '\U000003D1',
	"thickapprox;":              '\U00002248',
	"thicksim;":                 '\U0000223C',
	"thinsp;":                   '\U00002009',
	"thkap;":                    '\U00002248',
	"thksim;":                   '\U0000223C',
	"thorn;":                    '\U000000FE',
	"tilde;":                    '\U000002DC',
	"times;":                    '\U000000D7',
	"timesb;":                   '\U000022A0',
	"timesbar;":                 '\U00002A31',
	"timesd;":                   '\U00002A30',
	"tint;":                     '\U0000222D',
	"toea;":                     '\U00002928',
	"top;":                      '\U000022A4',
	"topbot;":                   '\U00002336',
	"topcir;":                   '\U00002AF1',
	"topf;":                     '\U0001D565',
	"topfork;":                  '\U00002ADA',
	"tosa;":                     '\U00002929',
	"tprime;":                   '\U00002034',
	"trade;":                    '\U00002122',
	"triangle;":                 '\U000025B5',
	"triangledown;":             '\U000025BF',
	"triangleleft;":             '\U000025C3',
	"trianglelefteq;":           '\U000022B4',
	"triangleq;":                '\U0000225C',
	"triangleright;":            '\U000025B9',
	"trianglerighteq;":          '\U000022B5',
	"tridot;":                   '\U000025EC',
	"trie;":                     '\U0000225C',
	"triminus;":                 '\U00002A3A',
	"triplus;":                  '\U00002A39',
	"trisb;":                    '\U000029CD',
	"tritime;":                  '\U00002A3B',
	"trpezium;":                 '\U000023E2',
	"tscr;":                     '\U0001D4C9',
	"tscy;":                     '\U00000446',
	"tshcy;":                    '\U0000045B',
	"tstrok;":                   '\U00000167',
	"twixt;":                    '\U0000226C',
	"twoheadleftarrow;":         '\U0000219E',
	"twoheadrightarrow;":        '\U000021A0',
	"uArr;":                     '\U000021D1',
	"uHar;":                     '\U00002963',
	"uacute;":                   '\U000000FA',
	"uarr;":                     '\U00002191',
	"ubrcy;":                    '\U0000045E',
	"ubreve;":                   '\U0000016D',
	"ucirc;":                    '\U000000FB',
	"ucy;":                      '\U00000443',
	"udarr;":                    '\U000021C5',
	"udblac;":                   '\U00000171',
	"udhar;":                    '\U0000296E',
	"ufisht;":                   '\U0000297E',
	"ufr;":                      '\U0001D532',
	"ugrave;":                   '\U000000F9',
	"uharl;":                    '\U000021BF',
	"uharr;":                    '\U000021BE',
	"uhblk;":                    '\U00002580',
	"ulcorn;":                   '\U0000231C',
	"ulcorner;":                 '\U0000231C',
	"ulcrop;":                   '\U0000230F',
	"ultri;":                    '\U000025F8',
	"umacr;":                    '\U0000016B',
	"uml;":                      '\U000000A8',
	"uogon;":                    '\U00000173',
	"uopf;":                     '\U0001D566',
	"uparrow;":                  '\U00002191',
	"updownarrow;":              '\U00002195',
	"upharpoonleft;":            '\U000021BF',
	"upharpoonright;":           '\U000021BE',
	"uplus;":                    '\U0000228E',
	"upsi;":                     '\U000003C5',
	"upsih;":                    '\U000003D2',
	"upsilon;":                  '\U000003C5',
	"upuparrows;":               '\U000021C8',
	"urcorn;":                   '\U0000231D',
	"urcorner;":                 '\U0000231D',
	"urcrop;":                   '\U0000230E',
	"uring;":                    '\U0000016F',
	"urtri;":                    '\U000025F9',
	"uscr;":                     '\U0001D4CA',
	"utdot;":                    '\U000022F0',
	"utilde;":                   '\U00000169',
	"utri;":                     '\U000025B5',
	"utrif;":                    '\U000025B4',
	"uuarr;":                    '\U000021C8',
	"uuml;":                     '\U000000FC',
	"uwangle;":                  '\U000029A7',
	"vArr;":                     '\U000021D5',
	"vBar;":                     '\U00002AE8',
	"vBarv;":                    '\U00002AE9',
	"vDash;":                    '\U000022A8',
	"vangrt;":                   '\U0000299C',
	"varepsilon;":               '\U000003F5',
	"varkappa;":                 '\U000003F0',
	"varnothing;":               '\U00002205',
	"varphi;":                   '\U000003D5',
	"varpi;":                    '\U000003D6',
	"varpropto;":                '\U0000221D',
	"varr;":                     '\U00002195',
	"varrho;":                   '\U000003F1',
	"varsigma;":                 '\U000003C2',
	"vartheta;":                 '\U000003D1',
	"vartriangleleft;":          '\U000022B2',
	"vartriangleright;":         '\U000022B3',
	"vcy;":                      '\U00000432',
	"vdash;":                    '\U000022A2',
	"vee;":                      '\U00002228',
	"veebar;":                   '\U000022BB',
	"veeeq;":                    '\U0000225A',
	"vellip;":                   '\U000022EE',
	"verbar;":                   '\U0000007C',
	"vert;":                     '\U0000007C',
	"vfr;":                      '\U0001D533',
	"vltri;":                    '\U000022B2',
	"vopf;":                     '\U0001D567',
	"vprop;":                    '\U0000221D',
	"vrtri;":                    '\U000022B3',
	"vscr;":                     '\U0001D4CB',
	"vzigzag;":                  '\U0000299A',
	"wcirc;":                    '\U00000175',
	"wedbar;":                   '\U00002A5F',
	"wedge;":                    '\U00002227',
	"wedgeq;":                   '\U00002259',
	"weierp;":                   '\U00002118',
	"wfr;":                      '\U0001D534',
	"wopf;":                     '\U0001D568',
	"wp;":                       '\U00002118',
	"wr;":                       '\U00002240',
	"wreath;":                   '\U00002240',
	"wscr;":                     '\U0001D4CC',
	"xcap;":                     '\U000022C2',
	"xcirc;":                    '\U000025EF',
	"xcup;":                     '\U000022C3',
	"xdtri;":                    '\U000025BD',
	"xfr;":                      '\U0001D535',
	"xhArr;":                    '\U000027FA',
	"xharr;":                    '\U000027F7',
	"xi;":                       '\U000003BE',
	"xlArr;":                    '\U000027F8',
	"xlarr;":                    '\U000027F5',
	"xmap;":                     '\U000027FC',
	"xnis;":                     '\U000022FB',
	"xodot;":                    '\U00002A00',
	"xopf;":                     '\U0001D569',
	"xoplus;":                   '\U00002A01',
	"xotime;":                   '\U00002A02',
	"xrArr;":                    '\U000027F9',
	"xrarr;":                    '\U000027F6',
	"xscr;":                     '\U0001D4CD',
	"xsqcup;":                   '\U00002A06',
	"xuplus;":                   '\U00002A04',
	"xutri;":                    '\U000025B3',
	"xvee;":                     '\U000022C1',
	"xwedge;":                   '\U000022C0',
	"yacute;":                   '\U000000FD',
	"yacy;":                     '\U0000044F',
	"ycirc;":                    '\U00000177',
	"ycy;":                      '\U0000044B',
	"yen;":                      '\U000000A5',
	"yfr;":                      '\U0001D536',
	"yicy;":                     '\U00000457',
	"yopf;":                     '\U0001D56A',
	"yscr;":                     '\U0001D4CE',
	"yucy;":                     '\U0000044E',
	"yuml;":                     '\U000000FF',
	"zacute;":                   '\U0000017A',
	"zcaron;":                   '\U0000017E',
	"zcy;":                      '\U00000437',
	"zdot;":                     '\U0000017C',
	"zeetrf;":                   '\U00002128',
	"zeta;":                     '\U000003B6',
	"zfr;":                      '\U0001D537',
	"zhcy;":                     '\U00000436',
	"zigrarr;":                  '\U000021DD',
	"zopf;":                     '\U0001D56B',
	"zscr;":                     '\U0001D4CF',
	"zwj;":                      '\U0000200D',
	"zwnj;":                     '\U0000200C',
	"AElig":                     '\U000000C6',
	"AMP":                       '\U00000026',
	"Aacute":                    '\U000000C1',
	"Acirc":                     '\U000000C2',
	"Agrave":                    '\U000000C0',
	"Aring":                     '\U000000C5',
	"Atilde":                    '\U000000C3',
	"Auml":                      '\U000000C4',
	"COPY":                      '\U000000A9',
	"Ccedil":                    '\U000000C7',
	"ETH":                       '\U000000D0',
	"Eacute":                    '\U000000C9',
	"Ecirc":                     '\U000000CA',
	"Egrave":                    '\U000000C8',
	"Euml":                      '\U000000CB',
	"GT":                        '\U0000003E',
	"Iacute":                    '\U000000CD',
	"Icirc":                     '\U000000CE',
	"Igrave":                    '\U000000CC',
	"Iuml":                      '\U000000CF',
	"LT":                        '\U0000003C',
	"Ntilde":                    '\U000000D1',
	"Oacute":                    '\U000000D3',
	"Ocirc":                     '\U000000D4',
	"Ograve":                    '\U000000D2',
	"Oslash":                    '\U000000D8',
	"Otilde":                    '\U000000D5',
	"Ouml":                      '\U000000D6',
	"QUOT":                      '\U00000022',
	"REG":                       '\U000000AE',
	"THORN":                     '\U000000DE',
	"Uacute":                    '\U000000DA',
	"Ucirc":                     '\U000000DB',
	"Ugrave":                    '\U000000D9',
	"Uuml":                      '\U000000DC',
	"Yacute":                    '\U000000DD',
	"aacute":                    '\U000000E1',
	"acirc":                     '\U000000E2',
	"acute":                     '\U000000B4',
	"aelig":                     '\U000000E6',
	"agrave":                    '\U000000E0',
	"amp":                       '\U00000026',
	"aring":                     '\U000000E5',
	"atilde":                    '\U000000E3',
	"auml":                      '\U000000E4',
	"brvbar":                    '\U000000A6',
	"ccedil":                    '\U000000E7',
	"cedil":                     '\U000000B8',
	"cent":                      '\U000000A2',
	"copy":                      '\U000000A9',
	"curren":                    '\U000000A4',
	"deg":                       '\U000000B0',
	"divide":                    '\U000000F7',
	"eacute":                    '\U000000E9',
	"ecirc":                     '\U000000EA',
	"egrave":                    '\U000000E8',
	"eth":                       '\U000000F0',
	"euml":                      '\U000000EB',
	"frac12":                    '\U000000BD',
	"frac14":                    '\U000000BC',
	"frac34":                    '\U000000BE',
	"gt":                        '\U0000003E',
	"iacute":                    '\U000000ED',
	"icirc":                     '\U000000EE',
	"iexcl":                     '\U000000A1',
	"igrave":                    '\U000000EC',
	"iquest":                    '\U000000BF',
	"iuml":                      '\U000000EF',
	"laquo":                     '\U000000AB',
	"lt":                        '\U0000003C',
	"macr":                      '\U000000AF',
	"micro":                     '\U000000B5',
	"middot":                    '\U000000B7',
	"nbsp":                      '\U000000A0',
	"not":                       '\U000000AC',
	"ntilde":                    '\U000000F1',
	"oacute":                    '\U000000F3',
	"ocirc":                     '\U000000F4',
	"ograve":                    '\U000000F2',
	"ordf":                      '\U000000AA',
	"ordm":                      '\U000000BA',
	"oslash":                    '\U000000F8',
	"otilde":                    '\U000000F5',
	"ouml":                      '\U000000F6',
	"para":                      '\U000000B6',
	"plusmn":                    '\U000000B1',
	"pound":                     '\U000000A3',
	"quot":                      '\U00000022',
	"raquo":                     '\U000000BB',
	"reg":                       '\U000000AE',
	"sect":                      '\U000000A7',
	"shy":                       '\U000000AD',
	"sup1":                      '\U000000B9',
	"sup2":                      '\U000000B2',
	"sup3":                      '\U000000B3',
	"szlig":                     '\U000000DF',
	"thorn":                     '\U000000FE',
	"times":                     '\U000000D7',
	"uacute":                    '\U000000FA',
	"ucirc":                     '\U000000FB',
	"ugrave":                    '\U000000F9',
	"uml":                       '\U000000A8',
	"uuml":                      '\U000000FC',
	"yacute":                    '\U000000FD',
	"yen":                       '\U000000A5',
	"yuml":                      '\U000000FF',
}
var entity2 = map[string][2]rune{
	
	
	
	"NotEqualTilde;":           {'\u2242', '\u0338'},
	"NotGreaterFullEqual;":     {'\u2267', '\u0338'},
	"NotGreaterGreater;":       {'\u226B', '\u0338'},
	"NotGreaterSlantEqual;":    {'\u2A7E', '\u0338'},
	"NotHumpDownHump;":         {'\u224E', '\u0338'},
	"NotHumpEqual;":            {'\u224F', '\u0338'},
	"NotLeftTriangleBar;":      {'\u29CF', '\u0338'},
	"NotLessLess;":             {'\u226A', '\u0338'},
	"NotLessSlantEqual;":       {'\u2A7D', '\u0338'},
	"NotNestedGreaterGreater;": {'\u2AA2', '\u0338'},
	"NotNestedLessLess;":       {'\u2AA1', '\u0338'},
	"NotPrecedesEqual;":        {'\u2AAF', '\u0338'},
	"NotRightTriangleBar;":     {'\u29D0', '\u0338'},
	"NotSquareSubset;":         {'\u228F', '\u0338'},
	"NotSquareSuperset;":       {'\u2290', '\u0338'},
	"NotSubset;":               {'\u2282', '\u20D2'},
	"NotSucceedsEqual;":        {'\u2AB0', '\u0338'},
	"NotSucceedsTilde;":        {'\u227F', '\u0338'},
	"NotSuperset;":             {'\u2283', '\u20D2'},
	"ThickSpace;":              {'\u205F', '\u200A'},
	"acE;":                     {'\u223E', '\u0333'},
	"bne;":                     {'\u003D', '\u20E5'},
	"bnequiv;":                 {'\u2261', '\u20E5'},
	"caps;":                    {'\u2229', '\uFE00'},
	"cups;":                    {'\u222A', '\uFE00'},
	"fjlig;":                   {'\u0066', '\u006A'},
	"gesl;":                    {'\u22DB', '\uFE00'},
	"gvertneqq;":               {'\u2269', '\uFE00'},
	"gvnE;":                    {'\u2269', '\uFE00'},
	"lates;":                   {'\u2AAD', '\uFE00'},
	"lesg;":                    {'\u22DA', '\uFE00'},
	"lvertneqq;":               {'\u2268', '\uFE00'},
	"lvnE;":                    {'\u2268', '\uFE00'},
	"nGg;":                     {'\u22D9', '\u0338'},
	"nGtv;":                    {'\u226B', '\u0338'},
	"nLl;":                     {'\u22D8', '\u0338'},
	"nLtv;":                    {'\u226A', '\u0338'},
	"nang;":                    {'\u2220', '\u20D2'},
	"napE;":                    {'\u2A70', '\u0338'},
	"napid;":                   {'\u224B', '\u0338'},
	"nbump;":                   {'\u224E', '\u0338'},
	"nbumpe;":                  {'\u224F', '\u0338'},
	"ncongdot;":                {'\u2A6D', '\u0338'},
	"nedot;":                   {'\u2250', '\u0338'},
	"nesim;":                   {'\u2242', '\u0338'},
	"ngE;":                     {'\u2267', '\u0338'},
	"ngeqq;":                   {'\u2267', '\u0338'},
	"ngeqslant;":               {'\u2A7E', '\u0338'},
	"nges;":                    {'\u2A7E', '\u0338'},
	"nlE;":                     {'\u2266', '\u0338'},
	"nleqq;":                   {'\u2266', '\u0338'},
	"nleqslant;":               {'\u2A7D', '\u0338'},
	"nles;":                    {'\u2A7D', '\u0338'},
	"notinE;":                  {'\u22F9', '\u0338'},
	"notindot;":                {'\u22F5', '\u0338'},
	"nparsl;":                  {'\u2AFD', '\u20E5'},
	"npart;":                   {'\u2202', '\u0338'},
	"npre;":                    {'\u2AAF', '\u0338'},
	"npreceq;":                 {'\u2AAF', '\u0338'},
	"nrarrc;":                  {'\u2933', '\u0338'},
	"nrarrw;":                  {'\u219D', '\u0338'},
	"nsce;":                    {'\u2AB0', '\u0338'},
	"nsubE;":                   {'\u2AC5', '\u0338'},
	"nsubset;":                 {'\u2282', '\u20D2'},
	"nsubseteqq;":              {'\u2AC5', '\u0338'},
	"nsucceq;":                 {'\u2AB0', '\u0338'},
	"nsupE;":                   {'\u2AC6', '\u0338'},
	"nsupset;":                 {'\u2283', '\u20D2'},
	"nsupseteqq;":              {'\u2AC6', '\u0338'},
	"nvap;":                    {'\u224D', '\u20D2'},
	"nvge;":                    {'\u2265', '\u20D2'},
	"nvgt;":                    {'\u003E', '\u20D2'},
	"nvle;":                    {'\u2264', '\u20D2'},
	"nvlt;":                    {'\u003C', '\u20D2'},
	"nvltrie;":                 {'\u22B4', '\u20D2'},
	"nvrtrie;":                 {'\u22B5', '\u20D2'},
	"nvsim;":                   {'\u223C', '\u20D2'},
	"race;":                    {'\u223D', '\u0331'},
	"smtes;":                   {'\u2AAC', '\uFE00'},
	"sqcaps;":                  {'\u2293', '\uFE00'},
	"sqcups;":                  {'\u2294', '\uFE00'},
	"varsubsetneq;":            {'\u228A', '\uFE00'},
	"varsubsetneqq;":           {'\u2ACB', '\uFE00'},
	"varsupsetneq;":            {'\u228B', '\uFE00'},
	"varsupsetneqq;":           {'\u2ACC', '\uFE00'},
	"vnsub;":                   {'\u2282', '\u20D2'},
	"vnsup;":                   {'\u2283', '\u20D2'},
	"vsubnE;":                  {'\u2ACB', '\uFE00'},
	"vsubne;":                  {'\u228A', '\uFE00'},
	"vsupnE;":                  {'\u2ACC', '\uFE00'},
	"vsupne;":                  {'\u228B', '\uFE00'},
}
package html
import (
	"errors"
	"fmt"
	"io"
	"strings"
	a "golang.org
)
type parser struct {
	
	tokenizer *Tokenizer
	
	tok Token
	
	
	hasSelfClosingToken bool
	
	doc *Node
	
	
	oe, afe nodeStack
	
	head, form *Node
	
	scripting, framesetOK bool
	
	im insertionMode
	
	
	originalIM insertionMode
	
	
	fosterParenting bool
	
	quirks bool
	
	fragment bool
	
	
	context *Node
}
func (p *parser) top() *Node {
	if n := p.oe.top(); n != nil {
		return n
	}
	return p.doc
}
var (
	defaultScopeStopTags = map[string][]a.Atom{
		"":     {a.Applet, a.Caption, a.Html, a.Table, a.Td, a.Th, a.Marquee, a.Object, a.Template},
		"math": {a.AnnotationXml, a.Mi, a.Mn, a.Mo, a.Ms, a.Mtext},
		"svg":  {a.Desc, a.ForeignObject, a.Title},
	}
)
type scope int
const (
	defaultScope scope = iota
	listItemScope
	buttonScope
	tableScope
	tableRowScope
	tableBodyScope
	selectScope
)
func (p *parser) popUntil(s scope, matchTags ...a.Atom) bool {
	if i := p.indexOfElementInScope(s, matchTags...); i != -1 {
		p.oe = p.oe[:i]
		return true
	}
	return false
}
func (p *parser) indexOfElementInScope(s scope, matchTags ...a.Atom) int {
	for i := len(p.oe) - 1; i >= 0; i-- {
		tagAtom := p.oe[i].DataAtom
		if p.oe[i].Namespace == "" {
			for _, t := range matchTags {
				if t == tagAtom {
					return i
				}
			}
			switch s {
			case defaultScope:
				
			case listItemScope:
				if tagAtom == a.Ol || tagAtom == a.Ul {
					return -1
				}
			case buttonScope:
				if tagAtom == a.Button {
					return -1
				}
			case tableScope:
				if tagAtom == a.Html || tagAtom == a.Table {
					return -1
				}
			case selectScope:
				if tagAtom != a.Optgroup && tagAtom != a.Option {
					return -1
				}
			default:
				panic("unreachable")
			}
		}
		switch s {
		case defaultScope, listItemScope, buttonScope:
			for _, t := range defaultScopeStopTags[p.oe[i].Namespace] {
				if t == tagAtom {
					return -1
				}
			}
		}
	}
	return -1
}
func (p *parser) elementInScope(s scope, matchTags ...a.Atom) bool {
	return p.indexOfElementInScope(s, matchTags...) != -1
}
func (p *parser) clearStackToContext(s scope) {
	for i := len(p.oe) - 1; i >= 0; i-- {
		tagAtom := p.oe[i].DataAtom
		switch s {
		case tableScope:
			if tagAtom == a.Html || tagAtom == a.Table {
				p.oe = p.oe[:i+1]
				return
			}
		case tableRowScope:
			if tagAtom == a.Html || tagAtom == a.Tr {
				p.oe = p.oe[:i+1]
				return
			}
		case tableBodyScope:
			if tagAtom == a.Html || tagAtom == a.Tbody || tagAtom == a.Tfoot || tagAtom == a.Thead {
				p.oe = p.oe[:i+1]
				return
			}
		default:
			panic("unreachable")
		}
	}
}
func (p *parser) generateImpliedEndTags(exceptions ...string) {
	var i int
loop:
	for i = len(p.oe) - 1; i >= 0; i-- {
		n := p.oe[i]
		if n.Type == ElementNode {
			switch n.DataAtom {
			case a.Dd, a.Dt, a.Li, a.Option, a.Optgroup, a.P, a.Rp, a.Rt:
				for _, except := range exceptions {
					if n.Data == except {
						break loop
					}
				}
				continue
			}
		}
		break
	}
	p.oe = p.oe[:i+1]
}
func (p *parser) addChild(n *Node) {
	if p.shouldFosterParent() {
		p.fosterParent(n)
	} else {
		p.top().AppendChild(n)
	}
	if n.Type == ElementNode {
		p.oe = append(p.oe, n)
	}
}
func (p *parser) shouldFosterParent() bool {
	if p.fosterParenting {
		switch p.top().DataAtom {
		case a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr:
			return true
		}
	}
	return false
}
func (p *parser) fosterParent(n *Node) {
	var table, parent, prev *Node
	var i int
	for i = len(p.oe) - 1; i >= 0; i-- {
		if p.oe[i].DataAtom == a.Table {
			table = p.oe[i]
			break
		}
	}
	if table == nil {
		
		parent = p.oe[0]
	} else {
		parent = table.Parent
	}
	if parent == nil {
		parent = p.oe[i-1]
	}
	if table != nil {
		prev = table.PrevSibling
	} else {
		prev = parent.LastChild
	}
	if prev != nil && prev.Type == TextNode && n.Type == TextNode {
		prev.Data += n.Data
		return
	}
	parent.InsertBefore(n, table)
}
func (p *parser) addText(text string) {
	if text == "" {
		return
	}
	if p.shouldFosterParent() {
		p.fosterParent(&Node{
			Type: TextNode,
			Data: text,
		})
		return
	}
	t := p.top()
	if n := t.LastChild; n != nil && n.Type == TextNode {
		n.Data += text
		return
	}
	p.addChild(&Node{
		Type: TextNode,
		Data: text,
	})
}
func (p *parser) addElement() {
	p.addChild(&Node{
		Type:     ElementNode,
		DataAtom: p.tok.DataAtom,
		Data:     p.tok.Data,
		Attr:     p.tok.Attr,
	})
}
func (p *parser) addFormattingElement() {
	tagAtom, attr := p.tok.DataAtom, p.tok.Attr
	p.addElement()
	
	identicalElements := 0
findIdenticalElements:
	for i := len(p.afe) - 1; i >= 0; i-- {
		n := p.afe[i]
		if n.Type == scopeMarkerNode {
			break
		}
		if n.Type != ElementNode {
			continue
		}
		if n.Namespace != "" {
			continue
		}
		if n.DataAtom != tagAtom {
			continue
		}
		if len(n.Attr) != len(attr) {
			continue
		}
	compareAttributes:
		for _, t0 := range n.Attr {
			for _, t1 := range attr {
				if t0.Key == t1.Key && t0.Namespace == t1.Namespace && t0.Val == t1.Val {
					
					continue compareAttributes
				}
			}
			
			
			continue findIdenticalElements
		}
		identicalElements++
		if identicalElements >= 3 {
			p.afe.remove(n)
		}
	}
	p.afe = append(p.afe, p.top())
}
func (p *parser) clearActiveFormattingElements() {
	for {
		n := p.afe.pop()
		if len(p.afe) == 0 || n.Type == scopeMarkerNode {
			return
		}
	}
}
func (p *parser) reconstructActiveFormattingElements() {
	n := p.afe.top()
	if n == nil {
		return
	}
	if n.Type == scopeMarkerNode || p.oe.index(n) != -1 {
		return
	}
	i := len(p.afe) - 1
	for n.Type != scopeMarkerNode && p.oe.index(n) == -1 {
		if i == 0 {
			i = -1
			break
		}
		i--
		n = p.afe[i]
	}
	for {
		i++
		clone := p.afe[i].clone()
		p.addChild(clone)
		p.afe[i] = clone
		if i == len(p.afe)-1 {
			break
		}
	}
}
func (p *parser) acknowledgeSelfClosingTag() {
	p.hasSelfClosingToken = false
}
type insertionMode func(*parser) bool
func (p *parser) setOriginalIM() {
	if p.originalIM != nil {
		panic("html: bad parser state: originalIM was set twice")
	}
	p.originalIM = p.im
}
func (p *parser) resetInsertionMode() {
	for i := len(p.oe) - 1; i >= 0; i-- {
		n := p.oe[i]
		if i == 0 && p.context != nil {
			n = p.context
		}
		switch n.DataAtom {
		case a.Select:
			p.im = inSelectIM
		case a.Td, a.Th:
			p.im = inCellIM
		case a.Tr:
			p.im = inRowIM
		case a.Tbody, a.Thead, a.Tfoot:
			p.im = inTableBodyIM
		case a.Caption:
			p.im = inCaptionIM
		case a.Colgroup:
			p.im = inColumnGroupIM
		case a.Table:
			p.im = inTableIM
		case a.Head:
			p.im = inBodyIM
		case a.Body:
			p.im = inBodyIM
		case a.Frameset:
			p.im = inFramesetIM
		case a.Html:
			p.im = beforeHeadIM
		default:
			continue
		}
		return
	}
	p.im = inBodyIM
}
const whitespace = " \t\r\n\f"
func initialIM(p *parser) bool {
	switch p.tok.Type {
	case TextToken:
		p.tok.Data = strings.TrimLeft(p.tok.Data, whitespace)
		if len(p.tok.Data) == 0 {
			
			return true
		}
	case CommentToken:
		p.doc.AppendChild(&Node{
			Type: CommentNode,
			Data: p.tok.Data,
		})
		return true
	case DoctypeToken:
		n, quirks := parseDoctype(p.tok.Data)
		p.doc.AppendChild(n)
		p.quirks = quirks
		p.im = beforeHTMLIM
		return true
	}
	p.quirks = true
	p.im = beforeHTMLIM
	return false
}
func beforeHTMLIM(p *parser) bool {
	switch p.tok.Type {
	case DoctypeToken:
		
		return true
	case TextToken:
		p.tok.Data = strings.TrimLeft(p.tok.Data, whitespace)
		if len(p.tok.Data) == 0 {
			
			return true
		}
	case StartTagToken:
		if p.tok.DataAtom == a.Html {
			p.addElement()
			p.im = beforeHeadIM
			return true
		}
	case EndTagToken:
		switch p.tok.DataAtom {
		case a.Head, a.Body, a.Html, a.Br:
			p.parseImpliedToken(StartTagToken, a.Html, a.Html.String())
			return false
		default:
			
			return true
		}
	case CommentToken:
		p.doc.AppendChild(&Node{
			Type: CommentNode,
			Data: p.tok.Data,
		})
		return true
	}
	p.parseImpliedToken(StartTagToken, a.Html, a.Html.String())
	return false
}
func beforeHeadIM(p *parser) bool {
	switch p.tok.Type {
	case TextToken:
		p.tok.Data = strings.TrimLeft(p.tok.Data, whitespace)
		if len(p.tok.Data) == 0 {
			
			return true
		}
	case StartTagToken:
		switch p.tok.DataAtom {
		case a.Head:
			p.addElement()
			p.head = p.top()
			p.im = inHeadIM
			return true
		case a.Html:
			return inBodyIM(p)
		}
	case EndTagToken:
		switch p.tok.DataAtom {
		case a.Head, a.Body, a.Html, a.Br:
			p.parseImpliedToken(StartTagToken, a.Head, a.Head.String())
			return false
		default:
			
			return true
		}
	case CommentToken:
		p.addChild(&Node{
			Type: CommentNode,
			Data: p.tok.Data,
		})
		return true
	case DoctypeToken:
		
		return true
	}
	p.parseImpliedToken(StartTagToken, a.Head, a.Head.String())
	return false
}
func inHeadIM(p *parser) bool {
	switch p.tok.Type {
	case TextToken:
		s := strings.TrimLeft(p.tok.Data, whitespace)
		if len(s) < len(p.tok.Data) {
			
			p.addText(p.tok.Data[:len(p.tok.Data)-len(s)])
			if s == "" {
				return true
			}
			p.tok.Data = s
		}
	case StartTagToken:
		switch p.tok.DataAtom {
		case a.Html:
			return inBodyIM(p)
		case a.Base, a.Basefont, a.Bgsound, a.Command, a.Link, a.Meta:
			p.addElement()
			p.oe.pop()
			p.acknowledgeSelfClosingTag()
			return true
		case a.Script, a.Title, a.Noscript, a.Noframes, a.Style:
			p.addElement()
			p.setOriginalIM()
			p.im = textIM
			return true
		case a.Head:
			
			return true
		}
	case EndTagToken:
		switch p.tok.DataAtom {
		case a.Head:
			n := p.oe.pop()
			if n.DataAtom != a.Head {
				panic("html: bad parser state: <head> element not found, in the in-head insertion mode")
			}
			p.im = afterHeadIM
			return true
		case a.Body, a.Html, a.Br:
			p.parseImpliedToken(EndTagToken, a.Head, a.Head.String())
			return false
		default:
			
			return true
		}
	case CommentToken:
		p.addChild(&Node{
			Type: CommentNode,
			Data: p.tok.Data,
		})
		return true
	case DoctypeToken:
		
		return true
	}
	p.parseImpliedToken(EndTagToken, a.Head, a.Head.String())
	return false
}
func afterHeadIM(p *parser) bool {
	switch p.tok.Type {
	case TextToken:
		s := strings.TrimLeft(p.tok.Data, whitespace)
		if len(s) < len(p.tok.Data) {
			
			p.addText(p.tok.Data[:len(p.tok.Data)-len(s)])
			if s == "" {
				return true
			}
			p.tok.Data = s
		}
	case StartTagToken:
		switch p.tok.DataAtom {
		case a.Html:
			return inBodyIM(p)
		case a.Body:
			p.addElement()
			p.framesetOK = false
			p.im = inBodyIM
			return true
		case a.Frameset:
			p.addElement()
			p.im = inFramesetIM
			return true
		case a.Base, a.Basefont, a.Bgsound, a.Link, a.Meta, a.Noframes, a.Script, a.Style, a.Title:
			p.oe = append(p.oe, p.head)
			defer p.oe.remove(p.head)
			return inHeadIM(p)
		case a.Head:
			
			return true
		}
	case EndTagToken:
		switch p.tok.DataAtom {
		case a.Body, a.Html, a.Br:
			
		default:
			
			return true
		}
	case CommentToken:
		p.addChild(&Node{
			Type: CommentNode,
			Data: p.tok.Data,
		})
		return true
	case DoctypeToken:
		
		return true
	}
	p.parseImpliedToken(StartTagToken, a.Body, a.Body.String())
	p.framesetOK = true
	return false
}
func copyAttributes(dst *Node, src Token) {
	if len(src.Attr) == 0 {
		return
	}
	attr := map[string]string{}
	for _, t := range dst.Attr {
		attr[t.Key] = t.Val
	}
	for _, t := range src.Attr {
		if _, ok := attr[t.Key]; !ok {
			dst.Attr = append(dst.Attr, t)
			attr[t.Key] = t.Val
		}
	}
}
func inBodyIM(p *parser) bool {
	switch p.tok.Type {
	case TextToken:
		d := p.tok.Data
		switch n := p.oe.top(); n.DataAtom {
		case a.Pre, a.Listing:
			if n.FirstChild == nil {
				
				if d != "" && d[0] == '\r' {
					d = d[1:]
				}
				if d != "" && d[0] == '\n' {
					d = d[1:]
				}
			}
		}
		d = strings.Replace(d, "\x00", "", -1)
		if d == "" {
			return true
		}
		p.reconstructActiveFormattingElements()
		p.addText(d)
		if p.framesetOK && strings.TrimLeft(d, whitespace) != "" {
			
			p.framesetOK = false
		}
	case StartTagToken:
		switch p.tok.DataAtom {
		case a.Html:
			copyAttributes(p.oe[0], p.tok)
		case a.Base, a.Basefont, a.Bgsound, a.Command, a.Link, a.Meta, a.Noframes, a.Script, a.Style, a.Title:
			return inHeadIM(p)
		case a.Body:
			if len(p.oe) >= 2 {
				body := p.oe[1]
				if body.Type == ElementNode && body.DataAtom == a.Body {
					p.framesetOK = false
					copyAttributes(body, p.tok)
				}
			}
		case a.Frameset:
			if !p.framesetOK || len(p.oe) < 2 || p.oe[1].DataAtom != a.Body {
				
				return true
			}
			body := p.oe[1]
			if body.Parent != nil {
				body.Parent.RemoveChild(body)
			}
			p.oe = p.oe[:1]
			p.addElement()
			p.im = inFramesetIM
			return true
		case a.Address, a.Article, a.Aside, a.Blockquote, a.Center, a.Details, a.Dir, a.Div, a.Dl, a.Fieldset, a.Figcaption, a.Figure, a.Footer, a.Header, a.Hgroup, a.Menu, a.Nav, a.Ol, a.P, a.Section, a.Summary, a.Ul:
			p.popUntil(buttonScope, a.P)
			p.addElement()
		case a.H1, a.H2, a.H3, a.H4, a.H5, a.H6:
			p.popUntil(buttonScope, a.P)
			switch n := p.top(); n.DataAtom {
			case a.H1, a.H2, a.H3, a.H4, a.H5, a.H6:
				p.oe.pop()
			}
			p.addElement()
		case a.Pre, a.Listing:
			p.popUntil(buttonScope, a.P)
			p.addElement()
			
			p.framesetOK = false
		case a.Form:
			if p.form == nil {
				p.popUntil(buttonScope, a.P)
				p.addElement()
				p.form = p.top()
			}
		case a.Li:
			p.framesetOK = false
			for i := len(p.oe) - 1; i >= 0; i-- {
				node := p.oe[i]
				switch node.DataAtom {
				case a.Li:
					p.oe = p.oe[:i]
				case a.Address, a.Div, a.P:
					continue
				default:
					if !isSpecialElement(node) {
						continue
					}
				}
				break
			}
			p.popUntil(buttonScope, a.P)
			p.addElement()
		case a.Dd, a.Dt:
			p.framesetOK = false
			for i := len(p.oe) - 1; i >= 0; i-- {
				node := p.oe[i]
				switch node.DataAtom {
				case a.Dd, a.Dt:
					p.oe = p.oe[:i]
				case a.Address, a.Div, a.P:
					continue
				default:
					if !isSpecialElement(node) {
						continue
					}
				}
				break
			}
			p.popUntil(buttonScope, a.P)
			p.addElement()
		case a.Plaintext:
			p.popUntil(buttonScope, a.P)
			p.addElement()
		case a.Button:
			p.popUntil(defaultScope, a.Button)
			p.reconstructActiveFormattingElements()
			p.addElement()
			p.framesetOK = false
		case a.A:
			for i := len(p.afe) - 1; i >= 0 && p.afe[i].Type != scopeMarkerNode; i-- {
				if n := p.afe[i]; n.Type == ElementNode && n.DataAtom == a.A {
					p.inBodyEndTagFormatting(a.A)
					p.oe.remove(n)
					p.afe.remove(n)
					break
				}
			}
			p.reconstructActiveFormattingElements()
			p.addFormattingElement()
		case a.B, a.Big, a.Code, a.Em, a.Font, a.I, a.S, a.Small, a.Strike, a.Strong, a.Tt, a.U:
			p.reconstructActiveFormattingElements()
			p.addFormattingElement()
		case a.Nobr:
			p.reconstructActiveFormattingElements()
			if p.elementInScope(defaultScope, a.Nobr) {
				p.inBodyEndTagFormatting(a.Nobr)
				p.reconstructActiveFormattingElements()
			}
			p.addFormattingElement()
		case a.Applet, a.Marquee, a.Object:
			p.reconstructActiveFormattingElements()
			p.addElement()
			p.afe = append(p.afe, &scopeMarker)
			p.framesetOK = false
		case a.Table:
			if !p.quirks {
				p.popUntil(buttonScope, a.P)
			}
			p.addElement()
			p.framesetOK = false
			p.im = inTableIM
			return true
		case a.Area, a.Br, a.Embed, a.Img, a.Input, a.Keygen, a.Wbr:
			p.reconstructActiveFormattingElements()
			p.addElement()
			p.oe.pop()
			p.acknowledgeSelfClosingTag()
			if p.tok.DataAtom == a.Input {
				for _, t := range p.tok.Attr {
					if t.Key == "type" {
						if strings.ToLower(t.Val) == "hidden" {
							
							return true
						}
					}
				}
			}
			p.framesetOK = false
		case a.Param, a.Source, a.Track:
			p.addElement()
			p.oe.pop()
			p.acknowledgeSelfClosingTag()
		case a.Hr:
			p.popUntil(buttonScope, a.P)
			p.addElement()
			p.oe.pop()
			p.acknowledgeSelfClosingTag()
			p.framesetOK = false
		case a.Image:
			p.tok.DataAtom = a.Img
			p.tok.Data = a.Img.String()
			return false
		case a.Isindex:
			if p.form != nil {
				
				return true
			}
			action := ""
			prompt := "This is a searchable index. Enter search keywords: "
			attr := []Attribute{{Key: "name", Val: "isindex"}}
			for _, t := range p.tok.Attr {
				switch t.Key {
				case "action":
					action = t.Val
				case "name":
					
				case "prompt":
					prompt = t.Val
				default:
					attr = append(attr, t)
				}
			}
			p.acknowledgeSelfClosingTag()
			p.popUntil(buttonScope, a.P)
			p.parseImpliedToken(StartTagToken, a.Form, a.Form.String())
			if action != "" {
				p.form.Attr = []Attribute{{Key: "action", Val: action}}
			}
			p.parseImpliedToken(StartTagToken, a.Hr, a.Hr.String())
			p.parseImpliedToken(StartTagToken, a.Label, a.Label.String())
			p.addText(prompt)
			p.addChild(&Node{
				Type:     ElementNode,
				DataAtom: a.Input,
				Data:     a.Input.String(),
				Attr:     attr,
			})
			p.oe.pop()
			p.parseImpliedToken(EndTagToken, a.Label, a.Label.String())
			p.parseImpliedToken(StartTagToken, a.Hr, a.Hr.String())
			p.parseImpliedToken(EndTagToken, a.Form, a.Form.String())
		case a.Textarea:
			p.addElement()
			p.setOriginalIM()
			p.framesetOK = false
			p.im = textIM
		case a.Xmp:
			p.popUntil(buttonScope, a.P)
			p.reconstructActiveFormattingElements()
			p.framesetOK = false
			p.addElement()
			p.setOriginalIM()
			p.im = textIM
		case a.Iframe:
			p.framesetOK = false
			p.addElement()
			p.setOriginalIM()
			p.im = textIM
		case a.Noembed, a.Noscript:
			p.addElement()
			p.setOriginalIM()
			p.im = textIM
		case a.Select:
			p.reconstructActiveFormattingElements()
			p.addElement()
			p.framesetOK = false
			p.im = inSelectIM
			return true
		case a.Optgroup, a.Option:
			if p.top().DataAtom == a.Option {
				p.oe.pop()
			}
			p.reconstructActiveFormattingElements()
			p.addElement()
		case a.Rp, a.Rt:
			if p.elementInScope(defaultScope, a.Ruby) {
				p.generateImpliedEndTags()
			}
			p.addElement()
		case a.Math, a.Svg:
			p.reconstructActiveFormattingElements()
			if p.tok.DataAtom == a.Math {
				adjustAttributeNames(p.tok.Attr, mathMLAttributeAdjustments)
			} else {
				adjustAttributeNames(p.tok.Attr, svgAttributeAdjustments)
			}
			adjustForeignAttributes(p.tok.Attr)
			p.addElement()
			p.top().Namespace = p.tok.Data
			if p.hasSelfClosingToken {
				p.oe.pop()
				p.acknowledgeSelfClosingTag()
			}
			return true
		case a.Caption, a.Col, a.Colgroup, a.Frame, a.Head, a.Tbody, a.Td, a.Tfoot, a.Th, a.Thead, a.Tr:
			
		default:
			p.reconstructActiveFormattingElements()
			p.addElement()
		}
	case EndTagToken:
		switch p.tok.DataAtom {
		case a.Body:
			if p.elementInScope(defaultScope, a.Body) {
				p.im = afterBodyIM
			}
		case a.Html:
			if p.elementInScope(defaultScope, a.Body) {
				p.parseImpliedToken(EndTagToken, a.Body, a.Body.String())
				return false
			}
			return true
		case a.Address, a.Article, a.Aside, a.Blockquote, a.Button, a.Center, a.Details, a.Dir, a.Div, a.Dl, a.Fieldset, a.Figcaption, a.Figure, a.Footer, a.Header, a.Hgroup, a.Listing, a.Menu, a.Nav, a.Ol, a.Pre, a.Section, a.Summary, a.Ul:
			p.popUntil(defaultScope, p.tok.DataAtom)
		case a.Form:
			node := p.form
			p.form = nil
			i := p.indexOfElementInScope(defaultScope, a.Form)
			if node == nil || i == -1 || p.oe[i] != node {
				
				return true
			}
			p.generateImpliedEndTags()
			p.oe.remove(node)
		case a.P:
			if !p.elementInScope(buttonScope, a.P) {
				p.parseImpliedToken(StartTagToken, a.P, a.P.String())
			}
			p.popUntil(buttonScope, a.P)
		case a.Li:
			p.popUntil(listItemScope, a.Li)
		case a.Dd, a.Dt:
			p.popUntil(defaultScope, p.tok.DataAtom)
		case a.H1, a.H2, a.H3, a.H4, a.H5, a.H6:
			p.popUntil(defaultScope, a.H1, a.H2, a.H3, a.H4, a.H5, a.H6)
		case a.A, a.B, a.Big, a.Code, a.Em, a.Font, a.I, a.Nobr, a.S, a.Small, a.Strike, a.Strong, a.Tt, a.U:
			p.inBodyEndTagFormatting(p.tok.DataAtom)
		case a.Applet, a.Marquee, a.Object:
			if p.popUntil(defaultScope, p.tok.DataAtom) {
				p.clearActiveFormattingElements()
			}
		case a.Br:
			p.tok.Type = StartTagToken
			return false
		default:
			p.inBodyEndTagOther(p.tok.DataAtom)
		}
	case CommentToken:
		p.addChild(&Node{
			Type: CommentNode,
			Data: p.tok.Data,
		})
	}
	return true
}
func (p *parser) inBodyEndTagFormatting(tagAtom a.Atom) {
	
	
	
	
	
	
	for i := 0; i < 8; i++ {
		
		var formattingElement *Node
		for j := len(p.afe) - 1; j >= 0; j-- {
			if p.afe[j].Type == scopeMarkerNode {
				break
			}
			if p.afe[j].DataAtom == tagAtom {
				formattingElement = p.afe[j]
				break
			}
		}
		if formattingElement == nil {
			p.inBodyEndTagOther(tagAtom)
			return
		}
		feIndex := p.oe.index(formattingElement)
		if feIndex == -1 {
			p.afe.remove(formattingElement)
			return
		}
		if !p.elementInScope(defaultScope, tagAtom) {
			
			return
		}
		
		var furthestBlock *Node
		for _, e := range p.oe[feIndex:] {
			if isSpecialElement(e) {
				furthestBlock = e
				break
			}
		}
		if furthestBlock == nil {
			e := p.oe.pop()
			for e != formattingElement {
				e = p.oe.pop()
			}
			p.afe.remove(e)
			return
		}
		
		commonAncestor := p.oe[feIndex-1]
		bookmark := p.afe.index(formattingElement)
		
		lastNode := furthestBlock
		node := furthestBlock
		x := p.oe.index(node)
		
		for j := 0; j < 3; j++ {
			
			x--
			node = p.oe[x]
			
			if p.afe.index(node) == -1 {
				p.oe.remove(node)
				continue
			}
			
			if node == formattingElement {
				break
			}
			
			clone := node.clone()
			p.afe[p.afe.index(node)] = clone
			p.oe[p.oe.index(node)] = clone
			node = clone
			
			if lastNode == furthestBlock {
				bookmark = p.afe.index(node) + 1
			}
			
			if lastNode.Parent != nil {
				lastNode.Parent.RemoveChild(lastNode)
			}
			node.AppendChild(lastNode)
			
			lastNode = node
		}
		
		
		if lastNode.Parent != nil {
			lastNode.Parent.RemoveChild(lastNode)
		}
		switch commonAncestor.DataAtom {
		case a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr:
			p.fosterParent(lastNode)
		default:
			commonAncestor.AppendChild(lastNode)
		}
		
		
		clone := formattingElement.clone()
		reparentChildren(clone, furthestBlock)
		furthestBlock.AppendChild(clone)
		
		if oldLoc := p.afe.index(formattingElement); oldLoc != -1 && oldLoc < bookmark {
			
			bookmark--
		}
		p.afe.remove(formattingElement)
		p.afe.insert(bookmark, clone)
		
		p.oe.remove(formattingElement)
		p.oe.insert(p.oe.index(furthestBlock)+1, clone)
	}
}
func (p *parser) inBodyEndTagOther(tagAtom a.Atom) {
	for i := len(p.oe) - 1; i >= 0; i-- {
		if p.oe[i].DataAtom == tagAtom {
			p.oe = p.oe[:i]
			break
		}
		if isSpecialElement(p.oe[i]) {
			break
		}
	}
}
func textIM(p *parser) bool {
	switch p.tok.Type {
	case ErrorToken:
		p.oe.pop()
	case TextToken:
		d := p.tok.Data
		if n := p.oe.top(); n.DataAtom == a.Textarea && n.FirstChild == nil {
			
			if d != "" && d[0] == '\r' {
				d = d[1:]
			}
			if d != "" && d[0] == '\n' {
				d = d[1:]
			}
		}
		if d == "" {
			return true
		}
		p.addText(d)
		return true
	case EndTagToken:
		p.oe.pop()
	}
	p.im = p.originalIM
	p.originalIM = nil
	return p.tok.Type == EndTagToken
}
func inTableIM(p *parser) bool {
	switch p.tok.Type {
	case ErrorToken:
		
		return true
	case TextToken:
		p.tok.Data = strings.Replace(p.tok.Data, "\x00", "", -1)
		switch p.oe.top().DataAtom {
		case a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr:
			if strings.Trim(p.tok.Data, whitespace) == "" {
				p.addText(p.tok.Data)
				return true
			}
		}
	case StartTagToken:
		switch p.tok.DataAtom {
		case a.Caption:
			p.clearStackToContext(tableScope)
			p.afe = append(p.afe, &scopeMarker)
			p.addElement()
			p.im = inCaptionIM
			return true
		case a.Colgroup:
			p.clearStackToContext(tableScope)
			p.addElement()
			p.im = inColumnGroupIM
			return true
		case a.Col:
			p.parseImpliedToken(StartTagToken, a.Colgroup, a.Colgroup.String())
			return false
		case a.Tbody, a.Tfoot, a.Thead:
			p.clearStackToContext(tableScope)
			p.addElement()
			p.im = inTableBodyIM
			return true
		case a.Td, a.Th, a.Tr:
			p.parseImpliedToken(StartTagToken, a.Tbody, a.Tbody.String())
			return false
		case a.Table:
			if p.popUntil(tableScope, a.Table) {
				p.resetInsertionMode()
				return false
			}
			
			return true
		case a.Style, a.Script:
			return inHeadIM(p)
		case a.Input:
			for _, t := range p.tok.Attr {
				if t.Key == "type" && strings.ToLower(t.Val) == "hidden" {
					p.addElement()
					p.oe.pop()
					return true
				}
			}
			
		case a.Form:
			if p.form != nil {
				
				return true
			}
			p.addElement()
			p.form = p.oe.pop()
		case a.Select:
			p.reconstructActiveFormattingElements()
			switch p.top().DataAtom {
			case a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr:
				p.fosterParenting = true
			}
			p.addElement()
			p.fosterParenting = false
			p.framesetOK = false
			p.im = inSelectInTableIM
			return true
		}
	case EndTagToken:
		switch p.tok.DataAtom {
		case a.Table:
			if p.popUntil(tableScope, a.Table) {
				p.resetInsertionMode()
				return true
			}
			
			return true
		case a.Body, a.Caption, a.Col, a.Colgroup, a.Html, a.Tbody, a.Td, a.Tfoot, a.Th, a.Thead, a.Tr:
			
			return true
		}
	case CommentToken:
		p.addChild(&Node{
			Type: CommentNode,
			Data: p.tok.Data,
		})
		return true
	case DoctypeToken:
		
		return true
	}
	p.fosterParenting = true
	defer func() { p.fosterParenting = false }()
	return inBodyIM(p)
}
func inCaptionIM(p *parser) bool {
	switch p.tok.Type {
	case StartTagToken:
		switch p.tok.DataAtom {
		case a.Caption, a.Col, a.Colgroup, a.Tbody, a.Td, a.Tfoot, a.Thead, a.Tr:
			if p.popUntil(tableScope, a.Caption) {
				p.clearActiveFormattingElements()
				p.im = inTableIM
				return false
			} else {
				
				return true
			}
		case a.Select:
			p.reconstructActiveFormattingElements()
			p.addElement()
			p.framesetOK = false
			p.im = inSelectInTableIM
			return true
		}
	case EndTagToken:
		switch p.tok.DataAtom {
		case a.Caption:
			if p.popUntil(tableScope, a.Caption) {
				p.clearActiveFormattingElements()
				p.im = inTableIM
			}
			return true
		case a.Table:
			if p.popUntil(tableScope, a.Caption) {
				p.clearActiveFormattingElements()
				p.im = inTableIM
				return false
			} else {
				
				return true
			}
		case a.Body, a.Col, a.Colgroup, a.Html, a.Tbody, a.Td, a.Tfoot, a.Th, a.Thead, a.Tr:
			
			return true
		}
	}
	return inBodyIM(p)
}
func inColumnGroupIM(p *parser) bool {
	switch p.tok.Type {
	case TextToken:
		s := strings.TrimLeft(p.tok.Data, whitespace)
		if len(s) < len(p.tok.Data) {
			
			p.addText(p.tok.Data[:len(p.tok.Data)-len(s)])
			if s == "" {
				return true
			}
			p.tok.Data = s
		}
	case CommentToken:
		p.addChild(&Node{
			Type: CommentNode,
			Data: p.tok.Data,
		})
		return true
	case DoctypeToken:
		
		return true
	case StartTagToken:
		switch p.tok.DataAtom {
		case a.Html:
			return inBodyIM(p)
		case a.Col:
			p.addElement()
			p.oe.pop()
			p.acknowledgeSelfClosingTag()
			return true
		}
	case EndTagToken:
		switch p.tok.DataAtom {
		case a.Colgroup:
			if p.oe.top().DataAtom != a.Html {
				p.oe.pop()
				p.im = inTableIM
			}
			return true
		case a.Col:
			
			return true
		}
	}
	if p.oe.top().DataAtom != a.Html {
		p.oe.pop()
		p.im = inTableIM
		return false
	}
	return true
}
func inTableBodyIM(p *parser) bool {
	switch p.tok.Type {
	case StartTagToken:
		switch p.tok.DataAtom {
		case a.Tr:
			p.clearStackToContext(tableBodyScope)
			p.addElement()
			p.im = inRowIM
			return true
		case a.Td, a.Th:
			p.parseImpliedToken(StartTagToken, a.Tr, a.Tr.String())
			return false
		case a.Caption, a.Col, a.Colgroup, a.Tbody, a.Tfoot, a.Thead:
			if p.popUntil(tableScope, a.Tbody, a.Thead, a.Tfoot) {
				p.im = inTableIM
				return false
			}
			
			return true
		}
	case EndTagToken:
		switch p.tok.DataAtom {
		case a.Tbody, a.Tfoot, a.Thead:
			if p.elementInScope(tableScope, p.tok.DataAtom) {
				p.clearStackToContext(tableBodyScope)
				p.oe.pop()
				p.im = inTableIM
			}
			return true
		case a.Table:
			if p.popUntil(tableScope, a.Tbody, a.Thead, a.Tfoot) {
				p.im = inTableIM
				return false
			}
			
			return true
		case a.Body, a.Caption, a.Col, a.Colgroup, a.Html, a.Td, a.Th, a.Tr:
			
			return true
		}
	case CommentToken:
		p.addChild(&Node{
			Type: CommentNode,
			Data: p.tok.Data,
		})
		return true
	}
	return inTableIM(p)
}
func inRowIM(p *parser) bool {
	switch p.tok.Type {
	case StartTagToken:
		switch p.tok.DataAtom {
		case a.Td, a.Th:
			p.clearStackToContext(tableRowScope)
			p.addElement()
			p.afe = append(p.afe, &scopeMarker)
			p.im = inCellIM
			return true
		case a.Caption, a.Col, a.Colgroup, a.Tbody, a.Tfoot, a.Thead, a.Tr:
			if p.popUntil(tableScope, a.Tr) {
				p.im = inTableBodyIM
				return false
			}
			
			return true
		}
	case EndTagToken:
		switch p.tok.DataAtom {
		case a.Tr:
			if p.popUntil(tableScope, a.Tr) {
				p.im = inTableBodyIM
				return true
			}
			
			return true
		case a.Table:
			if p.popUntil(tableScope, a.Tr) {
				p.im = inTableBodyIM
				return false
			}
			
			return true
		case a.Tbody, a.Tfoot, a.Thead:
			if p.elementInScope(tableScope, p.tok.DataAtom) {
				p.parseImpliedToken(EndTagToken, a.Tr, a.Tr.String())
				return false
			}
			
			return true
		case a.Body, a.Caption, a.Col, a.Colgroup, a.Html, a.Td, a.Th:
			
			return true
		}
	}
	return inTableIM(p)
}
func inCellIM(p *parser) bool {
	switch p.tok.Type {
	case StartTagToken:
		switch p.tok.DataAtom {
		case a.Caption, a.Col, a.Colgroup, a.Tbody, a.Td, a.Tfoot, a.Th, a.Thead, a.Tr:
			if p.popUntil(tableScope, a.Td, a.Th) {
				
				p.clearActiveFormattingElements()
				p.im = inRowIM
				return false
			}
			
			return true
		case a.Select:
			p.reconstructActiveFormattingElements()
			p.addElement()
			p.framesetOK = false
			p.im = inSelectInTableIM
			return true
		}
	case EndTagToken:
		switch p.tok.DataAtom {
		case a.Td, a.Th:
			if !p.popUntil(tableScope, p.tok.DataAtom) {
				
				return true
			}
			p.clearActiveFormattingElements()
			p.im = inRowIM
			return true
		case a.Body, a.Caption, a.Col, a.Colgroup, a.Html:
			
			return true
		case a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr:
			if !p.elementInScope(tableScope, p.tok.DataAtom) {
				
				return true
			}
			
			p.popUntil(tableScope, a.Td, a.Th)
			p.clearActiveFormattingElements()
			p.im = inRowIM
			return false
		}
	}
	return inBodyIM(p)
}
func inSelectIM(p *parser) bool {
	switch p.tok.Type {
	case ErrorToken:
		
		return true
	case TextToken:
		p.addText(strings.Replace(p.tok.Data, "\x00", "", -1))
	case StartTagToken:
		switch p.tok.DataAtom {
		case a.Html:
			return inBodyIM(p)
		case a.Option:
			if p.top().DataAtom == a.Option {
				p.oe.pop()
			}
			p.addElement()
		case a.Optgroup:
			if p.top().DataAtom == a.Option {
				p.oe.pop()
			}
			if p.top().DataAtom == a.Optgroup {
				p.oe.pop()
			}
			p.addElement()
		case a.Select:
			p.tok.Type = EndTagToken
			return false
		case a.Input, a.Keygen, a.Textarea:
			if p.elementInScope(selectScope, a.Select) {
				p.parseImpliedToken(EndTagToken, a.Select, a.Select.String())
				return false
			}
			
			p.tokenizer.NextIsNotRawText()
			
			return true
		case a.Script:
			return inHeadIM(p)
		}
	case EndTagToken:
		switch p.tok.DataAtom {
		case a.Option:
			if p.top().DataAtom == a.Option {
				p.oe.pop()
			}
		case a.Optgroup:
			i := len(p.oe) - 1
			if p.oe[i].DataAtom == a.Option {
				i--
			}
			if p.oe[i].DataAtom == a.Optgroup {
				p.oe = p.oe[:i]
			}
		case a.Select:
			if p.popUntil(selectScope, a.Select) {
				p.resetInsertionMode()
			}
		}
	case CommentToken:
		p.addChild(&Node{
			Type: CommentNode,
			Data: p.tok.Data,
		})
	case DoctypeToken:
		
		return true
	}
	return true
}
func inSelectInTableIM(p *parser) bool {
	switch p.tok.Type {
	case StartTagToken, EndTagToken:
		switch p.tok.DataAtom {
		case a.Caption, a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr, a.Td, a.Th:
			if p.tok.Type == StartTagToken || p.elementInScope(tableScope, p.tok.DataAtom) {
				p.parseImpliedToken(EndTagToken, a.Select, a.Select.String())
				return false
			} else {
				
				return true
			}
		}
	}
	return inSelectIM(p)
}
func afterBodyIM(p *parser) bool {
	switch p.tok.Type {
	case ErrorToken:
		
		return true
	case TextToken:
		s := strings.TrimLeft(p.tok.Data, whitespace)
		if len(s) == 0 {
			
			return inBodyIM(p)
		}
	case StartTagToken:
		if p.tok.DataAtom == a.Html {
			return inBodyIM(p)
		}
	case EndTagToken:
		if p.tok.DataAtom == a.Html {
			if !p.fragment {
				p.im = afterAfterBodyIM
			}
			return true
		}
	case CommentToken:
		
		if len(p.oe) < 1 || p.oe[0].DataAtom != a.Html {
			panic("html: bad parser state: <html> element not found, in the after-body insertion mode")
		}
		p.oe[0].AppendChild(&Node{
			Type: CommentNode,
			Data: p.tok.Data,
		})
		return true
	}
	p.im = inBodyIM
	return false
}
func inFramesetIM(p *parser) bool {
	switch p.tok.Type {
	case CommentToken:
		p.addChild(&Node{
			Type: CommentNode,
			Data: p.tok.Data,
		})
	case TextToken:
		
		s := strings.Map(func(c rune) rune {
			switch c {
			case ' ', '\t', '\n', '\f', '\r':
				return c
			}
			return -1
		}, p.tok.Data)
		if s != "" {
			p.addText(s)
		}
	case StartTagToken:
		switch p.tok.DataAtom {
		case a.Html:
			return inBodyIM(p)
		case a.Frameset:
			p.addElement()
		case a.Frame:
			p.addElement()
			p.oe.pop()
			p.acknowledgeSelfClosingTag()
		case a.Noframes:
			return inHeadIM(p)
		}
	case EndTagToken:
		switch p.tok.DataAtom {
		case a.Frameset:
			if p.oe.top().DataAtom != a.Html {
				p.oe.pop()
				if p.oe.top().DataAtom != a.Frameset {
					p.im = afterFramesetIM
					return true
				}
			}
		}
	default:
		
	}
	return true
}
func afterFramesetIM(p *parser) bool {
	switch p.tok.Type {
	case CommentToken:
		p.addChild(&Node{
			Type: CommentNode,
			Data: p.tok.Data,
		})
	case TextToken:
		
		s := strings.Map(func(c rune) rune {
			switch c {
			case ' ', '\t', '\n', '\f', '\r':
				return c
			}
			return -1
		}, p.tok.Data)
		if s != "" {
			p.addText(s)
		}
	case StartTagToken:
		switch p.tok.DataAtom {
		case a.Html:
			return inBodyIM(p)
		case a.Noframes:
			return inHeadIM(p)
		}
	case EndTagToken:
		switch p.tok.DataAtom {
		case a.Html:
			p.im = afterAfterFramesetIM
			return true
		}
	default:
		
	}
	return true
}
func afterAfterBodyIM(p *parser) bool {
	switch p.tok.Type {
	case ErrorToken:
		
		return true
	case TextToken:
		s := strings.TrimLeft(p.tok.Data, whitespace)
		if len(s) == 0 {
			
			return inBodyIM(p)
		}
	case StartTagToken:
		if p.tok.DataAtom == a.Html {
			return inBodyIM(p)
		}
	case CommentToken:
		p.doc.AppendChild(&Node{
			Type: CommentNode,
			Data: p.tok.Data,
		})
		return true
	case DoctypeToken:
		return inBodyIM(p)
	}
	p.im = inBodyIM
	return false
}
func afterAfterFramesetIM(p *parser) bool {
	switch p.tok.Type {
	case CommentToken:
		p.doc.AppendChild(&Node{
			Type: CommentNode,
			Data: p.tok.Data,
		})
	case TextToken:
		
		s := strings.Map(func(c rune) rune {
			switch c {
			case ' ', '\t', '\n', '\f', '\r':
				return c
			}
			return -1
		}, p.tok.Data)
		if s != "" {
			p.tok.Data = s
			return inBodyIM(p)
		}
	case StartTagToken:
		switch p.tok.DataAtom {
		case a.Html:
			return inBodyIM(p)
		case a.Noframes:
			return inHeadIM(p)
		}
	case DoctypeToken:
		return inBodyIM(p)
	default:
		
	}
	return true
}
const whitespaceOrNUL = whitespace + "\x00"
func parseForeignContent(p *parser) bool {
	switch p.tok.Type {
	case TextToken:
		if p.framesetOK {
			p.framesetOK = strings.TrimLeft(p.tok.Data, whitespaceOrNUL) == ""
		}
		p.tok.Data = strings.Replace(p.tok.Data, "\x00", "\ufffd", -1)
		p.addText(p.tok.Data)
	case CommentToken:
		p.addChild(&Node{
			Type: CommentNode,
			Data: p.tok.Data,
		})
	case StartTagToken:
		b := breakout[p.tok.Data]
		if p.tok.DataAtom == a.Font {
		loop:
			for _, attr := range p.tok.Attr {
				switch attr.Key {
				case "color", "face", "size":
					b = true
					break loop
				}
			}
		}
		if b {
			for i := len(p.oe) - 1; i >= 0; i-- {
				n := p.oe[i]
				if n.Namespace == "" || htmlIntegrationPoint(n) || mathMLTextIntegrationPoint(n) {
					p.oe = p.oe[:i+1]
					break
				}
			}
			return false
		}
		switch p.top().Namespace {
		case "math":
			adjustAttributeNames(p.tok.Attr, mathMLAttributeAdjustments)
		case "svg":
			
			
			if x := svgTagNameAdjustments[p.tok.Data]; x != "" {
				p.tok.DataAtom = a.Lookup([]byte(x))
				p.tok.Data = x
			}
			adjustAttributeNames(p.tok.Attr, svgAttributeAdjustments)
		default:
			panic("html: bad parser state: unexpected namespace")
		}
		adjustForeignAttributes(p.tok.Attr)
		namespace := p.top().Namespace
		p.addElement()
		p.top().Namespace = namespace
		if namespace != "" {
			
			
			p.tokenizer.NextIsNotRawText()
		}
		if p.hasSelfClosingToken {
			p.oe.pop()
			p.acknowledgeSelfClosingTag()
		}
	case EndTagToken:
		for i := len(p.oe) - 1; i >= 0; i-- {
			if p.oe[i].Namespace == "" {
				return p.im(p)
			}
			if strings.EqualFold(p.oe[i].Data, p.tok.Data) {
				p.oe = p.oe[:i]
				break
			}
		}
		return true
	default:
		
	}
	return true
}
func (p *parser) inForeignContent() bool {
	if len(p.oe) == 0 {
		return false
	}
	n := p.oe[len(p.oe)-1]
	if n.Namespace == "" {
		return false
	}
	if mathMLTextIntegrationPoint(n) {
		if p.tok.Type == StartTagToken && p.tok.DataAtom != a.Mglyph && p.tok.DataAtom != a.Malignmark {
			return false
		}
		if p.tok.Type == TextToken {
			return false
		}
	}
	if n.Namespace == "math" && n.DataAtom == a.AnnotationXml && p.tok.Type == StartTagToken && p.tok.DataAtom == a.Svg {
		return false
	}
	if htmlIntegrationPoint(n) && (p.tok.Type == StartTagToken || p.tok.Type == TextToken) {
		return false
	}
	if p.tok.Type == ErrorToken {
		return false
	}
	return true
}
func (p *parser) parseImpliedToken(t TokenType, dataAtom a.Atom, data string) {
	realToken, selfClosing := p.tok, p.hasSelfClosingToken
	p.tok = Token{
		Type:     t,
		DataAtom: dataAtom,
		Data:     data,
	}
	p.hasSelfClosingToken = false
	p.parseCurrentToken()
	p.tok, p.hasSelfClosingToken = realToken, selfClosing
}
func (p *parser) parseCurrentToken() {
	if p.tok.Type == SelfClosingTagToken {
		p.hasSelfClosingToken = true
		p.tok.Type = StartTagToken
	}
	consumed := false
	for !consumed {
		if p.inForeignContent() {
			consumed = parseForeignContent(p)
		} else {
			consumed = p.im(p)
		}
	}
	if p.hasSelfClosingToken {
		
		p.hasSelfClosingToken = false
	}
}
func (p *parser) parse() error {
	
	var err error
	for err != io.EOF {
		
		n := p.oe.top()
		p.tokenizer.AllowCDATA(n != nil && n.Namespace != "")
		
		p.tokenizer.Next()
		p.tok = p.tokenizer.Token()
		if p.tok.Type == ErrorToken {
			err = p.tokenizer.Err()
			if err != nil && err != io.EOF {
				return err
			}
		}
		p.parseCurrentToken()
	}
	return nil
}
func Parse(r io.Reader) (*Node, error) {
	p := &parser{
		tokenizer: NewTokenizer(r),
		doc: &Node{
			Type: DocumentNode,
		},
		scripting:  true,
		framesetOK: true,
		im:         initialIM,
	}
	err := p.parse()
	if err != nil {
		return nil, err
	}
	return p.doc, nil
}
func ParseFragment(r io.Reader, context *Node) ([]*Node, error) {
	contextTag := ""
	if context != nil {
		if context.Type != ElementNode {
			return nil, errors.New("html: ParseFragment of non-element Node")
		}
		
		
		
		if context.DataAtom != a.Lookup([]byte(context.Data)) {
			return nil, fmt.Errorf("html: inconsistent Node: DataAtom=%q, Data=%q", context.DataAtom, context.Data)
		}
		contextTag = context.DataAtom.String()
	}
	p := &parser{
		tokenizer: NewTokenizerFragment(r, contextTag),
		doc: &Node{
			Type: DocumentNode,
		},
		scripting: true,
		fragment:  true,
		context:   context,
	}
	root := &Node{
		Type:     ElementNode,
		DataAtom: a.Html,
		Data:     a.Html.String(),
	}
	p.doc.AppendChild(root)
	p.oe = nodeStack{root}
	p.resetInsertionMode()
	for n := context; n != nil; n = n.Parent {
		if n.Type == ElementNode && n.DataAtom == a.Form {
			p.form = n
			break
		}
	}
	err := p.parse()
	if err != nil {
		return nil, err
	}
	parent := p.doc
	if context != nil {
		parent = root
	}
	var result []*Node
	for c := parent.FirstChild; c != nil; {
		next := c.NextSibling
		parent.RemoveChild(c)
		result = append(result, c)
		c = next
	}
	return result, nil
}
package html_test
import (
	"fmt"
	"log"
	"strings"
	"golang.org
)
func ExampleParse() {
	s := `<p>Links:<
	doc, err := html.Parse(strings.NewReader(s))
	if err != nil {
		log.Fatal(err)
	}
	var f func(*html.Node)
	f = func(n *html.Node) {
		if n.Type == html.ElementNode && n.Data == "a" {
			for _, a := range n.Attr {
				if a.Key == "href" {
					fmt.Println(a.Val)
					break
				}
			}
		}
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			f(c)
		}
	}
	f(doc)
	
	
	
}
package atom 
type Atom uint32
func (a Atom) String() string {
	start := uint32(a >> 8)
	n := uint32(a & 0xff)
	if start+n > uint32(len(atomText)) {
		return ""
	}
	return atomText[start : start+n]
}
func (a Atom) string() string {
	return atomText[a>>8 : a>>8+a&0xff]
}
func fnv(h uint32, s []byte) uint32 {
	for i := range s {
		h ^= uint32(s[i])
		h *= 16777619
	}
	return h
}
func match(s string, t []byte) bool {
	for i, c := range t {
		if s[i] != c {
			return false
		}
	}
	return true
}
func Lookup(s []byte) Atom {
	if len(s) == 0 || len(s) > maxAtomLen {
		return 0
	}
	h := fnv(hash0, s)
	if a := table[h&uint32(len(table)-1)]; int(a&0xff) == len(s) && match(a.string(), s) {
		return a
	}
	if a := table[(h>>16)&uint32(len(table)-1)]; int(a&0xff) == len(s) && match(a.string(), s) {
		return a
	}
	return 0
}
func String(s []byte) string {
	if a := Lookup(s); a != 0 {
		return a.String()
	}
	return string(s)
}
package main
import (
	"flag"
	"fmt"
	"math
	"os"
	"sort"
	"strings"
)
func identifier(s string) string {
	b := make([]byte, 0, len(s))
	cap := true
	for _, c := range s {
		if c == '-' {
			cap = true
			continue
		}
		if cap && 'a' <= c && c <= 'z' {
			c -= 'a' - 'A'
		}
		cap = false
		b = append(b, byte(c))
	}
	return string(b)
}
var test = flag.Bool("test", false, "generate table_test.go")
func main() {
	flag.Parse()
	var all []string
	all = append(all, elements...)
	all = append(all, attributes...)
	all = append(all, eventHandlers...)
	all = append(all, extra...)
	sort.Strings(all)
	if *test {
		fmt.Printf("
		fmt.Printf("package atom\n\n")
		fmt.Printf("var testAtomList = []string{\n")
		for _, s := range all {
			fmt.Printf("\t%q,\n", s)
		}
		fmt.Printf("}\n")
		return
	}
	
	
	maxLen := 0
	w := 0
	for _, s := range all {
		if w == 0 || all[w-1] != s {
			if maxLen < len(s) {
				maxLen = len(s)
			}
			all[w] = s
			w++
		}
	}
	all = all[:w]
	
	var best *table
	for i := 0; i < 1000000; i++ {
		if best != nil && 1<<(best.k-1) < len(all) {
			break
		}
		h := rand.Uint32()
		for k := uint(0); k <= 16; k++ {
			if best != nil && k >= best.k {
				break
			}
			var t table
			if t.init(h, k, all) {
				best = &t
				break
			}
		}
	}
	if best == nil {
		fmt.Fprintf(os.Stderr, "failed to construct string table\n")
		os.Exit(1)
	}
	
	layout := append([]string{}, all...)
	
	for changed := true; changed; {
		changed = false
		for i, s := range layout {
			if s == "" {
				continue
			}
			for j, t := range layout {
				if i != j && t != "" && strings.Contains(s, t) {
					changed = true
					layout[j] = ""
				}
			}
		}
	}
	
	for {
		
		
		besti := -1
		bestj := -1
		bestk := 0
		for i, s := range layout {
			if s == "" {
				continue
			}
			for j, t := range layout {
				if i == j {
					continue
				}
				for k := bestk + 1; k <= len(s) && k <= len(t); k++ {
					if s[len(s)-k:] == t[:k] {
						besti = i
						bestj = j
						bestk = k
					}
				}
			}
		}
		if bestk > 0 {
			layout[besti] += layout[bestj][bestk:]
			layout[bestj] = ""
			continue
		}
		break
	}
	text := strings.Join(layout, "")
	atom := map[string]uint32{}
	for _, s := range all {
		off := strings.Index(text, s)
		if off < 0 {
			panic("lost string " + s)
		}
		atom[s] = uint32(off<<8 | len(s))
	}
	
	fmt.Printf("
	fmt.Printf("package atom\n\nconst (\n")
	for _, s := range all {
		fmt.Printf("\t%s Atom = %#x\n", identifier(s), atom[s])
	}
	fmt.Printf(")\n\n")
	fmt.Printf("const hash0 = %#x\n\n", best.h0)
	fmt.Printf("const maxAtomLen = %d\n\n", maxLen)
	fmt.Printf("var table = [1<<%d]Atom{\n", best.k)
	for i, s := range best.tab {
		if s == "" {
			continue
		}
		fmt.Printf("\t%#x: %#x, 
	}
	fmt.Printf("}\n")
	datasize := (1 << best.k) * 4
	fmt.Printf("const atomText =\n")
	textsize := len(text)
	for len(text) > 60 {
		fmt.Printf("\t%q +\n", text[:60])
		text = text[60:]
	}
	fmt.Printf("\t%q\n\n", text)
	fmt.Fprintf(os.Stderr, "%d atoms; %d string bytes + %d tables = %d total data\n", len(all), textsize, datasize, textsize+datasize)
}
type byLen []string
func (x byLen) Less(i, j int) bool { return len(x[i]) > len(x[j]) }
func (x byLen) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }
func (x byLen) Len() int           { return len(x) }
func fnv(h uint32, s string) uint32 {
	for i := 0; i < len(s); i++ {
		h ^= uint32(s[i])
		h *= 16777619
	}
	return h
}
type table struct {
	h0   uint32
	k    uint
	mask uint32
	tab  []string
}
func (t *table) hash(s string) (h1, h2 uint32) {
	h := fnv(t.h0, s)
	h1 = h & t.mask
	h2 = (h >> 16) & t.mask
	return
}
func (t *table) init(h0 uint32, k uint, x []string) bool {
	t.h0 = h0
	t.k = k
	t.tab = make([]string, 1<<k)
	t.mask = 1<<k - 1
	for _, s := range x {
		if !t.insert(s) {
			return false
		}
	}
	return true
}
func (t *table) insert(s string) bool {
	h1, h2 := t.hash(s)
	if t.tab[h1] == "" {
		t.tab[h1] = s
		return true
	}
	if t.tab[h2] == "" {
		t.tab[h2] = s
		return true
	}
	if t.push(h1, 0) {
		t.tab[h1] = s
		return true
	}
	if t.push(h2, 0) {
		t.tab[h2] = s
		return true
	}
	return false
}
func (t *table) push(i uint32, depth int) bool {
	if depth > len(t.tab) {
		return false
	}
	s := t.tab[i]
	h1, h2 := t.hash(s)
	j := h1 + h2 - i
	if t.tab[j] != "" && !t.push(j, depth+1) {
		return false
	}
	t.tab[j] = s
	return true
}
var elements = []string{
	"a",
	"abbr",
	"address",
	"area",
	"article",
	"aside",
	"audio",
	"b",
	"base",
	"bdi",
	"bdo",
	"blockquote",
	"body",
	"br",
	"button",
	"canvas",
	"caption",
	"cite",
	"code",
	"col",
	"colgroup",
	"command",
	"data",
	"datalist",
	"dd",
	"del",
	"details",
	"dfn",
	"dialog",
	"div",
	"dl",
	"dt",
	"em",
	"embed",
	"fieldset",
	"figcaption",
	"figure",
	"footer",
	"form",
	"h1",
	"h2",
	"h3",
	"h4",
	"h5",
	"h6",
	"head",
	"header",
	"hgroup",
	"hr",
	"html",
	"i",
	"iframe",
	"img",
	"input",
	"ins",
	"kbd",
	"keygen",
	"label",
	"legend",
	"li",
	"link",
	"map",
	"mark",
	"menu",
	"menuitem",
	"meta",
	"meter",
	"nav",
	"noscript",
	"object",
	"ol",
	"optgroup",
	"option",
	"output",
	"p",
	"param",
	"pre",
	"progress",
	"q",
	"rp",
	"rt",
	"ruby",
	"s",
	"samp",
	"script",
	"section",
	"select",
	"small",
	"source",
	"span",
	"strong",
	"style",
	"sub",
	"summary",
	"sup",
	"table",
	"tbody",
	"td",
	"template",
	"textarea",
	"tfoot",
	"th",
	"thead",
	"time",
	"title",
	"tr",
	"track",
	"u",
	"ul",
	"var",
	"video",
	"wbr",
}
var attributes = []string{
	"abbr",
	"accept",
	"accept-charset",
	"accesskey",
	"action",
	"alt",
	"async",
	"autocomplete",
	"autofocus",
	"autoplay",
	"challenge",
	"charset",
	"checked",
	"cite",
	"class",
	"cols",
	"colspan",
	"command",
	"content",
	"contenteditable",
	"contextmenu",
	"controls",
	"coords",
	"crossorigin",
	"data",
	"datetime",
	"default",
	"defer",
	"dir",
	"dirname",
	"disabled",
	"download",
	"draggable",
	"dropzone",
	"enctype",
	"for",
	"form",
	"formaction",
	"formenctype",
	"formmethod",
	"formnovalidate",
	"formtarget",
	"headers",
	"height",
	"hidden",
	"high",
	"href",
	"hreflang",
	"http-equiv",
	"icon",
	"id",
	"inputmode",
	"ismap",
	"itemid",
	"itemprop",
	"itemref",
	"itemscope",
	"itemtype",
	"keytype",
	"kind",
	"label",
	"lang",
	"list",
	"loop",
	"low",
	"manifest",
	"max",
	"maxlength",
	"media",
	"mediagroup",
	"method",
	"min",
	"minlength",
	"multiple",
	"muted",
	"name",
	"novalidate",
	"open",
	"optimum",
	"pattern",
	"ping",
	"placeholder",
	"poster",
	"preload",
	"radiogroup",
	"readonly",
	"rel",
	"required",
	"reversed",
	"rows",
	"rowspan",
	"sandbox",
	"spellcheck",
	"scope",
	"scoped",
	"seamless",
	"selected",
	"shape",
	"size",
	"sizes",
	"sortable",
	"sorted",
	"span",
	"src",
	"srcdoc",
	"srclang",
	"start",
	"step",
	"style",
	"tabindex",
	"target",
	"title",
	"translate",
	"type",
	"typemustmatch",
	"usemap",
	"value",
	"width",
	"wrap",
}
var eventHandlers = []string{
	"onabort",
	"onautocomplete",
	"onautocompleteerror",
	"onafterprint",
	"onbeforeprint",
	"onbeforeunload",
	"onblur",
	"oncancel",
	"oncanplay",
	"oncanplaythrough",
	"onchange",
	"onclick",
	"onclose",
	"oncontextmenu",
	"oncuechange",
	"ondblclick",
	"ondrag",
	"ondragend",
	"ondragenter",
	"ondragleave",
	"ondragover",
	"ondragstart",
	"ondrop",
	"ondurationchange",
	"onemptied",
	"onended",
	"onerror",
	"onfocus",
	"onhashchange",
	"oninput",
	"oninvalid",
	"onkeydown",
	"onkeypress",
	"onkeyup",
	"onlanguagechange",
	"onload",
	"onloadeddata",
	"onloadedmetadata",
	"onloadstart",
	"onmessage",
	"onmousedown",
	"onmousemove",
	"onmouseout",
	"onmouseover",
	"onmouseup",
	"onmousewheel",
	"onoffline",
	"ononline",
	"onpagehide",
	"onpageshow",
	"onpause",
	"onplay",
	"onplaying",
	"onpopstate",
	"onprogress",
	"onratechange",
	"onreset",
	"onresize",
	"onscroll",
	"onseeked",
	"onseeking",
	"onselect",
	"onshow",
	"onsort",
	"onstalled",
	"onstorage",
	"onsubmit",
	"onsuspend",
	"ontimeupdate",
	"ontoggle",
	"onunload",
	"onvolumechange",
	"onwaiting",
}
var extra = []string{
	"align",
	"annotation",
	"annotation-xml",
	"applet",
	"basefont",
	"bgsound",
	"big",
	"blink",
	"center",
	"color",
	"desc",
	"face",
	"font",
	"foreignObject", 
	"foreignobject",
	"frame",
	"frameset",
	"image",
	"isindex",
	"listing",
	"malignmark",
	"marquee",
	"math",
	"mglyph",
	"mi",
	"mn",
	"mo",
	"ms",
	"mtext",
	"nobr",
	"noembed",
	"noframes",
	"plaintext",
	"prompt",
	"public",
	"spacer",
	"strike",
	"svg",
	"system",
	"tt",
	"xmp",
}
package atom
const (
	A                   Atom = 0x1
	Abbr                Atom = 0x4
	Accept              Atom = 0x2106
	AcceptCharset       Atom = 0x210e
	Accesskey           Atom = 0x3309
	Action              Atom = 0x1f606
	Address             Atom = 0x4f307
	Align               Atom = 0x1105
	Alt                 Atom = 0x4503
	Annotation          Atom = 0x1670a
	AnnotationXml       Atom = 0x1670e
	Applet              Atom = 0x2b306
	Area                Atom = 0x2fa04
	Article             Atom = 0x38807
	Aside               Atom = 0x8305
	Async               Atom = 0x7b05
	Audio               Atom = 0xa605
	Autocomplete        Atom = 0x1fc0c
	Autofocus           Atom = 0xb309
	Autoplay            Atom = 0xce08
	B                   Atom = 0x101
	Base                Atom = 0xd604
	Basefont            Atom = 0xd608
	Bdi                 Atom = 0x1a03
	Bdo                 Atom = 0xe703
	Bgsound             Atom = 0x11807
	Big                 Atom = 0x12403
	Blink               Atom = 0x12705
	Blockquote          Atom = 0x12c0a
	Body                Atom = 0x2f04
	Br                  Atom = 0x202
	Button              Atom = 0x13606
	Canvas              Atom = 0x7f06
	Caption             Atom = 0x1bb07
	Center              Atom = 0x5b506
	Challenge           Atom = 0x21f09
	Charset             Atom = 0x2807
	Checked             Atom = 0x32807
	Cite                Atom = 0x3c804
	Class               Atom = 0x4de05
	Code                Atom = 0x14904
	Col                 Atom = 0x15003
	Colgroup            Atom = 0x15008
	Color               Atom = 0x15d05
	Cols                Atom = 0x16204
	Colspan             Atom = 0x16207
	Command             Atom = 0x17507
	Content             Atom = 0x42307
	Contenteditable     Atom = 0x4230f
	Contextmenu         Atom = 0x3310b
	Controls            Atom = 0x18808
	Coords              Atom = 0x19406
	Crossorigin         Atom = 0x19f0b
	Data                Atom = 0x44a04
	Datalist            Atom = 0x44a08
	Datetime            Atom = 0x23c08
	Dd                  Atom = 0x26702
	Default             Atom = 0x8607
	Defer               Atom = 0x14b05
	Del                 Atom = 0x3ef03
	Desc                Atom = 0x4db04
	Details             Atom = 0x4807
	Dfn                 Atom = 0x6103
	Dialog              Atom = 0x1b06
	Dir                 Atom = 0x6903
	Dirname             Atom = 0x6907
	Disabled            Atom = 0x10c08
	Div                 Atom = 0x11303
	Dl                  Atom = 0x11e02
	Download            Atom = 0x40008
	Draggable           Atom = 0x17b09
	Dropzone            Atom = 0x39108
	Dt                  Atom = 0x50902
	Em                  Atom = 0x6502
	Embed               Atom = 0x6505
	Enctype             Atom = 0x21107
	Face                Atom = 0x5b304
	Fieldset            Atom = 0x1b008
	Figcaption          Atom = 0x1b80a
	Figure              Atom = 0x1cc06
	Font                Atom = 0xda04
	Footer              Atom = 0x8d06
	For                 Atom = 0x1d803
	ForeignObject       Atom = 0x1d80d
	Foreignobject       Atom = 0x1e50d
	Form                Atom = 0x1f204
	Formaction          Atom = 0x1f20a
	Formenctype         Atom = 0x20d0b
	Formmethod          Atom = 0x2280a
	Formnovalidate      Atom = 0x2320e
	Formtarget          Atom = 0x2470a
	Frame               Atom = 0x9a05
	Frameset            Atom = 0x9a08
	H1                  Atom = 0x26e02
	H2                  Atom = 0x29402
	H3                  Atom = 0x2a702
	H4                  Atom = 0x2e902
	H5                  Atom = 0x2f302
	H6                  Atom = 0x50b02
	Head                Atom = 0x2d504
	Header              Atom = 0x2d506
	Headers             Atom = 0x2d507
	Height              Atom = 0x25106
	Hgroup              Atom = 0x25906
	Hidden              Atom = 0x26506
	High                Atom = 0x26b04
	Hr                  Atom = 0x27002
	Href                Atom = 0x27004
	Hreflang            Atom = 0x27008
	Html                Atom = 0x25504
	HttpEquiv           Atom = 0x2780a
	I                   Atom = 0x601
	Icon                Atom = 0x42204
	Id                  Atom = 0x8502
	Iframe              Atom = 0x29606
	Image               Atom = 0x29c05
	Img                 Atom = 0x2a103
	Input               Atom = 0x3e805
	Inputmode           Atom = 0x3e809
	Ins                 Atom = 0x1a803
	Isindex             Atom = 0x2a907
	Ismap               Atom = 0x2b005
	Itemid              Atom = 0x33c06
	Itemprop            Atom = 0x3c908
	Itemref             Atom = 0x5ad07
	Itemscope           Atom = 0x2b909
	Itemtype            Atom = 0x2c308
	Kbd                 Atom = 0x1903
	Keygen              Atom = 0x3906
	Keytype             Atom = 0x53707
	Kind                Atom = 0x10904
	Label               Atom = 0xf005
	Lang                Atom = 0x27404
	Legend              Atom = 0x18206
	Li                  Atom = 0x1202
	Link                Atom = 0x12804
	List                Atom = 0x44e04
	Listing             Atom = 0x44e07
	Loop                Atom = 0xf404
	Low                 Atom = 0x11f03
	Malignmark          Atom = 0x100a
	Manifest            Atom = 0x5f108
	Map                 Atom = 0x2b203
	Mark                Atom = 0x1604
	Marquee             Atom = 0x2cb07
	Math                Atom = 0x2d204
	Max                 Atom = 0x2e103
	Maxlength           Atom = 0x2e109
	Media               Atom = 0x6e05
	Mediagroup          Atom = 0x6e0a
	Menu                Atom = 0x33804
	Menuitem            Atom = 0x33808
	Meta                Atom = 0x45d04
	Meter               Atom = 0x24205
	Method              Atom = 0x22c06
	Mglyph              Atom = 0x2a206
	Mi                  Atom = 0x2eb02
	Min                 Atom = 0x2eb03
	Minlength           Atom = 0x2eb09
	Mn                  Atom = 0x23502
	Mo                  Atom = 0x3ed02
	Ms                  Atom = 0x2bc02
	Mtext               Atom = 0x2f505
	Multiple            Atom = 0x30308
	Muted               Atom = 0x30b05
	Name                Atom = 0x6c04
	Nav                 Atom = 0x3e03
	Nobr                Atom = 0x5704
	Noembed             Atom = 0x6307
	Noframes            Atom = 0x9808
	Noscript            Atom = 0x3d208
	Novalidate          Atom = 0x2360a
	Object              Atom = 0x1ec06
	Ol                  Atom = 0xc902
	Onabort             Atom = 0x13a07
	Onafterprint        Atom = 0x1c00c
	Onautocomplete      Atom = 0x1fa0e
	Onautocompleteerror Atom = 0x1fa13
	Onbeforeprint       Atom = 0x6040d
	Onbeforeunload      Atom = 0x4e70e
	Onblur              Atom = 0xaa06
	Oncancel            Atom = 0xe908
	Oncanplay           Atom = 0x28509
	Oncanplaythrough    Atom = 0x28510
	Onchange            Atom = 0x3a708
	Onclick             Atom = 0x31007
	Onclose             Atom = 0x31707
	Oncontextmenu       Atom = 0x32f0d
	Oncuechange         Atom = 0x3420b
	Ondblclick          Atom = 0x34d0a
	Ondrag              Atom = 0x35706
	Ondragend           Atom = 0x35709
	Ondragenter         Atom = 0x3600b
	Ondragleave         Atom = 0x36b0b
	Ondragover          Atom = 0x3760a
	Ondragstart         Atom = 0x3800b
	Ondrop              Atom = 0x38f06
	Ondurationchange    Atom = 0x39f10
	Onemptied           Atom = 0x39609
	Onended             Atom = 0x3af07
	Onerror             Atom = 0x3b607
	Onfocus             Atom = 0x3bd07
	Onhashchange        Atom = 0x3da0c
	Oninput             Atom = 0x3e607
	Oninvalid           Atom = 0x3f209
	Onkeydown           Atom = 0x3fb09
	Onkeypress          Atom = 0x4080a
	Onkeyup             Atom = 0x41807
	Onlanguagechange    Atom = 0x43210
	Onload              Atom = 0x44206
	Onloadeddata        Atom = 0x4420c
	Onloadedmetadata    Atom = 0x45510
	Onloadstart         Atom = 0x46b0b
	Onmessage           Atom = 0x47609
	Onmousedown         Atom = 0x47f0b
	Onmousemove         Atom = 0x48a0b
	Onmouseout          Atom = 0x4950a
	Onmouseover         Atom = 0x4a20b
	Onmouseup           Atom = 0x4ad09
	Onmousewheel        Atom = 0x4b60c
	Onoffline           Atom = 0x4c209
	Ononline            Atom = 0x4cb08
	Onpagehide          Atom = 0x4d30a
	Onpageshow          Atom = 0x4fe0a
	Onpause             Atom = 0x50d07
	Onplay              Atom = 0x51706
	Onplaying           Atom = 0x51709
	Onpopstate          Atom = 0x5200a
	Onprogress          Atom = 0x52a0a
	Onratechange        Atom = 0x53e0c
	Onreset             Atom = 0x54a07
	Onresize            Atom = 0x55108
	Onscroll            Atom = 0x55f08
	Onseeked            Atom = 0x56708
	Onseeking           Atom = 0x56f09
	Onselect            Atom = 0x57808
	Onshow              Atom = 0x58206
	Onsort              Atom = 0x58b06
	Onstalled           Atom = 0x59509
	Onstorage           Atom = 0x59e09
	Onsubmit            Atom = 0x5a708
	Onsuspend           Atom = 0x5bb09
	Ontimeupdate        Atom = 0xdb0c
	Ontoggle            Atom = 0x5c408
	Onunload            Atom = 0x5cc08
	Onvolumechange      Atom = 0x5d40e
	Onwaiting           Atom = 0x5e209
	Open                Atom = 0x3cf04
	Optgroup            Atom = 0xf608
	Optimum             Atom = 0x5eb07
	Option              Atom = 0x60006
	Output              Atom = 0x49c06
	P                   Atom = 0xc01
	Param               Atom = 0xc05
	Pattern             Atom = 0x5107
	Ping                Atom = 0x7704
	Placeholder         Atom = 0xc30b
	Plaintext           Atom = 0xfd09
	Poster              Atom = 0x15706
	Pre                 Atom = 0x25e03
	Preload             Atom = 0x25e07
	Progress            Atom = 0x52c08
	Prompt              Atom = 0x5fa06
	Public              Atom = 0x41e06
	Q                   Atom = 0x13101
	Radiogroup          Atom = 0x30a
	Readonly            Atom = 0x2fb08
	Rel                 Atom = 0x25f03
	Required            Atom = 0x1d008
	Reversed            Atom = 0x5a08
	Rows                Atom = 0x9204
	Rowspan             Atom = 0x9207
	Rp                  Atom = 0x1c602
	Rt                  Atom = 0x13f02
	Ruby                Atom = 0xaf04
	S                   Atom = 0x2c01
	Samp                Atom = 0x4e04
	Sandbox             Atom = 0xbb07
	Scope               Atom = 0x2bd05
	Scoped              Atom = 0x2bd06
	Script              Atom = 0x3d406
	Seamless            Atom = 0x31c08
	Section             Atom = 0x4e207
	Select              Atom = 0x57a06
	Selected            Atom = 0x57a08
	Shape               Atom = 0x4f905
	Size                Atom = 0x55504
	Sizes               Atom = 0x55505
	Small               Atom = 0x18f05
	Sortable            Atom = 0x58d08
	Sorted              Atom = 0x19906
	Source              Atom = 0x1aa06
	Spacer              Atom = 0x2db06
	Span                Atom = 0x9504
	Spellcheck          Atom = 0x3230a
	Src                 Atom = 0x3c303
	Srcdoc              Atom = 0x3c306
	Srclang             Atom = 0x41107
	Start               Atom = 0x38605
	Step                Atom = 0x5f704
	Strike              Atom = 0x53306
	Strong              Atom = 0x55906
	Style               Atom = 0x61105
	Sub                 Atom = 0x5a903
	Summary             Atom = 0x61607
	Sup                 Atom = 0x61d03
	Svg                 Atom = 0x62003
	System              Atom = 0x62306
	Tabindex            Atom = 0x46308
	Table               Atom = 0x42d05
	Target              Atom = 0x24b06
	Tbody               Atom = 0x2e05
	Td                  Atom = 0x4702
	Template            Atom = 0x62608
	Textarea            Atom = 0x2f608
	Tfoot               Atom = 0x8c05
	Th                  Atom = 0x22e02
	Thead               Atom = 0x2d405
	Time                Atom = 0xdd04
	Title               Atom = 0xa105
	Tr                  Atom = 0x10502
	Track               Atom = 0x10505
	Translate           Atom = 0x14009
	Tt                  Atom = 0x5302
	Type                Atom = 0x21404
	Typemustmatch       Atom = 0x2140d
	U                   Atom = 0xb01
	Ul                  Atom = 0x8a02
	Usemap              Atom = 0x51106
	Value               Atom = 0x4005
	Var                 Atom = 0x11503
	Video               Atom = 0x28105
	Wbr                 Atom = 0x12103
	Width               Atom = 0x50705
	Wrap                Atom = 0x58704
	Xmp                 Atom = 0xc103
)
const hash0 = 0xc17da63e
const maxAtomLen = 19
var table = [1 << 9]Atom{
	0x1:   0x48a0b, 
	0x2:   0x5e209, 
	0x3:   0x1fa13, 
	0x4:   0x5fa06, 
	0x7:   0x5eb07, 
	0x8:   0x1604,  
	0xa:   0x5ad07, 
	0xb:   0x4fe0a, 
	0xc:   0x57a06, 
	0xd:   0x17b09, 
	0xe:   0x3e03,  
	0xf:   0x17507, 
	0x11:  0xb01,   
	0x14:  0x2d507, 
	0x15:  0x44a08, 
	0x17:  0x4e04,  
	0x1a:  0x3fb09, 
	0x1b:  0x55f08, 
	0x1c:  0x15003, 
	0x20:  0x3c908, 
	0x21:  0x2780a, 
	0x22:  0x61d03, 
	0x24:  0x1d008, 
	0x2b:  0x25e07, 
	0x2c:  0x6040d, 
	0x2d:  0x3600b, 
	0x2e:  0x50902, 
	0x2f:  0x5a708, 
	0x30:  0x27002, 
	0x31:  0x32f0d, 
	0x33:  0x29c05, 
	0x34:  0x50d07, 
	0x35:  0x25906, 
	0x36:  0x7704,  
	0x37:  0x57808, 
	0x3a:  0x11303, 
	0x3b:  0x1fa0e, 
	0x40:  0x2eb02, 
	0x41:  0x31c08, 
	0x42:  0x2807,  
	0x43:  0x8502,  
	0x44:  0x5200a, 
	0x45:  0x3ef03, 
	0x46:  0x2cb07, 
	0x47:  0x3309,  
	0x49:  0x8d06,  
	0x4a:  0x44e04, 
	0x4b:  0x2b005, 
	0x51:  0x33804, 
	0x52:  0x2f04,  
	0x55:  0x9a08,  
	0x56:  0x54a07, 
	0x57:  0x12705, 
	0x58:  0xa105,  
	0x59:  0x38807, 
	0x5b:  0x22e02, 
	0x5d:  0x13101, 
	0x5e:  0x3cf04, 
	0x5f:  0x2fa04, 
	0x61:  0x44206, 
	0x62:  0xda04,  
	0x63:  0xd604,  
	0x64:  0x16207, 
	0x65:  0x53707, 
	0x66:  0x11e02, 
	0x68:  0x1b008, 
	0x6a:  0x2eb03, 
	0x6b:  0x11503, 
	0x6f:  0x2d506, 
	0x70:  0x13f02, 
	0x71:  0x15008, 
	0x72:  0x23502, 
	0x74:  0x13a07, 
	0x75:  0x3906,  
	0x76:  0x4c209, 
	0x77:  0x21f09, 
	0x78:  0x2b203, 
	0x7a:  0x2e902, 
	0x7b:  0x3b607, 
	0x7c:  0x2e109, 
	0x7d:  0x2f505, 
	0x7e:  0xbb07,  
	0x7f:  0x58b06, 
	0x80:  0x100a,  
	0x81:  0x45d04, 
	0x82:  0x7b05,  
	0x83:  0x2a702, 
	0x84:  0x26702, 
	0x85:  0x27004, 
	0x86:  0x6e0a,  
	0x87:  0x19406, 
	0x88:  0x41107, 
	0x89:  0x34d0a, 
	0x8a:  0x4005,  
	0x8c:  0xe908,  
	0x8e:  0x3230a, 
	0x8f:  0x9a05,  
	0x91:  0x12403, 
	0x94:  0x1f606, 
	0x95:  0x6903,  
	0x97:  0x2fb08, 
	0x99:  0x42d05, 
	0x9a:  0x61607, 
	0x9b:  0x12103, 
	0x9c:  0x30a,   
	0x9d:  0x6c04,  
	0x9f:  0x62306, 
	0xa1:  0x15d05, 
	0xa2:  0x7f06,  
	0xa3:  0x25504, 
	0xa5:  0x56f09, 
	0xac:  0x4f905, 
	0xad:  0x25f03, 
	0xae:  0x28510, 
	0xaf:  0x3760a, 
	0xb0:  0x62608, 
	0xb1:  0x1d80d, 
	0xb3:  0x9204,  
	0xb6:  0x44e07, 
	0xb7:  0x49c06, 
	0xb9:  0x3310b, 
	0xbb:  0x11f03, 
	0xbc:  0x1c602, 
	0xbd:  0x5bb09, 
	0xbe:  0x13606, 
	0xbf:  0x4db04, 
	0xc1:  0x4e207, 
	0xc2:  0x52a0a, 
	0xc3:  0x59e09, 
	0xc4:  0x2d204, 
	0xc5:  0x4503,  
	0xc7:  0x8a02,  
	0xc8:  0x5107,  
	0xc9:  0x4b60c, 
	0xca:  0x35709, 
	0xcb:  0xaf04,  
	0xcc:  0xc01,   
	0xcd:  0x31707, 
	0xce:  0x24205, 
	0xcf:  0x11807, 
	0xd2:  0x25106, 
	0xd4:  0x101,   
	0xd5:  0x2c308, 
	0xd8:  0x1bb07, 
	0xd9:  0x10c08, 
	0xdb:  0x33808, 
	0xdc:  0x62003, 
	0xdd:  0x18f05, 
	0xde:  0x44a04, 
	0xe0:  0x4cb08, 
	0xe1:  0x2a206, 
	0xe3:  0x6505,  
	0xe4:  0x10502, 
	0xe5:  0x46b0b, 
	0xe7:  0x3c306, 
	0xeb:  0x5c408, 
	0xed:  0xe703,  
	0xee:  0x4702,  
	0xef:  0x8305,  
	0xf0:  0x29402, 
	0xf1:  0x52c08, 
	0xf2:  0x12c0a, 
	0xf4:  0xf005,  
	0xf5:  0x601,   
	0xf7:  0x9207,  
	0xfb:  0x51709, 
	0xfd:  0x2a103, 
	0xfe:  0xf608,  
	0xff:  0x42307, 
	0x101: 0x53e0c, 
	0x103: 0x3da0c, 
	0x104: 0x4807,  
	0x106: 0x40008, 
	0x109: 0x14009, 
	0x10b: 0x4230f, 
	0x10d: 0x36b0b, 
	0x10e: 0x2106,  
	0x10f: 0x57a08, 
	0x112: 0x1f20a, 
	0x113: 0x5b506, 
	0x115: 0x45510, 
	0x116: 0x12804, 
	0x117: 0xdd04,  
	0x118: 0x19f0b, 
	0x119: 0x3bd07, 
	0x11a: 0x58704, 
	0x11b: 0x42204, 
	0x11d: 0x28105, 
	0x11e: 0x4de05, 
	0x121: 0x5d40e, 
	0x122: 0xaa06,  
	0x123: 0x2b909, 
	0x124: 0x61105, 
	0x127: 0x41e06, 
	0x129: 0x2320e, 
	0x12a: 0x58206, 
	0x12c: 0x51706, 
	0x12d: 0x3c804, 
	0x12e: 0x2bc02, 
	0x12f: 0xdb0c,  
	0x130: 0x10904, 
	0x131: 0x2470a, 
	0x135: 0x3af07, 
	0x136: 0x26506, 
	0x137: 0x2c01,  
	0x139: 0x2280a, 
	0x13a: 0x3e805, 
	0x13c: 0x50b02, 
	0x13d: 0xc902,  
	0x13e: 0x3420b, 
	0x13f: 0x1e50d, 
	0x143: 0x4e70e, 
	0x144: 0x2bd05, 
	0x145: 0x39609, 
	0x146: 0x14b05, 
	0x147: 0xc103,  
	0x148: 0x39f10, 
	0x149: 0x1903,  
	0x14c: 0x47609, 
	0x14d: 0x60006, 
	0x14e: 0x2eb09, 
	0x14f: 0x32807, 
	0x150: 0xce08,  
	0x152: 0x202,   
	0x153: 0x2360a, 
	0x156: 0x6307,  
	0x159: 0x31007, 
	0x15a: 0x47f0b, 
	0x15b: 0x3a708, 
	0x15e: 0x3f209, 
	0x15f: 0x2bd06, 
	0x160: 0x18808, 
	0x161: 0x30b05, 
	0x162: 0x58d08, 
	0x163: 0x51106, 
	0x164: 0x1b80a, 
	0x165: 0x35706, 
	0x166: 0x26b04, 
	0x168: 0x3c303, 
	0x169: 0x15706, 
	0x16b: 0x1670e, 
	0x16c: 0x5f704, 
	0x16d: 0x4,     
	0x16e: 0x1b06,  
	0x170: 0x1202,  
	0x172: 0x3ed02, 
	0x175: 0x1d803, 
	0x176: 0x1a803, 
	0x178: 0x55504, 
	0x179: 0x43210, 
	0x17a: 0x8607,  
	0x17b: 0x1a03,  
	0x17c: 0x4d30a, 
	0x17d: 0x6907,  
	0x17e: 0x21404, 
	0x17f: 0x1f204, 
	0x181: 0x28509, 
	0x182: 0x6103,  
	0x183: 0x46308, 
	0x186: 0x6502,  
	0x187: 0x27404, 
	0x189: 0x39108, 
	0x18a: 0x4080a, 
	0x18b: 0x23c08, 
	0x18c: 0x16204, 
	0x18d: 0x1,     
	0x18e: 0x4420c, 
	0x190: 0xa605,  
	0x192: 0x2e05,  
	0x193: 0x22c06, 
	0x195: 0xf404,  
	0x196: 0x29606, 
	0x198: 0x2d504, 
	0x19e: 0x5f108, 
	0x19f: 0xb309,  
	0x1a0: 0x14904, 
	0x1a1: 0x55906, 
	0x1a2: 0x30308, 
	0x1a3: 0xc05,   
	0x1a6: 0x21107, 
	0x1a7: 0x5b304, 
	0x1a8: 0xfd09,  
	0x1a9: 0x26e02, 
	0x1aa: 0x59509, 
	0x1ad: 0x3d406, 
	0x1ae: 0x2db06, 
	0x1af: 0x55108, 
	0x1b0: 0x4a20b, 
	0x1b1: 0x5cc08, 
	0x1b2: 0x56708, 
	0x1b4: 0x2140d, 
	0x1b5: 0x1cc06, 
	0x1b6: 0x4950a, 
	0x1b7: 0x25e03, 
	0x1b8: 0x50705, 
	0x1b9: 0x19906, 
	0x1bb: 0x5704,  
	0x1be: 0x5302,  
	0x1bf: 0x1105,  
	0x1c0: 0x3e607, 
	0x1c3: 0x41807, 
	0x1c6: 0x1c00c, 
	0x1c7: 0x210e,  
	0x1c8: 0x33c06, 
	0x1c9: 0x3e809, 
	0x1cb: 0x53306, 
	0x1cc: 0x5a903, 
	0x1cd: 0x10505, 
	0x1ce: 0x38605, 
	0x1d0: 0xd608,  
	0x1d6: 0x1aa06, 
	0x1d7: 0x18206, 
	0x1d8: 0x2d405, 
	0x1da: 0x8c05,  
	0x1dd: 0x1ec06, 
	0x1de: 0x6e05,  
	0x1df: 0x1670a, 
	0x1e0: 0x20d0b, 
	0x1e2: 0x3d208, 
	0x1e4: 0x55505, 
	0x1e5: 0x1fc0c, 
	0x1e6: 0x9504,  
	0x1e7: 0x9808,  
	0x1e8: 0x24b06, 
	0x1e9: 0x38f06, 
	0x1ea: 0x2b306, 
	0x1ec: 0x5a08,  
	0x1f0: 0x2a907, 
	0x1f3: 0x27008, 
	0x1f5: 0x2f302, 
	0x1f6: 0x4f307, 
	0x1fa: 0x2e103, 
	0x1fb: 0xc30b,  
	0x1fc: 0x2f608, 
	0x1fe: 0x4ad09, 
	0x1ff: 0x3800b, 
}
const atomText = "abbradiogrouparamalignmarkbdialogaccept-charsetbodyaccesskey" +
	"genavaluealtdetailsampatternobreversedfnoembedirnamediagroup" +
	"ingasyncanvasidefaultfooterowspanoframesetitleaudionblurubya" +
	"utofocusandboxmplaceholderautoplaybasefontimeupdatebdoncance" +
	"labelooptgrouplaintextrackindisabledivarbgsoundlowbrbigblink" +
	"blockquotebuttonabortranslatecodefercolgroupostercolorcolspa" +
	"nnotation-xmlcommandraggablegendcontrolsmallcoordsortedcross" +
	"originsourcefieldsetfigcaptionafterprintfigurequiredforeignO" +
	"bjectforeignobjectformactionautocompleteerrorformenctypemust" +
	"matchallengeformmethodformnovalidatetimeterformtargetheightm" +
	"lhgroupreloadhiddenhigh1hreflanghttp-equivideoncanplaythroug" +
	"h2iframeimageimglyph3isindexismappletitemscopeditemtypemarqu" +
	"eematheaderspacermaxlength4minlength5mtextareadonlymultiplem" +
	"utedonclickoncloseamlesspellcheckedoncontextmenuitemidoncuec" +
	"hangeondblclickondragendondragenterondragleaveondragoverondr" +
	"agstarticleondropzonemptiedondurationchangeonendedonerroronf" +
	"ocusrcdocitempropenoscriptonhashchangeoninputmodeloninvalido" +
	"nkeydownloadonkeypressrclangonkeyupublicontenteditableonlang" +
	"uagechangeonloadeddatalistingonloadedmetadatabindexonloadsta" +
	"rtonmessageonmousedownonmousemoveonmouseoutputonmouseoveronm" +
	"ouseuponmousewheelonofflineononlineonpagehidesclassectionbef" +
	"oreunloaddresshapeonpageshowidth6onpausemaponplayingonpopsta" +
	"teonprogresstrikeytypeonratechangeonresetonresizestrongonscr" +
	"ollonseekedonseekingonselectedonshowraponsortableonstalledon" +
	"storageonsubmitemrefacenteronsuspendontoggleonunloadonvolume" +
	"changeonwaitingoptimumanifestepromptoptionbeforeprintstylesu" +
	"mmarysupsvgsystemplate"
package atom
var testAtomList = []string{
	"a",
	"abbr",
	"abbr",
	"accept",
	"accept-charset",
	"accesskey",
	"action",
	"address",
	"align",
	"alt",
	"annotation",
	"annotation-xml",
	"applet",
	"area",
	"article",
	"aside",
	"async",
	"audio",
	"autocomplete",
	"autofocus",
	"autoplay",
	"b",
	"base",
	"basefont",
	"bdi",
	"bdo",
	"bgsound",
	"big",
	"blink",
	"blockquote",
	"body",
	"br",
	"button",
	"canvas",
	"caption",
	"center",
	"challenge",
	"charset",
	"checked",
	"cite",
	"cite",
	"class",
	"code",
	"col",
	"colgroup",
	"color",
	"cols",
	"colspan",
	"command",
	"command",
	"content",
	"contenteditable",
	"contextmenu",
	"controls",
	"coords",
	"crossorigin",
	"data",
	"data",
	"datalist",
	"datetime",
	"dd",
	"default",
	"defer",
	"del",
	"desc",
	"details",
	"dfn",
	"dialog",
	"dir",
	"dirname",
	"disabled",
	"div",
	"dl",
	"download",
	"draggable",
	"dropzone",
	"dt",
	"em",
	"embed",
	"enctype",
	"face",
	"fieldset",
	"figcaption",
	"figure",
	"font",
	"footer",
	"for",
	"foreignObject",
	"foreignobject",
	"form",
	"form",
	"formaction",
	"formenctype",
	"formmethod",
	"formnovalidate",
	"formtarget",
	"frame",
	"frameset",
	"h1",
	"h2",
	"h3",
	"h4",
	"h5",
	"h6",
	"head",
	"header",
	"headers",
	"height",
	"hgroup",
	"hidden",
	"high",
	"hr",
	"href",
	"hreflang",
	"html",
	"http-equiv",
	"i",
	"icon",
	"id",
	"iframe",
	"image",
	"img",
	"input",
	"inputmode",
	"ins",
	"isindex",
	"ismap",
	"itemid",
	"itemprop",
	"itemref",
	"itemscope",
	"itemtype",
	"kbd",
	"keygen",
	"keytype",
	"kind",
	"label",
	"label",
	"lang",
	"legend",
	"li",
	"link",
	"list",
	"listing",
	"loop",
	"low",
	"malignmark",
	"manifest",
	"map",
	"mark",
	"marquee",
	"math",
	"max",
	"maxlength",
	"media",
	"mediagroup",
	"menu",
	"menuitem",
	"meta",
	"meter",
	"method",
	"mglyph",
	"mi",
	"min",
	"minlength",
	"mn",
	"mo",
	"ms",
	"mtext",
	"multiple",
	"muted",
	"name",
	"nav",
	"nobr",
	"noembed",
	"noframes",
	"noscript",
	"novalidate",
	"object",
	"ol",
	"onabort",
	"onafterprint",
	"onautocomplete",
	"onautocompleteerror",
	"onbeforeprint",
	"onbeforeunload",
	"onblur",
	"oncancel",
	"oncanplay",
	"oncanplaythrough",
	"onchange",
	"onclick",
	"onclose",
	"oncontextmenu",
	"oncuechange",
	"ondblclick",
	"ondrag",
	"ondragend",
	"ondragenter",
	"ondragleave",
	"ondragover",
	"ondragstart",
	"ondrop",
	"ondurationchange",
	"onemptied",
	"onended",
	"onerror",
	"onfocus",
	"onhashchange",
	"oninput",
	"oninvalid",
	"onkeydown",
	"onkeypress",
	"onkeyup",
	"onlanguagechange",
	"onload",
	"onloadeddata",
	"onloadedmetadata",
	"onloadstart",
	"onmessage",
	"onmousedown",
	"onmousemove",
	"onmouseout",
	"onmouseover",
	"onmouseup",
	"onmousewheel",
	"onoffline",
	"ononline",
	"onpagehide",
	"onpageshow",
	"onpause",
	"onplay",
	"onplaying",
	"onpopstate",
	"onprogress",
	"onratechange",
	"onreset",
	"onresize",
	"onscroll",
	"onseeked",
	"onseeking",
	"onselect",
	"onshow",
	"onsort",
	"onstalled",
	"onstorage",
	"onsubmit",
	"onsuspend",
	"ontimeupdate",
	"ontoggle",
	"onunload",
	"onvolumechange",
	"onwaiting",
	"open",
	"optgroup",
	"optimum",
	"option",
	"output",
	"p",
	"param",
	"pattern",
	"ping",
	"placeholder",
	"plaintext",
	"poster",
	"pre",
	"preload",
	"progress",
	"prompt",
	"public",
	"q",
	"radiogroup",
	"readonly",
	"rel",
	"required",
	"reversed",
	"rows",
	"rowspan",
	"rp",
	"rt",
	"ruby",
	"s",
	"samp",
	"sandbox",
	"scope",
	"scoped",
	"script",
	"seamless",
	"section",
	"select",
	"selected",
	"shape",
	"size",
	"sizes",
	"small",
	"sortable",
	"sorted",
	"source",
	"spacer",
	"span",
	"span",
	"spellcheck",
	"src",
	"srcdoc",
	"srclang",
	"start",
	"step",
	"strike",
	"strong",
	"style",
	"style",
	"sub",
	"summary",
	"sup",
	"svg",
	"system",
	"tabindex",
	"table",
	"target",
	"tbody",
	"td",
	"template",
	"textarea",
	"tfoot",
	"th",
	"thead",
	"time",
	"title",
	"title",
	"tr",
	"track",
	"translate",
	"tt",
	"type",
	"typemustmatch",
	"u",
	"ul",
	"usemap",
	"value",
	"var",
	"video",
	"wbr",
	"width",
	"wrap",
	"xmp",
}
package atom
import (
	"sort"
	"testing"
)
func TestKnown(t *testing.T) {
	for _, s := range testAtomList {
		if atom := Lookup([]byte(s)); atom.String() != s {
			t.Errorf("Lookup(%q) = %#x (%q)", s, uint32(atom), atom.String())
		}
	}
}
func TestHits(t *testing.T) {
	for _, a := range table {
		if a == 0 {
			continue
		}
		got := Lookup([]byte(a.String()))
		if got != a {
			t.Errorf("Lookup(%q) = %#x, want %#x", a.String(), uint32(got), uint32(a))
		}
	}
}
func TestMisses(t *testing.T) {
	testCases := []string{
		"",
		"\x00",
		"\xff",
		"A",
		"DIV",
		"Div",
		"dIV",
		"aa",
		"a\x00",
		"ab",
		"abb",
		"abbr0",
		"abbr ",
		" abbr",
		" a",
		"acceptcharset",
		"acceptCharset",
		"accept_charset",
		"h0",
		"h1h2",
		"h7",
		"onClick",
		"λ",
		
		"\x00\x00\x00\x00\x00\x50\x18\xae\x38\xd0\xb7",
	}
	for _, tc := range testCases {
		got := Lookup([]byte(tc))
		if got != 0 {
			t.Errorf("Lookup(%q): got %d, want 0", tc, got)
		}
	}
}
func TestForeignObject(t *testing.T) {
	const (
		afo = Foreignobject
		afO = ForeignObject
		sfo = "foreignobject"
		sfO = "foreignObject"
	)
	if got := Lookup([]byte(sfo)); got != afo {
		t.Errorf("Lookup(%q): got %#v, want %#v", sfo, got, afo)
	}
	if got := Lookup([]byte(sfO)); got != afO {
		t.Errorf("Lookup(%q): got %#v, want %#v", sfO, got, afO)
	}
	if got := afo.String(); got != sfo {
		t.Errorf("Atom(%#v).String(): got %q, want %q", afo, got, sfo)
	}
	if got := afO.String(); got != sfO {
		t.Errorf("Atom(%#v).String(): got %q, want %q", afO, got, sfO)
	}
}
func BenchmarkLookup(b *testing.B) {
	sortedTable := make([]string, 0, len(table))
	for _, a := range table {
		if a != 0 {
			sortedTable = append(sortedTable, a.String())
		}
	}
	sort.Strings(sortedTable)
	x := make([][]byte, 1000)
	for i := range x {
		x[i] = []byte(sortedTable[i%len(sortedTable)])
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		for _, s := range x {
			Lookup(s)
		}
	}
}
package charset 
import (
	"bytes"
	"fmt"
	"io"
	"mime"
	"strings"
	"unicode
	"golang.org
	"golang.org
	"golang.org
	"golang.org
	"golang.org
)
func Lookup(label string) (e encoding.Encoding, name string) {
	e, err := htmlindex.Get(label)
	if err != nil {
		return nil, ""
	}
	name, _ = htmlindex.Name(e)
	return &htmlEncoding{e}, name
}
type htmlEncoding struct{ encoding.Encoding }
func (h *htmlEncoding) NewEncoder() *encoding.Encoder {
	
	
	return encoding.HTMLEscapeUnsupported(h.Encoding.NewEncoder())
}
func DetermineEncoding(content []byte, contentType string) (e encoding.Encoding, name string, certain bool) {
	if len(content) > 1024 {
		content = content[:1024]
	}
	for _, b := range boms {
		if bytes.HasPrefix(content, b.bom) {
			e, name = Lookup(b.enc)
			return e, name, true
		}
	}
	if _, params, err := mime.ParseMediaType(contentType); err == nil {
		if cs, ok := params["charset"]; ok {
			if e, name = Lookup(cs); e != nil {
				return e, name, true
			}
		}
	}
	if len(content) > 0 {
		e, name = prescan(content)
		if e != nil {
			return e, name, false
		}
	}
	
	
	for i := len(content) - 1; i >= 0 && i > len(content)-4; i-- {
		b := content[i]
		if b < 0x80 {
			break
		}
		if utf8.RuneStart(b) {
			content = content[:i]
			break
		}
	}
	hasHighBit := false
	for _, c := range content {
		if c >= 0x80 {
			hasHighBit = true
			break
		}
	}
	if hasHighBit && utf8.Valid(content) {
		return encoding.Nop, "utf-8", false
	}
	
	return charmap.Windows1252, "windows-1252", false
}
func NewReader(r io.Reader, contentType string) (io.Reader, error) {
	preview := make([]byte, 1024)
	n, err := io.ReadFull(r, preview)
	switch {
	case err == io.ErrUnexpectedEOF:
		preview = preview[:n]
		r = bytes.NewReader(preview)
	case err != nil:
		return nil, err
	default:
		r = io.MultiReader(bytes.NewReader(preview), r)
	}
	if e, _, _ := DetermineEncoding(preview, contentType); e != encoding.Nop {
		r = transform.NewReader(r, e.NewDecoder())
	}
	return r, nil
}
func NewReaderLabel(label string, input io.Reader) (io.Reader, error) {
	e, _ := Lookup(label)
	if e == nil {
		return nil, fmt.Errorf("unsupported charset: %q", label)
	}
	return transform.NewReader(input, e.NewDecoder()), nil
}
func prescan(content []byte) (e encoding.Encoding, name string) {
	z := html.NewTokenizer(bytes.NewReader(content))
	for {
		switch z.Next() {
		case html.ErrorToken:
			return nil, ""
		case html.StartTagToken, html.SelfClosingTagToken:
			tagName, hasAttr := z.TagName()
			if !bytes.Equal(tagName, []byte("meta")) {
				continue
			}
			attrList := make(map[string]bool)
			gotPragma := false
			const (
				dontKnow = iota
				doNeedPragma
				doNotNeedPragma
			)
			needPragma := dontKnow
			name = ""
			e = nil
			for hasAttr {
				var key, val []byte
				key, val, hasAttr = z.TagAttr()
				ks := string(key)
				if attrList[ks] {
					continue
				}
				attrList[ks] = true
				for i, c := range val {
					if 'A' <= c && c <= 'Z' {
						val[i] = c + 0x20
					}
				}
				switch ks {
				case "http-equiv":
					if bytes.Equal(val, []byte("content-type")) {
						gotPragma = true
					}
				case "content":
					if e == nil {
						name = fromMetaElement(string(val))
						if name != "" {
							e, name = Lookup(name)
							if e != nil {
								needPragma = doNeedPragma
							}
						}
					}
				case "charset":
					e, name = Lookup(string(val))
					needPragma = doNotNeedPragma
				}
			}
			if needPragma == dontKnow || needPragma == doNeedPragma && !gotPragma {
				continue
			}
			if strings.HasPrefix(name, "utf-16") {
				name = "utf-8"
				e = encoding.Nop
			}
			if e != nil {
				return e, name
			}
		}
	}
}
func fromMetaElement(s string) string {
	for s != "" {
		csLoc := strings.Index(s, "charset")
		if csLoc == -1 {
			return ""
		}
		s = s[csLoc+len("charset"):]
		s = strings.TrimLeft(s, " \t\n\f\r")
		if !strings.HasPrefix(s, "=") {
			continue
		}
		s = s[1:]
		s = strings.TrimLeft(s, " \t\n\f\r")
		if s == "" {
			return ""
		}
		if q := s[0]; q == '"' || q == '\'' {
			s = s[1:]
			closeQuote := strings.IndexRune(s, rune(q))
			if closeQuote == -1 {
				return ""
			}
			return s[:closeQuote]
		}
		end := strings.IndexAny(s, "; \t\n\f\r")
		if end == -1 {
			end = len(s)
		}
		return s[:end]
	}
	return ""
}
var boms = []struct {
	bom []byte
	enc string
}{
	{[]byte{0xfe, 0xff}, "utf-16be"},
	{[]byte{0xff, 0xfe}, "utf-16le"},
	{[]byte{0xef, 0xbb, 0xbf}, "utf-8"},
}
package charset
import (
	"bytes"
	"encoding
	"io
	"runtime"
	"strings"
	"testing"
	"golang.org
)
func transformString(t transform.Transformer, s string) (string, error) {
	r := transform.NewReader(strings.NewReader(s), t)
	b, err := ioutil.ReadAll(r)
	return string(b), err
}
type testCase struct {
	utf8, other, otherEncoding string
}
var testCases = []testCase{
	{"Résumé", "Résumé", "utf8"},
	{"Résumé", "R\xe9sum\xe9", "latin1"},
	{"これは漢字です。", "S0\x8c0o0\"oW[g0Y0\x020", "UTF-16LE"},
	{"これは漢字です。", "0S0\x8c0oo\"[W0g0Y0\x02", "UTF-16BE"},
	{"Hello, world", "Hello, world", "ASCII"},
	{"Gdańsk", "Gda\xf1sk", "ISO-8859-2"},
	{"Ââ Čč Đđ Ŋŋ Õõ Šš Žž Åå Ää", "\xc2\xe2 \xc8\xe8 \xa9\xb9 \xaf\xbf \xd5\xf5 \xaa\xba \xac\xbc \xc5\xe5 \xc4\xe4", "ISO-8859-10"},
	{"สำหรับ", "\xca\xd3\xcb\xc3\u047a", "ISO-8859-11"},
	{"latviešu", "latvie\xf0u", "ISO-8859-13"},
	{"Seònaid", "Se\xf2naid", "ISO-8859-14"},
	{"€1 is cheap", "\xa41 is cheap", "ISO-8859-15"},
	{"românește", "rom\xe2ne\xbate", "ISO-8859-16"},
	{"nutraĵo", "nutra\xbco", "ISO-8859-3"},
	{"Kalâdlit", "Kal\xe2dlit", "ISO-8859-4"},
	{"русский", "\xe0\xe3\xe1\xe1\xda\xd8\xd9", "ISO-8859-5"},
	{"ελληνικά", "\xe5\xeb\xeb\xe7\xed\xe9\xea\xdc", "ISO-8859-7"},
	{"Kağan", "Ka\xf0an", "ISO-8859-9"},
	{"Résumé", "R\x8esum\x8e", "macintosh"},
	{"Gdańsk", "Gda\xf1sk", "windows-1250"},
	{"русский", "\xf0\xf3\xf1\xf1\xea\xe8\xe9", "windows-1251"},
	{"Résumé", "R\xe9sum\xe9", "windows-1252"},
	{"ελληνικά", "\xe5\xeb\xeb\xe7\xed\xe9\xea\xdc", "windows-1253"},
	{"Kağan", "Ka\xf0an", "windows-1254"},
	{"עִבְרִית", "\xf2\xc4\xe1\xc0\xf8\xc4\xe9\xfa", "windows-1255"},
	{"العربية", "\xc7\xe1\xda\xd1\xc8\xed\xc9", "windows-1256"},
	{"latviešu", "latvie\xf0u", "windows-1257"},
	{"Việt", "Vi\xea\xf2t", "windows-1258"},
	{"สำหรับ", "\xca\xd3\xcb\xc3\u047a", "windows-874"},
	{"русский", "\xd2\xd5\xd3\xd3\xcb\xc9\xca", "KOI8-R"},
	{"українська", "\xd5\xcb\xd2\xc1\xa7\xce\xd3\xd8\xcb\xc1", "KOI8-U"},
	{"Hello 常用國字標準字體表", "Hello \xb1`\xa5\u03b0\xea\xa6r\xbc\u0437\u01e6r\xc5\xe9\xaa\xed", "big5"},
	{"Hello 常用國字標準字體表", "Hello \xb3\xa3\xd3\xc3\x87\xf8\xd7\xd6\x98\xcb\x9c\xca\xd7\xd6\xf3\x77\xb1\xed", "gbk"},
	{"Hello 常用國字標準字體表", "Hello \xb3\xa3\xd3\xc3\x87\xf8\xd7\xd6\x98\xcb\x9c\xca\xd7\xd6\xf3\x77\xb1\xed", "gb18030"},
	{"עִבְרִית", "\x81\x30\xfb\x30\x81\x30\xf6\x34\x81\x30\xf9\x33\x81\x30\xf6\x30\x81\x30\xfb\x36\x81\x30\xf6\x34\x81\x30\xfa\x31\x81\x30\xfb\x38", "gb18030"},
	{"㧯", "\x82\x31\x89\x38", "gb18030"},
	{"これは漢字です。", "\x82\xb1\x82\xea\x82\xcd\x8a\xbf\x8e\x9a\x82\xc5\x82\xb7\x81B", "SJIS"},
	{"Hello, 世界!", "Hello, \x90\xa2\x8aE!", "SJIS"},
	{"ｲｳｴｵｶ", "\xb2\xb3\xb4\xb5\xb6", "SJIS"},
	{"これは漢字です。", "\xa4\xb3\xa4\xec\xa4\u03f4\xc1\xbb\xfa\xa4\u01e4\xb9\xa1\xa3", "EUC-JP"},
	{"Hello, 世界!", "Hello, \x1b$B@$3&\x1b(B!", "ISO-2022-JP"},
	{"다음과 같은 조건을 따라야 합니다: 저작자표시", "\xb4\xd9\xc0\xbd\xb0\xfa \xb0\xb0\xc0\xba \xc1\xb6\xb0\xc7\xc0\xbb \xb5\xfb\xb6\xf3\xbe\xdf \xc7մϴ\xd9: \xc0\xfa\xc0\xdb\xc0\xdaǥ\xbd\xc3", "EUC-KR"},
}
func TestDecode(t *testing.T) {
	testCases := append(testCases, []testCase{
		
		
		{"Rés\ufffdumé", "Rés\xe1\x80umé", "utf8"},
	}...)
	for _, tc := range testCases {
		e, _ := Lookup(tc.otherEncoding)
		if e == nil {
			t.Errorf("%s: not found", tc.otherEncoding)
			continue
		}
		s, err := transformString(e.NewDecoder(), tc.other)
		if err != nil {
			t.Errorf("%s: decode %q: %v", tc.otherEncoding, tc.other, err)
			continue
		}
		if s != tc.utf8 {
			t.Errorf("%s: got %q, want %q", tc.otherEncoding, s, tc.utf8)
		}
	}
}
func TestEncode(t *testing.T) {
	testCases := append(testCases, []testCase{
		
		{"Rés\xe1\x80umé", "Rés\ufffd\ufffdumé", "utf8"},
		
		{"Gdańsk", "Gda&#324;sk", "ISO-8859-11"},
		{"\ufffd", "&#65533;", "ISO-8859-11"},
		{"a\xe1\x80b", "a&#65533;&#65533;b", "ISO-8859-11"},
	}...)
	for _, tc := range testCases {
		e, _ := Lookup(tc.otherEncoding)
		if e == nil {
			t.Errorf("%s: not found", tc.otherEncoding)
			continue
		}
		s, err := transformString(e.NewEncoder(), tc.utf8)
		if err != nil {
			t.Errorf("%s: encode %q: %s", tc.otherEncoding, tc.utf8, err)
			continue
		}
		if s != tc.other {
			t.Errorf("%s: got %q, want %q", tc.otherEncoding, s, tc.other)
		}
	}
}
var sniffTestCases = []struct {
	filename, declared, want string
}{
	{"HTTP-charset.html", "text
	{"UTF-16LE-BOM.html", "", "utf-16le"},
	{"UTF-16BE-BOM.html", "", "utf-16be"},
	{"meta-content-attribute.html", "text
	{"meta-charset-attribute.html", "text
	{"No-encoding-declaration.html", "text
	{"HTTP-vs-UTF-8-BOM.html", "text
	{"HTTP-vs-meta-content.html", "text
	{"HTTP-vs-meta-charset.html", "text
	{"UTF-8-BOM-vs-meta-content.html", "text
	{"UTF-8-BOM-vs-meta-charset.html", "text
}
func TestSniff(t *testing.T) {
	switch runtime.GOOS {
	case "nacl": 
		t.Skipf("not supported on %q", runtime.GOOS)
	}
	for _, tc := range sniffTestCases {
		content, err := ioutil.ReadFile("testdata
		if err != nil {
			t.Errorf("%s: error reading file: %v", tc.filename, err)
			continue
		}
		_, name, _ := DetermineEncoding(content, tc.declared)
		if name != tc.want {
			t.Errorf("%s: got %q, want %q", tc.filename, name, tc.want)
			continue
		}
	}
}
func TestReader(t *testing.T) {
	switch runtime.GOOS {
	case "nacl": 
		t.Skipf("not supported on %q", runtime.GOOS)
	}
	for _, tc := range sniffTestCases {
		content, err := ioutil.ReadFile("testdata
		if err != nil {
			t.Errorf("%s: error reading file: %v", tc.filename, err)
			continue
		}
		r, err := NewReader(bytes.NewReader(content), tc.declared)
		if err != nil {
			t.Errorf("%s: error creating reader: %v", tc.filename, err)
			continue
		}
		got, err := ioutil.ReadAll(r)
		if err != nil {
			t.Errorf("%s: error reading from charset.NewReader: %v", tc.filename, err)
			continue
		}
		e, _ := Lookup(tc.want)
		want, err := ioutil.ReadAll(transform.NewReader(bytes.NewReader(content), e.NewDecoder()))
		if err != nil {
			t.Errorf("%s: error decoding with hard-coded charset name: %v", tc.filename, err)
			continue
		}
		if !bytes.Equal(got, want) {
			t.Errorf("%s: got %q, want %q", tc.filename, got, want)
			continue
		}
	}
}
var metaTestCases = []struct {
	meta, want string
}{
	{"", ""},
	{"text
	{"text
	{"text
	{"text
	{`charset="big5"`, "big5"},
	{"charset='shift_jis'", "shift_jis"},
}
func TestFromMeta(t *testing.T) {
	for _, tc := range metaTestCases {
		got := fromMetaElement(tc.meta)
		if got != tc.want {
			t.Errorf("%q: got %q, want %q", tc.meta, got, tc.want)
		}
	}
}
func TestXML(t *testing.T) {
	const s = "<?xml version=\"1.0\" encoding=\"windows-1252\"?><a><Word>r\xe9sum\xe9<
	d := xml.NewDecoder(strings.NewReader(s))
	d.CharsetReader = NewReaderLabel
	var a struct {
		Word string
	}
	err := d.Decode(&a)
	if err != nil {
		t.Fatalf("Decode: %v", err)
	}
	want := "résumé"
	if a.Word != want {
		t.Errorf("got %q, want %q", a.Word, want)
	}
}
package html
import (
	"strings"
)
func adjustAttributeNames(aa []Attribute, nameMap map[string]string) {
	for i := range aa {
		if newName, ok := nameMap[aa[i].Key]; ok {
			aa[i].Key = newName
		}
	}
}
func adjustForeignAttributes(aa []Attribute) {
	for i, a := range aa {
		if a.Key == "" || a.Key[0] != 'x' {
			continue
		}
		switch a.Key {
		case "xlink:actuate", "xlink:arcrole", "xlink:href", "xlink:role", "xlink:show",
			"xlink:title", "xlink:type", "xml:base", "xml:lang", "xml:space", "xmlns:xlink":
			j := strings.Index(a.Key, ":")
			aa[i].Namespace = a.Key[:j]
			aa[i].Key = a.Key[j+1:]
		}
	}
}
func htmlIntegrationPoint(n *Node) bool {
	if n.Type != ElementNode {
		return false
	}
	switch n.Namespace {
	case "math":
		if n.Data == "annotation-xml" {
			for _, a := range n.Attr {
				if a.Key == "encoding" {
					val := strings.ToLower(a.Val)
					if val == "text
						return true
					}
				}
			}
		}
	case "svg":
		switch n.Data {
		case "desc", "foreignObject", "title":
			return true
		}
	}
	return false
}
func mathMLTextIntegrationPoint(n *Node) bool {
	if n.Namespace != "math" {
		return false
	}
	switch n.Data {
	case "mi", "mo", "mn", "ms", "mtext":
		return true
	}
	return false
}
var breakout = map[string]bool{
	"b":          true,
	"big":        true,
	"blockquote": true,
	"body":       true,
	"br":         true,
	"center":     true,
	"code":       true,
	"dd":         true,
	"div":        true,
	"dl":         true,
	"dt":         true,
	"em":         true,
	"embed":      true,
	"h1":         true,
	"h2":         true,
	"h3":         true,
	"h4":         true,
	"h5":         true,
	"h6":         true,
	"head":       true,
	"hr":         true,
	"i":          true,
	"img":        true,
	"li":         true,
	"listing":    true,
	"menu":       true,
	"meta":       true,
	"nobr":       true,
	"ol":         true,
	"p":          true,
	"pre":        true,
	"ruby":       true,
	"s":          true,
	"small":      true,
	"span":       true,
	"strong":     true,
	"strike":     true,
	"sub":        true,
	"sup":        true,
	"table":      true,
	"tt":         true,
	"u":          true,
	"ul":         true,
	"var":        true,
}
var svgTagNameAdjustments = map[string]string{
	"altglyph":            "altGlyph",
	"altglyphdef":         "altGlyphDef",
	"altglyphitem":        "altGlyphItem",
	"animatecolor":        "animateColor",
	"animatemotion":       "animateMotion",
	"animatetransform":    "animateTransform",
	"clippath":            "clipPath",
	"feblend":             "feBlend",
	"fecolormatrix":       "feColorMatrix",
	"fecomponenttransfer": "feComponentTransfer",
	"fecomposite":         "feComposite",
	"feconvolvematrix":    "feConvolveMatrix",
	"fediffuselighting":   "feDiffuseLighting",
	"fedisplacementmap":   "feDisplacementMap",
	"fedistantlight":      "feDistantLight",
	"feflood":             "feFlood",
	"fefunca":             "feFuncA",
	"fefuncb":             "feFuncB",
	"fefuncg":             "feFuncG",
	"fefuncr":             "feFuncR",
	"fegaussianblur":      "feGaussianBlur",
	"feimage":             "feImage",
	"femerge":             "feMerge",
	"femergenode":         "feMergeNode",
	"femorphology":        "feMorphology",
	"feoffset":            "feOffset",
	"fepointlight":        "fePointLight",
	"fespecularlighting":  "feSpecularLighting",
	"fespotlight":         "feSpotLight",
	"fetile":              "feTile",
	"feturbulence":        "feTurbulence",
	"foreignobject":       "foreignObject",
	"glyphref":            "glyphRef",
	"lineargradient":      "linearGradient",
	"radialgradient":      "radialGradient",
	"textpath":            "textPath",
}
var mathMLAttributeAdjustments = map[string]string{
	"definitionurl": "definitionURL",
}
var svgAttributeAdjustments = map[string]string{
	"attributename":             "attributeName",
	"attributetype":             "attributeType",
	"basefrequency":             "baseFrequency",
	"baseprofile":               "baseProfile",
	"calcmode":                  "calcMode",
	"clippathunits":             "clipPathUnits",
	"contentscripttype":         "contentScriptType",
	"contentstyletype":          "contentStyleType",
	"diffuseconstant":           "diffuseConstant",
	"edgemode":                  "edgeMode",
	"externalresourcesrequired": "externalResourcesRequired",
	"filterres":                 "filterRes",
	"filterunits":               "filterUnits",
	"glyphref":                  "glyphRef",
	"gradienttransform":         "gradientTransform",
	"gradientunits":             "gradientUnits",
	"kernelmatrix":              "kernelMatrix",
	"kernelunitlength":          "kernelUnitLength",
	"keypoints":                 "keyPoints",
	"keysplines":                "keySplines",
	"keytimes":                  "keyTimes",
	"lengthadjust":              "lengthAdjust",
	"limitingconeangle":         "limitingConeAngle",
	"markerheight":              "markerHeight",
	"markerunits":               "markerUnits",
	"markerwidth":               "markerWidth",
	"maskcontentunits":          "maskContentUnits",
	"maskunits":                 "maskUnits",
	"numoctaves":                "numOctaves",
	"pathlength":                "pathLength",
	"patterncontentunits":       "patternContentUnits",
	"patterntransform":          "patternTransform",
	"patternunits":              "patternUnits",
	"pointsatx":                 "pointsAtX",
	"pointsaty":                 "pointsAtY",
	"pointsatz":                 "pointsAtZ",
	"preservealpha":             "preserveAlpha",
	"preserveaspectratio":       "preserveAspectRatio",
	"primitiveunits":            "primitiveUnits",
	"refx":                      "refX",
	"refy":                      "refY",
	"repeatcount":               "repeatCount",
	"repeatdur":                 "repeatDur",
	"requiredextensions":        "requiredExtensions",
	"requiredfeatures":          "requiredFeatures",
	"specularconstant":          "specularConstant",
	"specularexponent":          "specularExponent",
	"spreadmethod":              "spreadMethod",
	"startoffset":               "startOffset",
	"stddeviation":              "stdDeviation",
	"stitchtiles":               "stitchTiles",
	"surfacescale":              "surfaceScale",
	"systemlanguage":            "systemLanguage",
	"tablevalues":               "tableValues",
	"targetx":                   "targetX",
	"targety":                   "targetY",
	"textlength":                "textLength",
	"viewbox":                   "viewBox",
	"viewtarget":                "viewTarget",
	"xchannelselector":          "xChannelSelector",
	"ychannelselector":          "yChannelSelector",
	"zoomandpan":                "zoomAndPan",
}
package html
import "testing"
type unescapeTest struct {
	
	desc string
	
	html string
	
	unescaped string
}
var unescapeTests = []unescapeTest{
	
	{
		"copy",
		"A\ttext\nstring",
		"A\ttext\nstring",
	},
	
	{
		"simple",
		"&amp; &gt; &lt;",
		"& > <",
	},
	
	{
		"stringEnd",
		"&amp &amp",
		"& &",
	},
	
	{
		"multiCodepoint",
		"text &gesl; blah",
		"text \u22db\ufe00 blah",
	},
	
	{
		"decimalEntity",
		"Delta = &#916; ",
		"Delta = Δ ",
	},
	
	{
		"hexadecimalEntity",
		"Lambda = &#x3bb; = &#X3Bb ",
		"Lambda = λ = λ ",
	},
	
	{
		"numericEnds",
		"&# &#x &#128;43 &copy = &#169f = &#xa9",
		"&# &#x €43 © = ©f = ©",
	},
	
	{
		"numericReplacements",
		"Footnote&#x87;",
		"Footnote‡",
	},
}
func TestUnescape(t *testing.T) {
	for _, tt := range unescapeTests {
		unescaped := UnescapeString(tt.html)
		if unescaped != tt.unescaped {
			t.Errorf("TestUnescape %s: want %q, got %q", tt.desc, tt.unescaped, unescaped)
		}
	}
}
func TestUnescapeEscape(t *testing.T) {
	ss := []string{
		``,
		`abc def`,
		`a & b`,
		`a&amp;b`,
		`a &amp b`,
		`&quot;`,
		`"`,
		`"<&>"`,
		`&quot;&lt;&amp;&gt;&quot;`,
		`3&5==1 && 0<1, "0&lt;1", a+acute=&aacute;`,
		`The special characters are: <, >, &, ' and "`,
	}
	for _, s := range ss {
		if got := UnescapeString(EscapeString(s)); got != s {
			t.Errorf("got %q want %q", got, s)
		}
	}
}
package html
import (
	"bytes"
	"strings"
	"unicode
)
var replacementTable = [...]rune{
	'\u20AC', 
	'\u0081',
	'\u201A',
	'\u0192',
	'\u201E',
	'\u2026',
	'\u2020',
	'\u2021',
	'\u02C6',
	'\u2030',
	'\u0160',
	'\u2039',
	'\u0152',
	'\u008D',
	'\u017D',
	'\u008F',
	'\u0090',
	'\u2018',
	'\u2019',
	'\u201C',
	'\u201D',
	'\u2022',
	'\u2013',
	'\u2014',
	'\u02DC',
	'\u2122',
	'\u0161',
	'\u203A',
	'\u0153',
	'\u009D',
	'\u017E',
	'\u0178', 
	
	
}
func unescapeEntity(b []byte, dst, src int, attribute bool) (dst1, src1 int) {
	
	
	i, s := 1, b[src:]
	if len(s) <= 1 {
		b[dst] = b[src]
		return dst + 1, src + 1
	}
	if s[i] == '#' {
		if len(s) <= 3 { 
			b[dst] = b[src]
			return dst + 1, src + 1
		}
		i++
		c := s[i]
		hex := false
		if c == 'x' || c == 'X' {
			hex = true
			i++
		}
		x := '\x00'
		for i < len(s) {
			c = s[i]
			i++
			if hex {
				if '0' <= c && c <= '9' {
					x = 16*x + rune(c) - '0'
					continue
				} else if 'a' <= c && c <= 'f' {
					x = 16*x + rune(c) - 'a' + 10
					continue
				} else if 'A' <= c && c <= 'F' {
					x = 16*x + rune(c) - 'A' + 10
					continue
				}
			} else if '0' <= c && c <= '9' {
				x = 10*x + rune(c) - '0'
				continue
			}
			if c != ';' {
				i--
			}
			break
		}
		if i <= 3 { 
			b[dst] = b[src]
			return dst + 1, src + 1
		}
		if 0x80 <= x && x <= 0x9F {
			
			x = replacementTable[x-0x80]
		} else if x == 0 || (0xD800 <= x && x <= 0xDFFF) || x > 0x10FFFF {
			
			x = '\uFFFD'
		}
		return dst + utf8.EncodeRune(b[dst:], x), src + i
	}
	
	
	for i < len(s) {
		c := s[i]
		i++
		
		if 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z' || '0' <= c && c <= '9' {
			continue
		}
		if c != ';' {
			i--
		}
		break
	}
	entityName := string(s[1:i])
	if entityName == "" {
		
	} else if attribute && entityName[len(entityName)-1] != ';' && len(s) > i && s[i] == '=' {
		
	} else if x := entity[entityName]; x != 0 {
		return dst + utf8.EncodeRune(b[dst:], x), src + i
	} else if x := entity2[entityName]; x[0] != 0 {
		dst1 := dst + utf8.EncodeRune(b[dst:], x[0])
		return dst1 + utf8.EncodeRune(b[dst1:], x[1]), src + i
	} else if !attribute {
		maxLen := len(entityName) - 1
		if maxLen > longestEntityWithoutSemicolon {
			maxLen = longestEntityWithoutSemicolon
		}
		for j := maxLen; j > 1; j-- {
			if x := entity[entityName[:j]]; x != 0 {
				return dst + utf8.EncodeRune(b[dst:], x), src + j + 1
			}
		}
	}
	dst1, src1 = dst+i, src+i
	copy(b[dst:dst1], b[src:src1])
	return dst1, src1
}
func unescape(b []byte, attribute bool) []byte {
	for i, c := range b {
		if c == '&' {
			dst, src := unescapeEntity(b, i, i, attribute)
			for src < len(b) {
				c := b[src]
				if c == '&' {
					dst, src = unescapeEntity(b, dst, src, attribute)
				} else {
					b[dst] = c
					dst, src = dst+1, src+1
				}
			}
			return b[0:dst]
		}
	}
	return b
}
func lower(b []byte) []byte {
	for i, c := range b {
		if 'A' <= c && c <= 'Z' {
			b[i] = c + 'a' - 'A'
		}
	}
	return b
}
const escapedChars = "&'<>\"\r"
func escape(w writer, s string) error {
	i := strings.IndexAny(s, escapedChars)
	for i != -1 {
		if _, err := w.WriteString(s[:i]); err != nil {
			return err
		}
		var esc string
		switch s[i] {
		case '&':
			esc = "&amp;"
		case '\'':
			
			esc = "&#39;"
		case '<':
			esc = "&lt;"
		case '>':
			esc = "&gt;"
		case '"':
			
			esc = "&#34;"
		case '\r':
			esc = "&#13;"
		default:
			panic("unrecognized escape character")
		}
		s = s[i+1:]
		if _, err := w.WriteString(esc); err != nil {
			return err
		}
		i = strings.IndexAny(s, escapedChars)
	}
	_, err := w.WriteString(s)
	return err
}
func EscapeString(s string) string {
	if strings.IndexAny(s, escapedChars) == -1 {
		return s
	}
	var buf bytes.Buffer
	escape(&buf, s)
	return buf.String()
}
func UnescapeString(s string) string {
	for _, c := range s {
		if c == '&' {
			return string(unescape([]byte(s), false))
		}
	}
	return s
}
package html
import (
	"bufio"
	"errors"
	"fmt"
	"io"
	"strings"
)
type writer interface {
	io.Writer
	io.ByteWriter
	WriteString(string) (int, error)
}
func Render(w io.Writer, n *Node) error {
	if x, ok := w.(writer); ok {
		return render(x, n)
	}
	buf := bufio.NewWriter(w)
	if err := render(buf, n); err != nil {
		return err
	}
	return buf.Flush()
}
var plaintextAbort = errors.New("html: internal error (plaintext abort)")
func render(w writer, n *Node) error {
	err := render1(w, n)
	if err == plaintextAbort {
		err = nil
	}
	return err
}
func render1(w writer, n *Node) error {
	
	switch n.Type {
	case ErrorNode:
		return errors.New("html: cannot render an ErrorNode node")
	case TextNode:
		return escape(w, n.Data)
	case DocumentNode:
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			if err := render1(w, c); err != nil {
				return err
			}
		}
		return nil
	case ElementNode:
		
	case CommentNode:
		if _, err := w.WriteString("<!--"); err != nil {
			return err
		}
		if _, err := w.WriteString(n.Data); err != nil {
			return err
		}
		if _, err := w.WriteString("-->"); err != nil {
			return err
		}
		return nil
	case DoctypeNode:
		if _, err := w.WriteString("<!DOCTYPE "); err != nil {
			return err
		}
		if _, err := w.WriteString(n.Data); err != nil {
			return err
		}
		if n.Attr != nil {
			var p, s string
			for _, a := range n.Attr {
				switch a.Key {
				case "public":
					p = a.Val
				case "system":
					s = a.Val
				}
			}
			if p != "" {
				if _, err := w.WriteString(" PUBLIC "); err != nil {
					return err
				}
				if err := writeQuoted(w, p); err != nil {
					return err
				}
				if s != "" {
					if err := w.WriteByte(' '); err != nil {
						return err
					}
					if err := writeQuoted(w, s); err != nil {
						return err
					}
				}
			} else if s != "" {
				if _, err := w.WriteString(" SYSTEM "); err != nil {
					return err
				}
				if err := writeQuoted(w, s); err != nil {
					return err
				}
			}
		}
		return w.WriteByte('>')
	default:
		return errors.New("html: unknown node type")
	}
	
	if err := w.WriteByte('<'); err != nil {
		return err
	}
	if _, err := w.WriteString(n.Data); err != nil {
		return err
	}
	for _, a := range n.Attr {
		if err := w.WriteByte(' '); err != nil {
			return err
		}
		if a.Namespace != "" {
			if _, err := w.WriteString(a.Namespace); err != nil {
				return err
			}
			if err := w.WriteByte(':'); err != nil {
				return err
			}
		}
		if _, err := w.WriteString(a.Key); err != nil {
			return err
		}
		if _, err := w.WriteString(`="`); err != nil {
			return err
		}
		if err := escape(w, a.Val); err != nil {
			return err
		}
		if err := w.WriteByte('"'); err != nil {
			return err
		}
	}
	if voidElements[n.Data] {
		if n.FirstChild != nil {
			return fmt.Errorf("html: void element <%s> has child nodes", n.Data)
		}
		_, err := w.WriteString("
		return err
	}
	if err := w.WriteByte('>'); err != nil {
		return err
	}
	
	if c := n.FirstChild; c != nil && c.Type == TextNode && strings.HasPrefix(c.Data, "\n") {
		switch n.Data {
		case "pre", "listing", "textarea":
			if err := w.WriteByte('\n'); err != nil {
				return err
			}
		}
	}
	
	switch n.Data {
	case "iframe", "noembed", "noframes", "noscript", "plaintext", "script", "style", "xmp":
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			if c.Type == TextNode {
				if _, err := w.WriteString(c.Data); err != nil {
					return err
				}
			} else {
				if err := render1(w, c); err != nil {
					return err
				}
			}
		}
		if n.Data == "plaintext" {
			
			
			return plaintextAbort
		}
	default:
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			if err := render1(w, c); err != nil {
				return err
			}
		}
	}
	
	if _, err := w.WriteString("<
		return err
	}
	if _, err := w.WriteString(n.Data); err != nil {
		return err
	}
	return w.WriteByte('>')
}
func writeQuoted(w writer, s string) error {
	var q byte = '"'
	if strings.Contains(s, `"`) {
		q = '\''
	}
	if err := w.WriteByte(q); err != nil {
		return err
	}
	if _, err := w.WriteString(s); err != nil {
		return err
	}
	if err := w.WriteByte(q); err != nil {
		return err
	}
	return nil
}
var voidElements = map[string]bool{
	"area":    true,
	"base":    true,
	"br":      true,
	"col":     true,
	"command": true,
	"embed":   true,
	"hr":      true,
	"img":     true,
	"input":   true,
	"keygen":  true,
	"link":    true,
	"meta":    true,
	"param":   true,
	"source":  true,
	"track":   true,
	"wbr":     true,
}
package lif
var (
	littleEndian binaryLittleEndian
	bigEndian    binaryBigEndian
)
type binaryByteOrder interface {
	Uint16([]byte) uint16
	Uint32([]byte) uint32
	Uint64([]byte) uint64
	PutUint16([]byte, uint16)
	PutUint32([]byte, uint32)
	PutUint64([]byte, uint64)
}
type binaryLittleEndian struct{}
func (binaryLittleEndian) Uint16(b []byte) uint16 {
	_ = b[1] 
	return uint16(b[0]) | uint16(b[1])<<8
}
func (binaryLittleEndian) PutUint16(b []byte, v uint16) {
	_ = b[1] 
	b[0] = byte(v)
	b[1] = byte(v >> 8)
}
func (binaryLittleEndian) Uint32(b []byte) uint32 {
	_ = b[3] 
	return uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24
}
func (binaryLittleEndian) PutUint32(b []byte, v uint32) {
	_ = b[3] 
	b[0] = byte(v)
	b[1] = byte(v >> 8)
	b[2] = byte(v >> 16)
	b[3] = byte(v >> 24)
}
func (binaryLittleEndian) Uint64(b []byte) uint64 {
	_ = b[7] 
	return uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 |
		uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56
}
func (binaryLittleEndian) PutUint64(b []byte, v uint64) {
	_ = b[7] 
	b[0] = byte(v)
	b[1] = byte(v >> 8)
	b[2] = byte(v >> 16)
	b[3] = byte(v >> 24)
	b[4] = byte(v >> 32)
	b[5] = byte(v >> 40)
	b[6] = byte(v >> 48)
	b[7] = byte(v >> 56)
}
type binaryBigEndian struct{}
func (binaryBigEndian) Uint16(b []byte) uint16 {
	_ = b[1] 
	return uint16(b[1]) | uint16(b[0])<<8
}
func (binaryBigEndian) PutUint16(b []byte, v uint16) {
	_ = b[1] 
	b[0] = byte(v >> 8)
	b[1] = byte(v)
}
func (binaryBigEndian) Uint32(b []byte) uint32 {
	_ = b[3] 
	return uint32(b[3]) | uint32(b[2])<<8 | uint32(b[1])<<16 | uint32(b[0])<<24
}
func (binaryBigEndian) PutUint32(b []byte, v uint32) {
	_ = b[3] 
	b[0] = byte(v >> 24)
	b[1] = byte(v >> 16)
	b[2] = byte(v >> 8)
	b[3] = byte(v)
}
func (binaryBigEndian) Uint64(b []byte) uint64 {
	_ = b[7] 
	return uint64(b[7]) | uint64(b[6])<<8 | uint64(b[5])<<16 | uint64(b[4])<<24 |
		uint64(b[3])<<32 | uint64(b[2])<<40 | uint64(b[1])<<48 | uint64(b[0])<<56
}
func (binaryBigEndian) PutUint64(b []byte, v uint64) {
	_ = b[7] 
	b[0] = byte(v >> 56)
	b[1] = byte(v >> 48)
	b[2] = byte(v >> 40)
	b[3] = byte(v >> 32)
	b[4] = byte(v >> 24)
	b[5] = byte(v >> 16)
	b[6] = byte(v >> 8)
	b[7] = byte(v)
}
package lif
import "unsafe"
type Link struct {
	Name  string 
	Index int    
	Type  int    
	Flags int    
	MTU   int    
	Addr  []byte 
}
func (ll *Link) fetch(s uintptr) {
	var lifr lifreq
	for i := 0; i < len(ll.Name); i++ {
		lifr.Name[i] = int8(ll.Name[i])
	}
	ioc := int64(sysSIOCGLIFINDEX)
	if err := ioctl(s, uintptr(ioc), unsafe.Pointer(&lifr)); err == nil {
		ll.Index = int(nativeEndian.Uint32(lifr.Lifru[:4]))
	}
	ioc = int64(sysSIOCGLIFFLAGS)
	if err := ioctl(s, uintptr(ioc), unsafe.Pointer(&lifr)); err == nil {
		ll.Flags = int(nativeEndian.Uint64(lifr.Lifru[:8]))
	}
	ioc = int64(sysSIOCGLIFMTU)
	if err := ioctl(s, uintptr(ioc), unsafe.Pointer(&lifr)); err == nil {
		ll.MTU = int(nativeEndian.Uint32(lifr.Lifru[:4]))
	}
	switch ll.Type {
	case sysIFT_IPV4, sysIFT_IPV6, sysIFT_6TO4:
	default:
		ioc = int64(sysSIOCGLIFHWADDR)
		if err := ioctl(s, uintptr(ioc), unsafe.Pointer(&lifr)); err == nil {
			ll.Addr, _ = parseLinkAddr(lifr.Lifru[4:])
		}
	}
}
func Links(af int, name string) ([]Link, error) {
	eps, err := newEndpoints(af)
	if len(eps) == 0 {
		return nil, err
	}
	defer func() {
		for _, ep := range eps {
			ep.close()
		}
	}()
	return links(eps, name)
}
func links(eps []endpoint, name string) ([]Link, error) {
	var lls []Link
	lifn := lifnum{Flags: sysLIFC_NOXMIT | sysLIFC_TEMPORARY | sysLIFC_ALLZONES | sysLIFC_UNDER_IPMP}
	lifc := lifconf{Flags: sysLIFC_NOXMIT | sysLIFC_TEMPORARY | sysLIFC_ALLZONES | sysLIFC_UNDER_IPMP}
	for _, ep := range eps {
		lifn.Family = uint16(ep.af)
		ioc := int64(sysSIOCGLIFNUM)
		if err := ioctl(ep.s, uintptr(ioc), unsafe.Pointer(&lifn)); err != nil {
			continue
		}
		if lifn.Count == 0 {
			continue
		}
		b := make([]byte, lifn.Count*sizeofLifreq)
		lifc.Family = uint16(ep.af)
		lifc.Len = lifn.Count * sizeofLifreq
		if len(lifc.Lifcu) == 8 {
			nativeEndian.PutUint64(lifc.Lifcu[:], uint64(uintptr(unsafe.Pointer(&b[0]))))
		} else {
			nativeEndian.PutUint32(lifc.Lifcu[:], uint32(uintptr(unsafe.Pointer(&b[0]))))
		}
		ioc = int64(sysSIOCGLIFCONF)
		if err := ioctl(ep.s, uintptr(ioc), unsafe.Pointer(&lifc)); err != nil {
			continue
		}
		nb := make([]byte, 32) 
		for i := 0; i < int(lifn.Count); i++ {
			lifr := (*lifreq)(unsafe.Pointer(&b[i*sizeofLifreq]))
			for i := 0; i < 32; i++ {
				if lifr.Name[i] == 0 {
					nb = nb[:i]
					break
				}
				nb[i] = byte(lifr.Name[i])
			}
			llname := string(nb)
			nb = nb[:32]
			if isDupLink(lls, llname) || name != "" && name != llname {
				continue
			}
			ll := Link{Name: llname, Type: int(lifr.Type)}
			ll.fetch(ep.s)
			lls = append(lls, ll)
		}
	}
	return lls, nil
}
func isDupLink(lls []Link, name string) bool {
	for _, ll := range lls {
		if ll.Name == name {
			return true
		}
	}
	return false
}
package lif
import (
	"fmt"
	"testing"
)
type addrFamily int
func (af addrFamily) String() string {
	switch af {
	case sysAF_UNSPEC:
		return "unspec"
	case sysAF_INET:
		return "inet4"
	case sysAF_INET6:
		return "inet6"
	default:
		return fmt.Sprintf("%d", af)
	}
}
const hexDigit = "0123456789abcdef"
type llAddr []byte
func (a llAddr) String() string {
	if len(a) == 0 {
		return ""
	}
	buf := make([]byte, 0, len(a)*3-1)
	for i, b := range a {
		if i > 0 {
			buf = append(buf, ':')
		}
		buf = append(buf, hexDigit[b>>4])
		buf = append(buf, hexDigit[b&0xF])
	}
	return string(buf)
}
type ipAddr []byte
func (a ipAddr) String() string {
	if len(a) == 0 {
		return "<nil>"
	}
	if len(a) == 4 {
		return fmt.Sprintf("%d.%d.%d.%d", a[0], a[1], a[2], a[3])
	}
	if len(a) == 16 {
		return fmt.Sprintf("%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x", a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15])
	}
	s := make([]byte, len(a)*2)
	for i, tn := range a {
		s[i*2], s[i*2+1] = hexDigit[tn>>4], hexDigit[tn&0xf]
	}
	return string(s)
}
func (a *Inet4Addr) String() string {
	return fmt.Sprintf("(%s %s %d)", addrFamily(a.Family()), ipAddr(a.IP[:]), a.PrefixLen)
}
func (a *Inet6Addr) String() string {
	return fmt.Sprintf("(%s %s %d %d)", addrFamily(a.Family()), ipAddr(a.IP[:]), a.PrefixLen, a.ZoneID)
}
type addrPack struct {
	af int
	as []Addr
}
func addrPacks() ([]addrPack, error) {
	var lastErr error
	var aps []addrPack
	for _, af := range [...]int{sysAF_UNSPEC, sysAF_INET, sysAF_INET6} {
		as, err := Addrs(af, "")
		if err != nil {
			lastErr = err
			continue
		}
		aps = append(aps, addrPack{af: af, as: as})
	}
	return aps, lastErr
}
func TestAddrs(t *testing.T) {
	aps, err := addrPacks()
	if len(aps) == 0 && err != nil {
		t.Fatal(err)
	}
	lps, err := linkPacks()
	if len(lps) == 0 && err != nil {
		t.Fatal(err)
	}
	for _, lp := range lps {
		n := 0
		for _, ll := range lp.lls {
			as, err := Addrs(lp.af, ll.Name)
			if err != nil {
				t.Fatal(lp.af, ll.Name, err)
			}
			t.Logf("af=%s name=%s %v", addrFamily(lp.af), ll.Name, as)
			n += len(as)
		}
		for _, ap := range aps {
			if ap.af != lp.af {
				continue
			}
			if n != len(ap.as) {
				t.Errorf("af=%s got %d; want %d", addrFamily(lp.af), n, len(ap.as))
				continue
			}
		}
	}
}
package lif
import (
	"fmt"
	"testing"
)
func (ll *Link) String() string {
	return fmt.Sprintf("name=%s index=%d type=%d flags=%#x mtu=%d addr=%v", ll.Name, ll.Index, ll.Type, ll.Flags, ll.MTU, llAddr(ll.Addr))
}
type linkPack struct {
	af  int
	lls []Link
}
func linkPacks() ([]linkPack, error) {
	var lastErr error
	var lps []linkPack
	for _, af := range [...]int{sysAF_UNSPEC, sysAF_INET, sysAF_INET6} {
		lls, err := Links(af, "")
		if err != nil {
			lastErr = err
			continue
		}
		lps = append(lps, linkPack{af: af, lls: lls})
	}
	return lps, lastErr
}
func TestLinks(t *testing.T) {
	lps, err := linkPacks()
	if len(lps) == 0 && err != nil {
		t.Fatal(err)
	}
	for _, lp := range lps {
		n := 0
		for _, sll := range lp.lls {
			lls, err := Links(lp.af, sll.Name)
			if err != nil {
				t.Fatal(lp.af, sll.Name, err)
			}
			for _, ll := range lls {
				if ll.Name != sll.Name || ll.Index != sll.Index {
					t.Errorf("af=%s got %v; want %v", addrFamily(lp.af), &ll, &sll)
					continue
				}
				t.Logf("af=%s name=%s %v", addrFamily(lp.af), sll.Name, &ll)
				n++
			}
		}
		if n != len(lp.lls) {
			t.Errorf("af=%s got %d; want %d", addrFamily(lp.af), n, len(lp.lls))
			continue
		}
	}
}
package lif
import "syscall"
type endpoint struct {
	af int
	s  uintptr
}
func (ep *endpoint) close() error {
	return syscall.Close(int(ep.s))
}
func newEndpoints(af int) ([]endpoint, error) {
	var lastErr error
	var eps []endpoint
	afs := []int{sysAF_INET, sysAF_INET6}
	if af != sysAF_UNSPEC {
		afs = []int{af}
	}
	for _, af := range afs {
		s, err := syscall.Socket(af, sysSOCK_DGRAM, 0)
		if err != nil {
			lastErr = err
			continue
		}
		eps = append(eps, endpoint{af: af, s: uintptr(s)})
	}
	if len(eps) == 0 {
		return nil, lastErr
	}
	return eps, nil
}
package lif
#include <sys
#include <sys
#include <net
#include <net
*
import "C"
const (
	sysAF_UNSPEC = C.AF_UNSPEC
	sysAF_INET   = C.AF_INET
	sysAF_INET6  = C.AF_INET6
	sysSOCK_DGRAM = C.SOCK_DGRAM
)
type sockaddrStorage C.struct_sockaddr_storage
const (
	sysLIFC_NOXMIT          = C.LIFC_NOXMIT
	sysLIFC_EXTERNAL_SOURCE = C.LIFC_EXTERNAL_SOURCE
	sysLIFC_TEMPORARY       = C.LIFC_TEMPORARY
	sysLIFC_ALLZONES        = C.LIFC_ALLZONES
	sysLIFC_UNDER_IPMP      = C.LIFC_UNDER_IPMP
	sysLIFC_ENABLED         = C.LIFC_ENABLED
	sysSIOCGLIFADDR    = C.SIOCGLIFADDR
	sysSIOCGLIFDSTADDR = C.SIOCGLIFDSTADDR
	sysSIOCGLIFFLAGS   = C.SIOCGLIFFLAGS
	sysSIOCGLIFMTU     = C.SIOCGLIFMTU
	sysSIOCGLIFNETMASK = C.SIOCGLIFNETMASK
	sysSIOCGLIFMETRIC  = C.SIOCGLIFMETRIC
	sysSIOCGLIFNUM     = C.SIOCGLIFNUM
	sysSIOCGLIFINDEX   = C.SIOCGLIFINDEX
	sysSIOCGLIFSUBNET  = C.SIOCGLIFSUBNET
	sysSIOCGLIFLNKINFO = C.SIOCGLIFLNKINFO
	sysSIOCGLIFCONF    = C.SIOCGLIFCONF
	sysSIOCGLIFHWADDR  = C.SIOCGLIFHWADDR
)
const (
	sysIFF_UP          = C.IFF_UP
	sysIFF_BROADCAST   = C.IFF_BROADCAST
	sysIFF_DEBUG       = C.IFF_DEBUG
	sysIFF_LOOPBACK    = C.IFF_LOOPBACK
	sysIFF_POINTOPOINT = C.IFF_POINTOPOINT
	sysIFF_NOTRAILERS  = C.IFF_NOTRAILERS
	sysIFF_RUNNING     = C.IFF_RUNNING
	sysIFF_NOARP       = C.IFF_NOARP
	sysIFF_PROMISC     = C.IFF_PROMISC
	sysIFF_ALLMULTI    = C.IFF_ALLMULTI
	sysIFF_INTELLIGENT = C.IFF_INTELLIGENT
	sysIFF_MULTICAST   = C.IFF_MULTICAST
	sysIFF_MULTI_BCAST = C.IFF_MULTI_BCAST
	sysIFF_UNNUMBERED  = C.IFF_UNNUMBERED
	sysIFF_PRIVATE     = C.IFF_PRIVATE
)
const (
	sizeofLifnum       = C.sizeof_struct_lifnum
	sizeofLifreq       = C.sizeof_struct_lifreq
	sizeofLifconf      = C.sizeof_struct_lifconf
	sizeofLifIfinfoReq = C.sizeof_struct_lif_ifinfo_req
)
type lifnum C.struct_lifnum
type lifreq C.struct_lifreq
type lifconf C.struct_lifconf
type lifIfinfoReq C.struct_lif_ifinfo_req
const (
	sysIFT_IPV4 = C.IFT_IPV4
	sysIFT_IPV6 = C.IFT_IPV6
	sysIFT_6TO4 = C.IFT_6TO4
)
package lif
const (
	sysAF_UNSPEC = 0x0
	sysAF_INET   = 0x2
	sysAF_INET6  = 0x1a
	sysSOCK_DGRAM = 0x1
)
type sockaddrStorage struct {
	Family     uint16
	X_ss_pad1  [6]int8
	X_ss_align float64
	X_ss_pad2  [240]int8
}
const (
	sysLIFC_NOXMIT          = 0x1
	sysLIFC_EXTERNAL_SOURCE = 0x2
	sysLIFC_TEMPORARY       = 0x4
	sysLIFC_ALLZONES        = 0x8
	sysLIFC_UNDER_IPMP      = 0x10
	sysLIFC_ENABLED         = 0x20
	sysSIOCGLIFADDR    = -0x3f87968f
	sysSIOCGLIFDSTADDR = -0x3f87968d
	sysSIOCGLIFFLAGS   = -0x3f87968b
	sysSIOCGLIFMTU     = -0x3f879686
	sysSIOCGLIFNETMASK = -0x3f879683
	sysSIOCGLIFMETRIC  = -0x3f879681
	sysSIOCGLIFNUM     = -0x3ff3967e
	sysSIOCGLIFINDEX   = -0x3f87967b
	sysSIOCGLIFSUBNET  = -0x3f879676
	sysSIOCGLIFLNKINFO = -0x3f879674
	sysSIOCGLIFCONF    = -0x3fef965b
	sysSIOCGLIFHWADDR  = -0x3f879640
)
const (
	sysIFF_UP          = 0x1
	sysIFF_BROADCAST   = 0x2
	sysIFF_DEBUG       = 0x4
	sysIFF_LOOPBACK    = 0x8
	sysIFF_POINTOPOINT = 0x10
	sysIFF_NOTRAILERS  = 0x20
	sysIFF_RUNNING     = 0x40
	sysIFF_NOARP       = 0x80
	sysIFF_PROMISC     = 0x100
	sysIFF_ALLMULTI    = 0x200
	sysIFF_INTELLIGENT = 0x400
	sysIFF_MULTICAST   = 0x800
	sysIFF_MULTI_BCAST = 0x1000
	sysIFF_UNNUMBERED  = 0x2000
	sysIFF_PRIVATE     = 0x8000
)
const (
	sizeofLifnum       = 0xc
	sizeofLifreq       = 0x178
	sizeofLifconf      = 0x18
	sizeofLifIfinfoReq = 0x10
)
type lifnum struct {
	Family    uint16
	Pad_cgo_0 [2]byte
	Flags     int32
	Count     int32
}
type lifreq struct {
	Name   [32]int8
	Lifru1 [4]byte
	Type   uint32
	Lifru  [336]byte
}
type lifconf struct {
	Family    uint16
	Pad_cgo_0 [2]byte
	Flags     int32
	Len       int32
	Pad_cgo_1 [4]byte
	Lifcu     [8]byte
}
type lifIfinfoReq struct {
	Maxhops      uint8
	Pad_cgo_0    [3]byte
	Reachtime    uint32
	Reachretrans uint32
	Maxmtu       uint32
}
const (
	sysIFT_IPV4 = 0xc8
	sysIFT_IPV6 = 0xc9
	sysIFT_6TO4 = 0xca
)
package lif
import "unsafe"
var nativeEndian binaryByteOrder
func init() {
	i := uint32(1)
	b := (*[4]byte)(unsafe.Pointer(&i))
	if b[0] == 1 {
		nativeEndian = littleEndian
	} else {
		nativeEndian = bigEndian
	}
}
package lif
import (
	"syscall"
	"unsafe"
)
var procIoctl uintptr
func sysvicall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (uintptr, uintptr, syscall.Errno)
func ioctl(s, ioc uintptr, arg unsafe.Pointer) error {
	_, _, errno := sysvicall6(uintptr(unsafe.Pointer(&procIoctl)), 3, s, ioc, uintptr(arg), 0, 0, 0)
	if errno != 0 {
		return error(errno)
	}
	return nil
}
package lif
import (
	"errors"
	"unsafe"
)
type Addr interface {
	
	Family() int
}
type Inet4Addr struct {
	IP        [4]byte 
	PrefixLen int     
}
func (a *Inet4Addr) Family() int { return sysAF_INET }
type Inet6Addr struct {
	IP        [16]byte 
	PrefixLen int      
	ZoneID    int      
}
func (a *Inet6Addr) Family() int { return sysAF_INET6 }
func Addrs(af int, name string) ([]Addr, error) {
	eps, err := newEndpoints(af)
	if len(eps) == 0 {
		return nil, err
	}
	defer func() {
		for _, ep := range eps {
			ep.close()
		}
	}()
	lls, err := links(eps, name)
	if len(lls) == 0 {
		return nil, err
	}
	var as []Addr
	for _, ll := range lls {
		var lifr lifreq
		for i := 0; i < len(ll.Name); i++ {
			lifr.Name[i] = int8(ll.Name[i])
		}
		for _, ep := range eps {
			ioc := int64(sysSIOCGLIFADDR)
			err := ioctl(ep.s, uintptr(ioc), unsafe.Pointer(&lifr))
			if err != nil {
				continue
			}
			sa := (*sockaddrStorage)(unsafe.Pointer(&lifr.Lifru[0]))
			l := int(nativeEndian.Uint32(lifr.Lifru1[:4]))
			if l == 0 {
				continue
			}
			switch sa.Family {
			case sysAF_INET:
				a := &Inet4Addr{PrefixLen: l}
				copy(a.IP[:], lifr.Lifru[4:8])
				as = append(as, a)
			case sysAF_INET6:
				a := &Inet6Addr{PrefixLen: l, ZoneID: int(nativeEndian.Uint32(lifr.Lifru[24:28]))}
				copy(a.IP[:], lifr.Lifru[8:24])
				as = append(as, a)
			}
		}
	}
	return as, nil
}
func parseLinkAddr(b []byte) ([]byte, error) {
	nlen, alen, slen := int(b[1]), int(b[2]), int(b[3])
	l := 4 + nlen + alen + slen
	if len(b) < l {
		return nil, errors.New("invalid address")
	}
	b = b[4:]
	var addr []byte
	if nlen > 0 {
		b = b[nlen:]
	}
	if alen > 0 {
		addr = make([]byte, alen)
		copy(addr, b[:alen])
	}
	return addr, nil
}
package main
import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"go
	"io"
	"io
	"net
	"os"
	"regexp"
	"sort"
	"strings"
	"golang.org
)
const (
	
	nodesBitsChildren   = 9
	nodesBitsICANN      = 1
	nodesBitsTextOffset = 15
	nodesBitsTextLength = 6
	
	childrenBitsWildcard = 1
	childrenBitsNodeType = 2
	childrenBitsHi       = 14
	childrenBitsLo       = 14
)
var (
	maxChildren   int
	maxTextOffset int
	maxTextLength int
	maxHi         uint32
	maxLo         uint32
)
func max(a, b int) int {
	if a < b {
		return b
	}
	return a
}
func u32max(a, b uint32) uint32 {
	if a < b {
		return b
	}
	return a
}
const (
	nodeTypeNormal     = 0
	nodeTypeException  = 1
	nodeTypeParentOnly = 2
	numNodeType        = 3
)
func nodeTypeStr(n int) string {
	switch n {
	case nodeTypeNormal:
		return "+"
	case nodeTypeException:
		return "!"
	case nodeTypeParentOnly:
		return "o"
	}
	panic("unreachable")
}
const (
	defaultURL   = "https:
	gitCommitURL = "https:
)
var (
	labelEncoding = map[string]uint32{}
	labelsList    = []string{}
	labelsMap     = map[string]bool{}
	rules         = []string{}
	
	
	
	validSuffixRE = regexp.MustCompile(`^[a-z0-9_\!\*\-\.]+$`)
	shaRE  = regexp.MustCompile(`"sha":"([^"]+)"`)
	dateRE = regexp.MustCompile(`"committer":{[^{]+"date":"([^"]+)"`)
	comments = flag.Bool("comments", false, "generate table.go comments, for debugging")
	subset   = flag.Bool("subset", false, "generate only a subset of the full table, for debugging")
	url      = flag.String("url", defaultURL, "URL of the publicsuffix.org list. If empty, stdin is read instead")
	v        = flag.Bool("v", false, "verbose output (to stderr)")
	version  = flag.String("version", "", "the effective_tld_names.dat version")
)
func main() {
	if err := main1(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}
func main1() error {
	flag.Parse()
	if nodesBitsTextLength+nodesBitsTextOffset+nodesBitsICANN+nodesBitsChildren > 32 {
		return fmt.Errorf("not enough bits to encode the nodes table")
	}
	if childrenBitsLo+childrenBitsHi+childrenBitsNodeType+childrenBitsWildcard > 32 {
		return fmt.Errorf("not enough bits to encode the children table")
	}
	if *version == "" {
		if *url != defaultURL {
			return fmt.Errorf("-version was not specified, and the -url is not the default one")
		}
		sha, date, err := gitCommit()
		if err != nil {
			return err
		}
		*version = fmt.Sprintf("publicsuffix.org's public_suffix_list.dat, git revision %s (%s)", sha, date)
	}
	var r io.Reader = os.Stdin
	if *url != "" {
		res, err := http.Get(*url)
		if err != nil {
			return err
		}
		if res.StatusCode != http.StatusOK {
			return fmt.Errorf("bad GET status for %s: %d", *url, res.Status)
		}
		r = res.Body
		defer res.Body.Close()
	}
	var root node
	icann := false
	br := bufio.NewReader(r)
	for {
		s, err := br.ReadString('\n')
		if err != nil {
			if err == io.EOF {
				break
			}
			return err
		}
		s = strings.TrimSpace(s)
		if strings.Contains(s, "BEGIN ICANN DOMAINS") {
			icann = true
			continue
		}
		if strings.Contains(s, "END ICANN DOMAINS") {
			icann = false
			continue
		}
		if s == "" || strings.HasPrefix(s, "
			continue
		}
		s, err = idna.ToASCII(s)
		if err != nil {
			return err
		}
		if !validSuffixRE.MatchString(s) {
			return fmt.Errorf("bad publicsuffix.org list data: %q", s)
		}
		if *subset {
			switch {
			case s == "ac.jp" || strings.HasSuffix(s, ".ac.jp"):
			case s == "ak.us" || strings.HasSuffix(s, ".ak.us"):
			case s == "ao" || strings.HasSuffix(s, ".ao"):
			case s == "ar" || strings.HasSuffix(s, ".ar"):
			case s == "arpa" || strings.HasSuffix(s, ".arpa"):
			case s == "cy" || strings.HasSuffix(s, ".cy"):
			case s == "dyndns.org" || strings.HasSuffix(s, ".dyndns.org"):
			case s == "jp":
			case s == "kobe.jp" || strings.HasSuffix(s, ".kobe.jp"):
			case s == "kyoto.jp" || strings.HasSuffix(s, ".kyoto.jp"):
			case s == "om" || strings.HasSuffix(s, ".om"):
			case s == "uk" || strings.HasSuffix(s, ".uk"):
			case s == "uk.com" || strings.HasSuffix(s, ".uk.com"):
			case s == "tw" || strings.HasSuffix(s, ".tw"):
			case s == "zw" || strings.HasSuffix(s, ".zw"):
			case s == "xn--p1ai" || strings.HasSuffix(s, ".xn--p1ai"):
				
			default:
				continue
			}
		}
		rules = append(rules, s)
		nt, wildcard := nodeTypeNormal, false
		switch {
		case strings.HasPrefix(s, "*."):
			s, nt = s[2:], nodeTypeParentOnly
			wildcard = true
		case strings.HasPrefix(s, "!"):
			s, nt = s[1:], nodeTypeException
		}
		labels := strings.Split(s, ".")
		for n, i := &root, len(labels)-1; i >= 0; i-- {
			label := labels[i]
			n = n.child(label)
			if i == 0 {
				if nt != nodeTypeParentOnly && n.nodeType == nodeTypeParentOnly {
					n.nodeType = nt
				}
				n.icann = n.icann && icann
				n.wildcard = n.wildcard || wildcard
			}
			labelsMap[label] = true
		}
	}
	labelsList = make([]string, 0, len(labelsMap))
	for label := range labelsMap {
		labelsList = append(labelsList, label)
	}
	sort.Strings(labelsList)
	if err := generate(printReal, &root, "table.go"); err != nil {
		return err
	}
	if err := generate(printTest, &root, "table_test.go"); err != nil {
		return err
	}
	return nil
}
func generate(p func(io.Writer, *node) error, root *node, filename string) error {
	buf := new(bytes.Buffer)
	if err := p(buf, root); err != nil {
		return err
	}
	b, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}
	return ioutil.WriteFile(filename, b, 0644)
}
func gitCommit() (sha, date string, retErr error) {
	res, err := http.Get(gitCommitURL)
	if err != nil {
		return "", "", err
	}
	if res.StatusCode != http.StatusOK {
		return "", "", fmt.Errorf("bad GET status for %s: %d", gitCommitURL, res.Status)
	}
	defer res.Body.Close()
	b, err := ioutil.ReadAll(res.Body)
	if err != nil {
		return "", "", err
	}
	if m := shaRE.FindSubmatch(b); m != nil {
		sha = string(m[1])
	}
	if m := dateRE.FindSubmatch(b); m != nil {
		date = string(m[1])
	}
	if sha == "" || date == "" {
		retErr = fmt.Errorf("could not find commit SHA and date in %s", gitCommitURL)
	}
	return sha, date, retErr
}
func printTest(w io.Writer, n *node) error {
	fmt.Fprintf(w, "
	fmt.Fprintf(w, "package publicsuffix\n\nvar rules = [...]string{\n")
	for _, rule := range rules {
		fmt.Fprintf(w, "%q,\n", rule)
	}
	fmt.Fprintf(w, "}\n\nvar nodeLabels = [...]string{\n")
	if err := n.walk(w, printNodeLabel); err != nil {
		return err
	}
	fmt.Fprintf(w, "}\n")
	return nil
}
func printReal(w io.Writer, n *node) error {
	const header = `
package publicsuffix
const version = %q
const (
	nodesBitsChildren   = %d
	nodesBitsICANN      = %d
	nodesBitsTextOffset = %d
	nodesBitsTextLength = %d
	childrenBitsWildcard = %d
	childrenBitsNodeType = %d
	childrenBitsHi       = %d
	childrenBitsLo       = %d
)
const (
	nodeTypeNormal     = %d
	nodeTypeException  = %d
	nodeTypeParentOnly = %d
)
const numTLD = %d
`
	fmt.Fprintf(w, header, *version,
		nodesBitsChildren, nodesBitsICANN, nodesBitsTextOffset, nodesBitsTextLength,
		childrenBitsWildcard, childrenBitsNodeType, childrenBitsHi, childrenBitsLo,
		nodeTypeNormal, nodeTypeException, nodeTypeParentOnly, len(n.children))
	text := combineText(labelsList)
	if text == "" {
		return fmt.Errorf("internal error: makeText returned no text")
	}
	for _, label := range labelsList {
		offset, length := strings.Index(text, label), len(label)
		if offset < 0 {
			return fmt.Errorf("internal error: could not find %q in text %q", label, text)
		}
		maxTextOffset, maxTextLength = max(maxTextOffset, offset), max(maxTextLength, length)
		if offset >= 1<<nodesBitsTextOffset {
			return fmt.Errorf("text offset %d is too large, or nodeBitsTextOffset is too small", offset)
		}
		if length >= 1<<nodesBitsTextLength {
			return fmt.Errorf("text length %d is too large, or nodeBitsTextLength is too small", length)
		}
		labelEncoding[label] = uint32(offset)<<nodesBitsTextLength | uint32(length)
	}
	fmt.Fprintf(w, "
	for len(text) > 0 {
		n, plus := len(text), ""
		if n > 64 {
			n, plus = 64, " +"
		}
		fmt.Fprintf(w, "%q%s\n", text[:n], plus)
		text = text[n:]
	}
	if err := n.walk(w, assignIndexes); err != nil {
		return err
	}
	fmt.Fprintf(w, `
var nodes = [...]uint32{
`,
		32-nodesBitsChildren-nodesBitsICANN-nodesBitsTextOffset-nodesBitsTextLength,
		nodesBitsChildren, nodesBitsICANN, nodesBitsTextOffset, nodesBitsTextLength)
	if err := n.walk(w, printNode); err != nil {
		return err
	}
	fmt.Fprintf(w, `}
var children=[...]uint32{
`,
		32-childrenBitsWildcard-childrenBitsNodeType-childrenBitsHi-childrenBitsLo,
		childrenBitsWildcard, childrenBitsNodeType, childrenBitsHi, childrenBitsLo)
	for i, c := range childrenEncoding {
		s := "---------------"
		lo := c & (1<<childrenBitsLo - 1)
		hi := (c >> childrenBitsLo) & (1<<childrenBitsHi - 1)
		if lo != hi {
			s = fmt.Sprintf("n0x%04x-n0x%04x", lo, hi)
		}
		nodeType := int(c>>(childrenBitsLo+childrenBitsHi)) & (1<<childrenBitsNodeType - 1)
		wildcard := c>>(childrenBitsLo+childrenBitsHi+childrenBitsNodeType) != 0
		if *comments {
			fmt.Fprintf(w, "0x%08x, 
				c, i, s, wildcardStr(wildcard), nodeTypeStr(nodeType))
		} else {
			fmt.Fprintf(w, "0x%x,\n", c)
		}
	}
	fmt.Fprintf(w, "}\n\n")
	fmt.Fprintf(w, "
	fmt.Fprintf(w, "
	fmt.Fprintf(w, "
	fmt.Fprintf(w, "
	fmt.Fprintf(w, "
	return nil
}
type node struct {
	label    string
	nodeType int
	icann    bool
	wildcard bool
	
	
	nodesIndex, childrenIndex int
	
	
	firstChild int
	
	children []*node
}
func (n *node) walk(w io.Writer, f func(w1 io.Writer, n1 *node) error) error {
	if err := f(w, n); err != nil {
		return err
	}
	for _, c := range n.children {
		if err := c.walk(w, f); err != nil {
			return err
		}
	}
	return nil
}
func (n *node) child(label string) *node {
	for _, c := range n.children {
		if c.label == label {
			return c
		}
	}
	c := &node{
		label:    label,
		nodeType: nodeTypeParentOnly,
		icann:    true,
	}
	n.children = append(n.children, c)
	sort.Sort(byLabel(n.children))
	return c
}
type byLabel []*node
func (b byLabel) Len() int           { return len(b) }
func (b byLabel) Swap(i, j int)      { b[i], b[j] = b[j], b[i] }
func (b byLabel) Less(i, j int) bool { return b[i].label < b[j].label }
var nextNodesIndex int
var childrenEncoding = []uint32{
	0 << (childrenBitsLo + childrenBitsHi), 
	1 << (childrenBitsLo + childrenBitsHi), 
	2 << (childrenBitsLo + childrenBitsHi), 
	4 << (childrenBitsLo + childrenBitsHi), 
	5 << (childrenBitsLo + childrenBitsHi), 
	6 << (childrenBitsLo + childrenBitsHi), 
}
var firstCallToAssignIndexes = true
func assignIndexes(w io.Writer, n *node) error {
	if len(n.children) != 0 {
		
		n.firstChild = nextNodesIndex
		for _, c := range n.children {
			c.nodesIndex = nextNodesIndex
			nextNodesIndex++
		}
		
		if firstCallToAssignIndexes {
			firstCallToAssignIndexes = false
			return nil
		}
		
		maxChildren = max(maxChildren, len(childrenEncoding))
		if len(childrenEncoding) >= 1<<nodesBitsChildren {
			return fmt.Errorf("children table size %d is too large, or nodeBitsChildren is too small", len(childrenEncoding))
		}
		n.childrenIndex = len(childrenEncoding)
		lo := uint32(n.firstChild)
		hi := lo + uint32(len(n.children))
		maxLo, maxHi = u32max(maxLo, lo), u32max(maxHi, hi)
		if lo >= 1<<childrenBitsLo {
			return fmt.Errorf("children lo %d is too large, or childrenBitsLo is too small", lo)
		}
		if hi >= 1<<childrenBitsHi {
			return fmt.Errorf("children hi %d is too large, or childrenBitsHi is too small", hi)
		}
		enc := hi<<childrenBitsLo | lo
		enc |= uint32(n.nodeType) << (childrenBitsLo + childrenBitsHi)
		if n.wildcard {
			enc |= 1 << (childrenBitsLo + childrenBitsHi + childrenBitsNodeType)
		}
		childrenEncoding = append(childrenEncoding, enc)
	} else {
		n.childrenIndex = n.nodeType
		if n.wildcard {
			n.childrenIndex += numNodeType
		}
	}
	return nil
}
func printNode(w io.Writer, n *node) error {
	for _, c := range n.children {
		s := "---------------"
		if len(c.children) != 0 {
			s = fmt.Sprintf("n0x%04x-n0x%04x", c.firstChild, c.firstChild+len(c.children))
		}
		encoding := labelEncoding[c.label]
		if c.icann {
			encoding |= 1 << (nodesBitsTextLength + nodesBitsTextOffset)
		}
		encoding |= uint32(c.childrenIndex) << (nodesBitsTextLength + nodesBitsTextOffset + nodesBitsICANN)
		if *comments {
			fmt.Fprintf(w, "0x%08x, 
				encoding, c.nodesIndex, c.childrenIndex, s, wildcardStr(c.wildcard),
				nodeTypeStr(c.nodeType), icannStr(c.icann), c.label,
			)
		} else {
			fmt.Fprintf(w, "0x%x,\n", encoding)
		}
	}
	return nil
}
func printNodeLabel(w io.Writer, n *node) error {
	for _, c := range n.children {
		fmt.Fprintf(w, "%q,\n", c.label)
	}
	return nil
}
func icannStr(icann bool) string {
	if icann {
		return "I"
	}
	return " "
}
func wildcardStr(wildcard bool) string {
	if wildcard {
		return "*"
	}
	return " "
}
func combineText(labelsList []string) string {
	beforeLength := 0
	for _, s := range labelsList {
		beforeLength += len(s)
	}
	text := crush(removeSubstrings(labelsList))
	if *v {
		fmt.Fprintf(os.Stderr, "crushed %d bytes to become %d bytes\n", beforeLength, len(text))
	}
	return text
}
type byLength []string
func (s byLength) Len() int           { return len(s) }
func (s byLength) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }
func (s byLength) Less(i, j int) bool { return len(s[i]) < len(s[j]) }
func removeSubstrings(input []string) []string {
	
	ss := append(make([]string, 0, len(input)), input...)
	sort.Sort(byLength(ss))
	for i, shortString := range ss {
		
		
		for _, longString := range ss[i+1:] {
			if strings.Contains(longString, shortString) {
				ss[i] = ""
				break
			}
		}
	}
	
	sort.Strings(ss)
	for len(ss) > 0 && ss[0] == "" {
		ss = ss[1:]
	}
	return ss
}
func crush(ss []string) string {
	maxLabelLen := 0
	for _, s := range ss {
		if maxLabelLen < len(s) {
			maxLabelLen = len(s)
		}
	}
	for prefixLen := maxLabelLen; prefixLen > 0; prefixLen-- {
		prefixes := makePrefixMap(ss, prefixLen)
		for i, s := range ss {
			if len(s) <= prefixLen {
				continue
			}
			mergeLabel(ss, i, prefixLen, prefixes)
		}
	}
	return strings.Join(ss, "")
}
func mergeLabel(ss []string, i, prefixLen int, prefixes prefixMap) {
	s := ss[i]
	suffix := s[len(s)-prefixLen:]
	for _, j := range prefixes[suffix] {
		
		if ss[j] == "" || i == j {
			continue
		}
		if *v {
			fmt.Fprintf(os.Stderr, "%d-length overlap at (%4d,%4d): %q and %q share %q\n",
				prefixLen, i, j, ss[i], ss[j], suffix)
		}
		ss[i] += ss[j][prefixLen:]
		ss[j] = ""
		
		
		
		
		
		
		
		
		
		mergeLabel(ss, i, prefixLen, prefixes)
		return
	}
}
type prefixMap map[string][]int
func makePrefixMap(ss []string, prefixLen int) prefixMap {
	prefixes := make(prefixMap)
	for i, s := range ss {
		
		
		
		if prefixLen < len(s) {
			prefix := s[:prefixLen]
			prefixes[prefix] = append(prefixes[prefix], i)
		}
	}
	return prefixes
}
package publicsuffix 
import (
	"fmt"
	"net
	"strings"
)
var List cookiejar.PublicSuffixList = list{}
type list struct{}
func (list) PublicSuffix(domain string) string {
	ps, _ := PublicSuffix(domain)
	return ps
}
func (list) String() string {
	return version
}
func PublicSuffix(domain string) (publicSuffix string, icann bool) {
	lo, hi := uint32(0), uint32(numTLD)
	s, suffix, wildcard := domain, len(domain), false
loop:
	for {
		dot := strings.LastIndex(s, ".")
		if wildcard {
			suffix = 1 + dot
		}
		if lo == hi {
			break
		}
		f := find(s[1+dot:], lo, hi)
		if f == notFound {
			break
		}
		u := nodes[f] >> (nodesBitsTextOffset + nodesBitsTextLength)
		icann = u&(1<<nodesBitsICANN-1) != 0
		u >>= nodesBitsICANN
		u = children[u&(1<<nodesBitsChildren-1)]
		lo = u & (1<<childrenBitsLo - 1)
		u >>= childrenBitsLo
		hi = u & (1<<childrenBitsHi - 1)
		u >>= childrenBitsHi
		switch u & (1<<childrenBitsNodeType - 1) {
		case nodeTypeNormal:
			suffix = 1 + dot
		case nodeTypeException:
			suffix = 1 + len(s)
			break loop
		}
		u >>= childrenBitsNodeType
		wildcard = u&(1<<childrenBitsWildcard-1) != 0
		if dot == -1 {
			break
		}
		s = s[:dot]
	}
	if suffix == len(domain) {
		
		return domain[1+strings.LastIndex(domain, "."):], icann
	}
	return domain[suffix:], icann
}
const notFound uint32 = 1<<32 - 1
func find(label string, lo, hi uint32) uint32 {
	for lo < hi {
		mid := lo + (hi-lo)
		s := nodeLabel(mid)
		if s < label {
			lo = mid + 1
		} else if s == label {
			return mid
		} else {
			hi = mid
		}
	}
	return notFound
}
func nodeLabel(i uint32) string {
	x := nodes[i]
	length := x & (1<<nodesBitsTextLength - 1)
	x >>= nodesBitsTextLength
	offset := x & (1<<nodesBitsTextOffset - 1)
	return text[offset : offset+length]
}
func EffectiveTLDPlusOne(domain string) (string, error) {
	suffix, _ := PublicSuffix(domain)
	if len(domain) <= len(suffix) {
		return "", fmt.Errorf("publicsuffix: cannot derive eTLD+1 for domain %q", domain)
	}
	i := len(domain) - len(suffix) - 1
	if domain[i] != '.' {
		return "", fmt.Errorf("publicsuffix: invalid public suffix %q for domain %q", suffix, domain)
	}
	return domain[1+strings.LastIndex(domain[:i], "."):], nil
}
package publicsuffix
const version = "publicsuffix.org's public_suffix_list.dat, git revision f47d806df99585862c8426c3e064a50eb5a278f5 (2017-06-14T11:49:01Z)"
const (
	nodesBitsChildren   = 9
	nodesBitsICANN      = 1
	nodesBitsTextOffset = 15
	nodesBitsTextLength = 6
	childrenBitsWildcard = 1
	childrenBitsNodeType = 2
	childrenBitsHi       = 14
	childrenBitsLo       = 14
)
const (
	nodeTypeNormal     = 0
	nodeTypeException  = 1
	nodeTypeParentOnly = 2
)
const numTLD = 1549
const text = "bifukagawalterbihorologybikedagestangeorgeorgiaxasnesoddenmarkha" +
	"ngelskjakdnepropetrovskiervaapsteiermarkaragandabruzzoologicalvi" +
	"nklein-addrammenuernberggfarmerseine12bilbaogakidsmynasushiobara" +
	"gusartsalangeninohekinannestadray-dnsiskinkyotobetsumidatlantica" +
	"tholicheltenham-radio-opencraftranagatorodoybillustrationinomiya" +
	"konojosoyrorosalondonetskarpaczeladzjavald-aostarnbergladegreevj" +
	"e-og-hornnesaltdalimitedraydnsupdaternopilawabioceanographiquebi" +
	"rdartcenterprisesakikuchikuseikarugamvikaruizawabirkenesoddtange" +
	"novaraumalopolskanlandrivelandrobaknoluoktachikawakembuchikumaga" +
	"yagawakkanaibetsubamericanfamilydscloudcontrolledekafjordrudunsa" +
	"lvadordalibabalatinord-aurdalvdalaskanittedallasalleasinglesuran" +
	"certmgretagajobojinzais-a-candidatebirthplacebjarkoybjerkreimbal" +
	"sfjordgcahcesuolocus-1bjugnirasakis-a-catererblockbustermezlglas" +
	"sassinationalheritagematsubarakawagoebloombergbauernishiazais-a-" +
	"celticsfanishigoddabloxcmsalzburgliwicebluedancebmoattachmentsam" +
	"egawabmsamnangerbmwegroweibolzanordkappgafanquannefrankfurtjmaxx" +
	"xboxenapponazure-mobilebnpparibaselburglobalashovhachinohedmarka" +
	"rumaifarmsteadupontariomutashinais-a-chefarsundurbanamexnethnolo" +
	"gybnrweirbonnishiharabookinglobodoes-itvedestrandurhamburglogowf" +
	"ashionishiizunazukis-a-conservativefsnillfjordvrcambridgestonexu" +
	"s-2bootsamsclubindalimoliserniaboschaefflerdalindashorokanaiebos" +
	"tikasaokaminokawanishiaizubangebostonakijinsekikogentingloppenza" +
	"ogashimadachicagoboatsamsungmbhartiffanybotanicalgardenishikatak" +
	"ayamatta-varjjatjometlifeinsurancebotanicgardenishikatsuragithub" +
	"usercontentjxfinitybotanybouncemerckmsdnipropetrovskjervoyagebou" +
	"nty-fullensakerrypropertiesandvikcoromantovalle-d-aostatic-acces" +
	"sanfranciscofreakunemurorangeiseiyoichippubetsubetsugaruhrboutiq" +
	"uebecngminakamichiharabozentsujiiebplacedogawarabikomaezakirunor" +
	"dlandvrdnsangoppdalindesnesanjournalismailillesandefjordyndns-at" +
	"-workinggroupaleobrandywinevalleybrasiliabresciabrindisibenikebr" +
	"istoloslocalhistorybritishcolumbialowiezachpomorskienishikawazuk" +
	"amitondabayashiogamagoriziabroadcastlegallocalhostrodawaravennag" +
	"asukebroadwaybroke-itkmaxxjaworznowtvalled-aostavangerbrokerbron" +
	"noysundyndns-blogdnsannanishimerabrothermesaverdeatnurembergmode" +
	"nakasatsunais-a-cpadualstackspace-to-rentalstomakomaibarabrowser" +
	"safetymarketsannohelplfinancialivornobrumunddalombardiamondsanok" +
	"ashibatakashimaseratis-a-cubicle-slavellinotteroybrunelasticbean" +
	"stalkashiharabrusselsantabarbarabruxellesantacruzsantafedjeffers" +
	"onishinomiyashironobryanskleppalermomahachijorpelandyndns-freebo" +
	"x-ostrowwlkpmgmxn--0trq7p7nnishinoomotegobrynewhollandyndns-home" +
	"dnsanukis-a-democratmpalmspringsakerbuskerudinewmexicodyn-vpnplu" +
	"sterbuzenishinoshimattelefonicarbonia-iglesias-carboniaiglesiasc" +
	"arboniabuzzpamperedchefastlylbaltimore-og-romsdalwaysdatabasebal" +
	"langenoamishirasatochigiessensiositelemarkarateu-1bwhalingrimsta" +
	"dyndns-ipirangaulardalombardynamisches-dnsaotomemergencyachtsapo" +
	"dlasiellaktyubinskiptveterinairealtorlandyndns-mailomzaporizhzhe" +
	"guris-a-designerimarumorimachidabzhitomirumalselvendrellorenskog" +
	"ripescaravantaacondoshichinohealth-carereformitakeharaconference" +
	"constructionconsuladoesntexistanbullensvanguardyndns1consultanth" +
	"ropologyconsultingvolluroycontactoyotsukaidownloadynnsaskatchewa" +
	"ncontemporaryarteducationalchikugodoharuovatoyouracontractorsken" +
	"conventureshinodesashibetsuikinderoycookingchannelblagdenesnaase" +
	"ralingenkainanaejrietisalatinabenonichernivtsiciliacoolkuszczytn" +
	"ore-og-uvdalutskasuyameldaluxembourgrpanamacooperaunitenrightath" +
	"omeftpanasonichernovtsykkylvenetogakushimotoganewspapercopenhage" +
	"ncyclopedichirurgiens-dentistes-en-francecorsicagliaridagawarsza" +
	"washingtondclkaszubycorvettevadsoccertificationcosenzagancosidns" +
	"dojoetsuwanouchikujogaszkoladbrokesassaris-a-huntercostumedio-ca" +
	"mpidano-mediocampidanomediocouchpotatofriesatxn--11b4c3dynv6coun" +
	"ciluxurycouponsaudacoursesauheradynvpnchiryukyuragifuchungbukhar" +
	"acq-acranbrookuwanalyticsavannahgacreditcardyroyrvikingruecredit" +
	"unioncremonashgabadaddjambyluzerncrewiiheyakagecricketrzyncrimea" +
	"st-kazakhstanangercrotonextdirectoystre-slidrettozawacrownprovid" +
	"ercrsvparaglidinguitarsaves-the-whalessandria-trani-barletta-and" +
	"riatranibarlettaandriacruisesavonaplesaxocryptonomichigangwoncui" +
	"sinellahppiacenzakopanerairguardiannakadomarinebraskaunjargalsac" +
	"eoculturalcentertainmentozsdeltaitogliattiresbschokoladencuneocu" +
	"pcakecxn--12c1fe0bradescorporationcyberlevagangaviikanonjis-a-kn" +
	"ightpointtokaizukamikitayamatsuris-a-landscapercymrussiacyonabar" +
	"ulvikatowicecyouthdfcbankatsushikabeeldengeluidfidonnakamurataji" +
	"mibuildingulenfieldfiguerestaurantraniandriabarlettatraniandriaf" +
	"ilateliafilegearthachiojiyahoofilminamidaitomangotsukisosakitaga" +
	"wafinalfinancefineartschwarzgwangjuifminamiechizenfinlandfinnoyf" +
	"irebaseapparisor-fronfirenzefirestonefirmdaleirvikaufenfishingol" +
	"ffanschweizwildlifedorainfracloudfrontdoorfitjarmeniafitnessettl" +
	"ementranoyfjalerflesbergunmarburguovdageaidnuslivinghistoryflick" +
	"ragerotikakamigaharaflightsciencecentersciencehistoryflirflogint" +
	"ogurafloraflorencefloridavvesiidazaifudaigojomedizinhistorisches" +
	"cientistoragefloripaderbornfloristanohatakahamangyshlakasamatsud" +
	"ontexisteingeekautokeinoflorogerscjohnsonflowerscotlandflynnhuba" +
	"mblefrakkestadiscountysnes3-sa-east-1fndfoodnetworkshoppingushik" +
	"amifuranortonsbergxn--12co0c3b4evalleaostatoilfor-ourfor-someetn" +
	"edalfor-theaterforexrothachirogatakahatakaishimogosenforgotdnscr" +
	"apper-siteforli-cesena-forlicesenaforlikescandynamic-dnscrapping" +
	"forsaleitungsenforsandasuolodingenfortmissoulair-traffic-control" +
	"leyfortworthadanosegawaforuminamifuranofosneserveftparliamentran" +
	"sportransurlfotaruis-a-lawyerfoxfordedyn-ip24freeboxoservegame-s" +
	"erversailleservehalflifestylefreemasonryfreetlservehttparmafreib" +
	"urgfreightcminamiiselectrapaniimimatakatoris-a-liberalfresenius-" +
	"3fribourgfriuli-v-giuliafriuli-ve-giuliafriuli-vegiuliafriuli-ve" +
	"nezia-giuliafriuli-veneziagiuliafriuli-vgiuliafriuliv-giuliafriu" +
	"live-giuliafriulivegiuliafriulivenezia-giuliafriuliveneziagiulia" +
	"friulivgiuliafrlfroganservehumourfrognfrolandfrom-akrehamnfrom-a" +
	"lfrom-arqhadselfiparocherkasyno-dserveirchitachinakagawassamukaw" +
	"ataricohdatsunanjoburgriwataraidyndns-office-on-the-webcampobass" +
	"ociatesapporofrom-azfrom-capebretonamiastapleserveminecraftravel" +
	"channelfrom-collectionfrom-ctravelersinsurancefrom-dchitosetogit" +
	"suldalotenkawafrom-defenseljordfrom-flanderservemp3from-gausdalf" +
	"rom-higashiagatsumagoizumizakirkeneservep2parservepicservequakef" +
	"rom-iafrom-idfrom-ilfrom-incheonfrom-kservesarcasmatartanddesign" +
	"from-kyowariasahikawafrom-lajollamericanexpressexyfrom-maniwakur" +
	"atextileksvikazofrom-mdfrom-megurokunohealthcareerservicesettsur" +
	"geonshalloffamemorialfrom-microsoftbankazunofrom-mnfrom-modellin" +
	"gfrom-msevastopolefrom-mtnfrom-nchloefrom-ndfrom-nefrom-nhktrdfr" +
	"om-njcbnlfrom-nminamiizukamisatokamachintaifun-dnsaliasdaburfrom" +
	"-nvalledaostavernfrom-nyfrom-ohkurafrom-oketohmannorth-kazakhsta" +
	"nfrom-orfrom-padovaksdalfrom-pratohnoshoooshikamaishimodatefrom-" +
	"rivnefrom-schoenbrunnfrom-sdfrom-tnfrom-txn--1ck2e1bananarepubli" +
	"caseihichisobetsuitainairforcechirealminamiawajikibmdiscoveryomb" +
	"ondishakotanavigationavoiitatebayashiibahcavuotnagaraholtaleniwa" +
	"izumiotsukumiyamazonawsadodgemologicallyngenvironmentalconservat" +
	"ionavuotnaklodzkodairassnasabaerobaticketselinogradultashkentata" +
	"motors3-ap-northeast-2from-utazuerichardlillehammerfeste-ipartis" +
	"-a-libertarianfrom-val-daostavalleyfrom-vtrentino-a-adigefrom-wa" +
	"from-wielunnerfrom-wvallee-aosteroyfrom-wyfrosinonefrostalowa-wo" +
	"lawafroyahikobeardubaiduckdnsevenassisicilyfstcgroupartnersewill" +
	"iamhillfujiiderafujikawaguchikonefujiminohtawaramotoineppubologn" +
	"akanotoddenfujinomiyadafujiokayamansionsfranziskanerdpolicefujis" +
	"atoshonairtelecityeatsharis-a-linux-useranishiaritabashijonawate" +
	"fujisawafujishiroishidakabiratoridefinimakanegasakindlegokasells" +
	"-for-lessharpartshawaiijimarugame-hostrolekameokameyamatotakadaf" +
	"ujitsurugashimaritimekeepingfujixeroxn--1ctwolominamatakkokamino" +
	"yamaxunusualpersonfujiyoshidafukayabeatshellaspeziafukuchiyamada" +
	"fukudominichocolatemasekashiwazakiyosatokashikiyosemitefukuis-a-" +
	"llamarylandfukumitsubishigakirovogradoyfukuokazakiryuohaebarumin" +
	"amimakis-a-musicianfukuroishikarikaturindalfukusakisarazurewebsi" +
	"teshikagamiishibukawafukuyamagatakaharustkanoyakumoldeloittexasc" +
	"olipicenoipifonynysaarlandfunabashiriuchinadafunagatakahashimama" +
	"kishiwadafunahashikamiamakusatsumasendaisennangonohejis-a-nascar" +
	"fanfundaciofuoiskujukuriyamanxn--1lqs03nfuosskoczowinbarcelonaga" +
	"sakijobserverisignieznord-frontiereviewskrakowedeployomitanobihi" +
	"rosakikamijimastronomy-gatewaybomloans3-ap-south-1furnituredston" +
	"efurubiraquarelleborkangerfurudonostiaarpartyfurukawairtrafficho" +
	"funatoriginsurecifedexhibitionishiokoppegardyndns-picsardegnamss" +
	"koganeis-a-doctorayfusodegaurafussaikisofukushimaoris-a-nurserve" +
	"bbshimojis-a-painteractivegarsheis-a-patsfanfutabayamaguchinomig" +
	"awafutboldlygoingnowhere-for-moregontrailroadfuttsurugimperiafut" +
	"urehostingfuturemailingfvgfyis-a-personaltrainerfylkesbiblackfri" +
	"dayfyresdalhangoutsystemscloudfunctionshimokawahannanmokuizumode" +
	"rnhannotaireshimokitayamahanyuzenhapmirhareidsbergenharstadharve" +
	"stcelebrationhasamarcheapassagenshimonitayanagitlaborhasaminami-" +
	"alpssells-itrentino-aadigehashbanghasudahasura-appassenger-assoc" +
	"iationhasvikddielddanuorrikuzentakataiwanairlinedre-eikerhatogay" +
	"aitakamoriokalmykiahatoyamazakitahiroshimarnardalhatsukaichikais" +
	"eis-a-republicancerresearchaeologicaliforniahattfjelldalhayashim" +
	"amotobungotakadapliernewjerseyhazuminobusellsyourhomegoodshimono" +
	"sekikawahboehringerikehelsinkitakamiizumisanofidelitysvardollshi" +
	"mosuwalkis-a-rockstarachowicehembygdsforbundhemneshimotsukehemse" +
	"dalhepforgeherokussldheroyhgtvalleeaosteigenhigashichichibunkyon" +
	"anaoshimageandsoundandvisionhigashihiroshimanehigashiizumozakita" +
	"katakanabeautydalhigashikagawahigashikagurasoedahigashikawakitaa" +
	"ikitakyushuaiahigashikurumeiwamarriottrentino-alto-adigehigashim" +
	"atsushimarshallstatebankfhappouhigashimatsuyamakitaakitadaitoiga" +
	"wahigashimurayamamotorcycleshimotsumahigashinarusembokukitamidor" +
	"is-a-socialistmein-vigorgehigashinehigashiomihachimanchesterhiga" +
	"shiosakasayamanakakogawahigashishirakawamatakanezawahigashisumiy" +
	"oshikawaminamiaikitamotosumitakagildeskaliszhigashitsunotogawahi" +
	"gashiurausukitanakagusukumoduminamiminowahigashiyamatokoriyamana" +
	"shifteditchyouripaviancarrierhigashiyodogawahigashiyoshinogaris-" +
	"a-soxfanhiraizumisatohobby-sitehirakatashinagawahiranais-a-stude" +
	"ntalhirarahiratsukagawahirayaizuwakamatsubushikusakadogawahistor" +
	"ichouseshinichinanhitachiomiyaginankokubunjis-a-teacherkassymant" +
	"echnologyhitachiotagooglecodespotrentino-altoadigehitraeumtgerad" +
	"elmenhorstalbanshinjournalistjohnhjartdalhjelmelandholeckobierzy" +
	"ceholidayhomeipfizerhomelinkhakassiahomelinuxn--1lqs71dhomeoffic" +
	"ehomesecuritymaceratakaokaluganskolevangerhomesecuritypccwindmil" +
	"lhomesenseminehomeunixn--1qqw23ahondahoneywellbeingzonehongopocz" +
	"northwesternmutualhonjyoitakarazukamakurazakitashiobarahornindal" +
	"horseoulminamiogunicomcastresistancehortendofinternet-dnshinjuku" +
	"manohospitalhoteleshinkamigotoyohashimotoshimahotmailhoyangerhoy" +
	"landetroitskydivinghumanitieshinshinotsurgeryhurdalhurumajis-a-t" +
	"echietis-a-therapistoiahyllestadhyogoris-an-accountantshinshiroh" +
	"yugawarahyundaiwafunehzchoseiroumuenchenishitosashimizunaminamia" +
	"shigarajfkhmelnitskiyamashikejgorajlchoyodobashichikashukujitawa" +
	"rajlljmpharmacienshiojirishirifujiedajnjcpgfoggiajoyokaichibahcc" +
	"avuotnagareyamalborkdalpha-myqnapcloudapplebesbyglandjpmorganjpn" +
	"jprshioyanaizujuniperjurkoshimizumakis-an-engineeringkoshunantok" +
	"igawakosugekotohiradomainshirakofuefukihaboromskoguchikuzenkotou" +
	"rakouhokutamakis-an-entertainerkounosupplieshiranukamogawakouyam" +
	"ashikokuchuokouzushimasoykozagawakozakis-bykpnkppspdnshiraois-ce" +
	"rtifieducatorahimeshimamateramochizukirakrasnodarkredirectmelhus" +
	"cultureggio-calabriakristiansandcatshiraokanagawakristiansundkro" +
	"dsheradkrokstadelvaldaostarostwodzislawindowshiratakahagivestbyk" +
	"ryminamisanrikubetsupportrentino-sued-tirolkumatorinokumejimasud" +
	"akumenanyokkaichiropractichristmasakikugawatchandclockasukabedzi" +
	"n-the-bandaikawachinaganoharamcoachampionshiphoptobishimaizurugb" +
	"ydgoszczecinemakeupowiathletajimabariakeisenbahnishiwakis-a-fina" +
	"ncialadvisor-aurdalottokonamegatakasugais-a-geekgalaxykunisakis-" +
	"foundationkunitachiarailwaykunitomigusukumamotoyamassa-carrara-m" +
	"assacarraramassabusinessebytomaritimobarakunneppulawykunstsammlu" +
	"ngkunstunddesignkuokgrouphdkureggio-emilia-romagnakatsugawakurga" +
	"nkurobelaudiblebtimnetzkurogimilanokuroisoftwarendalenugkuromats" +
	"unais-gonekurotakikawasakis-into-animelbournekushirogawakustanai" +
	"s-into-carshintomikasaharakusupplykutchanelkutnokuzumakis-into-c" +
	"artoonshinyoshitomiokamitsuekvafjordkvalsundkvamfamberkeleykvana" +
	"ngenkvinesdalkvinnheradkviteseidskogkvitsoykwpspiegelkzmissilewi" +
	"smillermisugitokorozawamitourismolancastermitoyoakemiuramiyazumi" +
	"yotamanomjondalenmlbfanmonmouthagebostadmonstermonticellolmontre" +
	"alestatefarmequipmentrentino-suedtirolmonza-brianzaporizhzhiamon" +
	"za-e-della-brianzapposhishikuis-not-certifiedunetbankharkovanylv" +
	"enicemonzabrianzaptokuyamatsusakahoginowaniihamatamakawajimaphil" +
	"adelphiaareadmyblogsitemonzaebrianzaramonzaedellabrianzamoonscal" +
	"exusdecorativeartshisognemoparachutingmordoviajessheiminamitanem" +
	"oriyamatsushigemoriyoshimilitarymormoneymoroyamatsuuramortgagemo" +
	"scowinnershisuifuelveruminamiuonumatsumotofukemoseushistorymosjo" +
	"enmoskeneshitaramamosshizukuishimofusaitamatsukuris-savedmosvikn" +
	"x-serveronakatombetsunndalmoteginozawaonsenmoviemovistargardmtpc" +
	"hromedicaltanissettairamtranbymuenstermugithubcloudusercontentre" +
	"ntinoa-adigemuikamishihoronobeauxartsandcraftshizuokananporovigo" +
	"tpantheonsitemukochikushinonsenergymulhouservebeermunakatanemunc" +
	"ieszynmuosattemuphilatelymurmanskolobrzegersundmurotorcraftrenti" +
	"noaadigemusashimurayamatsuzakis-slickhersonmusashinoharamuseetre" +
	"ntinoalto-adigemuseumverenigingmusicargodaddynaliascoli-picenogi" +
	"ftshoujis-uberleetrentino-stirolmutsuzawamy-vigorlicemy-wanggouv" +
	"icenzamyactivedirectorymyasustor-elvdalmycdn77-securechtrainingm" +
	"ydissentrentinoaltoadigemydrobofagemydshowamyeffectrentinos-tiro" +
	"lmyfirewallonieruchomoscienceandindustrynmyfritzmyftpaccesshowti" +
	"meteorapphilipsynology-diskstationmyfusionmyhome-serverrankoshig" +
	"ayanagawamykolaivaporcloudmymailermymediapchryslermyokohamamatsu" +
	"damypepsongdalenviknakanojohanamakinoharamypetshriramlidlugoleka" +
	"gaminoduminamiyamashirokawanabelembroideryggeelvincklabudhabikin" +
	"okawabarthagakhanamigawamyphotoshibajddarchaeologyeongnamegawalb" +
	"rzycharternidmypsxn--30rr7ymysecuritycamerakermyshopblocksienara" +
	"shinomytis-a-bookkeeperugiamyvnchungnamdalseidfjordyndns-remotew" +
	"dyndns-serverdalouvreggioemiliaromagnakayamatsumaebashikshacknet" +
	"oyookanmakiwakunigamidsundyndns-weberlincolnissandnessjoenissayo" +
	"koshibahikariwanumatakazakis-a-greenissedalowiczest-le-patrondhe" +
	"immobilienisshingugepicturesilkomaganepiemontepilotsimple-urlpim" +
	"ientaketomisatolgapinkomakiyosumy-routerpioneerpippuphonefossigd" +
	"alpiszpittsburghofauskedsmokorsetagayasells-for-unzenpiwatepizza" +
	"pkomatsushimashikizunokunimihoboleslawiechristiansburgroks-thisa" +
	"yamanobeokakudamatsueplanetariuminanoplantationplantsirdalplatfo" +
	"rmshangrilanciaplaystationplazaplchurchaseljeepostfoldnavyplumbi" +
	"ngopmnpodzonepohlpoivronpokerpokrovskomforbarclays3-us-gov-west-" +
	"1politiendapolkowicepoltavalle-aostathellezajskommunalforbundpom" +
	"orzeszowioslingpordenonepornporsangerporsanguidellogliastradingp" +
	"orsgrunnanpoznanpraxis-a-bruinsfanprdpreservationpresidioprgmrpr" +
	"imeloyalistockholmestrandprincipeprivatizehealthinsuranceprochow" +
	"iceproductionslupskommuneprofbsbxn--12cfi8ixb8lvivano-frankivska" +
	"tsuyamasfjordenprogressivegasiapromombetsurfbx-oscholarshipschoo" +
	"lpropertyprotectionprotonetrentinosud-tirolprudentialpruszkowitd" +
	"komonoprzeworskogptplusgardenpvtrentinosudtirolpwcirclegnicafede" +
	"rationiyodogawapzqldqponqslgbtrentinosued-tirolquicksytesnoasait" +
	"omobellevuelosangelesjaguarchitecturealtychyattorneyagawalesundq" +
	"uipelementsokanazawaqvcircustomerstuff-4-salestufftoread-booksne" +
	"solognestuttgartritonsusakis-very-evillagesusonosuzakaneyamazoes" +
	"uzukaniepcesuzukis-very-goodhandsonsvalbardunloppacificitadelive" +
	"rysveiosvelvikongsbergsvizzeraswedenswidnicartierswiebodzindiana" +
	"polis-a-bloggerswiftcoversicherungswinoujscienceandhistoryswissh" +
	"ikis-very-nicesynology-dsolundbeckomorotsukamiokamikoaniikappugl" +
	"iatushuissier-justicetuvalle-daostaticsomatuxfamilytwmailvennesl" +
	"askerrylogisticsomnaritakurashikis-very-badajozoravestfoldvestne" +
	"soovestre-slidreamhostersopotrentinosuedtirolvestre-totennishiaw" +
	"akuravestvagoyvevelstadvibo-valentiavibovalentiavideovillaskimit" +
	"subatamicable-modembetsukuis-very-sweetpeppervinnicartoonartdeco" +
	"ffeedbackplaneappspotagervinnytsiavipsinaappiagetmyiphoenixn--32" +
	"vp30haibarakitahatakamatsukawavirginiavirtualvirtueeldomeindianm" +
	"arketingvirtuelvisakegawavistaprinternationalfirearmsor-odalvite" +
	"rboltrogstadvivoldavixn--3bst00minnesotaketakatsukis-into-gamess" +
	"inatsukigatakasagotembaixadavlaanderenvladikavkazimierz-dolnyvla" +
	"dimirvlogoipictetrentinostirolvolkswagentsor-varangervologdansko" +
	"ninjamisonvolvolkenkundenvolyngdalvossevangenvotevotingvotoyonak" +
	"agyokutoursorfoldwloclawekonskowolayangroupharmacyshirahamatonbe" +
	"tsurnadalwmflabsorreisahayakawakamiichikawamisatotalworldworse-t" +
	"handawowithgoogleapisa-hockeynutsiracusakatakinouewritesthisblog" +
	"sytewroclawithyoutubeneventoeidsvollwtcitichernigovernmentoyonow" +
	"tfbxoschulewuozuwwwiwatsukiyonowruzhgorodeowzmiuwajimaxn--45brj9" +
	"civilaviationxn--45q11civilisationxn--4gbriminingxn--4it168dxn--" +
	"4it797konyveloftrentino-sudtirolxn--4pvxs4allxn--54b7fta0ccivili" +
	"zationxn--55qw42gxn--55qx5dxn--5js045dxn--5rtp49civilwarmanageme" +
	"ntoyosatoyakokonoexn--5rtq34kooris-an-anarchistoricalsocietyxn--" +
	"5su34j936bgsgxn--5tzm5gxn--6btw5axn--6frz82gxn--6orx2rxn--6qq986" +
	"b3xlxn--7t0a264claimsarlucaniaxn--80adxhksortlandxn--80ao21axn--" +
	"80aqecdr1axn--80asehdbarreauctionflfanfshostrowiecasertaipeiheij" +
	"iiyamanouchikuhokuryugasakitaurayasudaukraanghkeymachineustarhub" +
	"alsanagochihayaakasakawaharanzanpachigasakicks-assedicasadelamon" +
	"edatingjemnes3-ap-southeast-2xn--80aswgxn--80audnedalnxn--8ltr62" +
	"kopervikhmelnytskyivaolbia-tempio-olbiatempioolbialystokkepnogat" +
	"aijis-an-actresshintokushimaxn--8pvr4uxn--8y0a063axn--90a3academ" +
	"y-firewall-gatewayxn--90aishobaraomoriguchiharahkkeravjuedisches" +
	"apeakebayernrtromsakakinokiaxn--90azhytomyrxn--9dbhblg6dietcimdb" +
	"arrel-of-knowledgeologyonagoyaurskog-holandroverhalla-speziaerop" +
	"ortalaheadjudaicaaarborteaches-yogasawaracingroks-theatree164xn-" +
	"-9dbq2axn--9et52uxn--9krt00axn--andy-iraxn--aroport-byandexn--3d" +
	"s443gxn--asky-iraxn--aurskog-hland-jnbarrell-of-knowledgeometre-" +
	"experts-comptables3-us-west-1xn--avery-yuasakuhokkaidoomdnshome-" +
	"webservercellikes-piedmontblancomeeresorumincommbankmpspbarclayc" +
	"ards3-us-east-2xn--b-5gaxn--b4w605ferdxn--bck1b9a5dre4cldmailucc" +
	"apitalonewportlligatoyotaris-a-gurulsandoyxn--bdddj-mrabdxn--bea" +
	"ralvhki-y4axn--berlevg-jxaxn--bhcavuotna-s4axn--bhccavuotna-k7ax" +
	"n--bidr-5nachikatsuuraxn--bievt-0qa2xn--bjarky-fyaotsurreyxn--bj" +
	"ddar-ptamayufuettertdasnetzxn--blt-elabourxn--bmlo-graingerxn--b" +
	"od-2naroyxn--brnny-wuaccident-investigation-aptibleaseating-orga" +
	"nicbcn-north-1xn--brnnysund-m8accident-prevention-webhopenairbus" +
	"antiquest-a-la-maisondre-landebudapest-a-la-masionionjukudoyamag" +
	"entositelekommunikationthewifiat-band-campaniaxn--brum-voagatrom" +
	"sojampagefrontapphotographysioxn--btsfjord-9zaxn--c1avgxn--c2br7" +
	"gxn--c3s14mintelligencexn--cck2b3barsyonlinewhampshirebungoonord" +
	"-odalazioceanographics3-us-west-2xn--cg4bkis-with-thebandovre-ei" +
	"kerxn--ciqpnxn--clchc0ea0b2g2a9gcdn77-sslattumisakis-leetrentino" +
	"-s-tirollagrigentomologyeongbukharkivgucciprianiigataishinomakim" +
	"obetsuliguriaxn--comunicaes-v6a2oxn--correios-e-telecomunicaes-g" +
	"hc29axn--czr694bashkiriaustevollarvikarasjohkamiminers3-ca-centr" +
	"al-1xn--czrs0trusteexn--czru2dxn--czrw28basilicataniaustinnatura" +
	"lsciencesnaturelles3-eu-central-1xn--d1acj3basketballfinanzgorau" +
	"straliaisondriodejaneirochesterepbodynathomebuiltatarantottoribe" +
	"staddnskingjerdrumckinseyokosukanzakiwienaturbruksgymnaturhistor" +
	"isches3-eu-west-1xn--d1alfaromeoxn--d1atrvarggatroandinosaureise" +
	"nxn--d5qv7z876clickasumigaurawa-mazowszextraspacekitagatajirissa" +
	"gamiharaxn--davvenjrga-y4axn--djrs72d6uyxn--djty4koryokamikawane" +
	"honbetsurutaharaxn--dnna-grajewolterskluwerxn--drbak-wuaxn--dyry" +
	"-iraxn--e1a4clinichernihivanovodkagoshimalvikashiwaraxn--eckvdtc" +
	"9dxn--efvn9southcarolinazawaxn--efvy88hair-surveillancexn--ehqz5" +
	"6nxn--elqq16hakatanoshiroomuraxn--estv75gxn--eveni-0qa01gaxn--f6" +
	"qx53axn--fct429kosaigawaxn--fhbeiarnxn--finny-yuaxn--fiq228c5hso" +
	"uthwestfalenxn--fiq64batodayonaguniversityoriikariyaltakasakiyok" +
	"awaraustrheimatunduhrennesoyokoteastcoastaldefencebinagisochildr" +
	"ensgardenatuurwetenschappenaumburgjerstadotsuruokakegawaetnagaha" +
	"maroygardenebakkeshibechambagriculturennebudejjudygarlandd-dnsfo" +
	"r-better-thanawawdev-myqnapcloudcontrolapplinzi234xn--fiqs8sowax" +
	"n--fiqz9spjelkavikomvuxn--2m4a15exn--fjord-lraxn--fjq720axn--fl-" +
	"ziaxn--flor-jraxn--flw351exn--fpcrj9c3dxn--frde-grandrapidspread" +
	"bettingxn--frna-woaraisaijotrysiljanxn--frya-hraxn--fzc2c9e2clin" +
	"iquenoharaxn--fzys8d69uvgmailxn--g2xx48clintonoshoesarpsborgrond" +
	"arxn--gckr3f0fedorapeopleirfjordxn--gecrj9clothingrongaxn--ggavi" +
	"ika-8ya47hakodatexn--gildeskl-g0axn--givuotna-8yasakaiminatoyone" +
	"zawaxn--gjvik-wuaxn--gk3at1exn--gls-elacaixaxn--gmq050isleofmand" +
	"alxn--gmqw5axn--h-2failxn--h1aeghakonexn--h2brj9cnsarufutsunomiy" +
	"awakasaikaitakoelnxn--h3cuzk1digitalxn--hbmer-xqaxn--hcesuolo-7y" +
	"a35batsfjordivtasvuodnakaiwamizawauthordalandroiddnss3-eu-west-2" +
	"xn--hery-iraxn--hgebostad-g3axn--hmmrfeasta-s4acctulangevagrarbo" +
	"retumbriaxn--hnefoss-q1axn--hobl-iraxn--holtlen-hxaxn--hpmir-xqa" +
	"xn--hxt814exn--hyanger-q1axn--hylandet-54axn--i1b6b1a6a2exn--imr" +
	"513nxn--indery-fyasugissmarterthanyouxn--io0a7iwchoshibuyachiyod" +
	"avvenjargapartmentsardiniaxn--j1aefedoraprojectrani-andria-barle" +
	"tta-trani-andriaxn--j1amhakubaghdadxn--j6w193gxn--jlq61u9w7bauha" +
	"usposts-and-telecommunicationsncfdivttasvuotnakamagayahababyklec" +
	"lercasinordre-landiyoshiokaracoldwarmiamihamadautomotivecoalipay" +
	"okozebinorfolkebibleikangereportateshinanomachimkentateyamagroce" +
	"rybnikahokutobamaintenancebetsukubank12xn--jlster-byasuokanraxn-" +
	"-jrpeland-54axn--jvr189misasaguris-lostre-toteneis-an-actorxn--k" +
	"7yn95exn--karmy-yuaxn--kbrq7oxn--kcrx77d1x4axn--kfjord-iuaxn--kl" +
	"bu-woaxn--klt787dxn--kltp7dxn--kltx9axn--klty5xn--3e0b707exn--ko" +
	"luokta-7ya57hakuis-a-photographerokuappasadenamsosnowiechonanbui" +
	"lderschmidtre-gauldalottexn--kprw13dxn--kpry57dxn--kpu716fermoda" +
	"lenxn--kput3ixn--krager-gyatomitamamuraxn--kranghke-b0axn--krdsh" +
	"erad-m8axn--krehamn-dxaxn--krjohka-hwab49jeonnamerikawauexn--ksn" +
	"es-uuaxn--kvfjord-nxaxn--kvitsy-fyatsukanumazuryxn--kvnangen-k0a" +
	"xn--l-1fairwindspydebergxn--l1accentureklamborghiniizaxn--lahead" +
	"ju-7yatsushiroxn--langevg-jxaxn--lcvr32dxn--ldingen-q1axn--leaga" +
	"viika-52bbcateringebugattipschlesisches3-website-ap-northeast-1x" +
	"n--lesund-huaxn--lgbbat1ad8jetztrentino-sud-tirolxn--lgrd-poacnt" +
	"oyotomiyazakis-a-hard-workerxn--lhppi-xqaxn--linds-pramericanart" +
	"unesolutionsokndalxn--lns-qlansrlxn--loabt-0qaxn--lrdal-sraxn--l" +
	"renskog-54axn--lt-liacolonialwilliamsburgrossetouchijiwadell-ogl" +
	"iastraderxn--lten-granexn--lury-iraxn--m3ch0j3axn--mely-iraxn--m" +
	"erker-kuaxn--mgb2ddesrtrentoyokawaxn--mgb9awbferraraxn--mgba3a3e" +
	"jtunkongsvingerxn--mgba3a4f16axn--mgba3a4franamizuholdingsmilelx" +
	"n--mgba7c0bbn0axn--mgbaakc7dvferrarittogoldpoint2thisamitsukexn-" +
	"-mgbaam7a8hakusandiegoodyearxn--mgbab2bdxn--mgbai9a5eva00bbtatto" +
	"olsztynsettlers3-website-ap-southeast-1xn--mgbai9azgqp6jevnakers" +
	"huscountryestateofdelawarezzoologyxn--mgbayh7gpagespeedmobilizer" +
	"oxn--mgbb9fbpobanazawaxn--mgbbh1a71exn--mgbc0a9azcgxn--mgbca7dzd" +
	"oxn--mgberp4a5d4a87gxn--mgberp4a5d4arxn--mgbi4ecexposedxn--mgbpl" +
	"2fhskodjejuegoshikiminokamoenairportland-4-salernoboribetsucksrv" +
	"areserveblogspotrevisohughesolarssonxn--mgbqly7c0a67fbcoloradopl" +
	"ateaudioxn--mgbqly7cvafredrikstadtvstordalxn--mgbt3dhdxn--mgbtf8" +
	"flatangerxn--mgbtx2bbvacationswatch-and-clockerhcloudns3-website" +
	"-ap-southeast-2xn--mgbx4cd0abbotturystykannamifunexn--mix082ferr" +
	"eroticanonoichinomiyakexn--mix891fetsundxn--mjndalen-64axn--mk0a" +
	"xindustriesteambulancexn--mk1bu44columbusheyxn--mkru45ixn--mlatv" +
	"uopmi-s4axn--mli-tlanxesstorehabmerxn--mlselv-iuaxn--moreke-juax" +
	"n--mori-qsakuragawaxn--mosjen-eyawaraxn--mot-tlapyatigorskypexn-" +
	"-mre-og-romsdal-qqbentleyukinfinitintuitaxihuanhlfanhs3-website-" +
	"eu-west-1xn--msy-ula0haldenxn--mtta-vrjjat-k7afamilycompanycommu" +
	"nitysfjordyndns-wikinkobayashikaoirminamibosogndalucernexn--muos" +
	"t-0qaxn--mxtq1misawaxn--ngbc5azdxn--ngbe9e0axn--ngbrxn--3oq18vl8" +
	"pn36axn--nit225kosakaerodromegallupinbarefootballooningjovikarat" +
	"suginamikatagamiharuconnectatsunobiraugustowadaegubs3-ap-southea" +
	"st-1xn--nmesjevuemie-tcbalestrandabergamoarekexn--nnx388axn--nod" +
	"exn--nqv7fs00emaxn--nry-yla5gxn--ntso0iqx3axn--ntsq17gxn--nttery" +
	"-byaeservecounterstrikexn--nvuotna-hwaxn--nyqy26axn--o1achattano" +
	"oganordreisa-geekoseis-an-artisteinkjerusalemrxn--o3cw4halsaintl" +
	"ouis-a-anarchistoiredumbrellanbibaidarxn--o3cyx2axn--od0algxn--o" +
	"d0aq3beppublishproxyzgorzeleccolognewyorkshirecipesaro-urbino-pe" +
	"sarourbinopesaromasvuotnaharimamurogawatches3-website-sa-east-1x" +
	"n--ogbpf8flekkefjordxn--oppegrd-ixaxn--ostery-fyawatahamaxn--osy" +
	"ro-wuaxn--p1acfgujolsterxn--p1aixn--pbt977comobilyxn--pgbs0dhlxn" +
	"--porsgu-sta26fhvalerxn--pssu33lxn--pssy2uxn--q9jyb4comparemarke" +
	"rryhotelsasayamaxn--qcka1pmcdonaldstorfjordxn--qqqt11misconfused" +
	"xn--qxamuneuestorjelenia-goraxn--rady-iraxn--rdal-poaxn--rde-ula" +
	"quilancashireggiocalabriaxn--rdy-0nabarixn--rennesy-v1axn--rhkke" +
	"rvju-01aflakstadaokagakibichuoxn--rholt-mragowoodsidexn--rhqv96g" +
	"xn--rht27zxn--rht3dxn--rht61exn--risa-5narusawaxn--risr-iraxn--r" +
	"land-uuaxn--rlingen-mxaxn--rmskog-byaxn--rny31hammarfeastafricap" +
	"etownnews-stagingxn--rovu88bernuorockartuzyukuhashimoichinosekig" +
	"aharautoscanadaejeonbukarasjokarasuyamarylhurstjordalshalsenaust" +
	"dalavagiskebizenakaniikawatanaguramusementarnobrzegyptianaturalh" +
	"istorymuseumcenterepaircraftarumizusawabogadocscbgdyniabkhaziama" +
	"llamagazineat-url-o-g-i-nativeamericanantiques3-ap-northeast-1ka" +
	"ppchizippodhaleangaviikadenadexetereit3l3p0rtargets-itargiving12" +
	"000emmafanconagawakayamadridvagsoyericssonyoursidealerimo-i-rana" +
	"amesjevuemielno-ip6xn--rros-granvindafjordxn--rskog-uuaxn--rst-0" +
	"narutokyotangovtuscanyxn--rsta-francaiseharaxn--ryken-vuaxn--ryr" +
	"vik-byaxn--s-1faithruherecreationxn--s9brj9compute-1xn--sandness" +
	"jen-ogbizxn--sandy-yuaxn--seral-lraxn--ses554gxn--sgne-gratangen" +
	"xn--skierv-utazaskoyabearalvahkihokumakogengerdalcestpetersburgx" +
	"n--skjervy-v1axn--skjk-soaxn--sknit-yqaxn--sknland-fxaxn--slat-5" +
	"narviikamisunagawaxn--slt-elabbvieeexn--smla-hraxn--smna-gratis-" +
	"a-bulls-fanxn--snase-nraxn--sndre-land-0cbremangerxn--snes-poaxn" +
	"--snsa-roaxn--sr-aurdal-l8axn--sr-fron-q1axn--sr-odal-q1axn--sr-" +
	"varanger-ggbeskidyn-o-saurlandes3-website-us-east-1xn--srfold-by" +
	"axn--srreisa-q1axn--srum-grazxn--stfold-9xaxn--stjrdal-s1axn--st" +
	"jrdalshalsen-sqbestbuyshouses3-website-us-west-1xn--stre-toten-z" +
	"cbstreamsterdamnserverbaniaxn--t60b56axn--tckweatherchannelxn--t" +
	"iq49xqyjewelryxn--tjme-hraxn--tn0agrinet-freakstudioxn--tnsberg-" +
	"q1axn--tor131oxn--trany-yuaxn--trgstad-r1axn--trna-woaxn--troms-" +
	"zuaxn--tysvr-vraxn--uc0atvaroyxn--uc0ay4axn--uist22hamurakamigor" +
	"is-a-playerxn--uisz3gxn--unjrga-rtaobaokinawashirosatochiokinosh" +
	"imalatvuopmiasakuchinotsuchiurakawakuyabukievenestudyndns-at-hom" +
	"edepotenzamamicrolightingxn--unup4yxn--uuwu58axn--vads-jraxn--va" +
	"rd-jraxn--vegrshei-c0axn--vermgensberater-ctbetainaboxfusejnyuri" +
	"honjoyentgoryusuharaveroykenglandds3-external-1xn--vermgensberat" +
	"ung-pwbieigersundnpalaceu-3utilitiesquare7xn--vestvgy-ixa6oxn--v" +
	"g-yiabcgxn--vgan-qoaxn--vgsy-qoa0jewishartgalleryxn--vgu402compu" +
	"terhistoryofscience-fictionxn--vhquvbargainstitutelevisionayorov" +
	"nobninskarelianceu-2xn--vler-qoaxn--vre-eiker-k8axn--vrggt-xqadx" +
	"n--vry-yla5gxn--vuq861bielawalmartjeldsundrangedalillyusuisserve" +
	"exchangevents3-website-us-west-2xn--w4r85el8fhu5dnraxn--w4rs40lx" +
	"n--wcvs22dxn--wgbh1comsecuritytacticsaseboknowsitallukowhoswhokk" +
	"sundyndns-workisboringroundhandlingroznyxn--wgbl6axn--xhq521biel" +
	"laakesvuemielecceverbankarlsoyuufcfanikinuyamashinashikitchenikk" +
	"oebenhavnikolaevennodessagaeroclubmedecincinnationwidealstahauge" +
	"sunderseaportsinfolldalabamagasakishimabarackmazerbaijan-mayendo" +
	"ftheinternetflixilovecollegefantasyleaguernseyuzawavocatanzarowe" +
	"ddingjesdalavangenaval-d-aosta-valleyolasitehimejibigawaskvolloa" +
	"bathsbc66xn--xkc2al3hye2axn--xkc2dl3a5ee0hangglidingxn--y9a3aqua" +
	"riumishimatsunoxn--yer-znarvikosherbrookegawaxn--yfro4i67oxn--yg" +
	"arden-p1axn--ygbi2ammxn--3pxu8konsulatrobeepilepsydneyxn--ystre-" +
	"slidre-ujbieszczadygeyachimataikikonaioirasebastopologyeonggieht" +
	"avuoatnagaivuotnagaokakyotambabia-goracleaningatlantabuseekloges" +
	"t-mon-blogueurovisionikonantankarmoyxn--zbx025dxn--zf0ao64axn--z" +
	"f0avxn--42c2d9axn--zfr164bievatmallorcadaquesakurainvestmentsaky" +
	"otanabellunorddalimanowarudavoues3-fips-us-gov-west-1xperiaxz"
var nodes = [...]uint32{
	0x31a403,
	0x284944,
	0x2dd106,
	0x3706c3,
	0x3706c6,
	0x398706,
	0x3a8103,
	0x2fe244,
	0x38e987,
	0x2dcd48,
	0x1a05702,
	0x316e87,
	0x35c789,
	0x2abb0a,
	0x2abb0b,
	0x22f383,
	0x287506,
	0x232dc5,
	0x1e021c2,
	0x2161c4,
	0x238743,
	0x26fc45,
	0x2214902,
	0x347743,
	0x266f744,
	0x33ddc5,
	0x2a04702,
	0x376b4e,
	0x24c4c3,
	0x38ae46,
	0x2e00142,
	0x2dd287,
	0x236f46,
	0x3209282,
	0x229d83,
	0x24d9c4,
	0x325e86,
	0x26c588,
	0x2761c6,
	0x2011c4,
	0x3600242,
	0x3335c9,
	0x20a1c7,
	0x351e86,
	0x330c89,
	0x298308,
	0x26e904,
	0x241ec6,
	0x222a46,
	0x3a022c2,
	0x26480f,
	0x20948e,
	0x211d04,
	0x2c2b85,
	0x2fe145,
	0x39e189,
	0x23c409,
	0x349a87,
	0x20fa86,
	0x275a83,
	0x3e02a82,
	0x315503,
	0x34e24a,
	0x20f903,
	0x2af985,
	0x284202,
	0x284209,
	0x4200ec2,
	0x212484,
	0x2b9686,
	0x2f3645,
	0x3552c4,
	0x4a05644,
	0x2030c3,
	0x232344,
	0x4e00c02,
	0x268d44,
	0x52ef6c4,
	0x25ef4a,
	0x5603dc2,
	0x2ba587,
	0x2f3b08,
	0x6208142,
	0x311687,
	0x2bf204,
	0x2bf207,
	0x36e0c5,
	0x34ffc7,
	0x349846,
	0x24f3c4,
	0x38c105,
	0x29e447,
	0x72001c2,
	0x26e503,
	0x200b82,
	0x200b83,
	0x760de02,
	0x2102c5,
	0x7a02a42,
	0x350e04,
	0x2734c5,
	0x211c47,
	0x26bcce,
	0x2b9184,
	0x245544,
	0x202f03,
	0x281d49,
	0x31ee0b,
	0x2e9a88,
	0x379948,
	0x3a9908,
	0x22ae48,
	0x330aca,
	0x34fec7,
	0x318186,
	0x7e87002,
	0x35e203,
	0x367e43,
	0x36f4c4,
	0x3a8143,
	0x3250c3,
	0x1720b82,
	0x8202502,
	0x27a8c5,
	0x296206,
	0x2d1b84,
	0x375487,
	0x2e1886,
	0x331f84,
	0x39d3c7,
	0x203bc3,
	0x86c54c2,
	0x8b0f242,
	0x8e16742,
	0x216746,
	0x9200002,
	0x3523c5,
	0x3220c3,
	0x200604,
	0x2e8f84,
	0x2e8f85,
	0x206b43,
	0x978d2c3,
	0x9a0bb42,
	0x289e05,
	0x289e0b,
	0x31e686,
	0x20cb4b,
	0x221344,
	0x20d949,
	0x20e9c4,
	0x9e0ec02,
	0x20f143,
	0x20f403,
	0x16105c2,
	0x268183,
	0x2105ca,
	0xa20b382,
	0x216445,
	0x29224a,
	0x2d7744,
	0x283783,
	0x26cfc4,
	0x212543,
	0x212544,
	0x212547,
	0x2140c5,
	0x2147c5,
	0x214f46,
	0x2157c6,
	0x216a03,
	0x21ae88,
	0x210043,
	0xa601c02,
	0x243448,
	0x213ccb,
	0x220148,
	0x220d86,
	0x221847,
	0x225348,
	0xb642b42,
	0xbabf3c2,
	0x326788,
	0x35e4c7,
	0x246085,
	0x357f48,
	0x2bd408,
	0x34dd83,
	0x22a1c4,
	0x36f502,
	0xbe2bc82,
	0xc238482,
	0xca2e802,
	0x22e803,
	0xce01ec2,
	0x2fe203,
	0x2f1e84,
	0x201ec3,
	0x26e8c4,
	0x201ecb,
	0x213c03,
	0x2de946,
	0x239f84,
	0x29034e,
	0x371145,
	0x38af48,
	0x31ffc7,
	0x31ffca,
	0x229743,
	0x22f147,
	0x31efc5,
	0x22f8c4,
	0x265b06,
	0x265b07,
	0x2c11c4,
	0x2f7a87,
	0x313d44,
	0x26c004,
	0x26c006,
	0x387184,
	0x3510c6,
	0x203f83,
	0x35e288,
	0x203f88,
	0x245503,
	0x268143,
	0x399a04,
	0x39e003,
	0xd219f02,
	0xd6d6a42,
	0x20bac3,
	0x207146,
	0x241fc3,
	0x377cc4,
	0xdaee982,
	0x3af843,
	0x3507c3,
	0x217a02,
	0xde04142,
	0x2c1946,
	0x233ac7,
	0x2e8945,
	0x37de04,
	0x28c505,
	0x268907,
	0x267805,
	0x2b8649,
	0x2cefc6,
	0x2daa88,
	0x2e8846,
	0xe21a1c2,
	0x32ca08,
	0x2f1c46,
	0x21a1c5,
	0x2f6d87,
	0x309984,
	0x309985,
	0x276384,
	0x276388,
	0xe60cc02,
	0xea09882,
	0x3103c6,
	0x3b8988,
	0x334385,
	0x337306,
	0x342f08,
	0x344a88,
	0xee09885,
	0xf2142c4,
	0x3b0787,
	0xf60e5c2,
	0xfa1b102,
	0x10a099c2,
	0x2b9785,
	0x2a2645,
	0x2fef86,
	0x3b2547,
	0x380747,
	0x112a84c3,
	0x2a84c7,
	0x31eb08,
	0x376ec9,
	0x376d07,
	0x384d07,
	0x3a8ec8,
	0x3ad4c6,
	0x22f3c6,
	0x23000c,
	0x23120a,
	0x231687,
	0x232c8b,
	0x233907,
	0x23390e,
	0x234cc4,
	0x235ac4,
	0x237a47,
	0x3690c7,
	0x23b206,
	0x23b207,
	0x23b4c7,
	0x19604682,
	0x23c886,
	0x23c88a,
	0x23ce8b,
	0x23dbc7,
	0x23ed45,
	0x23f083,
	0x240586,
	0x240587,
	0x38eb43,
	0x19a0c442,
	0x240f4a,
	0x19f5d882,
	0x1a2a5e02,
	0x1a643142,
	0x1aa2cd82,
	0x244bc5,
	0x245304,
	0x1b205742,
	0x268dc5,
	0x23d483,
	0x20eac5,
	0x22ad44,
	0x206804,
	0x314046,
	0x25e206,
	0x28a003,
	0x238284,
	0x3a6803,
	0x1b600dc2,
	0x391c04,
	0x391c06,
	0x3b0d05,
	0x205e06,
	0x2f6e88,
	0x266e84,
	0x27ed08,
	0x2426c5,
	0x228308,
	0x29ff86,
	0x237587,
	0x22e204,
	0x22e206,
	0x33f443,
	0x383ec3,
	0x223d08,
	0x318dc4,
	0x348747,
	0x23e6c6,
	0x2d6389,
	0x250348,
	0x26cd08,
	0x26d084,
	0x351443,
	0x225e02,
	0x1c60f882,
	0x1ca10e82,
	0x3a7403,
	0x1ce04a42,
	0x38eac4,
	0x2862c6,
	0x26e605,
	0x21ba03,
	0x232884,
	0x2b14c7,
	0x33da03,
	0x231a88,
	0x208545,
	0x36e803,
	0x273445,
	0x273584,
	0x2f6a86,
	0x209ec4,
	0x211346,
	0x211b86,
	0x3916c4,
	0x213b43,
	0x1d205882,
	0x247345,
	0x221c03,
	0x1d61b0c2,
	0x22ffc3,
	0x209bc5,
	0x232403,
	0x232409,
	0x1da05f02,
	0x1e205e42,
	0x2893c5,
	0x218786,
	0x2d1746,
	0x2b0a88,
	0x2b0a8b,
	0x20718b,
	0x2e8b45,
	0x2db145,
	0x2c6309,
	0x1600302,
	0x391888,
	0x20dc44,
	0x1ea007c2,
	0x3a7883,
	0x1f2c6086,
	0x20ae88,
	0x1f601402,
	0x2344c8,
	0x1fa2bb82,
	0x3b92ca,
	0x1feccc43,
	0x3ac1c6,
	0x3af408,
	0x3ac008,
	0x31d006,
	0x36bc07,
	0x264a07,
	0x3349ca,
	0x2d77c4,
	0x3474c4,
	0x35c1c9,
	0x20794385,
	0x209686,
	0x20e1c3,
	0x24a044,
	0x20a02644,
	0x202647,
	0x212fc7,
	0x22a584,
	0x285445,
	0x2ff048,
	0x366747,
	0x370f07,
	0x20e18342,
	0x327704,
	0x292b48,
	0x245bc4,
	0x247784,
	0x248085,
	0x2481c7,
	0x223589,
	0x248fc4,
	0x249709,
	0x249948,
	0x249dc4,
	0x249dc7,
	0x2124aa83,
	0x24ad47,
	0x1609d02,
	0x16ad202,
	0x24bec6,
	0x24c507,
	0x24cd44,
	0x24e6c7,
	0x24fa47,
	0x24fdc3,
	0x248902,
	0x229642,
	0x250a03,
	0x250a04,
	0x250a0b,
	0x379a48,
	0x256804,
	0x2523c5,
	0x254007,
	0x2555c5,
	0x2bc00a,
	0x256743,
	0x2160fc82,
	0x226e84,
	0x258d89,
	0x25c343,
	0x25c407,
	0x24a849,
	0x282688,
	0x204743,
	0x278fc7,
	0x279709,
	0x268ac3,
	0x2810c4,
	0x283c89,
	0x2880c6,
	0x289683,
	0x200182,
	0x21f983,
	0x3a8a87,
	0x21f985,
	0x379746,
	0x256e84,
	0x302e85,
	0x2e4403,
	0x216c46,
	0x20db42,
	0x395144,
	0x221402,
	0x221403,
	0x21a00782,
	0x247303,
	0x215c44,
	0x215c47,
	0x200906,
	0x202602,
	0x21e025c2,
	0x2dca84,
	0x22235e82,
	0x22600b02,
	0x2d4f84,
	0x2d4f85,
	0x2b6dc5,
	0x390e06,
	0x22a05d42,
	0x205d45,
	0x20cf05,
	0x20ae03,
	0x210986,
	0x2126c5,
	0x2166c2,
	0x343605,
	0x2166c4,
	0x221ec3,
	0x227343,
	0x22e0c642,
	0x2d4987,
	0x3669c4,
	0x3669c9,
	0x249f44,
	0x291d43,
	0x2f6609,
	0x367508,
	0x232a24c4,
	0x2a24c6,
	0x21c303,
	0x247bc3,
	0x2e9dc3,
	0x236eb382,
	0x368cc2,
	0x23a05e82,
	0x323cc8,
	0x32a388,
	0x398e46,
	0x2e27c5,
	0x22efc5,
	0x352ec7,
	0x21d205,
	0x228782,
	0x23e38182,
	0x1603002,
	0x2416c8,
	0x32c945,
	0x2e3404,
	0x2ebac5,
	0x23f407,
	0x3207c4,
	0x240e42,
	0x24200582,
	0x338984,
	0x212cc7,
	0x28a2c7,
	0x34ff84,
	0x292203,
	0x245444,
	0x245448,
	0x22f706,
	0x26598a,
	0x223444,
	0x292588,
	0x288504,
	0x221946,
	0x294684,
	0x2b9a86,
	0x366c89,
	0x25da47,
	0x3375c3,
	0x24667e42,
	0x267e43,
	0x20ee02,
	0x24a11ec2,
	0x3085c6,
	0x365c88,
	0x2a4087,
	0x3a3f49,
	0x291c49,
	0x2a5045,
	0x2a6049,
	0x2a6805,
	0x2a6949,
	0x2a8005,
	0x2a9108,
	0x21fb84,
	0x24e890c7,
	0x2a9303,
	0x2a9307,
	0x3850c6,
	0x2a9b87,
	0x2a1085,
	0x2935c3,
	0x2521ae02,
	0x3b40c4,
	0x2562ce82,
	0x258203,
	0x25a17f42,
	0x36d586,
	0x2f3a85,
	0x2ac207,
	0x26cc43,
	0x325044,
	0x20e903,
	0x33e783,
	0x25e02bc2,
	0x266015c2,
	0x398804,
	0x2488c3,
	0x243c85,
	0x26a029c2,
	0x27206482,
	0x2b4506,
	0x318f04,
	0x2e3004,
	0x2e300a,
	0x27a01fc2,
	0x37204a,
	0x3756c8,
	0x27fb1384,
	0x20ad83,
	0x201fc3,
	0x3a9a49,
	0x217649,
	0x285246,
	0x28244183,
	0x3292c5,
	0x30180d,
	0x375886,
	0x3bac8b,
	0x28602e82,
	0x22c1c8,
	0x29206e82,
	0x29606fc2,
	0x2ae585,
	0x29a03942,
	0x258447,
	0x21c907,
	0x21e003,
	0x2306c8,
	0x29e06502,
	0x312684,
	0x212943,
	0x351d45,
	0x34db83,
	0x2f3546,
	0x205904,
	0x268103,
	0x2ae9c3,
	0x2a205fc2,
	0x2e8ac4,
	0x35f6c5,
	0x39f1c7,
	0x275643,
	0x2ad883,
	0x2ae083,
	0x160fec2,
	0x2ae143,
	0x2ae943,
	0x2a605102,
	0x282104,
	0x25e406,
	0x342643,
	0x2aec43,
	0x2aaafd42,
	0x2afd48,
	0x2b0004,
	0x36c246,
	0x2b0387,
	0x249c46,
	0x28e2c4,
	0x38600682,
	0x384f8b,
	0x2fb08e,
	0x21930f,
	0x2985c3,
	0x38ebbbc2,
	0x1600f42,
	0x39201582,
	0x28f403,
	0x2fdec3,
	0x233706,
	0x277c46,
	0x3afd87,
	0x3328c4,
	0x396188c2,
	0x39a08882,
	0x348345,
	0x2e6047,
	0x3b5746,
	0x39e27282,
	0x227284,
	0x2b3ac3,
	0x3a20be02,
	0x3a759ec3,
	0x2b4c44,
	0x2be409,
	0x16c3ac2,
	0x3aa03a82,
	0x203a85,
	0x3aec3d42,
	0x3b203202,
	0x346947,
	0x239689,
	0x35ca0b,
	0x2647c5,
	0x2c4849,
	0x2e8246,
	0x31e6c7,
	0x3b608484,
	0x3199c9,
	0x373487,
	0x20ab47,
	0x20a383,
	0x20a386,
	0x3b68c7,
	0x206a43,
	0x2565c6,
	0x3be02a02,
	0x3c232682,
	0x385803,
	0x324c45,
	0x350f47,
	0x250086,
	0x21f905,
	0x277d44,
	0x2c9fc5,
	0x2f2684,
	0x3c6040c2,
	0x331107,
	0x2dbd44,
	0x217544,
	0x21754d,
	0x257509,
	0x3a4448,
	0x253944,
	0x3abc45,
	0x206447,
	0x2144c4,
	0x2e1947,
	0x21c485,
	0x3caa4604,
	0x2d92c5,
	0x25b004,
	0x24bb86,
	0x3b2345,
	0x3ce250c2,
	0x283844,
	0x283845,
	0x36fa46,
	0x20c3c5,
	0x30c304,
	0x2c5dc3,
	0x2053c6,
	0x358505,
	0x2bb485,
	0x3b2444,
	0x2234c3,
	0x2234cc,
	0x3d288a02,
	0x3d6010c2,
	0x3da00282,
	0x206343,
	0x206344,
	0x3de04bc2,
	0x2f9688,
	0x379805,
	0x235684,
	0x23b086,
	0x3e201f42,
	0x3e609782,
	0x3ea00e82,
	0x306b85,
	0x391586,
	0x211084,
	0x3263c6,
	0x2ba346,
	0x219943,
	0x3ef0de0a,
	0x247b05,
	0x2c8e83,
	0x223186,
	0x300fc9,
	0x223187,
	0x297788,
	0x2981c9,
	0x224348,
	0x229486,
	0x20bf03,
	0x3f2a8542,
	0x385683,
	0x385689,
	0x332448,
	0x3f649a02,
	0x3fa02342,
	0x227f83,
	0x2da905,
	0x251ec4,
	0x2c0909,
	0x22cb84,
	0x266348,
	0x202343,
	0x202344,
	0x278b03,
	0x2187c8,
	0x217487,
	0x4020b102,
	0x274082,
	0x351905,
	0x266689,
	0x209703,
	0x27b184,
	0x329284,
	0x2064c3,
	0x27c3ca,
	0x40752bc2,
	0x40a83802,
	0x2c5443,
	0x3739c3,
	0x1602302,
	0x38ac03,
	0x40e0f242,
	0x4120ec42,
	0x41610444,
	0x210446,
	0x383b06,
	0x26ad44,
	0x36c643,
	0x38bcc3,
	0x226883,
	0x23d206,
	0x2cb8c5,
	0x2c5a07,
	0x31e589,
	0x2ca645,
	0x2cb806,
	0x2cbd88,
	0x2cbf86,
	0x236a04,
	0x29944b,
	0x2ceac3,
	0x2ceac5,
	0x2cec08,
	0x228502,
	0x346c42,
	0x41a44c42,
	0x41e0e602,
	0x218903,
	0x422675c2,
	0x2675c3,
	0x2cef04,
	0x2cf5c3,
	0x42a115c2,
	0x42ed43c6,
	0x2a7306,
	0x43207902,
	0x4360f442,
	0x43a27382,
	0x43e02c82,
	0x4422dd02,
	0x44602d02,
	0x234703,
	0x390685,
	0x319606,
	0x44a11cc4,
	0x3b0b0a,
	0x32fe86,
	0x2e8d84,
	0x281d03,
	0x45604642,
	0x200c82,
	0x25fd03,
	0x45a05503,
	0x2c7b87,
	0x3b2247,
	0x47250b07,
	0x312d87,
	0x227b03,
	0x227b0a,
	0x236b84,
	0x23e5c4,
	0x23e5ca,
	0x213f05,
	0x47609642,
	0x24e683,
	0x47a008c2,
	0x21c2c3,
	0x267e03,
	0x48203342,
	0x2a8444,
	0x21de84,
	0x3b9505,
	0x305005,
	0x2e1ac6,
	0x2e1e46,
	0x48608442,
	0x48a033c2,
	0x3185c5,
	0x2a7012,
	0x2511c6,
	0x220803,
	0x30a746,
	0x220805,
	0x1610602,
	0x50e120c2,
	0x353e83,
	0x2120c3,
	0x2441c3,
	0x512023c2,
	0x376e43,
	0x5160b482,
	0x210483,
	0x282148,
	0x25e983,
	0x25e986,
	0x3a2987,
	0x306806,
	0x30680b,
	0x2e8cc7,
	0x3b3ec4,
	0x51e04ec2,
	0x379685,
	0x522054c3,
	0x2a6e03,
	0x326c05,
	0x329983,
	0x52729986,
	0x391a0a,
	0x26a9c3,
	0x204584,
	0x3b88c6,
	0x21a5c6,
	0x52a00983,
	0x324f07,
	0x285147,
	0x29b0c5,
	0x2318c6,
	0x224a83,
	0x54a10bc3,
	0x54e056c2,
	0x328144,
	0x22a2cc,
	0x236149,
	0x2414c7,
	0x249245,
	0x262a84,
	0x273cc8,
	0x278305,
	0x55284a05,
	0x28c609,
	0x351f43,
	0x2a5d84,
	0x556013c2,
	0x2013c3,
	0x55a94142,
	0x2a4386,
	0x160f982,
	0x55e06e02,
	0x306a88,
	0x2be603,
	0x2d9207,
	0x2e4d05,
	0x2dd685,
	0x32840b,
	0x2dd686,
	0x328606,
	0x2ffac6,
	0x262c84,
	0x3042c6,
	0x2e3508,
	0x23a043,
	0x250dc3,
	0x250dc4,
	0x2e4484,
	0x2e4a07,
	0x2e5ec5,
	0x562e6002,
	0x5660ba02,
	0x20ba05,
	0x2e83c4,
	0x2e83cb,
	0x2e8e88,
	0x228f44,
	0x2272c2,
	0x56e28ec2,
	0x23b903,
	0x2e9344,
	0x2e9605,
	0x2ea047,
	0x2eb604,
	0x2e8b84,
	0x57201302,
	0x360cc9,
	0x2ec405,
	0x264a85,
	0x2ecf85,
	0x57601303,
	0x2ee0c4,
	0x2ee0cb,
	0x2ee644,
	0x2ef3cb,
	0x2ef7c5,
	0x21944a,
	0x2f0048,
	0x2f024a,
	0x2f0ac3,
	0x2f0aca,
	0x57a01742,
	0x57e2d4c2,
	0x21aa03,
	0x582f1bc2,
	0x2f1bc3,
	0x5875c402,
	0x58b22842,
	0x2f2504,
	0x21afc6,
	0x326105,
	0x2f4503,
	0x31a9c6,
	0x204405,
	0x25e704,
	0x58e05ec2,
	0x2c9244,
	0x2c5f8a,
	0x22d787,
	0x2f38c6,
	0x380b07,
	0x22a403,
	0x283e48,
	0x37f48b,
	0x3736c5,
	0x333ec5,
	0x333ec6,
	0x390884,
	0x3aa248,
	0x222943,
	0x222944,
	0x222947,
	0x38e446,
	0x352686,
	0x29018a,
	0x246604,
	0x24660a,
	0x59282846,
	0x282847,
	0x252447,
	0x270844,
	0x270849,
	0x25e0c5,
	0x235e0b,
	0x2e81c3,
	0x211503,
	0x22f003,
	0x22fac4,
	0x59600482,
	0x25d4c6,
	0x293345,
	0x30a985,
	0x24f6c6,
	0x3395c4,
	0x59a02782,
	0x23f0c4,
	0x59e01c42,
	0x2b9f05,
	0x21ad84,
	0x21bec3,
	0x5a612102,
	0x212103,
	0x23ba46,
	0x5aa03082,
	0x27f488,
	0x223004,
	0x223006,
	0x374246,
	0x2540c4,
	0x205345,
	0x2141c8,
	0x216547,
	0x219687,
	0x21968f,
	0x292a46,
	0x22cf03,
	0x22cf04,
	0x310504,
	0x20d003,
	0x221a84,
	0x240944,
	0x5ae42b02,
	0x289d43,
	0x242b03,
	0x5b209842,
	0x229f83,
	0x38eb83,
	0x21484a,
	0x358107,
	0x2efc0c,
	0x2efec6,
	0x30a146,
	0x248547,
	0x5b64c687,
	0x24f809,
	0x243584,
	0x24fbc4,
	0x5ba18942,
	0x5be027c2,
	0x290546,
	0x324d04,
	0x2d6bc6,
	0x2a5148,
	0x3b8dc4,
	0x258486,
	0x2d1705,
	0x265c88,
	0x207383,
	0x273705,
	0x273e83,
	0x264b83,
	0x264b84,
	0x2759c3,
	0x5c2ec082,
	0x5c602e02,
	0x2e8089,
	0x278205,
	0x278404,
	0x27a9c5,
	0x20dd44,
	0x2e0d07,
	0x343bc5,
	0x250cc4,
	0x250cc8,
	0x2d5086,
	0x2d7984,
	0x2d8e88,
	0x2dbb87,
	0x5ca03902,
	0x2e36c4,
	0x20d0c4,
	0x20ad47,
	0x5ce2b804,
	0x2ccf42,
	0x5d201102,
	0x201543,
	0x203984,
	0x2aa283,
	0x374e05,
	0x5d61e182,
	0x2eb285,
	0x202c42,
	0x34d5c5,
	0x365e45,
	0x5da00c42,
	0x350744,
	0x5de00d02,
	0x2387c6,
	0x29a146,
	0x2667c8,
	0x2bfa08,
	0x36d504,
	0x36d6c5,
	0x3610c9,
	0x2db1c4,
	0x3919c4,
	0x205183,
	0x5e222705,
	0x2c3b87,
	0x2a2744,
	0x341e8d,
	0x361782,
	0x361783,
	0x364503,
	0x5e600802,
	0x388305,
	0x25f9c7,
	0x205b44,
	0x312e47,
	0x2983c9,
	0x2c60c9,
	0x2519c7,
	0x273b03,
	0x273b08,
	0x2ed249,
	0x24e187,
	0x373605,
	0x39e086,
	0x39fb86,
	0x3a3c05,
	0x257605,
	0x5ea02d82,
	0x36ce45,
	0x2b2908,
	0x2c1706,
	0x5eeb7487,
	0x2efa04,
	0x2aa987,
	0x2f62c6,
	0x5f230982,
	0x36f746,
	0x2f83ca,
	0x2f8e85,
	0x5f6de402,
	0x5fa36542,
	0x3b6c06,
	0x2a1e88,
	0x5fe8a487,
	0x60234e42,
	0x2255c3,
	0x311d86,
	0x225044,
	0x3a2846,
	0x390b06,
	0x26ff0a,
	0x331c05,
	0x367ec6,
	0x3759c3,
	0x3759c4,
	0x207102,
	0x309943,
	0x60606382,
	0x2f0f83,
	0x3722c4,
	0x2a1fc4,
	0x2a1fca,
	0x229543,
	0x276288,
	0x22954a,
	0x27b447,
	0x2fcd86,
	0x238684,
	0x290bc2,
	0x2a2e82,
	0x60a04002,
	0x245403,
	0x252207,
	0x31ac87,
	0x2848c4,
	0x26f8c7,
	0x2ea146,
	0x216847,
	0x35e604,
	0x242a05,
	0x2b7985,
	0x60e0fe82,
	0x20fe86,
	0x218283,
	0x220502,
	0x220506,
	0x61203e02,
	0x6160b0c2,
	0x3ba785,
	0x61a21c82,
	0x61e03b42,
	0x33b5c5,
	0x393105,
	0x367f85,
	0x267303,
	0x286385,
	0x2dd747,
	0x307bc5,
	0x306185,
	0x38b044,
	0x3204c6,
	0x23e804,
	0x62201442,
	0x62f630c5,
	0x2ebe07,
	0x2d6dc8,
	0x25fe86,
	0x25fe8d,
	0x260709,
	0x260712,
	0x32f345,
	0x3339c3,
	0x6320a9c2,
	0x309444,
	0x375903,
	0x360fc5,
	0x2fa085,
	0x63612982,
	0x36e843,
	0x63a50b82,
	0x642bf542,
	0x6460fb42,
	0x353805,
	0x37ac43,
	0x37a4c8,
	0x64a07842,
	0x64e000c2,
	0x2a8406,
	0x33b80a,
	0x21bf03,
	0x20c343,
	0x2ee3c3,
	0x65a02dc2,
	0x73e35482,
	0x74601c82,
	0x201682,
	0x36f549,
	0x2c2f04,
	0x2309c8,
	0x74af4542,
	0x74e08602,
	0x2ef605,
	0x2330c8,
	0x282288,
	0x2f858c,
	0x22d543,
	0x25a9c2,
	0x75201f82,
	0x2caac6,
	0x2fdc05,
	0x26d343,
	0x23cc46,
	0x2fdd46,
	0x201f83,
	0x2ff883,
	0x300786,
	0x3013c4,
	0x295586,
	0x2cec85,
	0x30164a,
	0x2eebc4,
	0x302304,
	0x30370a,
	0x7566b082,
	0x337745,
	0x30478a,
	0x305285,
	0x305b44,
	0x305c46,
	0x305dc4,
	0x218dc6,
	0x75a6dac2,
	0x2f3206,
	0x2f3dc5,
	0x3ab6c7,
	0x200206,
	0x248744,
	0x2d5e07,
	0x30dd46,
	0x2b8a45,
	0x381947,
	0x39eb47,
	0x39eb4e,
	0x25ed06,
	0x2e1805,
	0x27dec7,
	0x282b43,
	0x3b2f87,
	0x20f5c5,
	0x212144,
	0x212f82,
	0x3addc7,
	0x332944,
	0x377404,
	0x273f0b,
	0x21d5c3,
	0x2b6987,
	0x21d5c4,
	0x2cc0c7,
	0x228bc3,
	0x33678d,
	0x388b48,
	0x21d044,
	0x250bc5,
	0x307d05,
	0x308143,
	0x75e22f02,
	0x309903,
	0x309fc3,
	0x210004,
	0x279805,
	0x218307,
	0x375a46,
	0x372003,
	0x23ab4b,
	0x26ba4b,
	0x2a654b,
	0x2de44a,
	0x30254b,
	0x31be8b,
	0x356b8c,
	0x378d11,
	0x3b654a,
	0x3ba10b,
	0x30ad8b,
	0x30b34a,
	0x30b88a,
	0x30cb4e,
	0x30d18b,
	0x30d44a,
	0x30ef11,
	0x30f34a,
	0x30f84b,
	0x30fd8e,
	0x31078c,
	0x310c4b,
	0x310f0e,
	0x31128c,
	0x31474a,
	0x31698c,
	0x76316c8a,
	0x317489,
	0x31af4a,
	0x31b1ca,
	0x31b44b,
	0x31f60e,
	0x31f991,
	0x328b89,
	0x328dca,
	0x3295cb,
	0x32a84a,
	0x32b316,
	0x32e14b,
	0x32f10a,
	0x32f50a,
	0x33084b,
	0x333449,
	0x337109,
	0x337d4d,
	0x33870b,
	0x33978b,
	0x33a14b,
	0x33a609,
	0x33ac4e,
	0x33b30a,
	0x33fc8a,
	0x33ffca,
	0x340b8b,
	0x3413cb,
	0x34168d,
	0x342c0d,
	0x343290,
	0x34374b,
	0x34408c,
	0x34480b,
	0x34644b,
	0x34798b,
	0x34c00b,
	0x34ca8f,
	0x34ce4b,
	0x34d94a,
	0x34e689,
	0x34f409,
	0x34f8cb,
	0x34fb8e,
	0x35434b,
	0x35574f,
	0x35864b,
	0x35890b,
	0x358bcb,
	0x3590ca,
	0x35c609,
	0x35f34f,
	0x36424c,
	0x36488c,
	0x364d0e,
	0x3653cf,
	0x36578e,
	0x365fd0,
	0x3663cf,
	0x366f4e,
	0x36770c,
	0x367a12,
	0x3689d1,
	0x36988e,
	0x36a04e,
	0x36a58e,
	0x36a90f,
	0x36acce,
	0x36b053,
	0x36b511,
	0x36b94e,
	0x36bdcc,
	0x36d913,
	0x36e210,
	0x36ea8c,
	0x36ed8c,
	0x36f24b,
	0x3703ce,
	0x370c8b,
	0x3715cb,
	0x37258c,
	0x37814a,
	0x37850c,
	0x37880c,
	0x378b09,
	0x37bb8b,
	0x37be48,
	0x37c049,
	0x37c04f,
	0x37d98b,
	0x7677eb8a,
	0x381fcc,
	0x383189,
	0x383608,
	0x38380b,
	0x383c8b,
	0x38480a,
	0x384a8b,
	0x38540c,
	0x386008,
	0x388d4b,
	0x38b44b,
	0x39484b,
	0x3958cb,
	0x39e6cb,
	0x39e989,
	0x39eecd,
	0x3a464a,
	0x3a5597,
	0x3a6bd8,
	0x3a96c9,
	0x3ab30b,
	0x3ac814,
	0x3acd0b,
	0x3ad28a,
	0x3aea0a,
	0x3aec8b,
	0x3b4250,
	0x3b4651,
	0x3b4d0a,
	0x3b5b4d,
	0x3b624d,
	0x3ba3cb,
	0x3bbd46,
	0x20ff83,
	0x76b80483,
	0x22cdc6,
	0x247645,
	0x27a007,
	0x31bd46,
	0x1656682,
	0x2ad9c9,
	0x31a7c4,
	0x2dacc8,
	0x232b43,
	0x309387,
	0x234f42,
	0x2ac243,
	0x76e07b02,
	0x2c7406,
	0x2c9884,
	0x369f44,
	0x390143,
	0x390145,
	0x776c3d82,
	0x77aa6cc4,
	0x270787,
	0x77e4a282,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x209703,
	0x205503,
	0x200983,
	0x204e83,
	0x205702,
	0x16d208,
	0x2099c2,
	0x2e9dc3,
	0x209703,
	0x205503,
	0x200983,
	0x214843,
	0x324556,
	0x325793,
	0x26f749,
	0x3b0688,
	0x379509,
	0x304906,
	0x3389d0,
	0x254b53,
	0x38e508,
	0x28ea47,
	0x36c747,
	0x284d0a,
	0x372349,
	0x38d849,
	0x28decb,
	0x349846,
	0x379b4a,
	0x220d86,
	0x31a3c3,
	0x2d48c5,
	0x35e288,
	0x23888d,
	0x2b984c,
	0x2de0c7,
	0x30b00d,
	0x2142c4,
	0x22fd8a,
	0x230d4a,
	0x23120a,
	0x2099c7,
	0x23af07,
	0x23d844,
	0x22e206,
	0x20c144,
	0x2b4148,
	0x22cbc9,
	0x2b0a86,
	0x2b0a88,
	0x2422cd,
	0x2c6309,
	0x3ac008,
	0x264a07,
	0x2f1f0a,
	0x24c506,
	0x2580c7,
	0x2cc3c4,
	0x23f287,
	0x309c0a,
	0x3ae54e,
	0x21d205,
	0x3b4a4b,
	0x331a09,
	0x217649,
	0x21c747,
	0x2a34ca,
	0x20ac87,
	0x2fb1c9,
	0x38f0c8,
	0x3533cb,
	0x2da905,
	0x3a430a,
	0x266e09,
	0x26d2ca,
	0x2ca6cb,
	0x23f18b,
	0x28dc55,
	0x2e3b85,
	0x264a85,
	0x2ee0ca,
	0x3945ca,
	0x331787,
	0x21da83,
	0x2904c8,
	0x2d2c4a,
	0x223006,
	0x24dfc9,
	0x265c88,
	0x2d7984,
	0x2aa289,
	0x2bfa08,
	0x29fec7,
	0x3630c6,
	0x2ebe07,
	0x289a47,
	0x23d005,
	0x21d04c,
	0x250bc5,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x2099c2,
	0x2a84c3,
	0x205503,
	0x204e83,
	0x200983,
	0x2a84c3,
	0x205503,
	0x25e983,
	0x200983,
	0x16d208,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x209703,
	0x205503,
	0x200983,
	0x16d208,
	0x2099c2,
	0x2006c2,
	0x231442,
	0x206502,
	0x200542,
	0x2decc2,
	0x46a84c3,
	0x232403,
	0x2163c3,
	0x2e9dc3,
	0x244183,
	0x209703,
	0x2d47c6,
	0x205503,
	0x200983,
	0x233183,
	0x16d208,
	0x31ae44,
	0x202107,
	0x392403,
	0x2ae584,
	0x22e043,
	0x21c7c3,
	0x2e9dc3,
	0x16fc07,
	0x205702,
	0x18d2c3,
	0x5a099c2,
	0x88f4d,
	0x8928d,
	0x231442,
	0x1b1384,
	0x200442,
	0x5fb1288,
	0xed844,
	0x16d208,
	0x1411d82,
	0x15054c6,
	0x231783,
	0x200c03,
	0x66a84c3,
	0x22fd84,
	0x6a32403,
	0x6ee9dc3,
	0x202bc2,
	0x3b1384,
	0x205503,
	0x2f78c3,
	0x203ec2,
	0x200983,
	0x21b5c2,
	0x2f2443,
	0x203082,
	0x211643,
	0x265d43,
	0x200202,
	0x16d208,
	0x231783,
	0x2f78c3,
	0x203ec2,
	0x2f2443,
	0x203082,
	0x211643,
	0x265d43,
	0x200202,
	0x2f2443,
	0x203082,
	0x211643,
	0x265d43,
	0x200202,
	0x2a84c3,
	0x38d2c3,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x3b1384,
	0x244183,
	0x209703,
	0x211cc4,
	0x205503,
	0x200983,
	0x20f942,
	0x201303,
	0x16d208,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x209703,
	0x205503,
	0x200983,
	0x38d2c3,
	0x2099c2,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x3b1384,
	0x205503,
	0x200983,
	0x373605,
	0x212982,
	0x205702,
	0x16d208,
	0x1456108,
	0x2e9dc3,
	0x2274c1,
	0x202901,
	0x202941,
	0x23ad81,
	0x23ad01,
	0x30aec1,
	0x23aec1,
	0x2275c1,
	0x2eea41,
	0x30afc1,
	0x200141,
	0x200001,
	0x129845,
	0x16d208,
	0x201ec1,
	0x200701,
	0x200301,
	0x200081,
	0x200181,
	0x200401,
	0x200041,
	0x201181,
	0x200101,
	0x200281,
	0x200e81,
	0x2008c1,
	0x200441,
	0x201301,
	0x206ec1,
	0x200341,
	0x200801,
	0x2002c1,
	0x2000c1,
	0x201501,
	0x200201,
	0x200bc1,
	0x2005c1,
	0x201cc1,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x2099c2,
	0x2a84c3,
	0x232403,
	0x200442,
	0x200983,
	0x16fc07,
	0x9807,
	0x1cdc6,
	0x13ef8a,
	0x88648,
	0x51d48,
	0x52107,
	0x191106,
	0xd8c05,
	0x192345,
	0x5d306,
	0x125c86,
	0x25ef44,
	0x311547,
	0x16d208,
	0x2d5f04,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x2a84c3,
	0x232403,
	0x2163c3,
	0x2e9dc3,
	0x244183,
	0x209703,
	0x205503,
	0x200983,
	0x212982,
	0x2c5983,
	0x2bb143,
	0x32c243,
	0x2022c2,
	0x25d183,
	0x2030c3,
	0x204903,
	0x200001,
	0x2dc745,
	0x206b43,
	0x221344,
	0x26cc83,
	0x318ec3,
	0x21b103,
	0x35ff43,
	0xaaa84c3,
	0x235ac4,
	0x23dbc3,
	0x21cc43,
	0x21b0c3,
	0x22ffc3,
	0x232403,
	0x232143,
	0x2459c3,
	0x2a2703,
	0x318e43,
	0x2344c3,
	0x202643,
	0x24ce44,
	0x24e347,
	0x248902,
	0x250943,
	0x256303,
	0x273ac3,
	0x390f43,
	0x2025c3,
	0xaee9dc3,
	0x20bec3,
	0x2143c3,
	0x24a5c3,
	0x328085,
	0x209d43,
	0x2fa383,
	0xb21f903,
	0x365f03,
	0x20d543,
	0x227f83,
	0x209703,
	0x228502,
	0x27d2c3,
	0x205503,
	0x1604e83,
	0x224a43,
	0x209a43,
	0x204a03,
	0x200983,
	0x35fe83,
	0x20f943,
	0x201303,
	0x2efe83,
	0x2ff903,
	0x2f2603,
	0x204405,
	0x23e743,
	0x285346,
	0x2f2643,
	0x36cf43,
	0x3759c4,
	0x2d9083,
	0x2284c3,
	0x267ec3,
	0x233183,
	0x212982,
	0x22d543,
	0x3024c3,
	0x304144,
	0x377404,
	0x20ce83,
	0x16d208,
	0x205702,
	0x200242,
	0x2022c2,
	0x201702,
	0x202a42,
	0x206c02,
	0x245482,
	0x2007c2,
	0x20d882,
	0x200e82,
	0x20b102,
	0x20e602,
	0x2675c2,
	0x2056c2,
	0x2decc2,
	0x2013c2,
	0x2069c2,
	0x201302,
	0x2172c2,
	0x202482,
	0x200482,
	0x219382,
	0x202782,
	0x209842,
	0x2027c2,
	0x222702,
	0x203b42,
	0x5702,
	0x242,
	0x22c2,
	0x1702,
	0x2a42,
	0x6c02,
	0x45482,
	0x7c2,
	0xd882,
	0xe82,
	0xb102,
	0xe602,
	0x675c2,
	0x56c2,
	0xdecc2,
	0x13c2,
	0x69c2,
	0x1302,
	0x172c2,
	0x2482,
	0x482,
	0x19382,
	0x2782,
	0x9842,
	0x27c2,
	0x22702,
	0x3b42,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x2099c2,
	0x200983,
	0xc6a84c3,
	0x2e9dc3,
	0x209703,
	0x21a2c2,
	0x16d208,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x7b02,
	0x201bc2,
	0x153f3c5,
	0x25ed82,
	0x16d208,
	0x99c2,
	0x20c182,
	0x208d02,
	0x2024c2,
	0x209642,
	0x208442,
	0x192345,
	0x2038c2,
	0x203ec2,
	0x2023c2,
	0x204dc2,
	0x2013c2,
	0x385502,
	0x201102,
	0x236582,
	0x16fc07,
	0x1b270d,
	0xd8c89,
	0x56e8b,
	0xdd608,
	0x53dc9,
	0xfacc6,
	0x2e9dc3,
	0x16d208,
	0x16d208,
	0x52e06,
	0x1a78c7,
	0x205702,
	0x25ef44,
	0x2099c2,
	0x2a84c3,
	0x2006c2,
	0x232403,
	0x20d882,
	0x2d5f04,
	0x244183,
	0x249a02,
	0x205503,
	0x200442,
	0x200983,
	0x264a86,
	0x31ba0f,
	0x70a403,
	0x16d208,
	0x2099c2,
	0x2163c3,
	0x2e9dc3,
	0x209703,
	0x1526f4b,
	0xd9888,
	0x142b68a,
	0x14fa807,
	0xda405,
	0x16fc07,
	0x2099c2,
	0x2a84c3,
	0x2e9dc3,
	0x205503,
	0x205702,
	0x20c202,
	0x20bb42,
	0xfea84c3,
	0x23c042,
	0x232403,
	0x209d02,
	0x221402,
	0x2e9dc3,
	0x228782,
	0x251442,
	0x2a6c82,
	0x200f82,
	0x28d742,
	0x203442,
	0x202e42,
	0x267e42,
	0x24ecc2,
	0x211ec2,
	0x2ad882,
	0x2eab02,
	0x2182c2,
	0x2ad342,
	0x209703,
	0x20ec42,
	0x205503,
	0x200e42,
	0x281702,
	0x200983,
	0x25d202,
	0x209842,
	0x218942,
	0x202e02,
	0x200c42,
	0x2de402,
	0x20fe82,
	0x250b82,
	0x220642,
	0x30d44a,
	0x34d94a,
	0x37fc4a,
	0x3bbec2,
	0x202cc2,
	0x2058c2,
	0x1026e389,
	0x1072510a,
	0x1594ac7,
	0x1410843,
	0x24d50,
	0x50642,
	0x2030c4,
	0x10ea84c3,
	0x232403,
	0x249944,
	0x2e9dc3,
	0x3b1384,
	0x244183,
	0x209703,
	0x205503,
	0xdc105,
	0x204e83,
	0x200983,
	0x23e743,
	0x25ed03,
	0x16d208,
	0x1591084,
	0x18ff45,
	0x1a768a,
	0x116902,
	0x18ae46,
	0xaf551,
	0x1166e389,
	0x18ffc8,
	0x13f9c8,
	0xff387,
	0xec2,
	0x12984b,
	0x1a5b0a,
	0x21347,
	0x16d208,
	0x108f08,
	0xe4c7,
	0x17818f4b,
	0x1b887,
	0x1c02,
	0x6c707,
	0x1a1ca,
	0x13f6cf,
	0x988f,
	0x1b102,
	0x99c2,
	0xa2648,
	0x19e30a,
	0x1320c8,
	0xdc2,
	0x13f44f,
	0x9e18b,
	0x68bc8,
	0x38f47,
	0x388a,
	0x304cb,
	0x4efc9,
	0x11dd07,
	0xfc34c,
	0x2c07,
	0x19b40a,
	0xd4ac8,
	0x1a3cce,
	0x1cdce,
	0x2118b,
	0x26ccb,
	0x27d4b,
	0x2c009,
	0x2da0b,
	0x5e7cd,
	0x85acb,
	0xdfc8d,
	0xe000d,
	0xe164a,
	0x17724b,
	0x1ae0cb,
	0x31c45,
	0x1424d50,
	0x12618f,
	0x1268cf,
	0xe2c0d,
	0x1b8f90,
	0x2bb82,
	0x17fb0388,
	0x9688,
	0x182ee705,
	0x48fcb,
	0x117090,
	0x4fdc8,
	0x26e8a,
	0x56b49,
	0x5cb47,
	0x5ce87,
	0x5d047,
	0x5f507,
	0x60587,
	0x60b87,
	0x61387,
	0x617c7,
	0x61cc7,
	0x61fc7,
	0x62fc7,
	0x63187,
	0x63347,
	0x63507,
	0x63807,
	0x64007,
	0x64c87,
	0x65407,
	0x66547,
	0x66b07,
	0x66cc7,
	0x67047,
	0x67487,
	0x67687,
	0x67947,
	0x67b07,
	0x67cc7,
	0x67f87,
	0x68247,
	0x68f07,
	0x69607,
	0x698c7,
	0x6a047,
	0x6a207,
	0x6a607,
	0x6aec7,
	0x6b147,
	0x6b547,
	0x6b707,
	0x6b8c7,
	0x70587,
	0x71387,
	0x718c7,
	0x71e47,
	0x72007,
	0x72387,
	0x728c7,
	0xdb42,
	0xbbb0a,
	0xffb87,
	0x184cfa0b,
	0x14cfa16,
	0x17e91,
	0x1082ca,
	0xa24ca,
	0x52e06,
	0xd0f8b,
	0x5e82,
	0x2f711,
	0x157789,
	0x942c9,
	0x67e42,
	0x9f54a,
	0xa4909,
	0xa504f,
	0xa5a8e,
	0xa6388,
	0x17f42,
	0x18ef09,
	0x17f08e,
	0xf80cc,
	0xdf20f,
	0x198f4e,
	0xc84c,
	0x11809,
	0x13491,
	0x222c8,
	0x24512,
	0x281cd,
	0x2e0cd,
	0x8618b,
	0xbadd5,
	0xbb9c9,
	0xe268a,
	0x120689,
	0x160310,
	0x39a0b,
	0x4480f,
	0x5648b,
	0x58a8c,
	0x70f90,
	0x7beca,
	0x7d18d,
	0x80d4e,
	0x86cca,
	0x8720c,
	0x89714,
	0x157411,
	0x1a200b,
	0x9004f,
	0x9320d,
	0x9a00e,
	0x9fd8c,
	0xa1acc,
	0xaae8b,
	0xab18e,
	0xab990,
	0x154c0b,
	0x1160cd,
	0x10e80f,
	0x17e50c,
	0xb090e,
	0xb2391,
	0xb3ecc,
	0xc00c7,
	0xc064d,
	0xc0fcc,
	0xc1dd0,
	0x102c8d,
	0x12bc87,
	0xc7750,
	0xd3748,
	0xd51cb,
	0x12aa8f,
	0x17e248,
	0x1084cd,
	0x14d550,
	0x18ba60c6,
	0xaff43,
	0xbe02,
	0x11e309,
	0x5394a,
	0x104186,
	0x18cd9009,
	0x11d43,
	0xd6191,
	0xd65c9,
	0xd7607,
	0xaf6cb,
	0xde6d0,
	0xdeb8c,
	0xdf6c5,
	0x18f248,
	0x19f94a,
	0x111947,
	0x33c2,
	0x124a4a,
	0x127549,
	0x35b4a,
	0x8a3cf,
	0x3edcb,
	0x12814c,
	0x169b92,
	0xaea45,
	0x166aca,
	0x192ece45,
	0x18020c,
	0x122843,
	0x185502,
	0xf2bca,
	0x14f3fcc,
	0x1b1a48,
	0xdfe48,
	0x16fb87,
	0x1c42,
	0x3082,
	0x3f590,
	0x27c2,
	0x1ad58f,
	0x5d306,
	0x77ece,
	0xe598b,
	0x86ec8,
	0xd1a49,
	0x17d152,
	0x1abecd,
	0x55b08,
	0x56d49,
	0x572cd,
	0x57b89,
	0x5c58b,
	0x5d848,
	0x61ac8,
	0x628c8,
	0x62b49,
	0x62d4a,
	0x6398c,
	0xe3cca,
	0xff947,
	0x2270d,
	0xf4b4b,
	0x11a5cc,
	0x18b050,
	0xc2,
	0x7a14d,
	0x2dc2,
	0x35482,
	0xff88a,
	0x1081ca,
	0x10928b,
	0x1ae28c,
	0x108c8e,
	0x100cd,
	0x1b3908,
	0x7b02,
	0x11b5ec4e,
	0x1227020e,
	0x12a83a0a,
	0x1336864e,
	0x13b143ce,
	0x1432ee0c,
	0x1594ac7,
	0x1594ac9,
	0x1410843,
	0x14b3054c,
	0x15333209,
	0x15b49dc9,
	0x50642,
	0x18fb51,
	0x70151,
	0x8394d,
	0x17acd1,
	0x114311,
	0x12ed4f,
	0x13048f,
	0x13314c,
	0x149d0c,
	0x1a688d,
	0x1bb815,
	0x5064c,
	0x11f0cc,
	0xe9c50,
	0x11d44c,
	0x12a54c,
	0x15e999,
	0x168399,
	0x16fd99,
	0x175d54,
	0x181ad4,
	0x19b7d4,
	0x19d714,
	0x1ac314,
	0x16250709,
	0x1699ba89,
	0x1731f189,
	0x11e224c9,
	0x50642,
	0x126224c9,
	0x50642,
	0x15e98a,
	0x50642,
	0x12e224c9,
	0x50642,
	0x15e98a,
	0x50642,
	0x136224c9,
	0x50642,
	0x13e224c9,
	0x50642,
	0x146224c9,
	0x50642,
	0x15e98a,
	0x50642,
	0x14e224c9,
	0x50642,
	0x15e98a,
	0x50642,
	0x156224c9,
	0x50642,
	0x15e224c9,
	0x50642,
	0x15e98a,
	0x50642,
	0x166224c9,
	0x50642,
	0x16e224c9,
	0x50642,
	0x176224c9,
	0x50642,
	0x15e98a,
	0x50642,
	0xaf545,
	0x1a5b04,
	0x2bb84,
	0x1aa404,
	0x1a75c4,
	0xc484,
	0x13fc4,
	0x58f44,
	0xff384,
	0x14ab3c3,
	0x143e603,
	0xfb244,
	0x1547c03,
	0x2bb82,
	0x100c3,
	0x205702,
	0x2099c2,
	0x2006c2,
	0x218342,
	0x20d882,
	0x200442,
	0x203082,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x24a5c3,
	0x205503,
	0x200983,
	0x16d208,
	0x2a84c3,
	0x232403,
	0x205503,
	0x200983,
	0x3fc3,
	0x2e9dc3,
	0x205702,
	0x38d2c3,
	0x1aea84c3,
	0x3b8e47,
	0x2e9dc3,
	0x206343,
	0x211cc4,
	0x205503,
	0x200983,
	0x255cca,
	0x264a85,
	0x201303,
	0x20b0c2,
	0x16d208,
	0x16d208,
	0x99c2,
	0x11fd02,
	0x6c845,
	0x129845,
	0x16d208,
	0x1b887,
	0xa84c3,
	0x1ba38e47,
	0x13ee06,
	0x1bd49c05,
	0x11de07,
	0x66ca,
	0x3748,
	0x65c7,
	0x56948,
	0x28d87,
	0x2c6cf,
	0x30b87,
	0x3b806,
	0x117090,
	0x12330f,
	0x104204,
	0x1c11dece,
	0xa8b4c,
	0x4f14a,
	0x9a2c7,
	0x112b8a,
	0x18f409,
	0xbf34a,
	0x5414a,
	0x104186,
	0x9a38a,
	0x8350a,
	0xe47c9,
	0xd5a48,
	0xd5d46,
	0xd9a8d,
	0xb3c45,
	0x1a78c7,
	0x5d6c7,
	0xd9394,
	0xf938b,
	0x68a0a,
	0xa2d0d,
	0x1cdc3,
	0x1cdc3,
	0x1cdc6,
	0x1cdc3,
	0x18d2c3,
	0x16d208,
	0x99c2,
	0x49944,
	0x887c3,
	0x173605,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x2030c3,
	0x2a84c3,
	0x232403,
	0x2163c3,
	0x2e9dc3,
	0x209703,
	0x205503,
	0x200983,
	0x294483,
	0x25ed03,
	0x2030c3,
	0x25ef44,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x2082c3,
	0x2a84c3,
	0x232403,
	0x218343,
	0x2163c3,
	0x2e9dc3,
	0x3b1384,
	0x353903,
	0x227f83,
	0x209703,
	0x205503,
	0x200983,
	0x201303,
	0x311dc3,
	0x1dea84c3,
	0x232403,
	0x246383,
	0x2e9dc3,
	0x20a203,
	0x227f83,
	0x200983,
	0x2072c3,
	0x33bac4,
	0x16d208,
	0x1e6a84c3,
	0x232403,
	0x2a6443,
	0x2e9dc3,
	0x209703,
	0x211cc4,
	0x205503,
	0x200983,
	0x21db03,
	0x16d208,
	0x1eea84c3,
	0x232403,
	0x2163c3,
	0x204e83,
	0x200983,
	0x16d208,
	0x1594ac7,
	0x38d2c3,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x3b1384,
	0x211cc4,
	0x205503,
	0x200983,
	0x129845,
	0x16fc07,
	0xd95cb,
	0xd69c4,
	0xb3c45,
	0x1456108,
	0xa6a8d,
	0x20284a05,
	0x18004,
	0x169c3,
	0x186345,
	0x349a05,
	0x16d208,
	0x1cdc2,
	0x336c3,
	0xf1446,
	0x319ec8,
	0x313bc7,
	0x25ef44,
	0x3b2c86,
	0x3bb6c6,
	0x16d208,
	0x30ce43,
	0x33e589,
	0x237295,
	0x3729f,
	0x2a84c3,
	0x31d012,
	0xefac6,
	0x10a045,
	0x26e8a,
	0x56b49,
	0x31cdcf,
	0x2d5f04,
	0x20b145,
	0x2fa150,
	0x3b0887,
	0x204e83,
	0x28b148,
	0x125bc6,
	0x2ae1ca,
	0x256044,
	0x2ec883,
	0x264a86,
	0x20b0c2,
	0x22d54b,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x209703,
	0x205503,
	0x200983,
	0x2f1743,
	0x2099c2,
	0x2cd83,
	0x205503,
	0x200983,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x209703,
	0x200983,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x206343,
	0x221f03,
	0x200983,
	0x2099c2,
	0x2a84c3,
	0x232403,
	0x205503,
	0x200983,
	0x205702,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x9885,
	0x25ef44,
	0x2a84c3,
	0x232403,
	0x210444,
	0x205503,
	0x200983,
	0x16d208,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x2a84c3,
	0x232403,
	0x2163c3,
	0x2143c3,
	0x209703,
	0x205503,
	0x200983,
	0x2099c2,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x16d208,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x391683,
	0x63643,
	0x6343,
	0x205503,
	0x200983,
	0x30d44a,
	0x32b0c9,
	0x346b0b,
	0x34708a,
	0x34d94a,
	0x35d74b,
	0x371e0a,
	0x37814a,
	0x37fc4a,
	0x37fecb,
	0x39f689,
	0x3a140a,
	0x3a178b,
	0x3acfcb,
	0x3b9eca,
	0x2a84c3,
	0x232403,
	0x2163c3,
	0x209703,
	0x205503,
	0x200983,
	0x4589,
	0x16d208,
	0x2a84c3,
	0x25cb44,
	0x207ac2,
	0x211cc4,
	0x26fc45,
	0x2030c3,
	0x25ef44,
	0x2a84c3,
	0x235ac4,
	0x232403,
	0x249944,
	0x2d5f04,
	0x3b1384,
	0x227f83,
	0x205503,
	0x200983,
	0x27a305,
	0x2082c3,
	0x201303,
	0x22ed03,
	0x250cc4,
	0x390fc4,
	0x34ae45,
	0x16d208,
	0x302044,
	0x3510c6,
	0x276384,
	0x2099c2,
	0x371007,
	0x24c0c7,
	0x247784,
	0x2555c5,
	0x302e85,
	0x2a9305,
	0x3b1384,
	0x3b8ac8,
	0x239486,
	0x30c188,
	0x24ed05,
	0x2da905,
	0x236b84,
	0x200983,
	0x2ed844,
	0x35c946,
	0x264b83,
	0x250cc4,
	0x256005,
	0x32d104,
	0x334944,
	0x20b0c2,
	0x2425c6,
	0x3962c6,
	0x2fdc05,
	0x205702,
	0x38d2c3,
	0x262099c2,
	0x2333c4,
	0x20d882,
	0x209703,
	0x202c82,
	0x205503,
	0x200442,
	0x214843,
	0x25ed03,
	0x16d208,
	0x16d208,
	0x2e9dc3,
	0x205702,
	0x26e099c2,
	0x2e9dc3,
	0x245b43,
	0x353903,
	0x327344,
	0x205503,
	0x200983,
	0x16d208,
	0x205702,
	0x276099c2,
	0x2a84c3,
	0x205503,
	0x200983,
	0x482,
	0x20a9c2,
	0x212982,
	0x206343,
	0x2e87c3,
	0x205702,
	0x129845,
	0x16d208,
	0x16fc07,
	0x2099c2,
	0x232403,
	0x249944,
	0x2032c3,
	0x2e9dc3,
	0x2143c3,
	0x209703,
	0x205503,
	0x216b03,
	0x200983,
	0x21da83,
	0x118fd3,
	0x11c954,
	0x16fc07,
	0x13b46,
	0x53b4b,
	0x1cdc6,
	0x51b87,
	0x11ab09,
	0xe6d4a,
	0x8850d,
	0x1b240c,
	0x1ada8a,
	0x192345,
	0x6708,
	0x5d306,
	0x125c86,
	0x22bb82,
	0xff14c,
	0x1a5cc7,
	0x22e51,
	0x2a84c3,
	0x568c5,
	0x77848,
	0x9e04,
	0x288347c6,
	0x17e86,
	0x8cb46,
	0x8da0a,
	0xac543,
	0x28e54b04,
	0x11aac5,
	0xde283,
	0xdc105,
	0xd104c,
	0xf04c8,
	0xb5708,
	0x9e009,
	0x134b08,
	0x141e046,
	0xda40a,
	0x82b48,
	0xf4648,
	0xff384,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x209703,
	0x205503,
	0x200983,
	0x205702,
	0x2099c2,
	0x2e9dc3,
	0x202bc2,
	0x205503,
	0x200983,
	0x214843,
	0x3653cf,
	0x36578e,
	0x16d208,
	0x2a84c3,
	0x42f87,
	0x232403,
	0x2e9dc3,
	0x244183,
	0x205503,
	0x200983,
	0x201bc3,
	0x201bc7,
	0x200142,
	0x32c249,
	0x200242,
	0x23f88b,
	0x297b8a,
	0x2a2a49,
	0x200882,
	0x391206,
	0x34ed15,
	0x23f9d5,
	0x246993,
	0x23ff53,
	0x202a82,
	0x205ac5,
	0x3b364c,
	0x27160b,
	0x2726c5,
	0x201702,
	0x284202,
	0x386fc6,
	0x200ec2,
	0x3695c6,
	0x2d4c4d,
	0x27ef4c,
	0x224dc4,
	0x203dc2,
	0x205942,
	0x2248c8,
	0x202a42,
	0x312fc6,
	0x2ba844,
	0x34eed5,
	0x246b13,
	0x210783,
	0x32fa0a,
	0x3bb147,
	0x3094c9,
	0x37b887,
	0x30f242,
	0x200002,
	0x3aef06,
	0x20cb42,
	0x16d208,
	0x2105c2,
	0x20b382,
	0x274e87,
	0x20f687,
	0x21b585,
	0x201c02,
	0x21da47,
	0x21dc08,
	0x242b42,
	0x2bf3c2,
	0x22e802,
	0x201ec2,
	0x237b88,
	0x201ec3,
	0x2b5308,
	0x2cf1cd,
	0x213c03,
	0x327988,
	0x239f8f,
	0x23a34e,
	0x25edca,
	0x229751,
	0x229bd0,
	0x2bcdcd,
	0x2bd10c,
	0x311c47,
	0x32fb87,
	0x3b2d49,
	0x224ec2,
	0x206c02,
	0x25340c,
	0x25370b,
	0x204142,
	0x2ab046,
	0x21a1c2,
	0x209882,
	0x21b102,
	0x2099c2,
	0x383a84,
	0x238bc7,
	0x204682,
	0x23d147,
	0x23e487,
	0x20e142,
	0x2301c2,
	0x242e45,
	0x205742,
	0x362e0e,
	0x2ebb8d,
	0x232403,
	0x2be90e,
	0x2e064d,
	0x37eac3,
	0x200e02,
	0x21fec4,
	0x2454c2,
	0x2175c2,
	0x358e45,
	0x364b47,
	0x383382,
	0x218342,
	0x249547,
	0x24d288,
	0x248902,
	0x2aeac6,
	0x25328c,
	0x2535cb,
	0x20fc82,
	0x25924f,
	0x259610,
	0x259a0f,
	0x259dd5,
	0x25a314,
	0x25a80e,
	0x25ab8e,
	0x25af0f,
	0x25b2ce,
	0x25b654,
	0x25bb53,
	0x25c00d,
	0x272a89,
	0x2895c3,
	0x200782,
	0x22b0c5,
	0x207f86,
	0x20d882,
	0x21f507,
	0x2e9dc3,
	0x205e82,
	0x362a08,
	0x229991,
	0x229dd0,
	0x206482,
	0x288d87,
	0x203942,
	0x214607,
	0x20be02,
	0x319cc9,
	0x386f87,
	0x27aac8,
	0x234606,
	0x2e86c3,
	0x32a105,
	0x232682,
	0x202082,
	0x3af305,
	0x380685,
	0x2040c2,
	0x24c543,
	0x32d187,
	0x223787,
	0x200502,
	0x254684,
	0x223b83,
	0x223b89,
	0x22c548,
	0x200282,
	0x204bc2,
	0x3105c7,
	0x31ff05,
	0x2a5348,
	0x219947,
	0x200e83,
	0x28c446,
	0x2bcc4d,
	0x2bcfcc,
	0x2b45c6,
	0x208d02,
	0x2a8542,
	0x202342,
	0x239e0f,
	0x23a20e,
	0x302f07,
	0x203d02,
	0x2bf745,
	0x2bf746,
	0x20f242,
	0x20ec42,
	0x221f06,
	0x214543,
	0x214546,
	0x2c6985,
	0x2c698d,
	0x2c6f55,
	0x2c814c,
	0x2c95cd,
	0x2c9992,
	0x20e602,
	0x2675c2,
	0x202d02,
	0x240806,
	0x2f7f86,
	0x2033c2,
	0x208006,
	0x2023c2,
	0x38b785,
	0x200542,
	0x2ebc89,
	0x31554c,
	0x31588b,
	0x200442,
	0x24e748,
	0x203b02,
	0x2056c2,
	0x26a346,
	0x222445,
	0x226747,
	0x257d85,
	0x29e405,
	0x243002,
	0x2067c2,
	0x2013c2,
	0x2df507,
	0x380c0d,
	0x380f8c,
	0x22f087,
	0x20f982,
	0x2069c2,
	0x241248,
	0x31e488,
	0x2e3988,
	0x308484,
	0x2ab407,
	0x2e90c3,
	0x228ec2,
	0x2082c2,
	0x2eb3c9,
	0x3a40c7,
	0x201302,
	0x26a745,
	0x22d4c2,
	0x21aa02,
	0x2f9f03,
	0x2f9f06,
	0x2f1742,
	0x2f23c2,
	0x201a42,
	0x202f86,
	0x21fe07,
	0x213bc2,
	0x205ec2,
	0x2b514f,
	0x2be74d,
	0x3872ce,
	0x2e04cc,
	0x2009c2,
	0x207302,
	0x234445,
	0x30ba46,
	0x2018c2,
	0x202482,
	0x200482,
	0x2198c4,
	0x2cf044,
	0x2d0e86,
	0x203082,
	0x36cac7,
	0x203083,
	0x285d48,
	0x34e488,
	0x239887,
	0x240706,
	0x203902,
	0x234b03,
	0x234b07,
	0x273946,
	0x2dee45,
	0x308808,
	0x200d02,
	0x331207,
	0x222702,
	0x361782,
	0x20cfc2,
	0x2c6749,
	0x230982,
	0x200842,
	0x22f303,
	0x331c87,
	0x2002c2,
	0x3156cc,
	0x3159cb,
	0x2b4646,
	0x2de1c5,
	0x221c82,
	0x203b42,
	0x2b7bc6,
	0x260dc3,
	0x38c187,
	0x236102,
	0x201442,
	0x34eb95,
	0x23fb95,
	0x246853,
	0x2400d3,
	0x2585c7,
	0x271a48,
	0x271a50,
	0x28d2cf,
	0x297953,
	0x2a2812,
	0x32be10,
	0x2d544f,
	0x35f7d2,
	0x30c3d1,
	0x2b7613,
	0x2c6512,
	0x2cff4f,
	0x2d2e8e,
	0x2d3f52,
	0x2d71d1,
	0x2d7c8f,
	0x30440e,
	0x2f0691,
	0x2f17d0,
	0x2f2752,
	0x2fc711,
	0x364586,
	0x36d3c7,
	0x372187,
	0x203142,
	0x27d8c5,
	0x3933c7,
	0x212982,
	0x209942,
	0x228a85,
	0x21e743,
	0x34b0c6,
	0x380dcd,
	0x38110c,
	0x201682,
	0x3b34cb,
	0x2714ca,
	0x20598a,
	0x2b6449,
	0x2ea64b,
	0x219a8d,
	0x2fa5cc,
	0x25180a,
	0x22090c,
	0x26908b,
	0x27250c,
	0x29474b,
	0x3154c3,
	0x36cfc6,
	0x3a98c2,
	0x2f4542,
	0x20a743,
	0x208602,
	0x21fe83,
	0x2366c6,
	0x259f87,
	0x2c7fc6,
	0x39e4c8,
	0x31e188,
	0x2ce146,
	0x201f82,
	0x2fd5cd,
	0x2fd90c,
	0x2d5fc7,
	0x301f07,
	0x213b82,
	0x201502,
	0x234a82,
	0x24d642,
	0x2099c2,
	0x205503,
	0x200983,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x209703,
	0x211cc4,
	0x205503,
	0x200983,
	0x214843,
	0x205702,
	0x2021c2,
	0x2ae8fdc5,
	0x2b247e45,
	0x2b717806,
	0x16d208,
	0x2baaee05,
	0x2099c2,
	0x2006c2,
	0x2bfb3ac5,
	0x2c27bdc5,
	0x2c67c9c7,
	0x2ca86a09,
	0x2ce3bc44,
	0x20d882,
	0x205e82,
	0x2d24b5c5,
	0x2d68f849,
	0x2db1db88,
	0x2deab805,
	0x2e300187,
	0x2e61ed48,
	0x2eae5d85,
	0x2ee00106,
	0x2f337809,
	0x2f6b5a48,
	0x2fac0488,
	0x2fe9704a,
	0x302732c4,
	0x306d13c5,
	0x30abc9c8,
	0x30e03a85,
	0x20cec2,
	0x31248a43,
	0x316a1686,
	0x31b60148,
	0x31eb94c6,
	0x32281f08,
	0x32719606,
	0x32adef04,
	0x200c82,
	0x32f2cb87,
	0x332a75c4,
	0x336756c7,
	0x33ba2987,
	0x200442,
	0x33e9b0c5,
	0x34334f84,
	0x346cd907,
	0x34a5f187,
	0x34e80886,
	0x3527c585,
	0x356959c7,
	0x35ad0b48,
	0x35e2b447,
	0x363164c9,
	0x36793105,
	0x36b31dc7,
	0x36e8f546,
	0x37391408,
	0x2273cd,
	0x279909,
	0x28174b,
	0x2a4b0b,
	0x34058b,
	0x2ffe8b,
	0x30bc4b,
	0x30bf0b,
	0x30c809,
	0x30d6cb,
	0x30d98b,
	0x30e48b,
	0x30f5ca,
	0x30fb0a,
	0x31010c,
	0x314d8b,
	0x31670a,
	0x32904a,
	0x33404e,
	0x33568e,
	0x335a0a,
	0x33808a,
	0x338dcb,
	0x33908b,
	0x339e8b,
	0x354ecb,
	0x3554ca,
	0x35618b,
	0x35644a,
	0x3566ca,
	0x35694a,
	0x372b0b,
	0x37914b,
	0x37c74e,
	0x37cacb,
	0x38454b,
	0x385acb,
	0x38900a,
	0x389289,
	0x3894ca,
	0x38a94a,
	0x3a00cb,
	0x3a1a4b,
	0x3a22ca,
	0x3a48cb,
	0x3a8c4b,
	0x3b990b,
	0x3767e648,
	0x37a87c89,
	0x37e9de89,
	0x382dacc8,
	0x342505,
	0x217083,
	0x21c6c4,
	0x220005,
	0x23b986,
	0x25da05,
	0x2864c4,
	0x21f408,
	0x308005,
	0x291784,
	0x203447,
	0x29cf8a,
	0x3712ca,
	0x338547,
	0x3af9c7,
	0x2f8f07,
	0x264e87,
	0x2f60c5,
	0x33bb86,
	0x2bb847,
	0x2b4904,
	0x2e4646,
	0x2e4546,
	0x3b9585,
	0x26d1c4,
	0x3519c6,
	0x29bf47,
	0x285746,
	0x2e3247,
	0x25e443,
	0x2b1c06,
	0x2328c5,
	0x27cac7,
	0x2641ca,
	0x260e44,
	0x217c08,
	0x2abd89,
	0x2cd247,
	0x336286,
	0x24e9c8,
	0x2b9c09,
	0x309684,
	0x366944,
	0x244245,
	0x2bb548,
	0x2c4b07,
	0x2a9709,
	0x364688,
	0x345e86,
	0x3204c6,
	0x298048,
	0x359646,
	0x247e45,
	0x280946,
	0x275ec8,
	0x24da46,
	0x2525cb,
	0x298646,
	0x29994d,
	0x3a6005,
	0x2a7486,
	0x208b45,
	0x2f9bc9,
	0x2f9a87,
	0x37a208,
	0x266986,
	0x298bc9,
	0x3793c6,
	0x264145,
	0x268686,
	0x2cae46,
	0x2cb3c9,
	0x3530c6,
	0x339487,
	0x26ad85,
	0x202ac3,
	0x252745,
	0x299c07,
	0x33c6c6,
	0x3a5f09,
	0x317806,
	0x280b86,
	0x210c49,
	0x280349,
	0x29fc07,
	0x282f88,
	0x28c989,
	0x27d548,
	0x378386,
	0x2d5805,
	0x2418ca,
	0x280c06,
	0x3b7986,
	0x2c8985,
	0x265808,
	0x223307,
	0x22f50a,
	0x249e46,
	0x279d45,
	0x37aa46,
	0x21ac47,
	0x336147,
	0x21bbc5,
	0x264305,
	0x357dc6,
	0x2ac5c6,
	0x34dc06,
	0x2b3204,
	0x27f689,
	0x288b46,
	0x2dd38a,
	0x21b388,
	0x3078c8,
	0x3712ca,
	0x20b445,
	0x29be85,
	0x350b88,
	0x2b2c88,
	0x27b5c7,
	0x258946,
	0x322388,
	0x2fdec7,
	0x27dc48,
	0x2b3846,
	0x281408,
	0x294f06,
	0x24ee87,
	0x299ec6,
	0x3519c6,
	0x3778ca,
	0x2bd8c6,
	0x2d5809,
	0x26dbc6,
	0x2af14a,
	0x2def09,
	0x2fb486,
	0x2b4b04,
	0x22b18d,
	0x287f07,
	0x326cc6,
	0x2c0345,
	0x379445,
	0x374246,
	0x2cd749,
	0x2b1647,
	0x277306,
	0x2cc246,
	0x286549,
	0x247d84,
	0x3482c4,
	0x352cc8,
	0x236a86,
	0x26a808,
	0x2e41c8,
	0x312747,
	0x3b7549,
	0x34de07,
	0x2aecca,
	0x2e1f8f,
	0x23188a,
	0x234245,
	0x276105,
	0x216e85,
	0x2ba787,
	0x21a803,
	0x283188,
	0x396786,
	0x396889,
	0x2b87c6,
	0x3b5207,
	0x298989,
	0x37a108,
	0x2c8a47,
	0x30a343,
	0x342585,
	0x21a785,
	0x2b304b,
	0x203b44,
	0x2c2084,
	0x274646,
	0x30abc7,
	0x382bca,
	0x248ac7,
	0x311e87,
	0x27bdc5,
	0x200645,
	0x2eef89,
	0x3519c6,
	0x24894d,
	0x353305,
	0x2b1383,
	0x205043,
	0x26f685,
	0x345c45,
	0x24e9c8,
	0x2790c7,
	0x348046,
	0x29db06,
	0x229105,
	0x2326c7,
	0x312247,
	0x239347,
	0x2d144a,
	0x2b1cc8,
	0x2b3204,
	0x24d7c7,
	0x27acc7,
	0x339306,
	0x262107,
	0x2dc4c8,
	0x2e6f08,
	0x268506,
	0x303008,
	0x2c87c4,
	0x2bb846,
	0x2353c6,
	0x33bfc6,
	0x2ba986,
	0x286004,
	0x264f46,
	0x2bf5c6,
	0x297546,
	0x247846,
	0x204f06,
	0x26e2c6,
	0x347f48,
	0x2b0748,
	0x2d1c88,
	0x25dc08,
	0x350b06,
	0x20dcc5,
	0x315ec6,
	0x2ab885,
	0x388447,
	0x215305,
	0x2125c3,
	0x211585,
	0x344cc4,
	0x205045,
	0x203b03,
	0x33a447,
	0x354648,
	0x2e3306,
	0x2c218d,
	0x2760c6,
	0x296ac5,
	0x2b7843,
	0x2bc389,
	0x247f06,
	0x28e7c6,
	0x29f4c4,
	0x231807,
	0x233606,
	0x2b1905,
	0x203cc3,
	0x3abd84,
	0x27ae86,
	0x2354c4,
	0x2da048,
	0x38ba89,
	0x215589,
	0x29f2ca,
	0x2a070d,
	0x313447,
	0x2b9186,
	0x206804,
	0x286a09,
	0x284688,
	0x287b06,
	0x33f286,
	0x262107,
	0x2b6b46,
	0x226346,
	0x26d606,
	0x3a2a0a,
	0x21ed48,
	0x2bacc5,
	0x262549,
	0x27e14a,
	0x2f5d08,
	0x29b908,
	0x295f08,
	0x2a7acc,
	0x30e705,
	0x29dd88,
	0x2e6586,
	0x37a386,
	0x3b50c7,
	0x2489c5,
	0x280ac5,
	0x215449,
	0x20e247,
	0x396845,
	0x227887,
	0x205043,
	0x2c5045,
	0x20ef48,
	0x252ac7,
	0x29b7c9,
	0x2d7985,
	0x2fa984,
	0x2a03c8,
	0x32ccc7,
	0x2c8c08,
	0x38d688,
	0x354b05,
	0x3a3946,
	0x278cc6,
	0x244609,
	0x2b01c7,
	0x2ac006,
	0x313787,
	0x210103,
	0x23bc44,
	0x2a1785,
	0x232804,
	0x3833c4,
	0x27fdc7,
	0x26c147,
	0x22e704,
	0x29b610,
	0x3b3c47,
	0x200645,
	0x24c20c,
	0x20a8c4,
	0x2c1488,
	0x24ed89,
	0x35acc6,
	0x334c48,
	0x215244,
	0x36c4c8,
	0x22fb06,
	0x2accc8,
	0x29c506,
	0x2bec0b,
	0x202ac5,
	0x2c8748,
	0x215ac4,
	0x38beca,
	0x29b7c9,
	0x245f06,
	0x216f48,
	0x256385,
	0x2b0f44,
	0x2c1386,
	0x239208,
	0x27e648,
	0x322c06,
	0x3a9ec4,
	0x241846,
	0x34de87,
	0x2755c7,
	0x26210f,
	0x207347,
	0x2fb547,
	0x3709c5,
	0x353e05,
	0x29f8c9,
	0x2dd046,
	0x27cc05,
	0x280647,
	0x2e0bc8,
	0x297645,
	0x299ec6,
	0x21b1c8,
	0x2b94ca,
	0x2db4c8,
	0x28ac87,
	0x2e23c6,
	0x262506,
	0x21a5c3,
	0x216a43,
	0x27e309,
	0x28c809,
	0x2c1286,
	0x2d7985,
	0x33bd48,
	0x216f48,
	0x3597c8,
	0x26d68b,
	0x2c23c7,
	0x30a589,
	0x262388,
	0x343084,
	0x3514c8,
	0x28cd89,
	0x2ac305,
	0x2ba687,
	0x23bcc5,
	0x27e548,
	0x28fc4b,
	0x295710,
	0x2a6dc5,
	0x215a0c,
	0x348205,
	0x27be43,
	0x2a8f86,
	0x2be6c4,
	0x335086,
	0x29bf47,
	0x21b244,
	0x240b88,
	0x28304d,
	0x302945,
	0x29b104,
	0x2243c4,
	0x276949,
	0x2a11c8,
	0x317687,
	0x22fb88,
	0x27f748,
	0x277605,
	0x209287,
	0x277587,
	0x33e347,
	0x264309,
	0x233489,
	0x214c46,
	0x2bd306,
	0x262346,
	0x37f785,
	0x3a7184,
	0x200006,
	0x200386,
	0x277648,
	0x21a90b,
	0x260d07,
	0x206804,
	0x353646,
	0x2fe447,
	0x26dec5,
	0x391d05,
	0x219644,
	0x233406,
	0x200088,
	0x286a09,
	0x2510c6,
	0x284048,
	0x2b19c6,
	0x345248,
	0x306dcc,
	0x2774c6,
	0x29678d,
	0x296c0b,
	0x339545,
	0x312387,
	0x3531c6,
	0x336008,
	0x214cc9,
	0x2d0588,
	0x200645,
	0x277987,
	0x27d648,
	0x349649,
	0x28e946,
	0x250fca,
	0x335d88,
	0x2d03cb,
	0x39818c,
	0x36c5c8,
	0x27a7c6,
	0x208c88,
	0x3b77c7,
	0x32cf49,
	0x28f74d,
	0x299dc6,
	0x27b808,
	0x2b0609,
	0x2bda48,
	0x281508,
	0x2bfe0c,
	0x2c0b47,
	0x2c1887,
	0x264145,
	0x2ad587,
	0x2e0a88,
	0x2c1406,
	0x2556cc,
	0x2ef888,
	0x2ccb88,
	0x25dec6,
	0x21a507,
	0x214e44,
	0x25dc08,
	0x22200c,
	0x2ce24c,
	0x2342c5,
	0x2d0d47,
	0x3a9e46,
	0x21a486,
	0x2f9d88,
	0x3af904,
	0x28574b,
	0x36cc0b,
	0x2e23c6,
	0x282ec7,
	0x37a805,
	0x269a05,
	0x285886,
	0x256345,
	0x203b05,
	0x2cc9c7,
	0x274c49,
	0x2ac784,
	0x2fbb45,
	0x2e4bc5,
	0x2d9dc8,
	0x329d05,
	0x2b72c9,
	0x2ae5c7,
	0x2ae5cb,
	0x381306,
	0x347c89,
	0x26d108,
	0x276545,
	0x33e448,
	0x2334c8,
	0x245747,
	0x3776c7,
	0x27fe49,
	0x2acc07,
	0x28a989,
	0x2aa70c,
	0x3163c8,
	0x2b2ac9,
	0x2b3d47,
	0x27f809,
	0x26c287,
	0x398288,
	0x3b7705,
	0x2bb7c6,
	0x2c0388,
	0x308a88,
	0x27e009,
	0x203b47,
	0x269ac5,
	0x222b09,
	0x2bd6c6,
	0x28f544,
	0x30e1c6,
	0x35ffc8,
	0x232ac7,
	0x21ab08,
	0x3030c9,
	0x3a3707,
	0x29d146,
	0x312444,
	0x211609,
	0x209108,
	0x25dd87,
	0x27eb46,
	0x21a846,
	0x3b7904,
	0x2241c6,
	0x204fc3,
	0x3b1649,
	0x202a86,
	0x303345,
	0x29db06,
	0x26cac5,
	0x27dac8,
	0x36c307,
	0x381646,
	0x3b3b06,
	0x3078c8,
	0x29fa47,
	0x299e05,
	0x29b408,
	0x3a1e48,
	0x335d88,
	0x3480c5,
	0x2bb846,
	0x215349,
	0x244484,
	0x26c94b,
	0x22604b,
	0x2babc9,
	0x205043,
	0x254485,
	0x2214c6,
	0x385208,
	0x2e1f04,
	0x2e3306,
	0x2d1589,
	0x2ca445,
	0x2cc906,
	0x32ccc6,
	0x216f44,
	0x2a764a,
	0x303288,
	0x308a86,
	0x3b8645,
	0x37a687,
	0x2e0fc7,
	0x3a3944,
	0x226287,
	0x2aecc4,
	0x33bf46,
	0x2096c3,
	0x264305,
	0x32ad45,
	0x207588,
	0x24d985,
	0x277209,
	0x25da47,
	0x25da4b,
	0x2a148c,
	0x2a224a,
	0x300187,
	0x203503,
	0x3afc08,
	0x348285,
	0x2976c5,
	0x205104,
	0x398186,
	0x24ed86,
	0x224207,
	0x33448b,
	0x286004,
	0x2e6684,
	0x21f044,
	0x2cafc6,
	0x21b244,
	0x2bb648,
	0x342445,
	0x21ba45,
	0x359707,
	0x312489,
	0x345c45,
	0x37424a,
	0x26ac89,
	0x2996ca,
	0x3a2b49,
	0x33fec4,
	0x2cc305,
	0x2b6c48,
	0x2cd9cb,
	0x244245,
	0x2f2fc6,
	0x213e84,
	0x277746,
	0x3a3589,
	0x353707,
	0x3179c8,
	0x2a0a86,
	0x34de07,
	0x27e648,
	0x3747c6,
	0x375604,
	0x365ac7,
	0x357305,
	0x367287,
	0x200104,
	0x353146,
	0x2f4308,
	0x296dc8,
	0x2e6047,
	0x274fc8,
	0x294fc5,
	0x204e84,
	0x3711c8,
	0x2750c4,
	0x216e05,
	0x2f5fc4,
	0x2fdfc7,
	0x288c07,
	0x27f948,
	0x2c8d86,
	0x24d905,
	0x277008,
	0x2db6c8,
	0x29f209,
	0x226346,
	0x22f588,
	0x38bd4a,
	0x26df48,
	0x2e5d85,
	0x20b306,
	0x26ab48,
	0x277a4a,
	0x210f87,
	0x284c45,
	0x292708,
	0x2ade04,
	0x265886,
	0x2c1c08,
	0x204f06,
	0x38e7c8,
	0x28f187,
	0x203346,
	0x2b4b04,
	0x284fc7,
	0x2b0d84,
	0x3a3547,
	0x28e60d,
	0x27b645,
	0x2cd54b,
	0x29c606,
	0x24e848,
	0x240b44,
	0x350d06,
	0x27ae86,
	0x208fc7,
	0x29644d,
	0x243cc7,
	0x2b12c8,
	0x269b85,
	0x278648,
	0x2c4a86,
	0x295048,
	0x228086,
	0x33d987,
	0x300449,
	0x343ac7,
	0x287dc8,
	0x2706c5,
	0x21b608,
	0x21a3c5,
	0x3a4245,
	0x3a2dc5,
	0x234543,
	0x2809c4,
	0x262545,
	0x337809,
	0x27ea46,
	0x2dc5c8,
	0x377485,
	0x2b2e87,
	0x2a78ca,
	0x2cc849,
	0x2cad4a,
	0x2d1d08,
	0x2276cc,
	0x2806cd,
	0x2fc003,
	0x38e6c8,
	0x3abd45,
	0x2b9286,
	0x379f86,
	0x2e58c5,
	0x313889,
	0x33cc45,
	0x277008,
	0x2552c6,
	0x347806,
	0x2a0289,
	0x393947,
	0x28ff06,
	0x2a7848,
	0x33bec8,
	0x2daec7,
	0x2ace4e,
	0x2c4cc5,
	0x349545,
	0x204e08,
	0x21fcc7,
	0x21a882,
	0x2bf984,
	0x334f8a,
	0x25de48,
	0x2fe546,
	0x298ac8,
	0x278cc6,
	0x332608,
	0x2ac008,
	0x3a4204,
	0x2b33c5,
	0x676384,
	0x676384,
	0x676384,
	0x202b43,
	0x21a6c6,
	0x2774c6,
	0x29cb0c,
	0x203383,
	0x27e146,
	0x2151c4,
	0x247e88,
	0x2d13c5,
	0x335086,
	0x2bcac8,
	0x2d2bc6,
	0x3815c6,
	0x245d08,
	0x2a1807,
	0x2ac9c9,
	0x2f214a,
	0x22b484,
	0x215305,
	0x2a96c5,
	0x247c06,
	0x313486,
	0x29d546,
	0x2f5546,
	0x2acb04,
	0x2acb0b,
	0x231804,
	0x29ccc5,
	0x2aad85,
	0x312806,
	0x3a6308,
	0x280587,
	0x317784,
	0x236203,
	0x2ad905,
	0x306047,
	0x28048b,
	0x207487,
	0x2bc9c8,
	0x2e62c7,
	0x370b06,
	0x279bc8,
	0x2a820b,
	0x21ff46,
	0x212309,
	0x2a8385,
	0x30a343,
	0x2cc906,
	0x28f088,
	0x213403,
	0x24f403,
	0x27e646,
	0x278cc6,
	0x35d10a,
	0x27a805,
	0x27accb,
	0x29da4b,
	0x23ef83,
	0x202843,
	0x2aec44,
	0x278a87,
	0x28f104,
	0x244504,
	0x2e6404,
	0x26e248,
	0x3b8588,
	0x3baf89,
	0x393188,
	0x2b9dc7,
	0x247846,
	0x2dc20f,
	0x2c4e06,
	0x2d1344,
	0x3b83ca,
	0x305f47,
	0x3b9606,
	0x28f589,
	0x3baf05,
	0x2076c5,
	0x3bb046,
	0x21b743,
	0x2ade49,
	0x21eec6,
	0x3afa89,
	0x382bc6,
	0x264305,
	0x2346c5,
	0x207343,
	0x278bc8,
	0x20d787,
	0x396784,
	0x247d08,
	0x2e1244,
	0x2f1006,
	0x2a8f86,
	0x23c346,
	0x2c8609,
	0x297645,
	0x3519c6,
	0x2582c9,
	0x2c41c6,
	0x26e2c6,
	0x387886,
	0x2160c5,
	0x2f5fc6,
	0x33d984,
	0x3b7705,
	0x2c0384,
	0x2b2246,
	0x3532c4,
	0x203c43,
	0x284745,
	0x2331c8,
	0x25e607,
	0x2b8209,
	0x284b48,
	0x297e11,
	0x32cd4a,
	0x2e2307,
	0x2e7246,
	0x2151c4,
	0x2c0488,
	0x22e448,
	0x297fca,
	0x2b708d,
	0x268686,
	0x245e06,
	0x285086,
	0x21ba47,
	0x2b1385,
	0x3912c7,
	0x247dc5,
	0x2ae704,
	0x2a6206,
	0x224047,
	0x2adb4d,
	0x26aa87,
	0x21f308,
	0x277309,
	0x20b206,
	0x28e8c5,
	0x22cb04,
	0x3600c6,
	0x3a3846,
	0x25dfc6,
	0x299348,
	0x215f83,
	0x208fc3,
	0x352105,
	0x277dc6,
	0x2abfc5,
	0x2a0c88,
	0x29c10a,
	0x282084,
	0x247e88,
	0x295f08,
	0x312647,
	0x377549,
	0x2bc6c8,
	0x286a87,
	0x2587c6,
	0x204f0a,
	0x360148,
	0x2f98c9,
	0x2a1288,
	0x221609,
	0x2e7107,
	0x2f2f05,
	0x26d886,
	0x2c1288,
	0x27e7c8,
	0x296088,
	0x2e24c8,
	0x29ccc5,
	0x208a84,
	0x20d488,
	0x23e2c4,
	0x3a2944,
	0x264305,
	0x2917c7,
	0x312249,
	0x208dc7,
	0x210cc5,
	0x274846,
	0x34f606,
	0x212444,
	0x2a05c6,
	0x24d744,
	0x278546,
	0x312006,
	0x213246,
	0x200645,
	0x2a0b47,
	0x203503,
	0x2079c9,
	0x3076c8,
	0x247d04,
	0x28690d,
	0x296ec8,
	0x2e3788,
	0x2f9846,
	0x300549,
	0x2cc849,
	0x3a3285,
	0x29c20a,
	0x27cf4a,
	0x29d74c,
	0x29d8c6,
	0x275446,
	0x2c4f86,
	0x2b4749,
	0x2b94c6,
	0x29fa86,
	0x33cd06,
	0x25dc08,
	0x274fc6,
	0x2ce80b,
	0x291945,
	0x21ba45,
	0x2756c5,
	0x352a46,
	0x204ec3,
	0x23c2c6,
	0x26aa07,
	0x2c0345,
	0x320585,
	0x379445,
	0x318446,
	0x31da84,
	0x31da86,
	0x292f49,
	0x3528cc,
	0x2ae448,
	0x239184,
	0x2f5c06,
	0x29c706,
	0x28f088,
	0x216f48,
	0x3527c9,
	0x37a687,
	0x2367c9,
	0x24cfc6,
	0x22e904,
	0x20ea44,
	0x280144,
	0x27e648,
	0x31208a,
	0x345bc6,
	0x353cc7,
	0x362c47,
	0x347d85,
	0x2a9684,
	0x28cd46,
	0x2b13c6,
	0x2336c3,
	0x307507,
	0x38d588,
	0x3a33ca,
	0x2cbb88,
	0x281f08,
	0x353305,
	0x339645,
	0x260e05,
	0x348146,
	0x3ad906,
	0x26c085,
	0x3b1889,
	0x2a948c,
	0x260ec7,
	0x298048,
	0x2e5c05,
	0x676384,
	0x320944,
	0x252c04,
	0x22df86,
	0x29eb0e,
	0x207747,
	0x21bc45,
	0x24440c,
	0x2e1107,
	0x223fc7,
	0x225109,
	0x217cc9,
	0x284c45,
	0x3076c8,
	0x215349,
	0x335c45,
	0x2c0288,
	0x2c2586,
	0x371446,
	0x2def04,
	0x2553c8,
	0x20b3c3,
	0x2af8c4,
	0x2ad985,
	0x3bab07,
	0x21c245,
	0x38bc09,
	0x28b30d,
	0x2a33c6,
	0x225fc4,
	0x2588c8,
	0x274a8a,
	0x2611c7,
	0x235d45,
	0x23b403,
	0x29dc0e,
	0x278ccc,
	0x2f5e07,
	0x29ecc7,
	0x200143,
	0x2b9505,
	0x252c05,
	0x298e88,
	0x295d49,
	0x239086,
	0x28f104,
	0x2e2246,
	0x27b5cb,
	0x2cc5cc,
	0x366d87,
	0x2d0305,
	0x3a1d48,
	0x2dac85,
	0x3b83c7,
	0x32cb87,
	0x247585,
	0x204ec3,
	0x26e584,
	0x21c685,
	0x2ac685,
	0x2ac686,
	0x292008,
	0x224047,
	0x37a286,
	0x26c486,
	0x3a2d06,
	0x268789,
	0x209387,
	0x25e286,
	0x2cc746,
	0x2731c6,
	0x2a7585,
	0x3b2b46,
	0x380145,
	0x329d88,
	0x29114b,
	0x28c346,
	0x362c84,
	0x2b4389,
	0x25da44,
	0x2c2508,
	0x30e2c7,
	0x281404,
	0x2bbd88,
	0x2c1684,
	0x2a75c4,
	0x286845,
	0x302986,
	0x26e187,
	0x203043,
	0x29d205,
	0x323284,
	0x349586,
	0x3a3308,
	0x38d2c5,
	0x290e09,
	0x222d05,
	0x2dbf88,
	0x215087,
	0x388588,
	0x2b8047,
	0x2fb609,
	0x264dc6,
	0x32bb46,
	0x28cac4,
	0x258705,
	0x2fce4c,
	0x2756c7,
	0x275fc7,
	0x362b08,
	0x2a33c6,
	0x26a944,
	0x328004,
	0x27fcc9,
	0x2c5086,
	0x298a07,
	0x208c04,
	0x23da46,
	0x33b785,
	0x2c88c7,
	0x2ce786,
	0x250e89,
	0x27cd87,
	0x262107,
	0x2a0106,
	0x23d985,
	0x27c548,
	0x21ed48,
	0x247a46,
	0x38d305,
	0x390586,
	0x2034c3,
	0x298d09,
	0x29d2ce,
	0x2b7d48,
	0x2e1348,
	0x24784b,
	0x291046,
	0x313104,
	0x2802c4,
	0x29d3ca,
	0x215907,
	0x25e345,
	0x212309,
	0x2bf685,
	0x3a2987,
	0x245c84,
	0x287087,
	0x2e40c8,
	0x2cd306,
	0x27b989,
	0x2bc7ca,
	0x215886,
	0x296a06,
	0x2aad05,
	0x37d085,
	0x282d07,
	0x244e48,
	0x33b6c8,
	0x3a4206,
	0x234745,
	0x31320e,
	0x2b3204,
	0x2479c5,
	0x2741c9,
	0x2dce48,
	0x28abc6,
	0x29af0c,
	0x29bd10,
	0x29e74f,
	0x29f7c8,
	0x300187,
	0x200645,
	0x262545,
	0x26e009,
	0x292909,
	0x241946,
	0x2442c7,
	0x2d0cc5,
	0x337b09,
	0x339386,
	0x2b930d,
	0x280009,
	0x244504,
	0x2b7ac8,
	0x20d549,
	0x345d86,
	0x274945,
	0x32bb46,
	0x317889,
	0x2f3c48,
	0x20dcc5,
	0x2553c4,
	0x29b0cb,
	0x345c45,
	0x29b206,
	0x280a06,
	0x265e46,
	0x276d4b,
	0x290f09,
	0x26c3c5,
	0x388347,
	0x32ccc6,
	0x334dc6,
	0x252988,
	0x302a89,
	0x21f0cc,
	0x305e48,
	0x309e46,
	0x322c03,
	0x2ba886,
	0x276b85,
	0x27b008,
	0x234146,
	0x2c8b08,
	0x248b45,
	0x279305,
	0x32eb08,
	0x332787,
	0x379ec7,
	0x224207,
	0x334c48,
	0x3002c8,
	0x2ad486,
	0x2b2087,
	0x23bb07,
	0x276a4a,
	0x201e03,
	0x352a46,
	0x2392c5,
	0x334f84,
	0x277309,
	0x2fb584,
	0x25e684,
	0x29c584,
	0x29eccb,
	0x20d6c7,
	0x313445,
	0x294cc8,
	0x274846,
	0x274848,
	0x27a746,
	0x28b085,
	0x28b645,
	0x28d886,
	0x28ee48,
	0x28f4c8,
	0x2774c6,
	0x294b0f,
	0x2987d0,
	0x3a6005,
	0x203503,
	0x22e9c5,
	0x30a4c8,
	0x292809,
	0x335d88,
	0x268608,
	0x2b8d48,
	0x20d787,
	0x274509,
	0x2c8d08,
	0x265304,
	0x29c408,
	0x2d9e89,
	0x2b27c7,
	0x299d44,
	0x208e88,
	0x2a090a,
	0x2e77c6,
	0x268686,
	0x226209,
	0x29bf47,
	0x2cba08,
	0x204848,
	0x2ddd88,
	0x35cc45,
	0x37e005,
	0x21ba45,
	0x252bc5,
	0x3b5987,
	0x204ec5,
	0x2c0345,
	0x313686,
	0x335cc7,
	0x2cd907,
	0x2a0c06,
	0x2d2245,
	0x29b206,
	0x27ba85,
	0x2b58c8,
	0x2f4284,
	0x2c4246,
	0x33b5c4,
	0x2b0f48,
	0x2c434a,
	0x2790cc,
	0x334685,
	0x21bb06,
	0x21f286,
	0x351fc6,
	0x309ec4,
	0x33ba45,
	0x27a587,
	0x29bfc9,
	0x2cb4c7,
	0x676384,
	0x676384,
	0x317605,
	0x37b944,
	0x29a8ca,
	0x2746c6,
	0x279e04,
	0x3b9585,
	0x37e405,
	0x2b12c4,
	0x280647,
	0x222c87,
	0x2cafc8,
	0x33de88,
	0x20dcc9,
	0x29cd88,
	0x29aa8b,
	0x2318c4,
	0x366885,
	0x27cc85,
	0x224189,
	0x302a89,
	0x2b4288,
	0x30e048,
	0x2d6604,
	0x29c745,
	0x217083,
	0x247bc5,
	0x351a46,
	0x295b8c,
	0x208b06,
	0x36c3c6,
	0x28ae45,
	0x3184c8,
	0x2b7ec6,
	0x2e73c6,
	0x268686,
	0x22920c,
	0x25e184,
	0x3a2e4a,
	0x28ad88,
	0x2959c7,
	0x323186,
	0x239147,
	0x2ec145,
	0x27eb46,
	0x34d406,
	0x35b847,
	0x25e6c4,
	0x2fe0c5,
	0x2741c4,
	0x2ae787,
	0x274408,
	0x2752ca,
	0x27d4c7,
	0x303407,
	0x300107,
	0x2dadc9,
	0x295b8a,
	0x21f083,
	0x25e5c5,
	0x213283,
	0x2e6449,
	0x33dc08,
	0x3709c7,
	0x335e89,
	0x21ee46,
	0x2b88c8,
	0x33a3c5,
	0x2db7ca,
	0x2d3549,
	0x2683c9,
	0x3b50c7,
	0x22e549,
	0x213148,
	0x35ba06,
	0x21bcc8,
	0x2160c7,
	0x2acc07,
	0x26ac87,
	0x2d0b48,
	0x2f5a86,
	0x2a06c5,
	0x27a587,
	0x296508,
	0x33b544,
	0x2dd244,
	0x28fe07,
	0x2ac387,
	0x2151ca,
	0x35b986,
	0x38c74a,
	0x2bf8c7,
	0x2b2fc7,
	0x246004,
	0x28aa44,
	0x2ce686,
	0x202d04,
	0x202d0c,
	0x3aff05,
	0x216d89,
	0x2d4f04,
	0x2b1385,
	0x274a08,
	0x279fc5,
	0x374246,
	0x223ec4,
	0x293c4a,
	0x2b00c6,
	0x29ba8a,
	0x22b447,
	0x21ac45,
	0x21b745,
	0x347dca,
	0x28efc5,
	0x26dfc6,
	0x23e2c4,
	0x2aedc6,
	0x282dc5,
	0x234206,
	0x2e604c,
	0x2cb14a,
	0x2587c4,
	0x247846,
	0x29bf47,
	0x2cf984,
	0x25dc08,
	0x393006,
	0x313089,
	0x2c7549,
	0x3164c9,
	0x26cb06,
	0x2161c6,
	0x21be07,
	0x3b17c8,
	0x215fc9,
	0x20d6c7,
	0x294e46,
	0x34de87,
	0x284f45,
	0x2b3204,
	0x21b9c7,
	0x23bcc5,
	0x286785,
	0x226987,
	0x247448,
	0x3a1cc6,
	0x29738d,
	0x29908f,
	0x29da4d,
	0x210d04,
	0x2332c6,
	0x2d3c08,
	0x33ccc5,
	0x276c08,
	0x24560a,
	0x244504,
	0x27bb46,
	0x26f3c7,
	0x286007,
	0x2a18c9,
	0x21bc85,
	0x2b12c4,
	0x2b330a,
	0x2bc289,
	0x22e647,
	0x265706,
	0x345d86,
	0x29c686,
	0x365b86,
	0x2d320f,
	0x2d3ac9,
	0x274fc6,
	0x22e346,
	0x31a809,
	0x2b2187,
	0x217443,
	0x229386,
	0x216a43,
	0x2e5788,
	0x34dcc7,
	0x29f9c9,
	0x2a8e08,
	0x37a008,
	0x203c86,
	0x208a49,
	0x242785,
	0x2b2244,
	0x2a99c7,
	0x2b47c5,
	0x210d04,
	0x313508,
	0x215bc4,
	0x2b1ec7,
	0x3545c6,
	0x357e85,
	0x2a1288,
	0x345c4b,
	0x331dc7,
	0x348046,
	0x2c4e84,
	0x319586,
	0x264305,
	0x23bcc5,
	0x27c2c9,
	0x280249,
	0x2acc44,
	0x2acc85,
	0x247885,
	0x2db646,
	0x3077c8,
	0x2bf046,
	0x38d3cb,
	0x35ab4a,
	0x2b0e85,
	0x28b6c6,
	0x396485,
	0x2cf485,
	0x2a54c7,
	0x352cc8,
	0x2367c4,
	0x25f806,
	0x28f546,
	0x213307,
	0x30a304,
	0x27ae86,
	0x237cc5,
	0x237cc9,
	0x2163c4,
	0x2a9809,
	0x2774c6,
	0x2c0c08,
	0x247885,
	0x362d45,
	0x234206,
	0x21efc9,
	0x217cc9,
	0x36c446,
	0x2dcf48,
	0x244508,
	0x396444,
	0x2b3644,
	0x2b3648,
	0x326dc8,
	0x2368c9,
	0x3519c6,
	0x268686,
	0x32224d,
	0x2e3306,
	0x306c89,
	0x315fc5,
	0x3bb046,
	0x391408,
	0x31d9c5,
	0x23bb44,
	0x264305,
	0x27fb48,
	0x29a689,
	0x274284,
	0x353146,
	0x279e8a,
	0x2f5d08,
	0x215349,
	0x38174a,
	0x335e06,
	0x299248,
	0x3b8185,
	0x2e0908,
	0x2b8145,
	0x21ed09,
	0x36a349,
	0x20d8c2,
	0x2a8385,
	0x269746,
	0x277407,
	0x3b05c5,
	0x308986,
	0x301448,
	0x2a33c6,
	0x2b6b09,
	0x2760c6,
	0x252808,
	0x2a89c5,
	0x23ebc6,
	0x33da88,
	0x27e648,
	0x2e7008,
	0x345f08,
	0x3b2b44,
	0x22a183,
	0x2b6d44,
	0x27d6c6,
	0x284f84,
	0x2e1287,
	0x2e72c9,
	0x2c45c5,
	0x204846,
	0x229386,
	0x291e4b,
	0x2b0dc6,
	0x3b8cc6,
	0x2c8488,
	0x3204c6,
	0x21aa43,
	0x3af743,
	0x2b3204,
	0x22f485,
	0x2b1807,
	0x274408,
	0x27440f,
	0x27a48b,
	0x3075c8,
	0x3531c6,
	0x3078ce,
	0x2319c3,
	0x2b1784,
	0x2b0d45,
	0x2b1146,
	0x28ce4b,
	0x291886,
	0x21b249,
	0x357e85,
	0x3899c8,
	0x20c688,
	0x217b8c,
	0x29ed06,
	0x247c06,
	0x2d7985,
	0x287b88,
	0x2790c5,
	0x343088,
	0x29b28a,
	0x29de89,
	0x676384,
	0x38a099c2,
	0x16d208,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x209703,
	0x205503,
	0x200983,
	0x38d2c3,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x3b1384,
	0x205503,
	0x200983,
	0x20cf83,
	0x25ef44,
	0x2a84c3,
	0x235ac4,
	0x232403,
	0x2d5f04,
	0x2e9dc3,
	0x3b0887,
	0x209703,
	0x204e83,
	0x28b148,
	0x200983,
	0x2ae1cb,
	0x2ec883,
	0x264a86,
	0x20b0c2,
	0x22d54b,
	0x232403,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x200983,
	0x26be43,
	0x204783,
	0x205702,
	0x16d208,
	0x325f45,
	0x23bd48,
	0x2df7c8,
	0x2099c2,
	0x37ab45,
	0x38c347,
	0x2007c2,
	0x240d87,
	0x20d882,
	0x248707,
	0x32c589,
	0x3b7d48,
	0x2ddc09,
	0x23e202,
	0x263647,
	0x36c1c4,
	0x38c407,
	0x35aa47,
	0x2bbbc2,
	0x209703,
	0x20e602,
	0x200c82,
	0x200442,
	0x2013c2,
	0x205ec2,
	0x209842,
	0x2a80c5,
	0x320885,
	0x99c2,
	0x32403,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x209703,
	0x205503,
	0x200983,
	0x12083,
	0x1ec1,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x3b1384,
	0x244183,
	0x205503,
	0x200983,
	0x219503,
	0x3b819d06,
	0x13f443,
	0x7df85,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x2099c2,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x4a82,
	0x16d208,
	0x44e04,
	0xdb085,
	0x205702,
	0x26f544,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x2358c3,
	0x2a9305,
	0x244183,
	0x206343,
	0x205503,
	0x21c2c3,
	0x200983,
	0x214843,
	0x2387c3,
	0x25ed03,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x2099c2,
	0x200983,
	0x16d208,
	0x2e9dc3,
	0x16d208,
	0x200c03,
	0x2a84c3,
	0x22fd84,
	0x232403,
	0x2e9dc3,
	0x202bc2,
	0x209703,
	0x205503,
	0x200983,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x202bc2,
	0x227f83,
	0x205503,
	0x200983,
	0x2e87c3,
	0x214843,
	0x205702,
	0x2099c2,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x264a85,
	0xe4886,
	0x25ef44,
	0x20b0c2,
	0x16d208,
	0x205702,
	0x1d848,
	0x1b4183,
	0x2099c2,
	0x3fc91386,
	0x1320c4,
	0xd95cb,
	0x13eec6,
	0x9807,
	0x232403,
	0x47208,
	0x2e9dc3,
	0xb9b45,
	0x13fb84,
	0x260f83,
	0x4ce87,
	0xd78c4,
	0x205503,
	0x7f1c4,
	0x200983,
	0x2ed844,
	0xd9388,
	0x125c86,
	0x82b48,
	0x6cf05,
	0x1fa49,
	0x2099c2,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x209703,
	0x204e83,
	0x200983,
	0x2ec883,
	0x20b0c2,
	0x16d208,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x24a5c3,
	0x211cc4,
	0x205503,
	0x200983,
	0x2a84c3,
	0x232403,
	0x2d5f04,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x264a86,
	0x232403,
	0x2e9dc3,
	0x176e43,
	0x200983,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x9807,
	0x16d208,
	0x2e9dc3,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x426a84c3,
	0x232403,
	0x205503,
	0x200983,
	0x16d208,
	0x205702,
	0x2099c2,
	0x2a84c3,
	0x2e9dc3,
	0x205503,
	0x200442,
	0x200983,
	0x316e87,
	0x33e6cb,
	0x22d703,
	0x241608,
	0x3b1547,
	0x20a7c6,
	0x2c2c45,
	0x372349,
	0x209488,
	0x360d49,
	0x38f790,
	0x360d4b,
	0x39e189,
	0x201b03,
	0x20fb89,
	0x230f06,
	0x230f0c,
	0x326008,
	0x3b4f08,
	0x34af09,
	0x2905ce,
	0x2dd9cb,
	0x2f364c,
	0x2030c3,
	0x263d0c,
	0x207089,
	0x2fee47,
	0x23234c,
	0x3a89ca,
	0x2030c4,
	0x2d084d,
	0x263bc8,
	0x20cf8d,
	0x273846,
	0x28decb,
	0x283349,
	0x3b8b87,
	0x32fd06,
	0x330f89,
	0x351b8a,
	0x30b148,
	0x2ec484,
	0x2fba07,
	0x34f707,
	0x2bab04,
	0x37b5c4,
	0x22a749,
	0x281d49,
	0x22ae48,
	0x210785,
	0x3b4005,
	0x20db86,
	0x2d0709,
	0x24588d,
	0x2f30c8,
	0x20da87,
	0x2c2cc8,
	0x2e1886,
	0x38b6c4,
	0x3523c5,
	0x202986,
	0x204b04,
	0x206f87,
	0x20b8ca,
	0x212244,
	0x2157c6,
	0x216a09,
	0x216a0f,
	0x21788d,
	0x2184c6,
	0x21d450,
	0x21d846,
	0x21df87,
	0x21e4c7,
	0x21e4cf,
	0x21f6c9,
	0x224c46,
	0x225347,
	0x225348,
	0x225809,
	0x246088,
	0x2e52c7,
	0x20cc83,
	0x372986,
	0x3ba948,
	0x29088a,
	0x213c09,
	0x2095c3,
	0x38c246,
	0x25f64a,
	0x29e587,
	0x2fec8a,
	0x313d4e,
	0x21f806,
	0x2a8587,
	0x20e006,
	0x207146,
	0x37de0b,
	0x20414a,
	0x317f0d,
	0x216287,
	0x33ce88,
	0x33ce89,
	0x33ce8f,
	0x2b838c,
	0x27b289,
	0x2e6a0e,
	0x3b098a,
	0x2ba246,
	0x2f4586,
	0x30b58c,
	0x30ce8c,
	0x30dc08,
	0x3439c7,
	0x2b8c45,
	0x351e04,
	0x33c90e,
	0x228d04,
	0x351747,
	0x26030a,
	0x362554,
	0x36dd8f,
	0x21e688,
	0x372848,
	0x35040d,
	0x35040e,
	0x376ec9,
	0x3a8ec8,
	0x3a8ecf,
	0x23204c,
	0x23204f,
	0x233007,
	0x236dca,
	0x2435cb,
	0x238508,
	0x239cc7,
	0x3690cd,
	0x250406,
	0x2d0a06,
	0x23c149,
	0x394648,
	0x242088,
	0x24208e,
	0x2b5007,
	0x243885,
	0x244bc5,
	0x2063c4,
	0x20aa86,
	0x22ad48,
	0x202203,
	0x2ca10e,
	0x369488,
	0x2a2fcb,
	0x200dc7,
	0x3a4045,
	0x22e206,
	0x2aa0c7,
	0x333d08,
	0x26cd09,
	0x292e45,
	0x284788,
	0x212c06,
	0x38ad4a,
	0x33c809,
	0x232409,
	0x23240b,
	0x38dc48,
	0x2ba9c9,
	0x210846,
	0x22eb8a,
	0x2dc80a,
	0x236fcc,
	0x3a6687,
	0x32c38a,
	0x26ea8b,
	0x26ea99,
	0x3b6a88,
	0x264b05,
	0x2c6086,
	0x211e49,
	0x390746,
	0x28550a,
	0x209686,
	0x202644,
	0x2c620d,
	0x202647,
	0x211149,
	0x246385,
	0x2464c8,
	0x246fc9,
	0x247784,
	0x248387,
	0x248388,
	0x248c87,
	0x261908,
	0x24d487,
	0x26c645,
	0x25488c,
	0x2550c9,
	0x2bc00a,
	0x3937c9,
	0x20fc89,
	0x275a0c,
	0x25774b,
	0x257ec8,
	0x259048,
	0x25c404,
	0x2810c8,
	0x283c89,
	0x3a8a87,
	0x216c46,
	0x2835c7,
	0x2dcac9,
	0x26e6cb,
	0x319407,
	0x200a07,
	0x22b587,
	0x20cf04,
	0x20cf05,
	0x29a545,
	0x341c0b,
	0x39c644,
	0x3b2988,
	0x26614a,
	0x212cc7,
	0x2f6707,
	0x28bed2,
	0x278446,
	0x22f706,
	0x33c24e,
	0x27aa06,
	0x292588,
	0x29374f,
	0x20d348,
	0x37f308,
	0x30eaca,
	0x30ead1,
	0x2a0e8e,
	0x24dd0a,
	0x24dd0c,
	0x21e307,
	0x3a90d0,
	0x200408,
	0x2a1085,
	0x2aa4ca,
	0x204b4c,
	0x29518d,
	0x2f7e46,
	0x2f7e47,
	0x2f7e4c,
	0x300e4c,
	0x3292cc,
	0x2873cb,
	0x284184,
	0x226384,
	0x346d89,
	0x3050c7,
	0x225e49,
	0x37e909,
	0x39f1c7,
	0x3a8846,
	0x3a8849,
	0x2ad1c3,
	0x21c74a,
	0x31a287,
	0x33eb8b,
	0x317d8a,
	0x248844,
	0x22ba46,
	0x27d749,
	0x202b84,
	0x3affca,
	0x348345,
	0x2bdd45,
	0x2bdd4d,
	0x2be08e,
	0x28cc05,
	0x323906,
	0x264687,
	0x3870ca,
	0x39b686,
	0x3616c4,
	0x36d747,
	0x2c3f0b,
	0x2e1947,
	0x33fa84,
	0x24bb86,
	0x24bb8d,
	0x21e1cc,
	0x2053c6,
	0x2f32ca,
	0x2e03c6,
	0x2ed0c8,
	0x377c47,
	0x23568a,
	0x23d6c6,
	0x216183,
	0x391586,
	0x3ba7c8,
	0x29ac8a,
	0x275807,
	0x275808,
	0x281684,
	0x24b687,
	0x279348,
	0x2bd748,
	0x27c0c8,
	0x38c94a,
	0x2da905,
	0x2cf0c7,
	0x24db53,
	0x31e806,
	0x266348,
	0x221a09,
	0x240c48,
	0x203d0b,
	0x2cb608,
	0x2a5f44,
	0x32ec06,
	0x30bac6,
	0x3027c9,
	0x2c3dc7,
	0x254988,
	0x28af06,
	0x226884,
	0x2cb8c5,
	0x2c55c8,
	0x2c5bca,
	0x2c5e88,
	0x2cbf86,
	0x29944a,
	0x2ac808,
	0x2cf788,
	0x2d18c8,
	0x2d1f06,
	0x2d3e06,
	0x38e18c,
	0x2d43d0,
	0x27d2c5,
	0x20d148,
	0x301950,
	0x20d150,
	0x38f60e,
	0x38de0e,
	0x38de14,
	0x32fe8f,
	0x330246,
	0x332d51,
	0x33d213,
	0x33d688,
	0x3b3445,
	0x241b48,
	0x386245,
	0x329a8c,
	0x291549,
	0x228b49,
	0x3201c7,
	0x236b89,
	0x380887,
	0x2f6146,
	0x3521c7,
	0x269c45,
	0x2120c3,
	0x2023c9,
	0x221cc9,
	0x376e43,
	0x27f384,
	0x32a20d,
	0x206bcf,
	0x2268c5,
	0x329986,
	0x211407,
	0x325d87,
	0x288786,
	0x28878b,
	0x2a2405,
	0x256786,
	0x2f6c07,
	0x24e489,
	0x3a7486,
	0x21d305,
	0x22854b,
	0x235946,
	0x249245,
	0x357988,
	0x306a88,
	0x2c8f0c,
	0x2c8f10,
	0x2d2409,
	0x2ffd07,
	0x32840b,
	0x2e3b86,
	0x2e518a,
	0x2e754b,
	0x2e794a,
	0x2e7bc6,
	0x2e8685,
	0x319fc6,
	0x36c808,
	0x32028a,
	0x35009c,
	0x2ec94c,
	0x2ecc48,
	0x264a85,
	0x34ea07,
	0x26bec6,
	0x274e05,
	0x21afc6,
	0x288948,
	0x2bc507,
	0x2904c8,
	0x2a868a,
	0x33130c,
	0x331589,
	0x38b847,
	0x2198c4,
	0x244c86,
	0x37ee8a,
	0x37ea05,
	0x209f8c,
	0x20e648,
	0x367388,
	0x21a00c,
	0x22550c,
	0x225a09,
	0x225c47,
	0x231d4c,
	0x23aa84,
	0x23c60a,
	0x35e6cc,
	0x26b28b,
	0x242b8b,
	0x2efec6,
	0x24a107,
	0x24c687,
	0x3a930f,
	0x2f8a51,
	0x2d8592,
	0x24c68d,
	0x24c68e,
	0x24c9ce,
	0x330048,
	0x330052,
	0x24fbc8,
	0x3b1187,
	0x24aeca,
	0x3681c8,
	0x27a9c5,
	0x3b57ca,
	0x21dd87,
	0x2e36c4,
	0x201543,
	0x2a57c5,
	0x30ed47,
	0x2f5007,
	0x29538e,
	0x3382cd,
	0x33af89,
	0x222705,
	0x35c3c3,
	0x3a78c6,
	0x36e745,
	0x2a3208,
	0x205b49,
	0x2983c5,
	0x3692cf,
	0x2d96c7,
	0x372285,
	0x20178a,
	0x2a36c6,
	0x2ed249,
	0x396ccc,
	0x2f51c9,
	0x3abdc6,
	0x265f4c,
	0x322d06,
	0x2f7588,
	0x2f7786,
	0x3b6c06,
	0x3b96c4,
	0x258243,
	0x2a1fca,
	0x327191,
	0x3a9c0a,
	0x27ee85,
	0x265047,
	0x252207,
	0x279444,
	0x27944b,
	0x3b7bc8,
	0x2b7bc6,
	0x362b85,
	0x38b044,
	0x255f09,
	0x31ad84,
	0x254f07,
	0x32f345,
	0x32f347,
	0x33c485,
	0x2a8183,
	0x3b1048,
	0x33b80a,
	0x203043,
	0x325f8a,
	0x203046,
	0x36904f,
	0x2b4f89,
	0x2ca090,
	0x2f1548,
	0x2ccc89,
	0x2971c7,
	0x24bb0f,
	0x336244,
	0x2d5f84,
	0x21d6c6,
	0x22f246,
	0x25708a,
	0x23cc46,
	0x2f58c7,
	0x300788,
	0x300987,
	0x301207,
	0x30370a,
	0x30534b,
	0x2f3dc5,
	0x2d81c8,
	0x21bb03,
	0x23800c,
	0x36f78f,
	0x2b8a4d,
	0x2a7147,
	0x33b0c9,
	0x22bcc7,
	0x24a2c8,
	0x36274c,
	0x2a5e48,
	0x250bc8,
	0x318ace,
	0x32d354,
	0x32d864,
	0x3475ca,
	0x36148b,
	0x380944,
	0x380949,
	0x27bbc8,
	0x245345,
	0x201d0a,
	0x3696c7,
	0x26f744,
	0x38d2c3,
	0x2a84c3,
	0x235ac4,
	0x232403,
	0x2e9dc3,
	0x3b1384,
	0x244183,
	0x209703,
	0x2d43c6,
	0x211cc4,
	0x205503,
	0x200983,
	0x201303,
	0x205702,
	0x38d2c3,
	0x2099c2,
	0x2a84c3,
	0x235ac4,
	0x232403,
	0x2e9dc3,
	0x244183,
	0x2d43c6,
	0x205503,
	0x200983,
	0x16d208,
	0x2a84c3,
	0x232403,
	0x2163c3,
	0x205503,
	0x200983,
	0x16d208,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x209703,
	0x211cc4,
	0x205503,
	0x200983,
	0x205702,
	0x2bb143,
	0x2099c2,
	0x232403,
	0x2e9dc3,
	0x209703,
	0x205503,
	0x200983,
	0x201ec2,
	0x219f02,
	0x2099c2,
	0x2a84c3,
	0x202242,
	0x201fc2,
	0x3b1384,
	0x210444,
	0x227382,
	0x211cc4,
	0x200442,
	0x200983,
	0x201303,
	0x2efec6,
	0x212982,
	0x202dc2,
	0x222f02,
	0x44e0d343,
	0x4521e303,
	0x52d46,
	0x52d46,
	0x25ef44,
	0x204e83,
	0x142abca,
	0x12778c,
	0x102cc,
	0x7dd8d,
	0x129845,
	0x21347,
	0x18648,
	0x1b887,
	0x20348,
	0x19d4ca,
	0x45ed6a45,
	0x12b809,
	0xaf848,
	0x4a70a,
	0x8a64e,
	0x1440a4b,
	0x1320c4,
	0x77848,
	0x68bc8,
	0x38f47,
	0x12807,
	0x4efc9,
	0x2c07,
	0xd4ac8,
	0x1318c9,
	0x3adc5,
	0x124d4e,
	0xa8a0d,
	0x9688,
	0x4622a586,
	0x46c2a588,
	0x70cc8,
	0x117090,
	0x5f347,
	0x601c7,
	0x64547,
	0x69447,
	0xdb42,
	0x190bc7,
	0x430c,
	0x35fc7,
	0xa4246,
	0xa4909,
	0xa6388,
	0x17f42,
	0x1fc2,
	0xb8fcb,
	0x7f247,
	0x11809,
	0xbb9c9,
	0x17e248,
	0xafd42,
	0x113a49,
	0xcdf8a,
	0xc9e09,
	0xd6fc9,
	0xd7ac8,
	0xd8a47,
	0xda889,
	0xde345,
	0xde6d0,
	0x175b86,
	0x192345,
	0x5e98d,
	0xf986,
	0xe9187,
	0xed858,
	0x1b1a48,
	0xb4c8a,
	0x1c42,
	0x52f4d,
	0x27c2,
	0x5d306,
	0x8d108,
	0x86ec8,
	0x16d0c9,
	0x55b08,
	0x5fb4e,
	0x1a78c7,
	0x19d0d,
	0xf2d05,
	0x190948,
	0x194448,
	0xfacc6,
	0xc2,
	0x125c86,
	0x7b02,
	0x341,
	0x57a07,
	0xc8e83,
	0x466ee0c4,
	0x46a94443,
	0x141,
	0x10986,
	0x141,
	0x1,
	0x10986,
	0xc8e83,
	0x1596bc5,
	0x2030c4,
	0x2a84c3,
	0x249944,
	0x3b1384,
	0x205503,
	0x2218c5,
	0x219503,
	0x23e743,
	0x373605,
	0x25ed03,
	0x47ea84c3,
	0x232403,
	0x2e9dc3,
	0x200041,
	0x209703,
	0x210444,
	0x211cc4,
	0x205503,
	0x200983,
	0x214843,
	0x16d208,
	0x205702,
	0x38d2c3,
	0x2099c2,
	0x2a84c3,
	0x232403,
	0x2163c3,
	0x201fc2,
	0x3b1384,
	0x244183,
	0x209703,
	0x205503,
	0x204e83,
	0x200983,
	0x25ed03,
	0x16d208,
	0x36f502,
	0x99c2,
	0x1456108,
	0x100b4e,
	0x48e016c2,
	0x31a448,
	0x234386,
	0x209cc6,
	0x233d07,
	0x4920c202,
	0x49768ec8,
	0x20884a,
	0x25cc88,
	0x200242,
	0x31a0c9,
	0x2f3e07,
	0x216bc6,
	0x3b0d89,
	0x2cf204,
	0x20a6c6,
	0x2dbcc4,
	0x26ffc4,
	0x2544c9,
	0x326686,
	0x320945,
	0x22c445,
	0x384e07,
	0x2bfb47,
	0x28fa44,
	0x233f46,
	0x2fb005,
	0x2fde45,
	0x3963c5,
	0x3b3dc7,
	0x200c05,
	0x314b49,
	0x312945,
	0x333e44,
	0x39b5c7,
	0x31974e,
	0x32e5c9,
	0x33c109,
	0x3a64c6,
	0x23d408,
	0x26d98b,
	0x2aeecc,
	0x37f806,
	0x2dd887,
	0x20a305,
	0x37b5ca,
	0x22af49,
	0x20bf49,
	0x24ff86,
	0x2f69c5,
	0x27ce45,
	0x3490c9,
	0x39654b,
	0x273346,
	0x33a786,
	0x202504,
	0x28bb86,
	0x243908,
	0x3ba646,
	0x214386,
	0x207c08,
	0x20bb47,
	0x20bd09,
	0x20c585,
	0x16d208,
	0x212784,
	0x3ada04,
	0x283785,
	0x399a49,
	0x220f07,
	0x220f0b,
	0x22394a,
	0x227a45,
	0x49a08d42,
	0x33ea47,
	0x49e28908,
	0x2afb87,
	0x350e85,
	0x20c1ca,
	0x99c2,
	0x34dfcb,
	0x24d5ca,
	0x221bc6,
	0x282bc3,
	0x28e34d,
	0x3492cc,
	0x35084d,
	0x245c45,
	0x32ae05,
	0x202247,
	0x3aba49,
	0x208746,
	0x23cac5,
	0x2d29c8,
	0x28ba83,
	0x2dfac8,
	0x28ba88,
	0x2c3747,
	0x309708,
	0x3a7209,
	0x2cc447,
	0x33e247,
	0x396a48,
	0x251f44,
	0x251f47,
	0x273748,
	0x3a3ac6,
	0x205f4f,
	0x211a07,
	0x2e5446,
	0x225d85,
	0x223083,
	0x371847,
	0x36c043,
	0x248e46,
	0x24aa86,
	0x24b286,
	0x290c05,
	0x261903,
	0x388208,
	0x36f009,
	0x38224b,
	0x24b408,
	0x24d145,
	0x24f605,
	0x4a248902,
	0x352289,
	0x3b1407,
	0x256805,
	0x2543c7,
	0x2559c6,
	0x365a45,
	0x36e58b,
	0x257ec4,
	0x25c845,
	0x25c987,
	0x272cc6,
	0x273105,
	0x2812c7,
	0x281a07,
	0x2cd884,
	0x289c0a,
	0x28a0c8,
	0x3b8209,
	0x241e85,
	0x207886,
	0x243aca,
	0x22c346,
	0x261e07,
	0x3b7ecd,
	0x29c809,
	0x38d185,
	0x314187,
	0x332288,
	0x33d848,
	0x3b3107,
	0x379d86,
	0x215dc7,
	0x249f43,
	0x341c04,
	0x363485,
	0x392707,
	0x395dc9,
	0x22be48,
	0x344c45,
	0x23cd84,
	0x246245,
	0x24b80d,
	0x200f82,
	0x373746,
	0x25d246,
	0x2c578a,
	0x376546,
	0x37edc5,
	0x33df85,
	0x33df87,
	0x38ab8c,
	0x270b4a,
	0x28b846,
	0x2b9645,
	0x28b9c6,
	0x28bd07,
	0x28e186,
	0x290b0c,
	0x3b0ec9,
	0x4a610e07,
	0x293b05,
	0x293b06,
	0x293ec8,
	0x23b705,
	0x2a2c85,
	0x2a3848,
	0x2a3a4a,
	0x4aa4ecc2,
	0x4ae0ee02,
	0x2e6705,
	0x284f83,
	0x3adf08,
	0x204043,
	0x2a3cc4,
	0x2ed38b,
	0x26dd48,
	0x2e4d48,
	0x4b349909,
	0x2a7dc9,
	0x2a8906,
	0x2a9d48,
	0x2a9f49,
	0x2aab46,
	0x2aacc5,
	0x3843c6,
	0x2ab5c9,
	0x331f47,
	0x23ea86,
	0x233747,
	0x2085c7,
	0x32c8c4,
	0x4b7b1d49,
	0x2cab88,
	0x368dc8,
	0x383447,
	0x2c5246,
	0x226ac9,
	0x209c87,
	0x32e90a,
	0x38c588,
	0x3af5c7,
	0x3b9786,
	0x24f38a,
	0x262708,
	0x2dccc5,
	0x226645,
	0x2ee487,
	0x2f7349,
	0x36510b,
	0x315008,
	0x3129c9,
	0x24bfc7,
	0x2b550c,
	0x2b5c4c,
	0x2b5f4a,
	0x2b61cc,
	0x2c2708,
	0x2c2908,
	0x2c2b04,
	0x2c2ec9,
	0x2c3109,
	0x2c334a,
	0x2c35c9,
	0x2c3907,
	0x3af00c,
	0x241146,
	0x34acc8,
	0x22c406,
	0x32e7c6,
	0x38d087,
	0x3b3288,
	0x39034b,
	0x2afa47,
	0x352489,
	0x3445c9,
	0x249ac7,
	0x278a04,
	0x265187,
	0x2db346,
	0x214a06,
	0x2f3485,
	0x2a5888,
	0x291444,
	0x291446,
	0x270a0b,
	0x21ca49,
	0x214b46,
	0x21c489,
	0x3b3f46,
	0x254688,
	0x223b83,
	0x2f6b45,
	0x22edc9,
	0x261145,
	0x2f9684,
	0x272206,
	0x231545,
	0x228f86,
	0x3056c7,
	0x26e986,
	0x3a304b,
	0x22ea87,
	0x3379c6,
	0x346f06,
	0x384ec6,
	0x28fa09,
	0x2ef14a,
	0x2b3505,
	0x2170cd,
	0x2a3b46,
	0x235546,
	0x2b4e86,
	0x2ed045,
	0x2de9c7,
	0x2e14c7,
	0x3581ce,
	0x209703,
	0x2c5209,
	0x391dc9,
	0x37b9c7,
	0x358f07,
	0x29d645,
	0x27ec45,
	0x4ba2a88f,
	0x2ccec7,
	0x2cd088,
	0x2cd484,
	0x2cde46,
	0x4be44c42,
	0x2d2186,
	0x2d43c6,
	0x391f8e,
	0x2df90a,
	0x357b06,
	0x285eca,
	0x203549,
	0x324105,
	0x398008,
	0x3b5606,
	0x38cec8,
	0x26f088,
	0x28eb8b,
	0x233e05,
	0x200c88,
	0x207d4c,
	0x2bd507,
	0x24ae06,
	0x2e28c8,
	0x20a948,
	0x4c208442,
	0x20a48b,
	0x282549,
	0x329f09,
	0x3bb287,
	0x20f7c8,
	0x4c61bf48,
	0x3511cb,
	0x37e0c9,
	0x234fcd,
	0x2750c8,
	0x224a48,
	0x4ca03ec2,
	0x20e3c4,
	0x4ce1a2c2,
	0x2f4ec6,
	0x4d2004c2,
	0x3813ca,
	0x21c346,
	0x285908,
	0x284488,
	0x2af446,
	0x22d8c6,
	0x2f12c6,
	0x2a3185,
	0x238c04,
	0x4d61e144,
	0x205146,
	0x272707,
	0x4dae8bc7,
	0x35490b,
	0x319b09,
	0x32ae4a,
	0x391804,
	0x33e0c8,
	0x23e84d,
	0x2eb709,
	0x2eb948,
	0x2ebfc9,
	0x2ed844,
	0x243484,
	0x27c885,
	0x317b4b,
	0x26dcc6,
	0x3424c5,
	0x250149,
	0x234008,
	0x2047c4,
	0x37b749,
	0x208105,
	0x2bfb88,
	0x33e907,
	0x33c508,
	0x27d946,
	0x35e387,
	0x292349,
	0x2286c9,
	0x2492c5,
	0x334ec5,
	0x4de2d902,
	0x333c04,
	0x2049c5,
	0x32c146,
	0x318385,
	0x2b1ac7,
	0x205245,
	0x272d04,
	0x3a6586,
	0x23cb47,
	0x232986,
	0x2dca05,
	0x203188,
	0x234585,
	0x2062c7,
	0x20f1c9,
	0x21cb8a,
	0x2e1b87,
	0x2e1b8c,
	0x320906,
	0x343cc9,
	0x23b385,
	0x23b648,
	0x210803,
	0x210805,
	0x2e8a05,
	0x261607,
	0x4e20c002,
	0x22d0c7,
	0x2e4f06,
	0x342786,
	0x2e7d06,
	0x20a886,
	0x208388,
	0x241c85,
	0x2e5507,
	0x2e550d,
	0x201543,
	0x21ec05,
	0x201547,
	0x22d408,
	0x201105,
	0x218c88,
	0x36c0c6,
	0x32b9c7,
	0x2c4785,
	0x233e86,
	0x26f5c5,
	0x21390a,
	0x2f2e06,
	0x377ac7,
	0x2ca505,
	0x3612c7,
	0x36d6c4,
	0x2f9606,
	0x2fb3c5,
	0x32648b,
	0x2db1c9,
	0x2bb24a,
	0x249348,
	0x301d08,
	0x304a4c,
	0x306287,
	0x3073c8,
	0x310a48,
	0x31e945,
	0x34020a,
	0x35c3c9,
	0x4e600802,
	0x200806,
	0x219d04,
	0x2ea849,
	0x220b49,
	0x269287,
	0x294947,
	0x37e789,
	0x38cb48,
	0x38cb4f,
	0x315d06,
	0x2d670b,
	0x36e8c5,
	0x36e8c7,
	0x385889,
	0x212ac6,
	0x37b6c7,
	0x2d8905,
	0x2303c4,
	0x261006,
	0x211ac4,
	0x2ce4c7,
	0x307048,
	0x4eaf68c8,
	0x2f7085,
	0x2f71c7,
	0x236549,
	0x23e284,
	0x23e288,
	0x4ee2b888,
	0x279444,
	0x231388,
	0x32fdc4,
	0x3ab849,
	0x2173c5,
	0x4f20b0c2,
	0x315d45,
	0x2e4345,
	0x251288,
	0x232e47,
	0x4f601442,
	0x204785,
	0x2cf606,
	0x24b106,
	0x333bc8,
	0x302108,
	0x318346,
	0x327f06,
	0x2e2e49,
	0x3426c6,
	0x21298b,
	0x296305,
	0x368106,
	0x377088,
	0x250506,
	0x292cc6,
	0x21914a,
	0x23084a,
	0x245005,
	0x241d47,
	0x308786,
	0x4fa01682,
	0x201687,
	0x238705,
	0x243a44,
	0x243a45,
	0x391706,
	0x26a447,
	0x219a85,
	0x220c04,
	0x2c7e88,
	0x292d85,
	0x333a47,
	0x3a1645,
	0x213845,
	0x256e04,
	0x287609,
	0x2fae48,
	0x2e0286,
	0x2d9d06,
	0x2b6e46,
	0x4fefbc88,
	0x2fbe87,
	0x2fc0cd,
	0x2fcb4c,
	0x2fd149,
	0x2fd389,
	0x5035b2c2,
	0x3a8603,
	0x207943,
	0x2db405,
	0x39280a,
	0x327dc6,
	0x302385,
	0x305884,
	0x30588b,
	0x31b70c,
	0x31c14c,
	0x31c455,
	0x31d74d,
	0x320a8f,
	0x320e52,
	0x3212cf,
	0x321692,
	0x321b13,
	0x321fcd,
	0x32258d,
	0x32290e,
	0x322e8e,
	0x3236cc,
	0x323a8c,
	0x323ecb,
	0x32424e,
	0x325392,
	0x327b8c,
	0x328790,
	0x335212,
	0x33640c,
	0x336acd,
	0x336e0c,
	0x339a51,
	0x33a90d,
	0x34084d,
	0x340e4a,
	0x3410cc,
	0x3419cc,
	0x3421cc,
	0x34290c,
	0x344dd3,
	0x345450,
	0x345850,
	0x34610d,
	0x34670c,
	0x347309,
	0x34890d,
	0x348c53,
	0x34a311,
	0x34a753,
	0x34b24f,
	0x34b60c,
	0x34b90f,
	0x34bccd,
	0x34c2cf,
	0x34c690,
	0x34d10e,
	0x3539ce,
	0x353f50,
	0x35518d,
	0x355b0e,
	0x355e8c,
	0x356e93,
	0x35934e,
	0x3599d0,
	0x359dd1,
	0x35a20f,
	0x35a5d3,
	0x35ae4d,
	0x35b18f,
	0x35b54e,
	0x35bc10,
	0x35c009,
	0x35cd90,
	0x35d38f,
	0x35da0f,
	0x35ddd2,
	0x35efce,
	0x35fc4d,
	0x36070d,
	0x360a4d,
	0x36184d,
	0x361b8d,
	0x361ed0,
	0x3622cb,
	0x36324c,
	0x3635cc,
	0x363bcc,
	0x363ece,
	0x371a10,
	0x372dd2,
	0x37324b,
	0x3738ce,
	0x373c4e,
	0x3744ce,
	0x37494b,
	0x50774f56,
	0x37624d,
	0x3766d4,
	0x377e0d,
	0x37b115,
	0x37c40d,
	0x37cd8f,
	0x37d5cf,
	0x38250f,
	0x3828ce,
	0x382e4d,
	0x383f91,
	0x38674c,
	0x386a4c,
	0x386d4b,
	0x38764c,
	0x387a0f,
	0x387dd2,
	0x38878d,
	0x38974c,
	0x389bcc,
	0x389ecd,
	0x38a20f,
	0x38a5ce,
	0x3924cc,
	0x392a8d,
	0x392dcb,
	0x39358c,
	0x393b0d,
	0x393e4e,
	0x3941c9,
	0x394d13,
	0x39524d,
	0x39558d,
	0x395b8c,
	0x39600e,
	0x396fcf,
	0x39738c,
	0x39768d,
	0x3979cf,
	0x397d8c,
	0x39848c,
	0x39890c,
	0x398c0c,
	0x3992cd,
	0x399612,
	0x399c8c,
	0x399f8c,
	0x39a291,
	0x39a6cf,
	0x39aa8f,
	0x39ae53,
	0x39bcce,
	0x39c04f,
	0x39c40c,
	0x50b9c74e,
	0x39cacf,
	0x39ce96,
	0x39dc12,
	0x39f38c,
	0x39fd0f,
	0x3a038d,
	0x3a06cf,
	0x3a0a8c,
	0x3a0d8d,
	0x3a10cd,
	0x3a254e,
	0x3a4b8c,
	0x3a4e8c,
	0x3a5190,
	0x3a7a91,
	0x3a7ecb,
	0x3a820c,
	0x3a850e,
	0x3aa811,
	0x3aac4e,
	0x3aafcd,
	0x3b53cb,
	0x3b5e8f,
	0x3b6d94,
	0x228782,
	0x228782,
	0x200c83,
	0x228782,
	0x200c83,
	0x228782,
	0x205142,
	0x384405,
	0x3aa50c,
	0x228782,
	0x228782,
	0x205142,
	0x228782,
	0x294545,
	0x21cb85,
	0x228782,
	0x228782,
	0x20b382,
	0x294545,
	0x31f3c9,
	0x34a00c,
	0x228782,
	0x228782,
	0x228782,
	0x228782,
	0x384405,
	0x228782,
	0x228782,
	0x228782,
	0x228782,
	0x20b382,
	0x31f3c9,
	0x228782,
	0x228782,
	0x228782,
	0x21cb85,
	0x228782,
	0x21cb85,
	0x34a00c,
	0x3aa50c,
	0x38d2c3,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x3b1384,
	0x205503,
	0x200983,
	0x2708,
	0x5fc84,
	0xe0e08,
	0x205702,
	0x51a099c2,
	0x23dbc3,
	0x24f2c4,
	0x2032c3,
	0x393304,
	0x22f706,
	0x20e883,
	0x3328c4,
	0x286bc5,
	0x209703,
	0x205503,
	0x200983,
	0x255cca,
	0x2efec6,
	0x373fcc,
	0x16d208,
	0x2099c2,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x227f83,
	0x2d43c6,
	0x205503,
	0x200983,
	0x201303,
	0xa4508,
	0x129845,
	0x14902,
	0x52f86185,
	0x21347,
	0xc93c8,
	0xec0e,
	0x88192,
	0xfe20b,
	0x532d6a45,
	0x536d6a4c,
	0xb007,
	0x16fc07,
	0x1b254a,
	0x3a6d0,
	0x149c05,
	0xd95cb,
	0x68bc8,
	0x38f47,
	0x304cb,
	0x4efc9,
	0x11dd07,
	0x2c07,
	0x73587,
	0x1c106,
	0xd4ac8,
	0x53c1cdc6,
	0xa8a0d,
	0x1b1f10,
	0x5402bb82,
	0x9688,
	0x4a450,
	0x14434c,
	0x5474e88d,
	0x655c7,
	0x78749,
	0x52e06,
	0x940c8,
	0x67e42,
	0x9f54a,
	0x27f07,
	0x35fc7,
	0xa4909,
	0xa6388,
	0xb9b45,
	0xec50e,
	0xb54e,
	0xdecf,
	0x11809,
	0xbb9c9,
	0x43e4b,
	0x7664f,
	0x8780c,
	0x9ef4b,
	0xbbf48,
	0x154807,
	0xcdc48,
	0xfb80b,
	0xf568c,
	0xf640c,
	0xf908c,
	0xfe68d,
	0x17e248,
	0xeab02,
	0x113a49,
	0x185d4b,
	0xc5446,
	0x116fcb,
	0xd804a,
	0xd8c05,
	0xde6d0,
	0x111806,
	0x192345,
	0xe3f48,
	0xe9187,
	0xe9447,
	0xff487,
	0xf4d0a,
	0xc924a,
	0x5d306,
	0x91a0d,
	0x86ec8,
	0x55b08,
	0x56d49,
	0xb3c45,
	0xf484c,
	0xfe88b,
	0x165044,
	0xfaa89,
	0xfacc6,
	0x1af7c6,
	0x2dc2,
	0x125c86,
	0x107247,
	0x7b02,
	0xc83c5,
	0x29544,
	0x1ec1,
	0x4c983,
	0x53a85146,
	0x94443,
	0xd882,
	0x27f04,
	0x242,
	0x5ef44,
	0x3dc2,
	0x8142,
	0x2502,
	0x10f242,
	0x1ec2,
	0xd6a42,
	0x4142,
	0x1b102,
	0x2cd82,
	0x5742,
	0xdc2,
	0xf882,
	0x32403,
	0x5f02,
	0x7c2,
	0x18342,
	0xfc82,
	0x5e82,
	0x1ae02,
	0x17f42,
	0x15c2,
	0x29c2,
	0x1fc2,
	0x44183,
	0x3942,
	0x6502,
	0xafd42,
	0xbe02,
	0x282,
	0x4bc2,
	0x1f42,
	0xa8542,
	0x2342,
	0x152bc2,
	0x675c2,
	0x2c82,
	0x5503,
	0x8c2,
	0x8442,
	0x33c2,
	0xb482,
	0x49245,
	0xba02,
	0x2d4c2,
	0x3c083,
	0x482,
	0x1c42,
	0x27c2,
	0x3902,
	0x1102,
	0x1442,
	0xc2,
	0x2dc2,
	0x9885,
	0x75c47,
	0x212503,
	0x205702,
	0x2a84c3,
	0x232403,
	0x2163c3,
	0x20ad83,
	0x227f83,
	0x205503,
	0x204e83,
	0x200983,
	0x294483,
	0x169c3,
	0x16d208,
	0x2a84c3,
	0x232403,
	0x2163c3,
	0x209703,
	0x205503,
	0x204e83,
	0x200983,
	0x2a84c3,
	0x232403,
	0x200983,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x200041,
	0x209703,
	0x205503,
	0x21c2c3,
	0x200983,
	0x38d2c3,
	0x2a84c3,
	0x232403,
	0x209683,
	0x2163c3,
	0x277dc3,
	0x280b83,
	0x21c303,
	0x252c03,
	0x2e9dc3,
	0x3b1384,
	0x205503,
	0x200983,
	0x25ed03,
	0x352e84,
	0x231a03,
	0x30c3,
	0x228483,
	0x37a908,
	0x24f3c4,
	0x3b870a,
	0x2b8ec6,
	0x1b6a04,
	0x39b2c7,
	0x21e7ca,
	0x315bc9,
	0x3ab587,
	0x3b724a,
	0x38d2c3,
	0x2e678b,
	0x2b9fc9,
	0x2bd645,
	0x2d1fc7,
	0x99c2,
	0x2a84c3,
	0x205747,
	0x2e2b85,
	0x2dbdc9,
	0x232403,
	0x233c06,
	0x2c1a43,
	0xdb283,
	0x104e46,
	0x18ec46,
	0xe807,
	0x212e46,
	0x21b185,
	0x282407,
	0x2d5b87,
	0x56ae9dc3,
	0x336647,
	0x365e03,
	0x206a05,
	0x3b1384,
	0x220688,
	0x38644c,
	0x2ad745,
	0x29c986,
	0x205607,
	0x38b907,
	0x238347,
	0x245108,
	0x303b8f,
	0x315e05,
	0x23dcc7,
	0x26f287,
	0x2a3e0a,
	0x2d2809,
	0x304f85,
	0x30664a,
	0x82a06,
	0x2c1ac5,
	0x374b84,
	0x2843c6,
	0x2f1d47,
	0x2eaa07,
	0x3bb408,
	0x22dc85,
	0x2e2a86,
	0x214305,
	0x3adcc5,
	0x21c984,
	0x2af347,
	0x2081ca,
	0x334808,
	0x35ba86,
	0x27f83,
	0x2da905,
	0x25f906,
	0x3af246,
	0x392246,
	0x209703,
	0x388a07,
	0x26f205,
	0x205503,
	0x2d830d,
	0x204e83,
	0x3bb508,
	0x27f404,
	0x272fc5,
	0x2a3d06,
	0x234d46,
	0x368007,
	0x2a6ec7,
	0x267345,
	0x200983,
	0x21fbc7,
	0x2788c9,
	0x311a49,
	0x22708a,
	0x243002,
	0x2069c4,
	0x2e5084,
	0x390207,
	0x22cf88,
	0x2ea2c9,
	0x21eac9,
	0x2eaf47,
	0x2ba486,
	0xec286,
	0x2ed844,
	0x2ede4a,
	0x2f0d48,
	0x2f1189,
	0x2bdbc6,
	0x2b1445,
	0x3346c8,
	0x2c5f8a,
	0x22ed03,
	0x353006,
	0x2eb047,
	0x223ec5,
	0x3a5e05,
	0x264b83,
	0x250cc4,
	0x226605,
	0x281b07,
	0x2faf85,
	0x2ee346,
	0xfc605,
	0x247d83,
	0x357bc9,
	0x272d8c,
	0x29344c,
	0x2ced08,
	0x293087,
	0x2f7908,
	0x2f7c4a,
	0x2f888b,
	0x2ba108,
	0x234e48,
	0x239586,
	0x390d45,
	0x38da4a,
	0x3a6205,
	0x20b0c2,
	0x2c4647,
	0x25fe86,
	0x35c8c5,
	0x370809,
	0x2f39c5,
	0x27e985,
	0x2ddf09,
	0x351846,
	0x237e88,
	0x33f383,
	0x20f486,
	0x272146,
	0x306445,
	0x306449,
	0x2b6789,
	0x279ac7,
	0x109104,
	0x309107,
	0x21e9c9,
	0x238d05,
	0x413c8,
	0x3b2e85,
	0x330e85,
	0x380509,
	0x201702,
	0x25e544,
	0x201e82,
	0x203942,
	0x31ecc5,
	0x3b6788,
	0x2b3b85,
	0x2c3ac3,
	0x2c3ac5,
	0x2d2383,
	0x20f442,
	0x377804,
	0x2ac783,
	0x2056c2,
	0x379884,
	0x2e5d43,
	0x2082c2,
	0x2b3c03,
	0x28d084,
	0x2e4c83,
	0x248684,
	0x203082,
	0x218943,
	0x22ef03,
	0x200d02,
	0x361782,
	0x2b65c9,
	0x207842,
	0x288d04,
	0x203cc2,
	0x334544,
	0x2ba444,
	0x2b74c4,
	0x202dc2,
	0x2391c2,
	0x225bc3,
	0x2f8403,
	0x23d904,
	0x281c84,
	0x2eb1c4,
	0x2f0f04,
	0x30a483,
	0x26e543,
	0x282984,
	0x30a2c4,
	0x30aac6,
	0x22a282,
	0x2099c2,
	0x232403,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x205702,
	0x38d2c3,
	0x2a84c3,
	0x232403,
	0x2007c3,
	0x2e9dc3,
	0x3b1384,
	0x2b6884,
	0x211cc4,
	0x205503,
	0x200983,
	0x201303,
	0x2ee644,
	0x31a403,
	0x2bd0c3,
	0x34ab84,
	0x3b2c86,
	0x202f03,
	0x16fc07,
	0x222403,
	0x2459c3,
	0x2b0543,
	0x206a43,
	0x227f83,
	0x2d6cc5,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x282c43,
	0x2a5143,
	0x16d208,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x244183,
	0x205503,
	0x23a504,
	0x200983,
	0x26bec4,
	0x2bf145,
	0x16fc07,
	0x2099c2,
	0x2006c2,
	0x20d882,
	0x200c82,
	0x200442,
	0x2a84c3,
	0x235ac4,
	0x232403,
	0x2e9dc3,
	0x209703,
	0x205503,
	0x200983,
	0x16d208,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x209703,
	0x211cc4,
	0x205503,
	0x200983,
	0x214843,
	0x25ef44,
	0x16d208,
	0x2a84c3,
	0x204e83,
	0x169c3,
	0x2030c4,
	0x16d208,
	0x2a84c3,
	0x249944,
	0x3b1384,
	0x204e83,
	0x203ec2,
	0x200983,
	0x23e743,
	0x50cc4,
	0x373605,
	0x20b0c2,
	0x30a403,
	0x205702,
	0x16d208,
	0x2099c2,
	0x232403,
	0x2e9dc3,
	0x201fc2,
	0x200983,
	0x205702,
	0x1b7407,
	0x12e3c9,
	0x6f83,
	0x16d208,
	0x18ebc3,
	0x5a31fd87,
	0xa84c3,
	0x708,
	0x232403,
	0x2e9dc3,
	0x1ae886,
	0x244183,
	0x8f2c8,
	0xc0e08,
	0x41a46,
	0x209703,
	0xca988,
	0xb1b43,
	0xdf145,
	0x32607,
	0x8003,
	0x174c0a,
	0x11ed83,
	0x308d44,
	0x10398b,
	0x103f48,
	0x8d742,
	0x205702,
	0x2099c2,
	0x2a84c3,
	0x232403,
	0x2d5f04,
	0x2e9dc3,
	0x244183,
	0x209703,
	0x205503,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x227f83,
	0x205503,
	0x200983,
	0x21aa03,
	0x214843,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x169c3,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x3b1384,
	0x227f83,
	0x205503,
	0x200983,
	0x212982,
	0x200141,
	0x205702,
	0x200001,
	0x320b82,
	0x16d208,
	0x21d445,
	0x201ec1,
	0xa84c3,
	0x200701,
	0x200301,
	0x200081,
	0x298602,
	0x36c044,
	0x384383,
	0x200181,
	0x200401,
	0x200041,
	0x200101,
	0x2e9907,
	0x2eab8f,
	0x340446,
	0x200281,
	0x37f6c6,
	0x200e81,
	0x2008c1,
	0x332a0e,
	0x200441,
	0x200983,
	0x201301,
	0x270e85,
	0x20f942,
	0x264a85,
	0x200341,
	0x200801,
	0x2002c1,
	0x20b0c2,
	0x2000c1,
	0x200201,
	0x200bc1,
	0x2005c1,
	0x201cc1,
	0x16d208,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x219503,
	0x2a84c3,
	0x2e9dc3,
	0x8d688,
	0x209703,
	0x205503,
	0x20803,
	0x200983,
	0x14e7e88,
	0x16d208,
	0x44e04,
	0x14e7e8a,
	0x16d208,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x205503,
	0x200983,
	0x2030c3,
	0x16d208,
	0x2a84c3,
	0x232403,
	0x2d5f04,
	0x200983,
	0x27a305,
	0x33b804,
	0x2a84c3,
	0x205503,
	0x200983,
	0x225ca,
	0xd5284,
	0x10c9c6,
	0x2099c2,
	0x2a84c3,
	0x230309,
	0x232403,
	0x3034c9,
	0x2e9dc3,
	0x209703,
	0x205503,
	0x200983,
	0x2ed648,
	0x22ca47,
	0x373605,
	0x18ed88,
	0x1b7407,
	0x2d20a,
	0xecb,
	0x4ab87,
	0x3d2c8,
	0x1b1b8a,
	0x10a48,
	0x12e3c9,
	0x264c7,
	0x3be87,
	0x152b08,
	0x708,
	0x3df8f,
	0x11d85,
	0xa07,
	0x1ae886,
	0x137607,
	0x3d586,
	0x8f2c8,
	0xa5606,
	0x151647,
	0x19c9,
	0x1aa1c7,
	0xa46c9,
	0xb4a09,
	0xbeec6,
	0xc0e08,
	0xbfcc5,
	0x4eb4a,
	0xca988,
	0xb1b43,
	0xd2648,
	0x32607,
	0x6d505,
	0x69c50,
	0x8003,
	0x1aa047,
	0x15ec5,
	0xe9748,
	0x13ce05,
	0x11ed83,
	0x6fd48,
	0xcd46,
	0x42849,
	0xaa147,
	0x6fa0b,
	0x14ac44,
	0xfa544,
	0x10398b,
	0x103f48,
	0x104d47,
	0x129845,
	0x2a84c3,
	0x232403,
	0x2163c3,
	0x200983,
	0x22a403,
	0x2e9dc3,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x209703,
	0x205503,
	0x200983,
	0x43f8b,
	0x205702,
	0x2099c2,
	0x200983,
	0x16d208,
	0x205702,
	0x2099c2,
	0x20d882,
	0x201fc2,
	0x203d02,
	0x205503,
	0x200442,
	0x205702,
	0x38d2c3,
	0x2099c2,
	0x2a84c3,
	0x232403,
	0x20d882,
	0x2e9dc3,
	0x244183,
	0x209703,
	0x211cc4,
	0x205503,
	0x216b03,
	0x200983,
	0x308d44,
	0x25ed03,
	0x2e9dc3,
	0x2099c2,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x209703,
	0x205503,
	0x204e83,
	0x200983,
	0x39f847,
	0x2a84c3,
	0x2614c7,
	0x2c7ac6,
	0x219203,
	0x218343,
	0x2e9dc3,
	0x2143c3,
	0x3b1384,
	0x37ef04,
	0x31ea46,
	0x20d143,
	0x205503,
	0x200983,
	0x27a305,
	0x318284,
	0x3b2a43,
	0x38b743,
	0x2c4647,
	0x33e885,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x209703,
	0x205503,
	0x200983,
	0x28e87,
	0x205942,
	0x287003,
	0x2bf143,
	0x38d2c3,
	0x626a84c3,
	0x202242,
	0x232403,
	0x2032c3,
	0x2e9dc3,
	0x3b1384,
	0x353903,
	0x315e03,
	0x209703,
	0x211cc4,
	0x62a04642,
	0x205503,
	0x200983,
	0x2082c3,
	0x229543,
	0x212982,
	0x25ed03,
	0x16d208,
	0x2e9dc3,
	0x169c3,
	0x26f744,
	0x38d2c3,
	0x2099c2,
	0x2a84c3,
	0x235ac4,
	0x232403,
	0x2e9dc3,
	0x3b1384,
	0x244183,
	0x282104,
	0x210444,
	0x2d43c6,
	0x211cc4,
	0x205503,
	0x200983,
	0x201303,
	0x25fe86,
	0x13f08b,
	0x1cdc6,
	0x5eb4a,
	0x107e4a,
	0x16d208,
	0x2142c4,
	0x63ea84c3,
	0x38d284,
	0x232403,
	0x256e84,
	0x2e9dc3,
	0x391683,
	0x209703,
	0x205503,
	0x200983,
	0x56243,
	0x32f78b,
	0x3a140a,
	0x3b9bcc,
	0xda688,
	0x205702,
	0x2099c2,
	0x20d882,
	0x2a9305,
	0x3b1384,
	0x202342,
	0x209703,
	0x210444,
	0x200c82,
	0x200442,
	0x209842,
	0x212982,
	0x18d2c3,
	0x19f02,
	0x2a1cc9,
	0x25d548,
	0x309a89,
	0x337449,
	0x23490a,
	0x23634a,
	0x20cc02,
	0x21b102,
	0x99c2,
	0x2a84c3,
	0x204682,
	0x23de86,
	0x35d882,
	0x201242,
	0x20124e,
	0x21898e,
	0x27b107,
	0x205487,
	0x275d02,
	0x232403,
	0x2e9dc3,
	0x200042,
	0x201fc2,
	0x4a5c3,
	0x2eec0f,
	0x200f42,
	0x32c787,
	0x2c7d07,
	0x2d3907,
	0x2ad24c,
	0x3151cc,
	0x3a3a44,
	0x27c6ca,
	0x2188c2,
	0x20be02,
	0x2b6fc4,
	0x2226c2,
	0x2c2702,
	0x315404,
	0x20cec2,
	0x200282,
	0x6343,
	0x2a5687,
	0x2352c5,
	0x201f42,
	0x2eeb84,
	0x352bc2,
	0x2da248,
	0x205503,
	0x3b0208,
	0x200d42,
	0x233385,
	0x3b04c6,
	0x200983,
	0x20ba02,
	0x2ea507,
	0xf942,
	0x26b005,
	0x3a9f45,
	0x201642,
	0x242b02,
	0x3b7a8a,
	0x2671ca,
	0x202c42,
	0x2e4744,
	0x2002c2,
	0x206888,
	0x201c82,
	0x30a848,
	0x2feb47,
	0x2ff649,
	0x26b082,
	0x305645,
	0x33bc85,
	0x22dd4b,
	0x2c6c4c,
	0x22e848,
	0x3188c8,
	0x22a282,
	0x35f782,
	0x205702,
	0x16d208,
	0x2099c2,
	0x2a84c3,
	0x20d882,
	0x200c82,
	0x200442,
	0x200983,
	0x209842,
	0x205702,
	0x652099c2,
	0x656e9dc3,
	0x206343,
	0x202342,
	0x205503,
	0x375cc3,
	0x200983,
	0x2e87c3,
	0x275d46,
	0x1614843,
	0x16d208,
	0x192345,
	0xa6a8d,
	0xa4dca,
	0x65c87,
	0x65e011c2,
	0x66200242,
	0x66600ec2,
	0x66a00c02,
	0x66e0de02,
	0x67201ec2,
	0x16fc07,
	0x676099c2,
	0x67a301c2,
	0x67e09982,
	0x68200dc2,
	0x218983,
	0x9e04,
	0x225d83,
	0x686149c2,
	0x68a00182,
	0x49f47,
	0x68e03002,
	0x69202e42,
	0x69600b42,
	0x69a02bc2,
	0x69e029c2,
	0x6a201fc2,
	0xb3985,
	0x234543,
	0x202b84,
	0x6a6226c2,
	0x6aa03a82,
	0x6ae03202,
	0x16c90b,
	0x6b200e82,
	0x6ba49a02,
	0x6be02342,
	0x6c203d02,
	0x6c60f242,
	0x6ca0ec42,
	0x6ce0e602,
	0x6d2675c2,
	0x6d604642,
	0x6da01b42,
	0x6de00c82,
	0x6e2042c2,
	0x6e61c702,
	0x6ea00e42,
	0x7f1c4,
	0x350703,
	0x6ee33082,
	0x6f216982,
	0x6f603402,
	0x6fa089c2,
	0x6fe00442,
	0x702056c2,
	0x44107,
	0x70601302,
	0x70a07302,
	0x70e09842,
	0x71218942,
	0xf484c,
	0x71621c82,
	0x71a3ab02,
	0x71e11602,
	0x72201682,
	0x72601f82,
	0x72a34a82,
	0x72e00202,
	0x7320e8c2,
	0x736724c2,
	0x73a56642,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0xa203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x6b753903,
	0x20a203,
	0x2d6d44,
	0x25d446,
	0x2f1743,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x353903,
	0x20a203,
	0x219f02,
	0x219f02,
	0x353903,
	0x20a203,
	0x742a84c3,
	0x232403,
	0x37ac03,
	0x209703,
	0x205503,
	0x200983,
	0x16d208,
	0x2099c2,
	0x2a84c3,
	0x205503,
	0x200983,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x209703,
	0x205503,
	0x200983,
	0x2030c4,
	0x2099c2,
	0x2a84c3,
	0x2028c3,
	0x232403,
	0x249944,
	0x2163c3,
	0x2e9dc3,
	0x3b1384,
	0x244183,
	0x209703,
	0x205503,
	0x200983,
	0x23e743,
	0x373605,
	0x2a1fc3,
	0x25ed03,
	0x2099c2,
	0x2a84c3,
	0x353903,
	0x205503,
	0x200983,
	0x205702,
	0x38d2c3,
	0x16d208,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x22f706,
	0x3b1384,
	0x244183,
	0x211cc4,
	0x205503,
	0x200983,
	0x201303,
	0x2a84c3,
	0x232403,
	0x205503,
	0x200983,
	0x14bb147,
	0x2a84c3,
	0x1cdc6,
	0x232403,
	0x2e9dc3,
	0xdba46,
	0x205503,
	0x200983,
	0x3149c8,
	0x318709,
	0x328b89,
	0x333808,
	0x37dc48,
	0x37dc49,
	0x24318d,
	0x2ee80f,
	0x251490,
	0x34848d,
	0x3638cc,
	0x37f98b,
	0x98605,
	0x205702,
	0x33e6c5,
	0x200243,
	0x772099c2,
	0x232403,
	0x2e9dc3,
	0x343ec7,
	0x206a43,
	0x209703,
	0x205503,
	0x21c2c3,
	0x20dcc3,
	0x204e83,
	0x200983,
	0x2efec6,
	0x20b0c2,
	0x25ed03,
	0x16d208,
	0x205702,
	0x38d2c3,
	0x2099c2,
	0x2a84c3,
	0x232403,
	0x2e9dc3,
	0x3b1384,
	0x209703,
	0x205503,
	0x200983,
	0x214843,
	0x14f53c6,
	0x205702,
	0x2099c2,
	0x2e9dc3,
	0x209703,
	0x200983,
}
var children = [...]uint32{
	0x0,
	0x10000000,
	0x20000000,
	0x40000000,
	0x50000000,
	0x60000000,
	0x184c60d,
	0x1850613,
	0x1870614,
	0x19cc61c,
	0x19e0673,
	0x19f4678,
	0x1a0467d,
	0x1a20681,
	0x1a24688,
	0x1a3c689,
	0x1a6468f,
	0x1a68699,
	0x1a8069a,
	0x1a846a0,
	0x1a886a1,
	0x1ab06a2,
	0x1ab46ac,
	0x21abc6ad,
	0x1b046af,
	0x1b086c1,
	0x1b286c2,
	0x1b3c6ca,
	0x1b406cf,
	0x1b706d0,
	0x1b8c6dc,
	0x1bb46e3,
	0x1bc06ed,
	0x1bc46f0,
	0x1c5c6f1,
	0x1c70717,
	0x1c8471c,
	0x1cb4721,
	0x1cc472d,
	0x1cd8731,
	0x1cfc736,
	0x1e3473f,
	0x1e3878d,
	0x1ea478e,
	0x1f107a9,
	0x1f247c4,
	0x1f387c9,
	0x1f407ce,
	0x1f507d0,
	0x1f547d4,
	0x1f6c7d5,
	0x1fb87db,
	0x1fd47ee,
	0x1fd87f5,
	0x1fdc7f6,
	0x1fe87f7,
	0x20247fa,
	0x62028809,
	0x203c80a,
	0x205080f,
	0x2054814,
	0x2064815,
	0x2114819,
	0x2118845,
	0x22124846,
	0x2212c849,
	0x216484b,
	0x2168859,
	0x25b885a,
	0x2265896e,
	0x2265c996,
	0x22660997,
	0x2266c998,
	0x2267099b,
	0x2267c99c,
	0x2268099f,
	0x226849a0,
	0x226889a1,
	0x2268c9a2,
	0x226909a3,
	0x2269c9a4,
	0x226a09a7,
	0x226ac9a8,
	0x226b09ab,
	0x226b49ac,
	0x226b89ad,
	0x226c49ae,
	0x226c89b1,
	0x226cc9b2,
	0x226d09b3,
	0x26d49b4,
	0x226d89b5,
	0x226e49b6,
	0x226e89b9,
	0x26f09ba,
	0x227089bc,
	0x2270c9c2,
	0x27189c3,
	0x2271c9c6,
	0x27209c7,
	0x227249c8,
	0x27409c9,
	0x27589d0,
	0x275c9d6,
	0x276c9d7,
	0x27749db,
	0x27a89dd,
	0x27ac9ea,
	0x27bc9eb,
	0x28609ef,
	0x22864a18,
	0x286ca19,
	0x2870a1b,
	0x2888a1c,
	0x289ca22,
	0x28c4a27,
	0x28e4a31,
	0x2914a39,
	0x293ca45,
	0x2940a4f,
	0x2964a50,
	0x2968a59,
	0x297ca5a,
	0x2980a5f,
	0x2984a60,
	0x29a4a61,
	0x29c0a69,
	0x29c4a70,
	0x229c8a71,
	0x29cca72,
	0x29d0a73,
	0x29e0a74,
	0x29e4a78,
	0x2a5ca79,
	0x2a78a97,
	0x2a88a9e,
	0x2a9caa2,
	0x2ab4aa7,
	0x2ac8aad,
	0x2ae0ab2,
	0x2ae4ab8,
	0x2afcab9,
	0x2b14abf,
	0x2b30ac5,
	0x2b48acc,
	0x2ba8ad2,
	0x2bc0aea,
	0x2bc4af0,
	0x2bd8af1,
	0x2c1caf6,
	0x2c9cb07,
	0x2cc8b27,
	0x2cccb32,
	0x2cd4b33,
	0x2cf4b35,
	0x2cf8b3d,
	0x2d18b3e,
	0x2d20b46,
	0x2d5cb48,
	0x2d9cb57,
	0x2da0b67,
	0x2e00b68,
	0x2e04b80,
	0x22e08b81,
	0x2e20b82,
	0x2e44b88,
	0x2e64b91,
	0x3428b99,
	0x3434d0a,
	0x3454d0d,
	0x3610d15,
	0x36e0d84,
	0x3750db8,
	0x37a8dd4,
	0x3890dea,
	0x38e8e24,
	0x3924e3a,
	0x3a20e49,
	0x3aece88,
	0x3b84ebb,
	0x3c14ee1,
	0x3c78f05,
	0x3eb0f1e,
	0x3f68fac,
	0x4034fda,
	0x408100d,
	0x4109020,
	0x4145042,
	0x4195051,
	0x420d065,
	0x64211083,
	0x64215084,
	0x64219085,
	0x4295086,
	0x42f10a5,
	0x436d0bc,
	0x43e50db,
	0x44650f9,
	0x44d1119,
	0x45fd134,
	0x465517f,
	0x64659195,
	0x46f1196,
	0x47791bc,
	0x47c51de,
	0x482d1f1,
	0x48d520b,
	0x499d235,
	0x4a05267,
	0x4b19281,
	0x64b1d2c6,
	0x64b212c7,
	0x4b7d2c8,
	0x4bd92df,
	0x4c692f6,
	0x4ce531a,
	0x4d29339,
	0x4e0d34a,
	0x4e41383,
	0x4ea1390,
	0x4f153a8,
	0x4f9d3c5,
	0x4fdd3e7,
	0x504d3f7,
	0x65051413,
	0x65055414,
	0x25059415,
	0x5071416,
	0x508d41c,
	0x50d1423,
	0x50e1434,
	0x50f9438,
	0x517143e,
	0x517945c,
	0x518d45e,
	0x51a5463,
	0x51cd469,
	0x51d1473,
	0x51d9474,
	0x51ed476,
	0x520947b,
	0x520d482,
	0x5215483,
	0x5251485,
	0x5265494,
	0x526d499,
	0x527549b,
	0x527949d,
	0x529d49e,
	0x52c14a7,
	0x52d94b0,
	0x52dd4b6,
	0x52e54b7,
	0x52e94b9,
	0x534d4ba,
	0x53514d3,
	0x53754d4,
	0x53954dd,
	0x53b14e5,
	0x53c14ec,
	0x53d54f0,
	0x53d94f5,
	0x53e14f6,
	0x53f54f8,
	0x54054fd,
	0x5409501,
	0x5425502,
	0x5cb5509,
	0x5ced72d,
	0x5d1973b,
	0x5d31746,
	0x5d5174c,
	0x5d71754,
	0x5db575c,
	0x5dbd76d,
	0x25dc176f,
	0x25dc5770,
	0x5dcd771,
	0x5f29773,
	0x25f2d7ca,
	0x25f3d7cb,
	0x25f457cf,
	0x25f517d1,
	0x5f557d4,
	0x5f597d5,
	0x5f817d6,
	0x5fa97e0,
	0x5fad7ea,
	0x5fe57eb,
	0x5ff97f9,
	0x6b517fe,
	0x6b55ad4,
	0x6b59ad5,
	0x26b5dad6,
	0x6b61ad7,
	0x26b65ad8,
	0x6b69ad9,
	0x26b75ada,
	0x6b79add,
	0x6b7dade,
	0x26b81adf,
	0x6b85ae0,
	0x26b8dae1,
	0x6b91ae3,
	0x6b95ae4,
	0x26ba5ae5,
	0x6ba9ae9,
	0x6badaea,
	0x6bb1aeb,
	0x6bb5aec,
	0x26bb9aed,
	0x6bbdaee,
	0x6bc1aef,
	0x6bc5af0,
	0x6bc9af1,
	0x26bd1af2,
	0x6bd5af4,
	0x6bd9af5,
	0x6bddaf6,
	0x26be1af7,
	0x6be5af8,
	0x26bedaf9,
	0x26bf1afb,
	0x6c0dafc,
	0x6c19b03,
	0x6c59b06,
	0x6c5db16,
	0x6c81b17,
	0x6c85b20,
	0x6c89b21,
	0x6e01b22,
	0x26e05b80,
	0x26e0db81,
	0x26e11b83,
	0x26e15b84,
	0x6e1db85,
	0x6ef9b87,
	0x26efdbbe,
	0x6f01bbf,
	0x6f2dbc0,
	0x6f31bcb,
	0x6f51bcc,
	0x6f5dbd4,
	0x6f7dbd7,
	0x6fb5bdf,
	0x724dbed,
	0x7309c93,
	0x731dcc2,
	0x7351cc7,
	0x7381cd4,
	0x739dce0,
	0x73c1ce7,
	0x73ddcf0,
	0x73f9cf7,
	0x741dcfe,
	0x742dd07,
	0x7431d0b,
	0x7465d0c,
	0x7481d19,
	0x74edd20,
	0x274f1d3b,
	0x7515d3c,
	0x7535d45,
	0x7549d4d,
	0x755dd52,
	0x7561d57,
	0x7581d58,
	0x7625d60,
	0x7641d89,
	0x7661d90,
	0x7665d98,
	0x766dd99,
	0x7671d9b,
	0x7685d9c,
	0x76a5da1,
	0x76b1da9,
	0x76bddac,
	0x76eddaf,
	0x77bddbb,
	0x77c1def,
	0x77d5df0,
	0x77d9df5,
	0x77f1df6,
	0x77f5dfc,
	0x7801dfd,
	0x7805e00,
	0x7821e01,
	0x785de08,
	0x7861e17,
	0x7881e18,
	0x78d1e20,
	0x78ede34,
	0x7941e3b,
	0x7945e50,
	0x7949e51,
	0x794de52,
	0x7991e53,
	0x79a1e64,
	0x79dde68,
	0x79e1e77,
	0x7a11e78,
	0x7b59e84,
	0x7b7ded6,
	0x7ba9edf,
	0x7bb5eea,
	0x7bbdeed,
	0x7ccdeef,
	0x7cd9f33,
	0x7ce5f36,
	0x7cf1f39,
	0x7cfdf3c,
	0x7d09f3f,
	0x7d15f42,
	0x7d21f45,
	0x7d2df48,
	0x7d39f4b,
	0x7d45f4e,
	0x7d51f51,
	0x7d5df54,
	0x7d69f57,
	0x7d71f5a,
	0x7d7df5c,
	0x7d89f5f,
	0x7d95f62,
	0x7da1f65,
	0x7dadf68,
	0x7db9f6b,
	0x7dc5f6e,
	0x7dd1f71,
	0x7dddf74,
	0x7de9f77,
	0x7df5f7a,
	0x7e01f7d,
	0x7e0df80,
	0x7e19f83,
	0x7e25f86,
	0x7e31f89,
	0x7e3df8c,
	0x7e45f8f,
	0x7e51f91,
	0x7e5df94,
	0x7e69f97,
	0x7e75f9a,
	0x7e81f9d,
	0x7e8dfa0,
	0x7e99fa3,
	0x7ea5fa6,
	0x7eb1fa9,
	0x7ebdfac,
	0x7ec9faf,
	0x7ed5fb2,
	0x7ee1fb5,
	0x7ee9fb8,
	0x7ef5fba,
	0x7f01fbd,
	0x7f0dfc0,
	0x7f19fc3,
	0x7f25fc6,
	0x7f31fc9,
	0x7f3dfcc,
	0x7f49fcf,
	0x7f4dfd2,
	0x7f59fd3,
	0x7f71fd6,
	0x7f75fdc,
	0x7f85fdd,
	0x7f9dfe1,
	0x7fe1fe7,
	0x7ff5ff8,
	0x8029ffd,
	0x803a00a,
	0x805a00e,
	0x8072016,
	0x808a01c,
	0x808e022,
	0x280d2023,
	0x80d6034,
	0x8102035,
	0x8106040,
	0x811a041,
}
